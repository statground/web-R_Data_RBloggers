{
  "id": "1b83d9ac8fcd26976822b14fc6a25e043b5b75de",
  "url": "https://www.r-bloggers.com/2023/11/lesser-known-reasons-to-prefer-apply-over-for-loops/",
  "created_at_utc": "2025-11-17T20:39:25Z",
  "data": null,
  "raw_original": {
    "uuid": "3c76ec3d-c573-4101-bb64-e12bdc238d34",
    "created_at": "2025-11-17 20:39:25",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/11/lesser-known-reasons-to-prefer-apply-over-for-loops/",
      "crawled_at": "2025-11-17T10:01:09.914186",
      "external_links": [
        {
          "href": "https://epiverse-trace.github.io/posts/for-vs-apply/",
          "text": "Epiverse-TRACE developer space"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://privefl.github.io/blog/why-loops-are-slow-in-r/",
          "text": "in other posts"
        },
        {
          "href": "https://en.wikipedia.org/wiki/Recursion",
          "text": "recursion"
        },
        {
          "href": "https://en.wikipedia.org/wiki/Iteration",
          "text": "iteration"
        },
        {
          "href": "https://www.w3schools.com/python/python_lists_comprehension.asp",
          "text": "list comprehensions"
        },
        {
          "href": "https://www.w3schools.com/python/ref_func_map.asp",
          "text": "map()function"
        },
        {
          "href": "https://adv-r.hadley.nz/functionals.html#functionals",
          "text": "“Functionals” chapter of theAdvanced Rbook by Hadley Wickham"
        },
        {
          "href": "https://creativecommons.org/licenses/by/4.0/",
          "text": "CC BY 4.0"
        },
        {
          "href": "https://epiverse-trace.github.io//posts/for-vs-apply",
          "text": "https://epiverse-trace.github.io//posts/for-vs-apply"
        },
        {
          "href": "https://epiverse-trace.github.io/posts/for-vs-apply/",
          "text": "Epiverse-TRACE developer space"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Lesser-known reasons to prefer apply() over for loops | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/hugo-gruson/",
          "text": "Hugo Gruson"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-379601 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Lesser-known reasons to prefer apply() over for loops</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 1, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/hugo-gruson/\">Hugo Gruson</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://epiverse-trace.github.io/posts/for-vs-apply/\"> Epiverse-TRACE developer space</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<p>The debate regarding the use of <code>for</code> loops versus the <code>apply()</code> function family (<code>apply()</code>, <code>lapply()</code>, <code>vapply()</code>, etc., along with their purrr counterparts: <code>map()</code>, <code>map2()</code>, <code>map_lgl()</code>, <code>map_chr()</code>, etc.), has been a longstanding one in the R community.</p>\n<p>While you may occasionally hear that <code>for</code> loops are slower, this notion has already been debunked <a href=\"https://privefl.github.io/blog/why-loops-are-slow-in-r/\" rel=\"nofollow\" target=\"_blank\">in other posts</a>. When utilized correctly, a <code>for</code> loop can achieve performance on par with <code>apply()</code> functions.</p>\n<p>However, there are still lesser-known reasons to prefer <code>apply()</code> functions over <code>for</code> loops, which we will explore in this post.</p>\n<section class=\"level2\" id=\"preamble-for-loops-can-be-used-in-more-cases-than-apply\">\n<h2 class=\"anchored\" data-anchor-id=\"preamble-for-loops-can-be-used-in-more-cases-than-apply\">Preamble: <code>for</code> loops can be used in more cases than <code>apply()</code></h2>\n<p>It is important to understand that <code>for</code> loops and <code>apply()</code> functions are not always interchangeable. Indeed, <code>for</code> loops can be used in cases where <code>apply</code> functions can’t: when the next step depends on the previous one. This concept is known as <a href=\"https://en.wikipedia.org/wiki/Recursion\" rel=\"nofollow\" target=\"_blank\"><em>recursion</em></a>.</p>\n<p>Conversely, when each step is independent of the previous one, but you want to perform the same operation on each element of a vector, it is referred to as <a href=\"https://en.wikipedia.org/wiki/Iteration\" rel=\"nofollow\" target=\"_blank\"><em>iteration</em></a>.</p>\n<p><code>for</code> loops are capable of both <em>recursion</em> and <em>iteration</em>, whereas <code>apply()</code> can only do <em>iteration</em>.</p>\n<table class=\"table\">\n<thead>\n<tr class=\"header\">\n<th>Operator</th>\n<th>Iteration</th>\n<th>Recursion</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>for</code></td>\n<td>✔️</td>\n<td>✔️</td>\n</tr>\n<tr class=\"even\">\n<td><code>apply()</code></td>\n<td>✔️</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<p>With this distinction in mind, we can now focus on why you should favour <code>apply()</code> for iteration over <code>for</code> loops.</p>\n</section>\n<section class=\"level2\" id=\"reason-1-clarity-of-intent\">\n<h2 class=\"anchored\" data-anchor-id=\"reason-1-clarity-of-intent\">Reason 1: clarity of intent</h2>\n<p>As mentioned earlier, <code>for</code> loops can be used for both iteration and recursion. By consistently employing <code>apply()</code> for iteration<sup>1</sup> and reserving <code>for</code> loops for recursion, we enable readers to immediately discern the underlying concept in the code. This leads to code that is easier to read and understand.</p>\n<div class=\"cell\">\n<pre>l &lt;- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# `for` solution -------------------\nres &lt;- numeric(length(l))\nfor (i in seq_along(l)) {\n  res[[i]] &lt;- mean(l[[i]])\n}\nres</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 3.0 4.0 6.0 4.8</pre>\n</div>\n<pre># `vapply()` solution ---------------\nres &lt;- vapply(l, mean, numeric(1))\nres</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 3.0 4.0 6.0 4.8</pre>\n</div>\n</div>\n<p>The simplicity of <code>apply()</code> is even more apparent in the case of multiple iterations. For example, if we want to find the median of each matrix row for a list of matrices:</p>\n<div class=\"cell\">\n<pre>l &lt;- replicate(5, { matrix(runif(9), nrow = 3) }, simplify = FALSE)\n\n# `for` solution -------------------\nres &lt;- list()\nfor (i in seq_along(l)) {\n  meds &lt;- numeric(nrow(l[[i]]))\n  for (j in seq_len(nrow(l[[i]]))) {\n    meds[[j]] &lt;- median(l[[i]][j, ])\n  }\n  res[[i]] &lt;- meds\n}\nres</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237</pre>\n</div>\n<pre># `vapply()` solution ---------------\nlapply(l, function(e) {\n  apply(e, 1, median)\n})</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237</pre>\n</div>\n</div>\n<p>Moreover, this clarity of intent is not limited to human readers alone; automated static analysis tools can also more effectively identify suboptimal patterns. This can be demonstrated using R most popular static analysis tool: the lintr package, suggesting vectorized alternatives:</p>\n<div class=\"cell\">\n<pre>lintr::lint(text = \"vapply(l, length, numeric(1))\")\n\nlintr::lint(text = \"apply(m, 1, sum)\")</pre>\n</div>\n</section>\n<section class=\"level2\" id=\"reason-2-code-compactness-and-conciseness\">\n<h2 class=\"anchored\" data-anchor-id=\"reason-2-code-compactness-and-conciseness\">Reason 2: code compactness and conciseness</h2>\n<p>As illustrated in the preceding example, <code>apply()</code> often leads to more compact code, as much of the boilerplate code is handled behind the scenes: you don’t have to initialize your variables, manage indexing, etc.</p>\n<p>This, in turn, impacts code readability since:</p>\n<ul>\n<li>The boilerplate code does not offer meaningful insights into the algorithm or implementation and can be seen as visual noise.</li>\n<li>While compactness should never take precedence over readability, a more compact solution allows for more code to be displayed on the screen without scrolling. This ultimately makes it easier to understand what the code is doing. With all things otherwise equal, the more compact solution should thus be preferred.</li>\n</ul>\n</section>\n<section class=\"level2\" id=\"reason-3-variable-leak\">\n<h2 class=\"anchored\" data-anchor-id=\"reason-3-variable-leak\">Reason 3: variable leak</h2>\n<p>As discussed in the previous sections, you have to manually manage the iteration index in a <code>for</code> loop, whereas they are abstracted in <code>apply()</code>. This can sometimes lead to perplexing errors:</p>\n<div class=\"cell\">\n<pre>k &lt;- 10\n\nfor (k in c(\"Paul\", \"Pierre\", \"Jacques\")) {\n  message(\"Hello \", k)\n}</pre>\n<div class=\"cell-output cell-output-stderr\">\n<pre>Hello Paul</pre>\n</div>\n<div class=\"cell-output cell-output-stderr\">\n<pre>Hello Pierre</pre>\n</div>\n<div class=\"cell-output cell-output-stderr\">\n<pre>Hello Jacques</pre>\n</div>\n<pre>rep(letters, times = k)</pre>\n<div class=\"cell-output cell-output-stderr\">\n<pre>Warning: NAs introduced by coercion</pre>\n</div>\n<div class=\"cell-output cell-output-error\">\n<pre>Error in rep(letters, times = k): invalid 'times' argument</pre>\n</div>\n</div>\n<p>This is because the loop index variable leaks into the global environment and can overwrite existing variables:</p>\n<div class=\"cell\">\n<pre>for (k in 1:3) {\n  # do something\n}\n\nmessage(\"The value of k is now \", k)</pre>\n<div class=\"cell-output cell-output-stderr\">\n<pre>The value of k is now 3</pre>\n</div>\n</div>\n</section>\n<section class=\"level2\" id=\"reason-4-pipelines\">\n<h2 class=\"anchored\" data-anchor-id=\"reason-4-pipelines\">Reason 4: pipelines</h2>\n<p>The final reason is that <code>apply()</code> (or more commonly in this situation <code>purrr::map()</code>) can be used in pipelines due to their functional nature:</p>\n<div class=\"cell\">\n<pre>l &lt;- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# Without pipe\nvapply(l, mean, numeric(1))</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 3.0 4.0 6.0 4.8</pre>\n</div>\n<pre># With pipe\nl |&gt; vapply(mean, numeric(1))</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 3.0 4.0 6.0 4.8</pre>\n</div>\n<pre>l |&gt; purrr::map_dbl(mean)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 3.0 4.0 6.0 4.8</pre>\n</div>\n</div>\n</section>\n<section class=\"level2\" id=\"conclusion\">\n<h2 class=\"anchored\" data-anchor-id=\"conclusion\">Conclusion</h2>\n<p>This post hopefully convinced you why it’s better to use <code>apply()</code> functions rather than <code>for</code> loops where possible (i.e., for iteration). Contrary to common misconception, the real reason is not performance, but code robustness and readability.</p>\n<p><em>Thanks to Jaime Pavlich-Mariscal, James Azam, Tim Taylor, and Pratik Gupte for their thoughtful comments and suggestions on earlier drafts of this post.</em></p>\n<div class=\"callout callout-style-default callout-tip callout-titled\" title=\"Beyond R\">\n<div class=\"callout-header d-flex align-content-center\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-title-container flex-fill\">\nBeyond R\n</div>\n</div>\n<div class=\"callout-body-container callout-body\">\n<p>This post focused on R, but the same principles generally apply to other functional languages. In Python for example, you would use <a href=\"https://www.w3schools.com/python/python_lists_comprehension.asp\" rel=\"nofollow\" target=\"_blank\">list comprehensions</a> or the <a href=\"https://www.w3schools.com/python/ref_func_map.asp\" rel=\"nofollow\" target=\"_blank\"><code>map()</code> function</a>.</p>\n</div>\n</div>\n<div class=\"callout callout-style-default callout-tip callout-titled\" title=\"Further reading\">\n<div class=\"callout-header d-flex align-content-center\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-title-container flex-fill\">\nFurther reading\n</div>\n</div>\n<div class=\"callout-body-container callout-body\">\n<p>If you liked the code patterns recommended in this post and want to use functional programming in more situations, including recursion, I recommend you check out the <a href=\"https://adv-r.hadley.nz/functionals.html#functionals\" rel=\"nofollow\" target=\"_blank\">“Functionals” chapter of the <em>Advanced R</em> book by Hadley Wickham</a></p>\n</div>\n</div>\n</section>\n<div class=\"default\" id=\"quarto-appendix\"><section class=\"quarto-appendix-contents\"><h2 class=\"anchored quarto-appendix-heading\">Reuse</h2><div class=\"quarto-appendix-contents\" id=\"quarto-reuse\"><div><a href=\"https://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\" target=\"_blank\">CC BY 4.0</a></div></div></section><section class=\"quarto-appendix-contents\"><h2 class=\"anchored quarto-appendix-heading\">Citation</h2><div><div class=\"quarto-appendix-secondary-label\">BibTeX citation:</div><pre>@online{gruson2023,\n  author = {Gruson, Hugo},\n  title = {Lesser-Known Reasons to Prefer `Apply()` over for Loops},\n  pages = {undefined},\n  date = {2023-11-02},\n  url = {https://epiverse-trace.github.io//posts/for-vs-apply},\n  langid = {en}\n}\n</pre><div class=\"quarto-appendix-secondary-label\">For attribution, please cite this work as:</div><div class=\"csl-entry quarto-appendix-citeas\" id=\"ref-gruson2023\">\nGruson, Hugo. 2023. <span>“Lesser-Known Reasons to Prefer `Apply()` over\nfor Loops.”</span> November 2, 2023. <a href=\"https://epiverse-trace.github.io//posts/for-vs-apply\" rel=\"nofollow\" target=\"_blank\">https://epiverse-trace.github.io//posts/for-vs-apply</a>.\n</div></div></section></div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://epiverse-trace.github.io/posts/for-vs-apply/\"> Epiverse-TRACE developer space</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "Lesser-known reasons to prefer apply() over for loops\nPosted on\nNovember 1, 2023\nby\nHugo Gruson\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nEpiverse-TRACE developer space\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nThe debate regarding the use of\nfor\nloops versus the\napply()\nfunction family (\napply()\n,\nlapply()\n,\nvapply()\n, etc., along with their purrr counterparts:\nmap()\n,\nmap2()\n,\nmap_lgl()\n,\nmap_chr()\n, etc.), has been a longstanding one in the R community.\nWhile you may occasionally hear that\nfor\nloops are slower, this notion has already been debunked\nin other posts\n. When utilized correctly, a\nfor\nloop can achieve performance on par with\napply()\nfunctions.\nHowever, there are still lesser-known reasons to prefer\napply()\nfunctions over\nfor\nloops, which we will explore in this post.\nPreamble:\nfor\nloops can be used in more cases than\napply()\nIt is important to understand that\nfor\nloops and\napply()\nfunctions are not always interchangeable. Indeed,\nfor\nloops can be used in cases where\napply\nfunctions can’t: when the next step depends on the previous one. This concept is known as\nrecursion\n.\nConversely, when each step is independent of the previous one, but you want to perform the same operation on each element of a vector, it is referred to as\niteration\n.\nfor\nloops are capable of both\nrecursion\nand\niteration\n, whereas\napply()\ncan only do\niteration\n.\nOperator\nIteration\nRecursion\nfor\n✔️\n✔️\napply()\n✔️\n❌\nWith this distinction in mind, we can now focus on why you should favour\napply()\nfor iteration over\nfor\nloops.\nReason 1: clarity of intent\nAs mentioned earlier,\nfor\nloops can be used for both iteration and recursion. By consistently employing\napply()\nfor iteration\n1\nand reserving\nfor\nloops for recursion, we enable readers to immediately discern the underlying concept in the code. This leads to code that is easier to read and understand.\nl <- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# `for` solution -------------------\nres <- numeric(length(l))\nfor (i in seq_along(l)) {\n  res[[i]] <- mean(l[[i]])\n}\nres\n[1] 3.0 4.0 6.0 4.8\n# `vapply()` solution ---------------\nres <- vapply(l, mean, numeric(1))\nres\n[1] 3.0 4.0 6.0 4.8\nThe simplicity of\napply()\nis even more apparent in the case of multiple iterations. For example, if we want to find the median of each matrix row for a list of matrices:\nl <- replicate(5, { matrix(runif(9), nrow = 3) }, simplify = FALSE)\n\n# `for` solution -------------------\nres <- list()\nfor (i in seq_along(l)) {\n  meds <- numeric(nrow(l[[i]]))\n  for (j in seq_len(nrow(l[[i]]))) {\n    meds[[j]] <- median(l[[i]][j, ])\n  }\n  res[[i]] <- meds\n}\nres\n[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237\n# `vapply()` solution ---------------\nlapply(l, function(e) {\n  apply(e, 1, median)\n})\n[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237\nMoreover, this clarity of intent is not limited to human readers alone; automated static analysis tools can also more effectively identify suboptimal patterns. This can be demonstrated using R most popular static analysis tool: the lintr package, suggesting vectorized alternatives:\nlintr::lint(text = \"vapply(l, length, numeric(1))\")\n\nlintr::lint(text = \"apply(m, 1, sum)\")\nReason 2: code compactness and conciseness\nAs illustrated in the preceding example,\napply()\noften leads to more compact code, as much of the boilerplate code is handled behind the scenes: you don’t have to initialize your variables, manage indexing, etc.\nThis, in turn, impacts code readability since:\nThe boilerplate code does not offer meaningful insights into the algorithm or implementation and can be seen as visual noise.\nWhile compactness should never take precedence over readability, a more compact solution allows for more code to be displayed on the screen without scrolling. This ultimately makes it easier to understand what the code is doing. With all things otherwise equal, the more compact solution should thus be preferred.\nReason 3: variable leak\nAs discussed in the previous sections, you have to manually manage the iteration index in a\nfor\nloop, whereas they are abstracted in\napply()\n. This can sometimes lead to perplexing errors:\nk <- 10\n\nfor (k in c(\"Paul\", \"Pierre\", \"Jacques\")) {\n  message(\"Hello \", k)\n}\nHello Paul\nHello Pierre\nHello Jacques\nrep(letters, times = k)\nWarning: NAs introduced by coercion\nError in rep(letters, times = k): invalid 'times' argument\nThis is because the loop index variable leaks into the global environment and can overwrite existing variables:\nfor (k in 1:3) {\n  # do something\n}\n\nmessage(\"The value of k is now \", k)\nThe value of k is now 3\nReason 4: pipelines\nThe final reason is that\napply()\n(or more commonly in this situation\npurrr::map()\n) can be used in pipelines due to their functional nature:\nl <- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# Without pipe\nvapply(l, mean, numeric(1))\n[1] 3.0 4.0 6.0 4.8\n# With pipe\nl |> vapply(mean, numeric(1))\n[1] 3.0 4.0 6.0 4.8\nl |> purrr::map_dbl(mean)\n[1] 3.0 4.0 6.0 4.8\nConclusion\nThis post hopefully convinced you why it’s better to use\napply()\nfunctions rather than\nfor\nloops where possible (i.e., for iteration). Contrary to common misconception, the real reason is not performance, but code robustness and readability.\nThanks to Jaime Pavlich-Mariscal, James Azam, Tim Taylor, and Pratik Gupte for their thoughtful comments and suggestions on earlier drafts of this post.\nBeyond R\nThis post focused on R, but the same principles generally apply to other functional languages. In Python for example, you would use\nlist comprehensions\nor the\nmap()\nfunction\n.\nFurther reading\nIf you liked the code patterns recommended in this post and want to use functional programming in more situations, including recursion, I recommend you check out the\n“Functionals” chapter of the\nAdvanced R\nbook by Hadley Wickham\nReuse\nCC BY 4.0\nCitation\nBibTeX citation:\n@online{gruson2023,\n  author = {Gruson, Hugo},\n  title = {Lesser-Known Reasons to Prefer `Apply()` over for Loops},\n  pages = {undefined},\n  date = {2023-11-02},\n  url = {https://epiverse-trace.github.io//posts/for-vs-apply},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nGruson, Hugo. 2023.\n“Lesser-Known Reasons to Prefer `Apply()` over\nfor Loops.”\nNovember 2, 2023.\nhttps://epiverse-trace.github.io//posts/for-vs-apply\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nEpiverse-TRACE developer space\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "The debate regarding the use of for loops versus the apply() function family (apply(), lapply(), vapply(), etc., along with their purrr counterparts: map(), map2(), map_lgl(), map_chr(), etc.), has been a longstanding one in the R community. Whi...",
      "meta_keywords": null,
      "og_description": "The debate regarding the use of for loops versus the apply() function family (apply(), lapply(), vapply(), etc., along with their purrr counterparts: map(), map2(), map_lgl(), map_chr(), etc.), has been a longstanding one in the R community. Whi...",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Lesser-known reasons to prefer apply() over for loops | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 6.1,
      "sitemap_lastmod": "2023-11-02T00:00:00+00:00",
      "twitter_description": "The debate regarding the use of for loops versus the apply() function family (apply(), lapply(), vapply(), etc., along with their purrr counterparts: map(), map2(), map_lgl(), map_chr(), etc.), has been a longstanding one in the R community. Whi...",
      "twitter_title": "Lesser-known reasons to prefer apply() over for loops | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/11/lesser-known-reasons-to-prefer-apply-over-for-loops/",
      "word_count": 1212
    }
  }
}