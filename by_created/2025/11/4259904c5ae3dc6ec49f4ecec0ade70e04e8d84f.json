{
  "id": "4259904c5ae3dc6ec49f4ecec0ade70e04e8d84f",
  "url": "https://www.r-bloggers.com/2023/12/a-new-focus-on-tidygraph/",
  "created_at_utc": "2025-11-17T20:38:50Z",
  "data": null,
  "raw_original": {
    "uuid": "36b31a54-050f-404b-a7b6-6a52c19d8f38",
    "created_at": "2025-11-17 20:38:50",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/12/a-new-focus-on-tidygraph/",
      "crawled_at": "2025-11-17T09:32:47.484933",
      "external_links": [
        {
          "href": "https://www.data-imaginist.com/2023/a-new-focus-on-tidygraph/",
          "text": "Data Imaginist"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://tidygraph.data-imaginist.com/",
          "text": "tidygraph"
        },
        {
          "href": "https://tidygraph.data-imaginist.com/",
          "text": "project website"
        },
        {
          "href": "https://www.data-imaginist.com/2023/a-new-focus-on-tidygraph/",
          "text": "Data Imaginist"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "A new focus on tidygraph | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/www.data-imaginist.com/post/2023-12-18-a-new-focus-on-tidygraph_files/figure-html/unnamed-chunk-5-1.png?w=450&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/data-imaginist/",
          "text": "Data Imaginist"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-380965 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">A new focus on tidygraph</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">December 17, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/data-imaginist/\">Data Imaginist</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://www.data-imaginist.com/2023/a-new-focus-on-tidygraph/\"> Data Imaginist</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<p>I’m pleased to announce a new release of <a href=\"https://tidygraph.data-imaginist.com/\" rel=\"nofollow\" target=\"_blank\">tidygraph</a>. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the <a href=\"https://tidygraph.data-imaginist.com/\" rel=\"nofollow\" target=\"_blank\">project website</a> first and become a user.</p>\n<div class=\"section level2\" id=\"let-us-focus-on-the-news\">\n<h2>Let us focus on the news</h2>\n<p>One new feature I’m particularly exited about is the inclusion of a new <code>focus()</code>/<code>unfocus()</code> pair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do?</p>\n<p>Let’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine – we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges?</p>\n<p>Enter the <code>focus()</code> verb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not.</p>\n<pre>library(tidygraph)\r\n## \n## Attaching package: 'tidygraph'\r\n## The following object is masked from 'package:stats':\n## \n##     filter\r\ngraph &lt;- play_forestfire(1e5, 0.1) |&gt; \n  mutate(important = dplyr::row_number() &lt;= 5) |&gt; \n  focus(important) |&gt; \n  mutate(efficiency = node_efficiency()) |&gt; \n  unfocus()\n\ngraph |&gt; \n  as_tibble() |&gt; \n  slice(1:10)\r\n## # A tibble: 10 × 2\n##    important efficiency\n##    &lt;lgl&gt;          &lt;dbl&gt;\n##  1 TRUE          0.0253\n##  2 TRUE          0.0274\n##  3 TRUE          0.0417\n##  4 TRUE          0.0306\n##  5 TRUE          0.0368\n##  6 FALSE        NA     \n##  7 FALSE        NA     \n##  8 FALSE        NA     \n##  9 FALSE        NA     \n## 10 FALSE        NA</pre>\n<p>In the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen.</p>\n<p>Focus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all.</p>\n</div>\n<div class=\"section level2\" id=\"iterating-on-old-ideas\">\n<h2>Iterating on old ideas</h2>\n<p>Another old feature idea of mine that finally materialized is a set of <code>iterate_*()</code> verbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of <code>while () {}</code> and <code>for () {}</code> so you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes:</p>\n<pre>unwire &lt;- function(graph) {\n  edge &lt;- graph |&gt; \n    activate(nodes) |&gt; \n    mutate(well_connected = centrality_degree() &gt; 1) |&gt; \n    activate(edges) |&gt; \n    mutate(can_remove = .N()$well_connected[from] &amp; .N()$well_connected[to],\n           will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |&gt; \n    pull(will_remove)\n  graph |&gt; \n    activate(edges) |&gt; \n    filter(!edge)\n}</pre>\n<p>We can use this function 20 times on our graph with the <code>iterate_n()</code> verbs like so:</p>\n<pre>create_notable('meredith') |&gt; \n  iterate_n(20, unwire)\r\n## # A tbl_graph: 70 nodes and 120 edges\n## #\n## # An undirected simple graph with 1 component\n## #\n## # Node Data: 70 × 0 (active)\n## #\n## # Edge Data: 120 × 2\n##    from    to\n##   &lt;int&gt; &lt;int&gt;\n## 1     1     5\n## 2     1     6\n## 3     1     7\n## # ℹ 117 more rows</pre>\n<p>Alternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the <code>unwire()</code> function until the graph has been split up into two components.</p>\n<pre>create_notable('meredith') |&gt; \n  iterate_while(graph_component_count() == 1, unwire) |&gt; \n  ggraph::autograph()</pre>\n<p><img data-lazy-src=\"https://i1.wp.com/www.data-imaginist.com/post/2023-12-18-a-new-focus-on-tidygraph_files/figure-html/unnamed-chunk-5-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.data-imaginist.com/post/2023-12-18-a-new-focus-on-tidygraph_files/figure-html/unnamed-chunk-5-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"catching-up\">\n<h2>Catching up</h2>\n<p>It’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions:</p>\n<ul>\n<li><p><code>edge_is_bridge()</code> will test for whether edges are bridges (their removal will result in splitting up a component into two</p></li>\n<li><p><code>edge_is_feedback_arc()</code> queries whether edges are part of the feedback arc set</p></li>\n<li><p><code>graph_is_eulerian()</code> and <code>edge_rank_eulerian()</code> provides access to eulerian path and cycle calculations</p></li>\n<li><p><code>graph_efficiency()</code> and <code>node_efficiency()</code> provides access to global and local efficiency calculations</p></li>\n<li><p><code>group_leiden()</code> and <code>group_fluid()</code> provides access to the new <code>cluster_leiden()</code> and <code>cluster_fluid_communities()</code> community detection algorithms</p></li>\n<li><p><code>group_color()</code> provides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node</p></li>\n<li><p><code>centrality_harmonic()</code> supersedes <code>centrality_closeness_harmonic()</code> using an efficient C implementation over the flexible but slower implementation from the netrankr package</p></li>\n<li><p><code>random_walk_rank()</code> provides access to random walks on both edges and nodes</p></li>\n<li><p><code>to_largest_component()</code> and <code>to_random_spanning_tree()</code> are two new morphers</p></li>\n<li><p><code>node_is_connected()</code> tests whether nodes are connected to all or any of the nodes in a given set</p></li>\n</ul>\n<p>Apart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various <code>slice_*()</code> types so that you can now use e.g. <code>slice_min()</code> or <code>slice_sample()</code> on tbl_graph objects. And while not directly dplyr (but tidyr) you can now use <code>replace_na()</code> and <code>drop_na()</code> with tbl_graph objects as well.</p>\n</div>\n<div class=\"section level2\" id=\"wrapping-up\">\n<h2>Wrapping up</h2>\n<p>Mature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care</p>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.data-imaginist.com/2023/a-new-focus-on-tidygraph/\"> Data Imaginist</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "A new focus on tidygraph\nPosted on\nDecember 17, 2023\nby\nData Imaginist\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nData Imaginist\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nI’m pleased to announce a new release of\ntidygraph\n. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the\nproject website\nfirst and become a user.\nLet us focus on the news\nOne new feature I’m particularly exited about is the inclusion of a new\nfocus()\n/\nunfocus()\npair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do?\nLet’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine – we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges?\nEnter the\nfocus()\nverb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not.\nlibrary(tidygraph)\n## \n## Attaching package: 'tidygraph'\n## The following object is masked from 'package:stats':\n## \n##     filter\ngraph <- play_forestfire(1e5, 0.1) |> \n  mutate(important = dplyr::row_number() <= 5) |> \n  focus(important) |> \n  mutate(efficiency = node_efficiency()) |> \n  unfocus()\n\ngraph |> \n  as_tibble() |> \n  slice(1:10)\n## # A tibble: 10 × 2\n##    important efficiency\n##    <lgl>          <dbl>\n##  1 TRUE          0.0253\n##  2 TRUE          0.0274\n##  3 TRUE          0.0417\n##  4 TRUE          0.0306\n##  5 TRUE          0.0368\n##  6 FALSE        NA     \n##  7 FALSE        NA     \n##  8 FALSE        NA     \n##  9 FALSE        NA     \n## 10 FALSE        NA\nIn the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen.\nFocus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all.\nIterating on old ideas\nAnother old feature idea of mine that finally materialized is a set of\niterate_*()\nverbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of\nwhile () {}\nand\nfor () {}\nso you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes:\nunwire <- function(graph) {\n  edge <- graph |> \n    activate(nodes) |> \n    mutate(well_connected = centrality_degree() > 1) |> \n    activate(edges) |> \n    mutate(can_remove = .N()$well_connected[from] & .N()$well_connected[to],\n           will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |> \n    pull(will_remove)\n  graph |> \n    activate(edges) |> \n    filter(!edge)\n}\nWe can use this function 20 times on our graph with the\niterate_n()\nverbs like so:\ncreate_notable('meredith') |> \n  iterate_n(20, unwire)\n## # A tbl_graph: 70 nodes and 120 edges\n## #\n## # An undirected simple graph with 1 component\n## #\n## # Node Data: 70 × 0 (active)\n## #\n## # Edge Data: 120 × 2\n##    from    to\n##   <int> <int>\n## 1     1     5\n## 2     1     6\n## 3     1     7\n## # ℹ 117 more rows\nAlternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the\nunwire()\nfunction until the graph has been split up into two components.\ncreate_notable('meredith') |> \n  iterate_while(graph_component_count() == 1, unwire) |> \n  ggraph::autograph()\nCatching up\nIt’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions:\nedge_is_bridge()\nwill test for whether edges are bridges (their removal will result in splitting up a component into two\nedge_is_feedback_arc()\nqueries whether edges are part of the feedback arc set\ngraph_is_eulerian()\nand\nedge_rank_eulerian()\nprovides access to eulerian path and cycle calculations\ngraph_efficiency()\nand\nnode_efficiency()\nprovides access to global and local efficiency calculations\ngroup_leiden()\nand\ngroup_fluid()\nprovides access to the new\ncluster_leiden()\nand\ncluster_fluid_communities()\ncommunity detection algorithms\ngroup_color()\nprovides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node\ncentrality_harmonic()\nsupersedes\ncentrality_closeness_harmonic()\nusing an efficient C implementation over the flexible but slower implementation from the netrankr package\nrandom_walk_rank()\nprovides access to random walks on both edges and nodes\nto_largest_component()\nand\nto_random_spanning_tree()\nare two new morphers\nnode_is_connected()\ntests whether nodes are connected to all or any of the nodes in a given set\nApart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various\nslice_*()\ntypes so that you can now use e.g.\nslice_min()\nor\nslice_sample()\non tbl_graph objects. And while not directly dplyr (but tidyr) you can now use\nreplace_na()\nand\ndrop_na()\nwith tbl_graph objects as well.\nWrapping up\nMature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nData Imaginist\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "I’m pleased to announce a new release of tidygraph. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the project website first and become a user. Let us focus on the news One new feature I’m particularly exited about is the inclusion of a new focus()/unfocus() pair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do? Let’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine - we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges? Enter the focus() verb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not. library(tidygraph) ## ## Attaching package: 'tidygraph' ## The following object is masked from 'package:stats': ## ## filter graph mutate(important = dplyr::row_number() focus(important) |> mutate(efficiency = node_efficiency()) |> unfocus() graph |> as_tibble() |> slice(1:10) ## # A tibble: 10 × 2 ## important efficiency ## ## 1 TRUE 0.0253 ## 2 TRUE 0.0274 ## 3 TRUE 0.0417 ## 4 TRUE 0.0306 ## 5 TRUE 0.0368 ## 6 FALSE NA ## 7 FALSE NA ## 8 FALSE NA ## 9 FALSE NA ## 10 FALSE NA In the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen. Focus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all. Iterating on old ideas Another old feature idea of mine that finally materialized is a set of iterate_*() verbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of while () {} and for () {} so you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes: unwire mutate(well_connected = centrality_degree() > 1) |> activate(edges) |> mutate(can_remove = .N()$well_connected[from] & .N()$well_connected[to], will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |> pull(will_remove) graph |> activate(edges) |> filter(!edge) } We can use this function 20 times on our graph with the iterate_n() verbs like so: create_notable('meredith') |> iterate_n(20, unwire) ## # A tbl_graph: 70 nodes and 120 edges ## # ## # An undirected simple graph with 1 component ## # ## # Node Data: 70 × 0 (active) ## # ## # Edge Data: 120 × 2 ## from to ## ## 1 1 5 ## 2 1 6 ## 3 1 7 ## # ℹ 117 more rows Alternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the unwire() function until the graph has been split up into two components. create_notable('meredith') |> iterate_while(graph_component_count() == 1, unwire) |> ggraph::autograph() Catching up It’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions: edge_is_bridge() will test for whether edges are bridges (their removal will result in splitting up a component into two edge_is_feedback_arc() queries whether edges are part of the feedback arc set graph_is_eulerian() and edge_rank_eulerian() provides access to eulerian path and cycle calculations graph_efficiency() and node_efficiency() provides access to global and local efficiency calculations group_leiden() and group_fluid() provides access to the new cluster_leiden() and cluster_fluid_communities() community detection algorithms group_color() provides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node centrality_harmonic() supersedes centrality_closeness_harmonic() using an efficient C implementation over the flexible but slower implementation from the netrankr package random_walk_rank() provides access to random walks on both edges and nodes to_largest_component() and to_random_spanning_tree() are two new morphers node_is_connected() tests whether nodes are connected to all or any of the nodes in a given set Apart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various slice_*() types so that you can now use e.g. slice_min() or slice_sample() on tbl_graph objects. And while not directly dplyr (but tidyr) you can now use replace_na() and drop_na() with tbl_graph objects as well. Wrapping up Mature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care",
      "meta_keywords": null,
      "og_description": "I’m pleased to announce a new release of tidygraph. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the project website first and become a user. Let us focus on the news One new feature I’m particularly exited about is the inclusion of a new focus()/unfocus() pair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do? Let’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine - we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges? Enter the focus() verb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not. library(tidygraph) ## ## Attaching package: 'tidygraph' ## The following object is masked from 'package:stats': ## ## filter graph mutate(important = dplyr::row_number() focus(important) |> mutate(efficiency = node_efficiency()) |> unfocus() graph |> as_tibble() |> slice(1:10) ## # A tibble: 10 × 2 ## important efficiency ## ## 1 TRUE 0.0253 ## 2 TRUE 0.0274 ## 3 TRUE 0.0417 ## 4 TRUE 0.0306 ## 5 TRUE 0.0368 ## 6 FALSE NA ## 7 FALSE NA ## 8 FALSE NA ## 9 FALSE NA ## 10 FALSE NA In the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen. Focus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all. Iterating on old ideas Another old feature idea of mine that finally materialized is a set of iterate_*() verbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of while () {} and for () {} so you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes: unwire mutate(well_connected = centrality_degree() > 1) |> activate(edges) |> mutate(can_remove = .N()$well_connected[from] & .N()$well_connected[to], will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |> pull(will_remove) graph |> activate(edges) |> filter(!edge) } We can use this function 20 times on our graph with the iterate_n() verbs like so: create_notable('meredith') |> iterate_n(20, unwire) ## # A tbl_graph: 70 nodes and 120 edges ## # ## # An undirected simple graph with 1 component ## # ## # Node Data: 70 × 0 (active) ## # ## # Edge Data: 120 × 2 ## from to ## ## 1 1 5 ## 2 1 6 ## 3 1 7 ## # ℹ 117 more rows Alternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the unwire() function until the graph has been split up into two components. create_notable('meredith') |> iterate_while(graph_component_count() == 1, unwire) |> ggraph::autograph() Catching up It’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions: edge_is_bridge() will test for whether edges are bridges (their removal will result in splitting up a component into two edge_is_feedback_arc() queries whether edges are part of the feedback arc set graph_is_eulerian() and edge_rank_eulerian() provides access to eulerian path and cycle calculations graph_efficiency() and node_efficiency() provides access to global and local efficiency calculations group_leiden() and group_fluid() provides access to the new cluster_leiden() and cluster_fluid_communities() community detection algorithms group_color() provides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node centrality_harmonic() supersedes centrality_closeness_harmonic() using an efficient C implementation over the flexible but slower implementation from the netrankr package random_walk_rank() provides access to random walks on both edges and nodes to_largest_component() and to_random_spanning_tree() are two new morphers node_is_connected() tests whether nodes are connected to all or any of the nodes in a given set Apart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various slice_*() types so that you can now use e.g. slice_min() or slice_sample() on tbl_graph objects. And while not directly dplyr (but tidyr) you can now use replace_na() and drop_na() with tbl_graph objects as well. Wrapping up Mature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care",
      "og_image": "https://www.data-imaginist.com/post/2023-12-18-a-new-focus-on-tidygraph_files/figure-html/unnamed-chunk-5-1.png",
      "og_title": "A new focus on tidygraph | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 6.6,
      "sitemap_lastmod": "2023-12-18T00:00:00+00:00",
      "twitter_description": "I’m pleased to announce a new release of tidygraph. It has been a while since something major has happened to the package, reflecting the stable nature of it, but this time I felt like doing a bit more than just brush it of for the occasional upstream dependency change. So, while it is in no way a grandiose release, it does contain enough new stuff to warrant a small blog post. If you are a tidygraph user you should definitely read on, otherwise perhaps explore the project website first and become a user. Let us focus on the news One new feature I’m particularly exited about is the inclusion of a new focus()/unfocus() pair of verbs. Part of my excitement is that this was one of my original ideas for the package but was scraped prior to release and then left to linger. The other reason is of course that it is super useful. So what does it do? Let’s start with the why. For classic tabular data you generally expect all data to be equally important during computations. Each row is an observation that needs to be treated with the same care. You perhaps do some filtering but for the resulting filter, it again holds that each data is equally important. For such data the vectorised approach of R (and thus dplyr) makes perfect sense. We tend to want to calculate stuff for each row. The same is not always true for graph data. We might have nodes that are the main focus of our attention and nodes that are simply auxillary. But performing a filter will alter our graph, and that might change our calculations due to the connectedness of our data. For many calculations this is of little concern as the algorithms are so performant, meaning the vectorised paradigm of tidygraph is fine - we simply ignore it. But, what if we have a huge graph and an algorithm that scales exponentially with the number of edges and we really are only interested in the result of a few nodes or edges? Enter the focus() verb. It allows you to perform a temporary filtering of the nodes or edges you are working on without removing the underlying graph structure. In practise it means that any tidygraph algorithms will only be called on the nodes or edges that are in focus but the algorithms will have access to the full graph and will thus return the same result for the focused nodes/edges irrespective of whether the focus was applied or not. library(tidygraph) ## ## Attaching package: 'tidygraph' ## The following object is masked from 'package:stats': ## ## filter graph mutate(important = dplyr::row_number() focus(important) |> mutate(efficiency = node_efficiency()) |> unfocus() graph |> as_tibble() |> slice(1:10) ## # A tibble: 10 × 2 ## important efficiency ## ## 1 TRUE 0.0253 ## 2 TRUE 0.0274 ## 3 TRUE 0.0417 ## 4 TRUE 0.0306 ## 5 TRUE 0.0368 ## 6 FALSE NA ## 7 FALSE NA ## 8 FALSE NA ## 9 FALSE NA ## 10 FALSE NA In the above code we calculate the local efficiency around each node, but since we are only interested in this measure for the first 5 nodes we focus on these and avoid computing it for the remaining 99995 nodes, gaining quite a speed boost. One (huge) caveat is that it is algorithm-dependent whether focusing on a subset provides a performance gain. Some algorithms work in a way were everything is calculated together, e.g. those that rely on convolutions of the distance matrix etc. In these cases no performance gain will be seen. Focus can be applied both to nodes and edges depending on which one is activated. The focus is the weakest of all graph states and a graph will be unfocused if you either activate, group, or morph a graph so think of it as the most temporary state of them all. Iterating on old ideas Another old feature idea of mine that finally materialized is a set of iterate_*() verbs. Those are quite a bit simpler but useful nonetheless if you want to encode simple simulations on graphs using tidygraph syntax. You can think of these as functional equivalents of while () {} and for () {} so you can incorporate them into a pipe. As an example let’s consider a simulation that removes an edge unless it isolates one of its nodes: unwire mutate(well_connected = centrality_degree() > 1) |> activate(edges) |> mutate(can_remove = .N()$well_connected[from] & .N()$well_connected[to], will_remove = dplyr::row_number() == sample(dplyr::row_number(), 1L, prob = can_remove)) |> pull(will_remove) graph |> activate(edges) |> filter(!edge) } We can use this function 20 times on our graph with the iterate_n() verbs like so: create_notable('meredith') |> iterate_n(20, unwire) ## # A tbl_graph: 70 nodes and 120 edges ## # ## # An undirected simple graph with 1 component ## # ## # Node Data: 70 × 0 (active) ## # ## # Edge Data: 120 × 2 ## from to ## ## 1 1 5 ## 2 1 6 ## 3 1 7 ## # ℹ 117 more rows Alternatively we can set up a condition to test for after each iteration that determines if iteration continues. Below we run the unwire() function until the graph has been split up into two components. create_notable('meredith') |> iterate_while(graph_component_count() == 1, unwire) |> ggraph::autograph() Catching up It’s been a while since tidygraph has been updated with interfaces into new features from igraph. This release fixes that somewhat by providing the following new functions: edge_is_bridge() will test for whether edges are bridges (their removal will result in splitting up a component into two edge_is_feedback_arc() queries whether edges are part of the feedback arc set graph_is_eulerian() and edge_rank_eulerian() provides access to eulerian path and cycle calculations graph_efficiency() and node_efficiency() provides access to global and local efficiency calculations group_leiden() and group_fluid() provides access to the new cluster_leiden() and cluster_fluid_communities() community detection algorithms group_color() provides an interface to graph coloring. While not really a clustering algorithm the output matches closely with those as it provides a single id to each node centrality_harmonic() supersedes centrality_closeness_harmonic() using an efficient C implementation over the flexible but slower implementation from the netrankr package random_walk_rank() provides access to random walks on both edges and nodes to_largest_component() and to_random_spanning_tree() are two new morphers node_is_connected() tests whether nodes are connected to all or any of the nodes in a given set Apart from changes in igraph, tidygraph also needs to stay somewhat current to another package, namely dplyr. In this release we have added support for the various slice_*() types so that you can now use e.g. slice_min() or slice_sample() on tbl_graph objects. And while not directly dplyr (but tidyr) you can now use replace_na() and drop_na() with tbl_graph objects as well. Wrapping up Mature packages are a weird thing as a developer. You seldom spend much time with them as they are working as intended, even if they are a cornerstone of some of your work. Tidygraph definitely falls into this spot. It was nice to get to relearn it a bit as I prepared this release and I hope the new additions will spark joy. Take care",
      "twitter_title": "A new focus on tidygraph | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/12/a-new-focus-on-tidygraph/",
      "word_count": 1314
    }
  }
}