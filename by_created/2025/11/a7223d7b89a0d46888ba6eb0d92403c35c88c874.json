{
  "id": "a7223d7b89a0d46888ba6eb0d92403c35c88c874",
  "url": "https://www.r-bloggers.com/2023/10/reading-notes-on-git-in-practice-by-mike-mcquaid/",
  "created_at_utc": "2025-11-17T20:39:26Z",
  "data": null,
  "raw_original": {
    "uuid": "2c5d5314-8c98-4d5d-a6de-167336b80d8e",
    "created_at": "2025-11-17 20:39:26",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/10/reading-notes-on-git-in-practice-by-mike-mcquaid/",
      "crawled_at": "2025-11-17T10:01:35.533884",
      "external_links": [
        {
          "href": "https://masalmon.eu/2023/11/01/reading-notes-git-in-practice/",
          "text": "Ma√´lle's R blog on Ma√´lle Salmon's personal website"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://suzan.rbind.io/2018/03/reflections-4-months-of-github/",
          "text": "post about Git and GitHub"
        },
        {
          "href": "https://suzan.rbind.io/2018/03/reflections-4-months-of-github/#final-thoughts",
          "text": "mentioned"
        },
        {
          "href": "https://www.manning.com/books/git-in-practice",
          "text": "‚ÄúGit in Practice‚Äù by Mike McQuaid"
        },
        {
          "href": "https://en.wikipedia.org/wiki/Momox",
          "text": "Momox"
        },
        {
          "href": "https://github.com/MikeMcQuaid/GitInPractice#readme",
          "text": "GitHub"
        },
        {
          "href": "https://www.manning.com/books/the-programmers-brain",
          "text": "‚ÄúThe Programmer‚Äôs Brain‚Äù by Felienne Hermans"
        },
        {
          "href": "https://peerj.com/preprints/3159/",
          "text": "‚ÄúExcuse me, do you have a moment to talk about version control?‚Äù by Jenny Bryan"
        },
        {
          "href": "https://www.conventionalcommits.org/en/v1.0.0/",
          "text": "conventional commits convention"
        },
        {
          "href": "https://github.com/r-lib/gert/issues/70",
          "text": "gert::git_commit_id()"
        },
        {
          "href": "https://happygitwithr.com/pull-tricky.html",
          "text": "‚ÄúPull, but you have local work‚Äù chapter"
        },
        {
          "href": "https://docs.ropensci.org/gert/reference/git_fetch.html",
          "text": "gert::git_push()"
        },
        {
          "href": "https://fledge.cynkra.com/",
          "text": "fledge package"
        },
        {
          "href": "https://rdrr.io/r/base/browser.html",
          "text": "browser()"
        },
        {
          "href": "https://mastodon.social/deck/@kirill@fosstodon.org/111302703034532823",
          "text": "toot by Kirill M√ºller"
        },
        {
          "href": "https://github.com/newren/git-filter-repo/",
          "text": "git filter-repo"
        },
        {
          "href": "https://github.com/newren/git-filter-repo/#simple-example-with-comparisons",
          "text": "simple example"
        },
        {
          "href": "https://usethis.r-lib.org/reference/git_vaccinate.html",
          "text": "usethis::git_vaccinate()"
        },
        {
          "href": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_help_autocorrect",
          "text": "help.autocorrect"
        },
        {
          "href": "https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors",
          "text": "https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors"
        },
        {
          "href": "https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors",
          "text": "rOpenSci dev guide"
        },
        {
          "href": "https://masalmon.eu/2023/11/01/reading-notes-git-in-practice/",
          "text": "Ma√´lle's R blog on Ma√´lle Salmon's personal website"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Reading notes on Git in Practice by Mike McQuaid | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/maelles-r-blog-on-maelle-salmons-personal-website/",
          "text": "Ma√´lle's R blog on Ma√´lle Salmon's personal website"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-379570 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Reading notes on Git in Practice by Mike McQuaid</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">October 31, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/maelles-r-blog-on-maelle-salmons-personal-website/\">Ma√´lle's R blog on Ma√´lle Salmon's personal website</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://masalmon.eu/2023/11/01/reading-notes-git-in-practice/\"> Ma√´lle's R blog on Ma√´lle Salmon's personal website</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>While preparing materials for teaching Git a few months ago, I re-read Suzan Baert‚Äôs excellent <a href=\"https://suzan.rbind.io/2018/03/reflections-4-months-of-github/\" rel=\"nofollow\" target=\"_blank\">post about Git and GitHub</a>, where she <a href=\"https://suzan.rbind.io/2018/03/reflections-4-months-of-github/#final-thoughts\" rel=\"nofollow\" target=\"_blank\">mentioned</a> having read <a href=\"https://www.manning.com/books/git-in-practice\" rel=\"nofollow\" target=\"_blank\">‚ÄúGit in Practice‚Äù by Mike McQuaid</a>. I added the book to my <a href=\"https://en.wikipedia.org/wiki/Momox\" rel=\"nofollow\" target=\"_blank\">Momox</a> alerts, where it got available a few weeks later. The book source is on <a href=\"https://github.com/MikeMcQuaid/GitInPractice#readme\" rel=\"nofollow\" target=\"_blank\">GitHub</a>.</p>\n<p>The book isn‚Äôt too heavy, so I took it with me on a long train journey! üöã</p>\n<p>Here are my reading notes, since I hope this habit of writing book learnings will stick. These notes are of limited generalizability, depending on what your own Git practice and knowledge are. Some chapter numbers are missing: they are those that were less relevant to me.</p>\n<h2 id=\"first-impressions\">First impressions</h2>\n<h3 id=\"manning-publications-book-cover\">Manning Publications book cover</h3>\n<p>This is the second book published by Manning that I own, the other being <a href=\"https://www.manning.com/books/the-programmers-brain\" rel=\"nofollow\" target=\"_blank\">‚ÄúThe Programmer‚Äôs Brain‚Äù by Felienne Hermans</a>. Both have covers featuring an ancient drawing of someone wearing a traditional dress, but different drawings of course, and different artists. For ‚ÄúGit in Practice‚Äù the cover is ‚ÄúA Kamtchadale in her full dress in 1768‚Äù. While the editor didn‚Äôt explain why a particular drawing was chosen, they have a general explanation</p>\n<blockquote>\n<p>At a time when it is hard to tell one computer book from another, Manning celebrates the inventiveness and initiative of the computer business with book covers based on the right diversity of national costumes (‚Ä¶)</p>\n</blockquote>\n<p>Good to know!</p>\n<h3 id=\"not-a-book-for-beginners\">Not a book for beginners</h3>\n<p>The book is advertised for users at an ‚Äúintermediate to advanced level‚Äù. One thing that clearly shows this is that the content on ‚ÄúWhy you should use version control and how to convince others that doing so is a good idea‚Äù is an Appendix! Note that the content I‚Äôd actually use on the topic is the article <a href=\"https://peerj.com/preprints/3159/\" rel=\"nofollow\" target=\"_blank\">‚ÄúExcuse me, do you have a moment to talk about version control?‚Äù by Jenny Bryan</a>.</p>\n<h3 id=\"an-older-book\">An older book?</h3>\n<p>The book was published in 2015. I guess some Git things have been deprecated but I assume most of the book is still valid. What aged really bad: the screenshots from GitHub interface!</p>\n<h3 id=\"66-techniques\">66 ‚Äútechniques‚Äù</h3>\n<p>The book cover indicates it includes 66 techniques. The first techniques are <code>git init</code>, <code>git add</code>, <code>git commit</code>: calling them techniques is a bit of a stretch to me? But then the very predictable structure of the book content was actually great, so using that structure from the get go wasn‚Äôt bad at all.</p>\n<h2 id=\"chapter-1-local-git\">Chapter 1: Local Git</h2>\n<h3 id=\"clearer-understanding-of-git-add\">Clearer understanding of Git add</h3>\n<blockquote>\n<p>‚ÄúRather than require all changes in the working tree to make up the next commit, Git allows files to be added incrementally to the index‚Äù</p>\n</blockquote>\n<p>So, while I‚Äôve been practicing this, I‚Äôm not sure I ever expressed the usefulness of <code>git add</code>.</p>\n<p>I also underlined a sentence explaining that <code>git add</code> does two things:</p>\n<blockquote>\n<p>‚Äúgit add is used both to initially add a file to the Git repository and to request that changes to the fine be used in the next commit.‚Äù</p>\n</blockquote>\n<h3 id=\"garbage-in-garbage-out\">Garbage in, garbage out</h3>\n<p>I liked that sentence:</p>\n<blockquote>\n<p>‚ÄúHow useful the history is relies a great deal on the quality of data entered into it.‚Äù</p>\n</blockquote>\n<p>Then the author mentions two reasons why small commits are better:</p>\n<ul>\n<li>Better readability of the history;</li>\n<li>Easier reversal of an unwanted change.</li>\n</ul>\n<h3 id=\"commit-messages-are-structured-like-emails\">Commit messages are structured like emails</h3>\n<p>And apparently this comes from the history of Git, where commits could be sent as email. So the first line of a commit message is the subject and the rest, the body.</p>\n<p>I guess there‚Äôs also a parallel between the <a href=\"https://www.conventionalcommits.org/en/v1.0.0/\" rel=\"nofollow\" target=\"_blank\">conventional commits convention</a>, where you add a prefix to the subject indicating its category: ‚Äúfix:‚Äù for bug fixes, ‚Äúfeat:‚Äù for features, is like adding a prefix to an email subject: ‚Äú[ACTION REQUIRED]‚Äù.</p>\n<h3 id=\"a-motivation-for-rewriting-history\">A motivation for rewriting history</h3>\n<blockquote>\n<p>‚Äúthere‚Äôs no need for everyone to see the mistakes you made along the way‚Äù</p>\n</blockquote>\n<p>Now let‚Äôs see if this, and other parts of the book, motivate me enough to rewrite the history of my Git branches before I mark a PR as ready for review.</p>\n<h3 id=\"a-better-understanding-of-git-diff\">A better understanding of Git diff</h3>\n<p>I didn‚Äôt know that one could call <code>git diff</code> without an argument, and that it‚Äôd show the diff between the working directory and the index staging area‚Ä¶ but apparently only for files that were already added, which answers my question about how different that is from <code>git status</code>:</p>\n<div class=\"highlight\">\n<pre>git_repo &lt;- withr::local_tempdir()\ngert::git_init(git_repo)\n\nbrio::write_lines(\"blop\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#&gt;      file status staged\n#&gt; 1 bla.txt    new   TRUE\nfirst_commit &lt;- gert::git_commit(\"first commit\", repo = git_repo)\n\nbrio::write_lines(\"bip\", path = file.path(git_repo, \"other.txt\"))\n\ngert::git_diff(\"HEAD\", repo = git_repo)\n#&gt;   status     old     new\n#&gt; 1      A bla.txt bla.txt\n#&gt;                                                                                                                                patch\n#&gt; 1 diff --git a/bla.txt b/bla.txt\\nnew file mode 100644\\nindex 0000000..35733a0\\n--- /dev/null\\n+++ b/bla.txt\\n@@ -0,0 +1 @@\\n+blop\\n\ngert::git_diff(first_commit, repo = git_repo)\n#&gt;   status     old     new\n#&gt; 1      A bla.txt bla.txt\n#&gt;                                                                                                                                patch\n#&gt; 1 diff --git a/bla.txt b/bla.txt\\nnew file mode 100644\\nindex 0000000..35733a0\\n--- /dev/null\\n+++ b/bla.txt\\n@@ -0,0 +1 @@\\n+blop\\n\ngert::git_diff(repo = git_repo)\n#&gt; [1] status old    new    patch \n#&gt; &lt;0 rows&gt; (or 0-length row.names)\ngert::git_status()\n#&gt;                                                              file  status\n#&gt; 2  content/post/2023-01-02-reading-notes-git-in-practice/index.md deleted\n#&gt; 1 content/post/2023-01-02-reading-notes-git-in-practice/index.Rmd deleted\n#&gt; 3          content/post/2023-11-01-reading-notes-git-in-practice/     new\n#&gt;   staged\n#&gt; 2  FALSE\n#&gt; 1  FALSE\n#&gt; 3  FALSE\n\nbrio::write_lines(\"bip\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_diff(repo = git_repo)\n#&gt;   status     old     new\n#&gt; 1      M bla.txt bla.txt\n#&gt;                                                                                                                     patch\n#&gt; 1 diff --git a/bla.txt b/bla.txt\\nindex 35733a0..94652b8 100644\\n--- a/bla.txt\\n+++ b/bla.txt\\n@@ -1 +1 @@\\n-blop\\n+bip\\n\ngert::git_status()\n#&gt;                                                              file  status\n#&gt; 2  content/post/2023-01-02-reading-notes-git-in-practice/index.md deleted\n#&gt; 1 content/post/2023-01-02-reading-notes-git-in-practice/index.Rmd deleted\n#&gt; 3          content/post/2023-11-01-reading-notes-git-in-practice/     new\n#&gt;   staged\n#&gt; 2  FALSE\n#&gt; 1  FALSE\n#&gt; 3  FALSE\n</pre>\n</div>\n<h3 id=\"smiling-refs\">Smiling refs</h3>\n<p>I learnt that <code>main^</code> is equivalent to <code>main~1</code> and <code>main^^</code> is equivalent to <code>main~2</code>. ^_^</p>\n<h3 id=\"git-rev-parse\">Git rev-parse</h3>\n<p>So if you use say <code>main^^</code> and want to get the actual SHA, you can use <code>git rev-parse</code>. In gert, that‚Äôs <a href=\"https://github.com/r-lib/gert/issues/70\" rel=\"nofollow\" target=\"_blank\">gert::git_commit_id()</a>.</p>\n<div class=\"highlight\">\n<pre>git_repo &lt;- withr::local_tempdir()\ngert::git_init(git_repo)\n\nbrio::write_lines(\"blop\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#&gt;      file status staged\n#&gt; 1 bla.txt    new   TRUE\ngert::git_commit(\"first commit\", repo = git_repo)\n#&gt; [1] \"c17a89d5682d3bab91e412aa935062c35dcdc1e2\"\n\nbrio::write_lines(\"blip\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#&gt;      file   status staged\n#&gt; 1 bla.txt modified   TRUE\ngert::git_commit(\"second commit\", repo = git_repo)\n#&gt; [1] \"9a02ae19cbcd1f03bd68aba9cd414b7d83250d3d\"\n\nbrio::write_lines(\"blup\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#&gt;      file   status staged\n#&gt; 1 bla.txt modified   TRUE\ngert::git_commit(\"third commit\", repo = git_repo)\n#&gt; [1] \"cd437aebe6e3f11223cdc4c4d62e3660bde56dbd\"\n\ngert::git_commit_id(\"main\", repo = git_repo)\n#&gt; [1] \"cd437aebe6e3f11223cdc4c4d62e3660bde56dbd\"\ngert::git_commit_id(\"main^\", repo = git_repo)\n#&gt; [1] \"9a02ae19cbcd1f03bd68aba9cd414b7d83250d3d\"\ngert::git_commit_id(\"main^^\", repo = git_repo)\n#&gt; [1] \"c17a89d5682d3bab91e412aa935062c35dcdc1e2\"\n</pre>\n</div>\n<h2 id=\"chapter-2-remote-git\">Chapter 2: Remote Git</h2>\n<p>Interestingly that‚Äôs the chapter where branches are introduced.</p>\n<h3 id=\"git-as-a-distributed-version-control-system\">Git as a distributed version control system</h3>\n<p>My first version control experience was with SVN, for a package developed on R-forge. I only remember two things: the cute tortoise of Tortoise-SVN, and the fact that instead of doing commit+push I‚Äôd only do commit. It makes sense now that I understand that Git is a distributed version control system whereas SVN is centralized, with a remote repo being the source of truth.</p>\n<h3 id=\"why-git-fetch\">Why Git fetch?</h3>\n<p>To be honest, I‚Äôm still not sure when I would use <code>git fetch</code>! <code>git fetch</code> is for fetching changes from a remote without modifying local branches. I only use <code>git pull</code> (which is fetch+merge) or <code>git pull --rebase</code> when that fails, mostly. Note that the <a href=\"https://happygitwithr.com/pull-tricky.html\" rel=\"nofollow\" target=\"_blank\">‚ÄúPull, but you have local work‚Äù chapter</a> of happygitwithr by Jenny Bryan, the STAT 545 TAs, Jim Hester looks useful (I found it by searching for ‚Äúfetch‚Äù in that book).</p>\n<p>Mike McQuaid wrote a paragraph ‚ÄúShould you use pull or fetch?‚Äù where he explains he prefers git fetch because he can incorporate remote changes when it makes sense, using a method of his choice (merging, rebasing, resetting). He also says <code>git fetch</code> is better for working in situations with no internet connection, which was unclear to me.</p>\n<h3 id=\"branch-names\">Branch names</h3>\n<p>Mike McQuaid recommends creating a branch name that describes ‚Äúthe branch‚Äôs purpose in multiple words separated by hyphens‚Äù. That‚Äôs what I tend to do, probably imitating what I saw elsewhere. Sometimes my branch names are less informative, and this makes me cringe when I open the corresponding PR.</p>\n<h3 id=\"pushing-a-local-branch-remotely\">Pushing a local branch remotely</h3>\n<p>This section just made me very happy I push local branches with <a href=\"https://docs.ropensci.org/gert/reference/git_fetch.html\" rel=\"nofollow\" target=\"_blank\"><code>gert::git_push()</code></a>, because it sets the upstream branch automatically by default.</p>\n<h3 id=\"slowly-slowly-understanding-merge-commits\">Slowly, slowly understanding merge commits</h3>\n<p>I learnt that merge commits are commits with multiple parents when working on the <a href=\"https://fledge.cynkra.com/\" rel=\"nofollow\" target=\"_blank\">fledge package</a>. When reading ‚ÄúGit in practice‚Äù, I at least understood ‚Äúfast-forward merge‚Äù which is something I had simply ignored when Git told me it had done one.</p>\n<p>So, for my future reference‚Ä¶ If I am merging a branch A into main, and Git tells me it did a fast-forward merge, it means no merge commit was needed so none was made. The branch A commits were added to the main branch without new commit before that.</p>\n<h3 id=\"conflicts-and-merge-commits\">Conflicts and merge commits</h3>\n<blockquote>\n<p>‚ÄúWhen conflicts have been resolved, a <em>merge commit</em> can be made. This stores the two parent commits and the conflicts that were resolved so they can be inspected un the future. Unfortunately, sometimes people pick the wrong option or merge incorrectly, so it‚Äôs good to be able to later see what conflicts they had to resolve.‚Äù</p>\n</blockquote>\n<p>This was new to me, certaintly not something I had in mind when resolving conflicts.</p>\n<h2 id=\"chapter-3-filesystem-interactions\">Chapter 3: Filesystem interactions</h2>\n<h3 id=\"git-mv-git-rm\">Git mv, Git rm</h3>\n<p>I was never aware of <code>git mv</code>, for renaming and moving a file. I think it‚Äôs because the RStudio IDE Git thingie was doing this for me? When I rename a file, I see the status becomes ‚ÄúR‚Äù once I‚Äôve added both the file deletion (old name) and the file adding (new name).</p>\n<p>The same goes for <code>git rm</code> for removing a file.</p>\n<h3 id=\"i-should-use-git-reset-more-often\">I should use Git reset more often</h3>\n<p>An use case for <code>git reset</code> that was described really resonated with me. üòÖ</p>\n<blockquote>\n<p>‚ÄúPerhaps you added debugging statements to files and have now commited a fix, so you want to reset all the files that haven‚Äôt been committed to their last committed state (on the current branch)‚Äù.</p>\n</blockquote>\n<p>So instead of looking at the Git diff to remember where I added <a href=\"https://rdrr.io/r/base/browser.html\" rel=\"nofollow\" target=\"_blank\"><code>browser()</code></a>, or looking for occurrences of a given debugging thing, I could use <code>git reset</code>, now that sounds smarter!</p>\n<h3 id=\"i-should-adopt-git-clean\">I should adopt Git clean</h3>\n<p><code>git clean</code> will remove any untracked file from the filesystem. Like the previous idea, it sounds like something I could use when debugging something and creating files √† la ‚Äúblop.text‚Äù.</p>\n<p>Now <code>git clean</code> can be dangerous so you can first run <code>git clean -n</code> or <code>git clean --dry-run</code> to see what would be removed.</p>\n<p>Note that gert doesn‚Äôt seem to support <code>git clean</code> so I‚Äôd do this from a terminal.</p>\n<p>The book also explains the <code>-X</code> argument of <code>git clean</code> for removing only ignored files, compared to the lower case <code>-x</code> argument for removing both ignored and untracked files.</p>\n<p>In conclusion I need to practice using <code>git clean</code>, and to refer to its docs when doing so, but at least now I know it exists.</p>\n<h3 id=\"could-git-stash-be-useful-to-me\">Could Git stash be useful to me</h3>\n<p><code>git stash save</code> is a command for temporarily stashing some changes. <code>git stash pop</code> gets them back. <code>git stadsh clear</code> clears stashed commits.</p>\n<p>I can‚Äôt think of an use case right now but maybe I will encounter one one day?</p>\n<h3 id=\"git-update-index---assume-unchanged-path\">Git update-index <code>--assume-unchanged</code> <path></path></h3>\n<p>Again an use case that resonated with me (well I don‚Äôt use Rails but still)</p>\n<blockquote>\n<p>‚ÄúI‚Äôve found myself in a situation in the past where I wanted to test a Rails configuration file change for a week or two while continuing to do my normal work. I didn‚Äôt want to commit it because I didn‚Äôt want it to apply to servers or my coworkers, but I did want to continue testing it while I made other commits rather than change to a particular branch each time.‚Äù</p>\n</blockquote>\n<p>So in that case one can run <code>Git update-index --assume-unchanged &lt;path&gt;</code>. Then you undo this by running <code>Git update-index --no-assume-unchanged &lt;path&gt;</code>.</p>\n<h2 id=\"chapter-4-history-visualization\">Chapter 4: History visualization</h2>\n<p>Honestly most of this chapter made me happy about the GitHub interface!</p>\n<p>The other thing is that it has an explanation of <code>git bisect</code> that I need to come back to next time I need to find which commit caused a particular bug. I tend to be scared of <code>git bisect</code>, but the explanation made sense. Also I guess I need to focus on making small informative commits before bisect really shines in my use cases. üòá</p>\n<p>I am especially curious about <code>git bisect run</code> for automating <code>git bisect</code>, I wonder how that would work with a testthat unit test.</p>\n<h2 id=\"chapter-5-advanced-branching\">Chapter 5: Advanced branching</h2>\n<h3 id=\"merge-strategies\">Merge strategies</h3>\n<p>I learnt there‚Äôs a merge strategy, <code>--ours</code>, that will ignore all changes from the incoming branch but still indicate it in the history. That‚Äôs supposed to be useful for when you want to keep an experiment from an experimental branch in the history.</p>\n<p>There‚Äôs another interesting merge strategy, <code>--patience</code>, that ‚Äúuses a slightly more expensive git diff algorithm to try to decrease the chance of a merge conflict‚Äù. It sounds like a joke.</p>\n<h3 id=\"not-useful-to-me-but-fun-name-git-rerere\">Not useful to me but fun name: git rerere</h3>\n<p><code>git rerere</code>, Reuse Recorded Resolution, allows you to resolve each merge conflict only once.</p>\n<p>I sort of understand the use case but it doesn‚Äôt sound useful to my work:</p>\n<blockquote>\n<p>‚ÄúYou may find yourself in a situation where you have a long-running branch that you have to keep merging in another branch, and you get the same merge conflict every time.‚Äù</p>\n</blockquote>\n<h3 id=\"yay-git-cherry-pick\">Yay git cherry-pick</h3>\n<p><code>git cherry-pick</code> allows you to add a single commit to the current branch. I recently successfully used it!</p>\n<p>A collaborator had mistakenly created a new feature branch from another feature branch instead of from the main branch. After that they added their feature commit but the PR was all broken. I created a new branch from the main branch, cherry-picked the commit and then opened a new PR. It‚Äôs a small step for humanity but it was a big step for me. üòÅ It was very cool to be able to say ‚Äúdon‚Äôt worry, I‚Äôve got it‚Äù to that collaborator.</p>\n<h2 id=\"chapter-6-rewriting-history-and-disaster-recovery\">Chapter 6: Rewriting history and disaster recovery</h2>\n<h3 id=\"another-new-to-me-command-git-reflog\">Another new-to-me command: git reflog</h3>\n<p><code>git reflog</code> will list ‚Äúall changes including history rewrites‚Äù, for the local repository. Commits that are deleted on all branches are only kept in the reflog for 90 days.</p>\n<h3 id=\"git-reset-can-take-a-list-of-paths-as-arguments\">Git reset can take a list of paths as arguments</h3>\n<p>An example would be <code>git reset HEAD^ -- path.txt</code></p>\n<h3 id=\"actually-retired-now-git-filter-branch\">Actually retired now: Git filter-branch</h3>\n<p>One technique presented in the book, for rewriting git repository history, is <code>git filter-branch</code> but then I saw a <a href=\"https://mastodon.social/deck/@kirill@fosstodon.org/111302703034532823\" rel=\"nofollow\" target=\"_blank\">toot by Kirill M√ºller</a> indicating it‚Äôs retired. A replacement is <a href=\"https://github.com/newren/git-filter-repo/\" rel=\"nofollow\" target=\"_blank\">git filter-repo</a>, that I‚Äôd have to explore a bit more before being able to use it. The <a href=\"https://github.com/newren/git-filter-repo/#simple-example-with-comparisons\" rel=\"nofollow\" target=\"_blank\">simple example</a> looks convincing enough! According to the book this can be useful for some cases of disaster recovery.</p>\n<h3 id=\"commit-regularly\">Commit regularly</h3>\n<p>This is the main message of this chapter, and it‚Äôs not an advanced technique at all, just a good habit. üò∏</p>\n<h2 id=\"chapter-7-personalizing-git\">Chapter 7: Personalizing Git</h2>\n<h3 id=\"option-for-pruning-branches-automatically\">Option for pruning branches automatically</h3>\n<p>If you want the references to now deleted remote branches to be deleted, you can run <code>git remote prune origin</code> or configure Git so that this will happen every time you pull or fetch.</p>\n<div class=\"highlight\">\n<pre>gert::git_config_global_set(\"fetch.prune\", 1)</pre>\n</div>\n<h3 id=\"global-gitignore\">Global gitignore</h3>\n<p>I already knew about the global gitignore file thanks to the handy <a href=\"https://usethis.r-lib.org/reference/git_vaccinate.html\" rel=\"nofollow\" target=\"_blank\"><code>usethis::git_vaccinate()</code></a>.</p>\n<h3 id=\"an-option-for-autocorrecting-misspelled-commands\">An option for autocorrecting misspelled commands</h3>\n<p>There‚Äôs a Git option for autocorrecting misspelled commands, <a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_help_autocorrect\" rel=\"nofollow\" target=\"_blank\">help.autocorrect</a>. It would not help me since my most frequent typo is ‚Äúgut‚Äù instead of ‚Äúgit‚Äù, sadly.</p>\n<h2 id=\"chapter-8-vendoring-dependencies-as-submodules\">Chapter 8: Vendoring dependencies as submodules</h2>\n<p>If I ever have to work again with a repo that uses submodules üò≠, I might go back to this chapter to see which commands to run.</p>\n<h2 id=\"chapter-12-creating-a-clean-history\">Chapter 12: Creating a clean history</h2>\n<h3 id=\"one-can-build-a-commit-from-parts-of-files\">One can build a commit from parts of files</h3>\n<p>Using <code>git add --patch &lt;path&gt;</code>. This opens an interactive menu letting you choose which hunk(s) to add to a commit. Each hunk can be split into smaller hunks. Then one uses <code>git commit</code> as usual.</p>\n<p>The book also mentions that <code>git commit --patch</code> also exists. It seems less intuitive to me to do the hunk selection at that stage.</p>\n<h2 id=\"chapter-13-merging-vsrebasing\">Chapter 13: merging vs.¬†rebasing</h2>\n<p>This chapter compares the strategies of two projects:</p>\n<ul>\n<li>CMake‚Äôs branching and merging strategy.</li>\n<li>Homebrew‚Äôs rebasing and squashing strategy. ‚ÄúThis hides merge commits, evidence of branches, and temporary commits (for example, those that fix previous commits on the same branch) from the main branch.‚Äù</li>\n</ul>\n<p>To me CMake history looks like a mess or even a nightmare so I guess I‚Äôm in favor of the Homebrew‚Äôs strategy!</p>\n<p>But in each project, it is worth to have a discussion about the chosen strategy, to educate contributors.</p>\n<p>I liked reading that in Homebrew, metadata is included into commit messages. For instance I enjoy the fact that GitHub automatically adds co-authors when you squash and merge a PR that add multiple contributors: <a href=\"https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors\" rel=\"nofollow\" target=\"_blank\">https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors</a></p>\n<h2 id=\"chapter-14-recommended-team-workflows\">Chapter 14: Recommended team workflows</h2>\n<p>Have you heard of GitHub flow, Git flow? These are <em>team workflows</em>.</p>\n<blockquote>\n<p>‚ÄúThe different strategies for deciding how and when to branch, merge or rebase as part of a team are called <em>team workflows</em>.‚Äù</p>\n</blockquote>\n<p>I much prefer GitHub flow where the default branch is stable and where there is no long-lived development branch, because in my experience, having such a long-lived development branch has lead to more confusion than gains. For <a href=\"https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors\" rel=\"nofollow\" target=\"_blank\">rOpenSci dev guide</a> we went from some sort of Git flow to GitHub flow, where actual relases will be, well, actual releases/tags of the main branch. Changing flows was such a relief!</p>\n<p>The author also presented his own two usual flows.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>‚ÄúGit in practice‚Äù by Mike McQuaid was a nice train travel companion. I feared it would be too dry or obscure but found it clear and well explained. I learnt a lot, but now, I will have to‚Ä¶ practice what I learnt! üòÅ</p>\n<p>Did you read this book, or another Git book? How did you learn Git? Any strong opinion on any of the topics mentioned in those notes?</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://masalmon.eu/2023/11/01/reading-notes-git-in-practice/\"> Ma√´lle's R blog on Ma√´lle Salmon's personal website</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "Reading notes on Git in Practice by Mike McQuaid\nPosted on\nOctober 31, 2023\nby\nMa√´lle's R blog on Ma√´lle Salmon's personal website\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nMa√´lle's R blog on Ma√´lle Salmon's personal website\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nWhile preparing materials for teaching Git a few months ago, I re-read Suzan Baert‚Äôs excellent\npost about Git and GitHub\n, where she\nmentioned\nhaving read\n‚ÄúGit in Practice‚Äù by Mike McQuaid\n. I added the book to my\nMomox\nalerts, where it got available a few weeks later. The book source is on\nGitHub\n.\nThe book isn‚Äôt too heavy, so I took it with me on a long train journey! üöã\nHere are my reading notes, since I hope this habit of writing book learnings will stick. These notes are of limited generalizability, depending on what your own Git practice and knowledge are. Some chapter numbers are missing: they are those that were less relevant to me.\nFirst impressions\nManning Publications book cover\nThis is the second book published by Manning that I own, the other being\n‚ÄúThe Programmer‚Äôs Brain‚Äù by Felienne Hermans\n. Both have covers featuring an ancient drawing of someone wearing a traditional dress, but different drawings of course, and different artists. For ‚ÄúGit in Practice‚Äù the cover is ‚ÄúA Kamtchadale in her full dress in 1768‚Äù. While the editor didn‚Äôt explain why a particular drawing was chosen, they have a general explanation\nAt a time when it is hard to tell one computer book from another, Manning celebrates the inventiveness and initiative of the computer business with book covers based on the right diversity of national costumes (‚Ä¶)\nGood to know!\nNot a book for beginners\nThe book is advertised for users at an ‚Äúintermediate to advanced level‚Äù. One thing that clearly shows this is that the content on ‚ÄúWhy you should use version control and how to convince others that doing so is a good idea‚Äù is an Appendix! Note that the content I‚Äôd actually use on the topic is the article\n‚ÄúExcuse me, do you have a moment to talk about version control?‚Äù by Jenny Bryan\n.\nAn older book?\nThe book was published in 2015. I guess some Git things have been deprecated but I assume most of the book is still valid. What aged really bad: the screenshots from GitHub interface!\n66 ‚Äútechniques‚Äù\nThe book cover indicates it includes 66 techniques. The first techniques are\ngit init\n,\ngit add\n,\ngit commit\n: calling them techniques is a bit of a stretch to me? But then the very predictable structure of the book content was actually great, so using that structure from the get go wasn‚Äôt bad at all.\nChapter 1: Local Git\nClearer understanding of Git add\n‚ÄúRather than require all changes in the working tree to make up the next commit, Git allows files to be added incrementally to the index‚Äù\nSo, while I‚Äôve been practicing this, I‚Äôm not sure I ever expressed the usefulness of\ngit add\n.\nI also underlined a sentence explaining that\ngit add\ndoes two things:\n‚Äúgit add is used both to initially add a file to the Git repository and to request that changes to the fine be used in the next commit.‚Äù\nGarbage in, garbage out\nI liked that sentence:\n‚ÄúHow useful the history is relies a great deal on the quality of data entered into it.‚Äù\nThen the author mentions two reasons why small commits are better:\nBetter readability of the history;\nEasier reversal of an unwanted change.\nCommit messages are structured like emails\nAnd apparently this comes from the history of Git, where commits could be sent as email. So the first line of a commit message is the subject and the rest, the body.\nI guess there‚Äôs also a parallel between the\nconventional commits convention\n, where you add a prefix to the subject indicating its category: ‚Äúfix:‚Äù for bug fixes, ‚Äúfeat:‚Äù for features, is like adding a prefix to an email subject: ‚Äú[ACTION REQUIRED]‚Äù.\nA motivation for rewriting history\n‚Äúthere‚Äôs no need for everyone to see the mistakes you made along the way‚Äù\nNow let‚Äôs see if this, and other parts of the book, motivate me enough to rewrite the history of my Git branches before I mark a PR as ready for review.\nA better understanding of Git diff\nI didn‚Äôt know that one could call\ngit diff\nwithout an argument, and that it‚Äôd show the diff between the working directory and the index staging area‚Ä¶ but apparently only for files that were already added, which answers my question about how different that is from\ngit status\n:\ngit_repo <- withr::local_tempdir()\ngert::git_init(git_repo)\n\nbrio::write_lines(\"blop\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#>      file status staged\n#> 1 bla.txt    new   TRUE\nfirst_commit <- gert::git_commit(\"first commit\", repo = git_repo)\n\nbrio::write_lines(\"bip\", path = file.path(git_repo, \"other.txt\"))\n\ngert::git_diff(\"HEAD\", repo = git_repo)\n#>   status     old     new\n#> 1      A bla.txt bla.txt\n#>                                                                                                                                patch\n#> 1 diff --git a/bla.txt b/bla.txt\\nnew file mode 100644\\nindex 0000000..35733a0\\n--- /dev/null\\n+++ b/bla.txt\\n@@ -0,0 +1 @@\\n+blop\\n\ngert::git_diff(first_commit, repo = git_repo)\n#>   status     old     new\n#> 1      A bla.txt bla.txt\n#>                                                                                                                                patch\n#> 1 diff --git a/bla.txt b/bla.txt\\nnew file mode 100644\\nindex 0000000..35733a0\\n--- /dev/null\\n+++ b/bla.txt\\n@@ -0,0 +1 @@\\n+blop\\n\ngert::git_diff(repo = git_repo)\n#> [1] status old    new    patch \n#> <0 rows> (or 0-length row.names)\ngert::git_status()\n#>                                                              file  status\n#> 2  content/post/2023-01-02-reading-notes-git-in-practice/index.md deleted\n#> 1 content/post/2023-01-02-reading-notes-git-in-practice/index.Rmd deleted\n#> 3          content/post/2023-11-01-reading-notes-git-in-practice/     new\n#>   staged\n#> 2  FALSE\n#> 1  FALSE\n#> 3  FALSE\n\nbrio::write_lines(\"bip\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_diff(repo = git_repo)\n#>   status     old     new\n#> 1      M bla.txt bla.txt\n#>                                                                                                                     patch\n#> 1 diff --git a/bla.txt b/bla.txt\\nindex 35733a0..94652b8 100644\\n--- a/bla.txt\\n+++ b/bla.txt\\n@@ -1 +1 @@\\n-blop\\n+bip\\n\ngert::git_status()\n#>                                                              file  status\n#> 2  content/post/2023-01-02-reading-notes-git-in-practice/index.md deleted\n#> 1 content/post/2023-01-02-reading-notes-git-in-practice/index.Rmd deleted\n#> 3          content/post/2023-11-01-reading-notes-git-in-practice/     new\n#>   staged\n#> 2  FALSE\n#> 1  FALSE\n#> 3  FALSE\nSmiling refs\nI learnt that\nmain^\nis equivalent to\nmain~1\nand\nmain^^\nis equivalent to\nmain~2\n. ^_^\nGit rev-parse\nSo if you use say\nmain^^\nand want to get the actual SHA, you can use\ngit rev-parse\n. In gert, that‚Äôs\ngert::git_commit_id()\n.\ngit_repo <- withr::local_tempdir()\ngert::git_init(git_repo)\n\nbrio::write_lines(\"blop\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#>      file status staged\n#> 1 bla.txt    new   TRUE\ngert::git_commit(\"first commit\", repo = git_repo)\n#> [1] \"c17a89d5682d3bab91e412aa935062c35dcdc1e2\"\n\nbrio::write_lines(\"blip\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#>      file   status staged\n#> 1 bla.txt modified   TRUE\ngert::git_commit(\"second commit\", repo = git_repo)\n#> [1] \"9a02ae19cbcd1f03bd68aba9cd414b7d83250d3d\"\n\nbrio::write_lines(\"blup\", path = file.path(git_repo, \"bla.txt\"))\ngert::git_add(\"bla.txt\", repo = git_repo)\n#>      file   status staged\n#> 1 bla.txt modified   TRUE\ngert::git_commit(\"third commit\", repo = git_repo)\n#> [1] \"cd437aebe6e3f11223cdc4c4d62e3660bde56dbd\"\n\ngert::git_commit_id(\"main\", repo = git_repo)\n#> [1] \"cd437aebe6e3f11223cdc4c4d62e3660bde56dbd\"\ngert::git_commit_id(\"main^\", repo = git_repo)\n#> [1] \"9a02ae19cbcd1f03bd68aba9cd414b7d83250d3d\"\ngert::git_commit_id(\"main^^\", repo = git_repo)\n#> [1] \"c17a89d5682d3bab91e412aa935062c35dcdc1e2\"\nChapter 2: Remote Git\nInterestingly that‚Äôs the chapter where branches are introduced.\nGit as a distributed version control system\nMy first version control experience was with SVN, for a package developed on R-forge. I only remember two things: the cute tortoise of Tortoise-SVN, and the fact that instead of doing commit+push I‚Äôd only do commit. It makes sense now that I understand that Git is a distributed version control system whereas SVN is centralized, with a remote repo being the source of truth.\nWhy Git fetch?\nTo be honest, I‚Äôm still not sure when I would use\ngit fetch\n!\ngit fetch\nis for fetching changes from a remote without modifying local branches. I only use\ngit pull\n(which is fetch+merge) or\ngit pull --rebase\nwhen that fails, mostly. Note that the\n‚ÄúPull, but you have local work‚Äù chapter\nof happygitwithr by Jenny Bryan, the STAT 545 TAs, Jim Hester looks useful (I found it by searching for ‚Äúfetch‚Äù in that book).\nMike McQuaid wrote a paragraph ‚ÄúShould you use pull or fetch?‚Äù where he explains he prefers git fetch because he can incorporate remote changes when it makes sense, using a method of his choice (merging, rebasing, resetting). He also says\ngit fetch\nis better for working in situations with no internet connection, which was unclear to me.\nBranch names\nMike McQuaid recommends creating a branch name that describes ‚Äúthe branch‚Äôs purpose in multiple words separated by hyphens‚Äù. That‚Äôs what I tend to do, probably imitating what I saw elsewhere. Sometimes my branch names are less informative, and this makes me cringe when I open the corresponding PR.\nPushing a local branch remotely\nThis section just made me very happy I push local branches with\ngert::git_push()\n, because it sets the upstream branch automatically by default.\nSlowly, slowly understanding merge commits\nI learnt that merge commits are commits with multiple parents when working on the\nfledge package\n. When reading ‚ÄúGit in practice‚Äù, I at least understood ‚Äúfast-forward merge‚Äù which is something I had simply ignored when Git told me it had done one.\nSo, for my future reference‚Ä¶ If I am merging a branch A into main, and Git tells me it did a fast-forward merge, it means no merge commit was needed so none was made. The branch A commits were added to the main branch without new commit before that.\nConflicts and merge commits\n‚ÄúWhen conflicts have been resolved, a\nmerge commit\ncan be made. This stores the two parent commits and the conflicts that were resolved so they can be inspected un the future. Unfortunately, sometimes people pick the wrong option or merge incorrectly, so it‚Äôs good to be able to later see what conflicts they had to resolve.‚Äù\nThis was new to me, certaintly not something I had in mind when resolving conflicts.\nChapter 3: Filesystem interactions\nGit mv, Git rm\nI was never aware of\ngit mv\n, for renaming and moving a file. I think it‚Äôs because the RStudio IDE Git thingie was doing this for me? When I rename a file, I see the status becomes ‚ÄúR‚Äù once I‚Äôve added both the file deletion (old name) and the file adding (new name).\nThe same goes for\ngit rm\nfor removing a file.\nI should use Git reset more often\nAn use case for\ngit reset\nthat was described really resonated with me. üòÖ\n‚ÄúPerhaps you added debugging statements to files and have now commited a fix, so you want to reset all the files that haven‚Äôt been committed to their last committed state (on the current branch)‚Äù.\nSo instead of looking at the Git diff to remember where I added\nbrowser()\n, or looking for occurrences of a given debugging thing, I could use\ngit reset\n, now that sounds smarter!\nI should adopt Git clean\ngit clean\nwill remove any untracked file from the filesystem. Like the previous idea, it sounds like something I could use when debugging something and creating files √† la ‚Äúblop.text‚Äù.\nNow\ngit clean\ncan be dangerous so you can first run\ngit clean -n\nor\ngit clean --dry-run\nto see what would be removed.\nNote that gert doesn‚Äôt seem to support\ngit clean\nso I‚Äôd do this from a terminal.\nThe book also explains the\n-X\nargument of\ngit clean\nfor removing only ignored files, compared to the lower case\n-x\nargument for removing both ignored and untracked files.\nIn conclusion I need to practice using\ngit clean\n, and to refer to its docs when doing so, but at least now I know it exists.\nCould Git stash be useful to me\ngit stash save\nis a command for temporarily stashing some changes.\ngit stash pop\ngets them back.\ngit stadsh clear\nclears stashed commits.\nI can‚Äôt think of an use case right now but maybe I will encounter one one day?\nGit update-index\n--assume-unchanged\nAgain an use case that resonated with me (well I don‚Äôt use Rails but still)\n‚ÄúI‚Äôve found myself in a situation in the past where I wanted to test a Rails configuration file change for a week or two while continuing to do my normal work. I didn‚Äôt want to commit it because I didn‚Äôt want it to apply to servers or my coworkers, but I did want to continue testing it while I made other commits rather than change to a particular branch each time.‚Äù\nSo in that case one can run\nGit update-index --assume-unchanged <path>\n. Then you undo this by running\nGit update-index --no-assume-unchanged <path>\n.\nChapter 4: History visualization\nHonestly most of this chapter made me happy about the GitHub interface!\nThe other thing is that it has an explanation of\ngit bisect\nthat I need to come back to next time I need to find which commit caused a particular bug. I tend to be scared of\ngit bisect\n, but the explanation made sense. Also I guess I need to focus on making small informative commits before bisect really shines in my use cases. üòá\nI am especially curious about\ngit bisect run\nfor automating\ngit bisect\n, I wonder how that would work with a testthat unit test.\nChapter 5: Advanced branching\nMerge strategies\nI learnt there‚Äôs a merge strategy,\n--ours\n, that will ignore all changes from the incoming branch but still indicate it in the history. That‚Äôs supposed to be useful for when you want to keep an experiment from an experimental branch in the history.\nThere‚Äôs another interesting merge strategy,\n--patience\n, that ‚Äúuses a slightly more expensive git diff algorithm to try to decrease the chance of a merge conflict‚Äù. It sounds like a joke.\nNot useful to me but fun name: git rerere\ngit rerere\n, Reuse Recorded Resolution, allows you to resolve each merge conflict only once.\nI sort of understand the use case but it doesn‚Äôt sound useful to my work:\n‚ÄúYou may find yourself in a situation where you have a long-running branch that you have to keep merging in another branch, and you get the same merge conflict every time.‚Äù\nYay git cherry-pick\ngit cherry-pick\nallows you to add a single commit to the current branch. I recently successfully used it!\nA collaborator had mistakenly created a new feature branch from another feature branch instead of from the main branch. After that they added their feature commit but the PR was all broken. I created a new branch from the main branch, cherry-picked the commit and then opened a new PR. It‚Äôs a small step for humanity but it was a big step for me. üòÅ It was very cool to be able to say ‚Äúdon‚Äôt worry, I‚Äôve got it‚Äù to that collaborator.\nChapter 6: Rewriting history and disaster recovery\nAnother new-to-me command: git reflog\ngit reflog\nwill list ‚Äúall changes including history rewrites‚Äù, for the local repository. Commits that are deleted on all branches are only kept in the reflog for 90 days.\nGit reset can take a list of paths as arguments\nAn example would be\ngit reset HEAD^ -- path.txt\nActually retired now: Git filter-branch\nOne technique presented in the book, for rewriting git repository history, is\ngit filter-branch\nbut then I saw a\ntoot by Kirill M√ºller\nindicating it‚Äôs retired. A replacement is\ngit filter-repo\n, that I‚Äôd have to explore a bit more before being able to use it. The\nsimple example\nlooks convincing enough! According to the book this can be useful for some cases of disaster recovery.\nCommit regularly\nThis is the main message of this chapter, and it‚Äôs not an advanced technique at all, just a good habit. üò∏\nChapter 7: Personalizing Git\nOption for pruning branches automatically\nIf you want the references to now deleted remote branches to be deleted, you can run\ngit remote prune origin\nor configure Git so that this will happen every time you pull or fetch.\ngert::git_config_global_set(\"fetch.prune\", 1)\nGlobal gitignore\nI already knew about the global gitignore file thanks to the handy\nusethis::git_vaccinate()\n.\nAn option for autocorrecting misspelled commands\nThere‚Äôs a Git option for autocorrecting misspelled commands,\nhelp.autocorrect\n. It would not help me since my most frequent typo is ‚Äúgut‚Äù instead of ‚Äúgit‚Äù, sadly.\nChapter 8: Vendoring dependencies as submodules\nIf I ever have to work again with a repo that uses submodules üò≠, I might go back to this chapter to see which commands to run.\nChapter 12: Creating a clean history\nOne can build a commit from parts of files\nUsing\ngit add --patch <path>\n. This opens an interactive menu letting you choose which hunk(s) to add to a commit. Each hunk can be split into smaller hunks. Then one uses\ngit commit\nas usual.\nThe book also mentions that\ngit commit --patch\nalso exists. It seems less intuitive to me to do the hunk selection at that stage.\nChapter 13: merging vs.¬†rebasing\nThis chapter compares the strategies of two projects:\nCMake‚Äôs branching and merging strategy.\nHomebrew‚Äôs rebasing and squashing strategy. ‚ÄúThis hides merge commits, evidence of branches, and temporary commits (for example, those that fix previous commits on the same branch) from the main branch.‚Äù\nTo me CMake history looks like a mess or even a nightmare so I guess I‚Äôm in favor of the Homebrew‚Äôs strategy!\nBut in each project, it is worth to have a discussion about the chosen strategy, to educate contributors.\nI liked reading that in Homebrew, metadata is included into commit messages. For instance I enjoy the fact that GitHub automatically adds co-authors when you squash and merge a PR that add multiple contributors:\nhttps://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors\nChapter 14: Recommended team workflows\nHave you heard of GitHub flow, Git flow? These are\nteam workflows\n.\n‚ÄúThe different strategies for deciding how and when to branch, merge or rebase as part of a team are called\nteam workflows\n.‚Äù\nI much prefer GitHub flow where the default branch is stable and where there is no long-lived development branch, because in my experience, having such a long-lived development branch has lead to more confusion than gains. For\nrOpenSci dev guide\nwe went from some sort of Git flow to GitHub flow, where actual relases will be, well, actual releases/tags of the main branch. Changing flows was such a relief!\nThe author also presented his own two usual flows.\nConclusion\n‚ÄúGit in practice‚Äù by Mike McQuaid was a nice train travel companion. I feared it would be too dry or obscure but found it clear and well explained. I learnt a lot, but now, I will have to‚Ä¶ practice what I learnt! üòÅ\nDid you read this book, or another Git book? How did you learn Git? Any strong opinion on any of the topics mentioned in those notes?\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nMa√´lle's R blog on Ma√´lle Salmon's personal website\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "While preparing materials for teaching Git a few months ago, I re-read Suzan Baert‚Äôs excellent post about Git and GitHub, where she mentioned having read ‚ÄúGit in Practice‚Äù by Mike McQuaid. I added the book to my Momox alerts, where it...",
      "meta_keywords": null,
      "og_description": "While preparing materials for teaching Git a few months ago, I re-read Suzan Baert‚Äôs excellent post about Git and GitHub, where she mentioned having read ‚ÄúGit in Practice‚Äù by Mike McQuaid. I added the book to my Momox alerts, where it...",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Reading notes on Git in Practice by Mike McQuaid | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 16.9,
      "sitemap_lastmod": "2023-11-01T00:00:00+00:00",
      "twitter_description": "While preparing materials for teaching Git a few months ago, I re-read Suzan Baert‚Äôs excellent post about Git and GitHub, where she mentioned having read ‚ÄúGit in Practice‚Äù by Mike McQuaid. I added the book to my Momox alerts, where it...",
      "twitter_title": "Reading notes on Git in Practice by Mike McQuaid | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/10/reading-notes-on-git-in-practice-by-mike-mcquaid/",
      "word_count": 3381
    }
  }
}