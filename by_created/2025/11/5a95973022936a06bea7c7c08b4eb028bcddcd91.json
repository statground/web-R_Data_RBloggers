{
  "id": "5a95973022936a06bea7c7c08b4eb028bcddcd91",
  "url": "https://www.r-bloggers.com/2024/01/a-simple-workflow-for-async-shiny-with-mirai/",
  "created_at_utc": "2025-11-17T20:38:34Z",
  "data": null,
  "raw_original": {
    "uuid": "be39782b-1521-49ec-9347-004541fb7e5a",
    "created_at": "2025-11-17 20:38:34",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2024/01/a-simple-workflow-for-async-shiny-with-mirai/",
      "crawled_at": "2025-11-17T09:18:05.246298",
      "external_links": [
        {
          "href": "https://discindo.org/post/a-simple-workflow-for-async-shiny-with-mirai/",
          "text": "R | Discindo"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/",
          "text": "previous post"
        },
        {
          "href": "https://discindo.org/post/asynchronous-execution-in-shiny/",
          "text": "my self"
        },
        {
          "href": "https://hypebright.nl/index.php/2023/09/12/async-programming-in-shiny-with-crew-and-callr/",
          "text": "others"
        },
        {
          "href": "https://github.com/shikokuchuo/mirai",
          "text": "mirai"
        },
        {
          "href": "https://shikokuchuo.net/mirai/articles/shiny.html#shiny-example-usage",
          "text": "mirai-only"
        },
        {
          "href": "https://shikokuchuo.net/mirai/articles/shiny.html#example-using-promises",
          "text": "miraiwithpromises"
        },
        {
          "href": "https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/",
          "text": "previous post"
        },
        {
          "href": "https://discindo.org/post/a-simple-workflow-for-async-shiny-with-mirai/",
          "text": "R | Discindo"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "A simple workflow for async `{shiny}` with `{mirai}` | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/r-discindo/",
          "text": "R | Discindo"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-381514 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">A simple workflow for async `{shiny}` with `{mirai}`</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 14, 2024</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-discindo/\">R | Discindo</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://discindo.org/post/a-simple-workflow-for-async-shiny-with-mirai/\"> R | Discindo</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>In my <a href=\"https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/\" rel=\"nofollow\" target=\"_blank\">previous post</a>,\nI developed a <code>shiny</code> module to encapsulate the logic of sending and monitoring background async\ntasks. The main advantage of this approach was to simplify making repeated async calls\nin larger applications. In the first version of this module, the async process was\ncreated with <code>callr:r_bg</code>, an approach that <a href=\"https://discindo.org/post/asynchronous-execution-in-shiny/\" rel=\"nofollow\" target=\"_blank\">my self</a> and\n<a href=\"https://hypebright.nl/index.php/2023/09/12/async-programming-in-shiny-with-crew-and-callr/\" rel=\"nofollow\" target=\"_blank\">others</a> have used before.</p>\n<p>However, there is one, potentially significant, drawback of using <code>callr</code> in such\na way. Take this hypotetical scenario as an example. You have a shiny app with\nfive async tasks triggered in response to a user changing a dataset. You test it locally,\nand everything works great. Then you deploy and share with the world. Ten of your\nfollowers click on the link more-or-less at the same time and visit the application,\neach choosing one of three datasets available in your data science app. The app’s\n<code>server</code>, featuring <code>async</code> functions gets to work, and initializes 5 (tasks) * 10 (users)\n= 50 <code>callr::r_bg</code> calls, each running in a separate child R process. Some of these\ncopy nothing the child enviroment, some only a few small objects, but others a large\ndata object needed for the async function to transform or run a model. It should be no surprise\nif the app is no longer that fast. The hosting server, even with a fast, multi-thread\nprocessor, still hast to contend with many <code>R</code> processes and the <code>shiny</code> session\nis also getting a bit bogged down, as it has potentially dozens of observers monitoring\nbackground processes. Clearly, we need to rethink our approach.</p>\n<p>Wouldn’t it be great if we had a way to limit the total number of concurrent\nchild <code>R</code> processes that our <code>shiny</code> session would spawn, and have a queue system\nthat would start another background job as soon as one completes? Enter\n<a href=\"https://github.com/shikokuchuo/mirai\" rel=\"nofollow\" target=\"_blank\"><code>mirai</code></a>. <code>mirai</code> lets us initialize a set\nnumber of <code>R</code> <code>daemons</code> (persistent background processes) that are\nready to receive <code>mirai</code> requests and ensures FIFO (first in, first out) scheduling.\nUsing <code>mirai</code>, we can handle a large number of async background jobs elegantly\nwithout overburdening the system. If the number of jobs requested by the <code>shiny</code>\napp exceeds the number of available <code>daemons</code>, <code>mirai</code> would hold the jobs until\none of the daemons (threads) frees up and submit on a first-come, first-serve\nbasis. Just great!</p>\n<h2 id=\"so-how-does-it-work\">So how does it work?</h2>\n<p>For example setups for <code>shiny</code>, check out the documentation, where you can read\nabout <a href=\"https://shikokuchuo.net/mirai/articles/shiny.html#shiny-example-usage\" rel=\"nofollow\" target=\"_blank\"><code>mirai</code>-only</a>\nsolutions, as well as approaches combining\n<a href=\"https://shikokuchuo.net/mirai/articles/shiny.html#example-using-promises\" rel=\"nofollow\" target=\"_blank\"><code>mirai</code> with <code>promises</code></a>.</p>\n<p>For my application, I’ll adapt the <code>callr</code> approach I described in my\n<a href=\"https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/\" rel=\"nofollow\" target=\"_blank\">previous post</a>\nto work with <code>mirai</code>. In fact, there very little to change to make the <code>callr</code>\nexample work with <code>mirai</code>:</p>\n<ol>\n<li>Change the <code>async</code> version of our function to use <code>mirai</code></li>\n</ol>\n<pre>head_six &lt;- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\nhead_six_async_mirai &lt;- function(x, sleep) {\nargs &lt;- list(head_six = head_six, x = x, sleep = sleep)\nbg_process &lt;- mirai::mirai(.expr = head_six(x, sleep), .args = args)\nreturn(bg_process)\n}\n</pre><ol start=\"2\">\n<li>Change the polling logic in the module’s server to use <code>mirai::unresolved</code>,\nrather than the <code>is_alive</code> method of the <code>callr</code> process object.</li>\n</ol>\n<pre>mod_async_srv_mirai &lt;- function(id, fun_async, fun_args, wait_for_event = FALSE, verbose = FALSE) {\nmoduleServer( id, function(input, output, session){\nres_rct &lt;- shiny::reactiveVal(NULL)\npoll_rct &lt;- shiny::reactiveVal(TRUE)\nif (isTRUE(wait_for_event)) {\npoll_rct(FALSE)\n}\nbg_job &lt;- reactive({\nreq(isTRUE(poll_rct()))\ndo.call(fun_async, fun_args)\n}) |&gt; bindEvent(poll_rct())\nobserve({\nreq(isTRUE(poll_rct()))\ninvalidateLater(250)\nif (verbose) {\nmessage(sprintf(\"checking: %s\", id))\n}\nalive &lt;- mirai::unresolved(bg_job())\nif (isFALSE(alive)) {\nres_rct(bg_job()$data)\nif (verbose) {\nmessage(sprintf(\"done: %s\", id))\n}\npoll_rct(FALSE)\n}\n})\nreturn(list(\nstart_job = function() poll_rct(TRUE),\nget_result = reactive(res_rct())\n))\n})\n}\n</pre><ol start=\"3\">\n<li>In the app’s <code>server</code>, or better yet <code>global.R</code> or equivalents, we need to\ninitialize the <code>daemons</code>:</li>\n</ol>\n<pre> mirai::daemons(2L)\nonStop(function() mirai::daemons(0L))\n</pre><p>In this setup, our shiny can run up to two parallel async jobs handled by the\n<code>mirai</code> queue. These <code>daemons</code> are shared across <em>all users</em> of our application,\nirrespective of the <code>shiny</code> session. This is because <code>mirai</code>’s daemons apply to\nthe entire <code>R</code> session, not individual <code>shiny</code> sessions.</p>\n<h2 id=\"gist\">Gist</h2>\n<p>For a running example of <code>mirai</code> async with the module, visit this gist:</p>\n\n<h2 id=\"summary\">Summary</h2>\n<p>In this post I went over an approach to organize <code>mirai</code> background async jobs using\na <code>shiny</code> module, in order to make the async code faster to write, less error prone\nand overall cleaner.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://discindo.org/post/a-simple-workflow-for-async-shiny-with-mirai/\"> R | Discindo</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "A simple workflow for async `{shiny}` with `{mirai}`\nPosted on\nJanuary 14, 2024\nby\nR | Discindo\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR | Discindo\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn my\nprevious post\n,\nI developed a\nshiny\nmodule to encapsulate the logic of sending and monitoring background async\ntasks. The main advantage of this approach was to simplify making repeated async calls\nin larger applications. In the first version of this module, the async process was\ncreated with\ncallr:r_bg\n, an approach that\nmy self\nand\nothers\nhave used before.\nHowever, there is one, potentially significant, drawback of using\ncallr\nin such\na way. Take this hypotetical scenario as an example. You have a shiny app with\nfive async tasks triggered in response to a user changing a dataset. You test it locally,\nand everything works great. Then you deploy and share with the world. Ten of your\nfollowers click on the link more-or-less at the same time and visit the application,\neach choosing one of three datasets available in your data science app. The app’s\nserver\n, featuring\nasync\nfunctions gets to work, and initializes 5 (tasks) * 10 (users)\n= 50\ncallr::r_bg\ncalls, each running in a separate child R process. Some of these\ncopy nothing the child enviroment, some only a few small objects, but others a large\ndata object needed for the async function to transform or run a model. It should be no surprise\nif the app is no longer that fast. The hosting server, even with a fast, multi-thread\nprocessor, still hast to contend with many\nR\nprocesses and the\nshiny\nsession\nis also getting a bit bogged down, as it has potentially dozens of observers monitoring\nbackground processes. Clearly, we need to rethink our approach.\nWouldn’t it be great if we had a way to limit the total number of concurrent\nchild\nR\nprocesses that our\nshiny\nsession would spawn, and have a queue system\nthat would start another background job as soon as one completes? Enter\nmirai\n.\nmirai\nlets us initialize a set\nnumber of\nR\ndaemons\n(persistent background processes) that are\nready to receive\nmirai\nrequests and ensures FIFO (first in, first out) scheduling.\nUsing\nmirai\n, we can handle a large number of async background jobs elegantly\nwithout overburdening the system. If the number of jobs requested by the\nshiny\napp exceeds the number of available\ndaemons\n,\nmirai\nwould hold the jobs until\none of the daemons (threads) frees up and submit on a first-come, first-serve\nbasis. Just great!\nSo how does it work?\nFor example setups for\nshiny\n, check out the documentation, where you can read\nabout\nmirai\n-only\nsolutions, as well as approaches combining\nmirai\nwith\npromises\n.\nFor my application, I’ll adapt the\ncallr\napproach I described in my\nprevious post\nto work with\nmirai\n. In fact, there very little to change to make the\ncallr\nexample work with\nmirai\n:\nChange the\nasync\nversion of our function to use\nmirai\nhead_six <- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\nhead_six_async_mirai <- function(x, sleep) {\nargs <- list(head_six = head_six, x = x, sleep = sleep)\nbg_process <- mirai::mirai(.expr = head_six(x, sleep), .args = args)\nreturn(bg_process)\n}\nChange the polling logic in the module’s server to use\nmirai::unresolved\n,\nrather than the\nis_alive\nmethod of the\ncallr\nprocess object.\nmod_async_srv_mirai <- function(id, fun_async, fun_args, wait_for_event = FALSE, verbose = FALSE) {\nmoduleServer( id, function(input, output, session){\nres_rct <- shiny::reactiveVal(NULL)\npoll_rct <- shiny::reactiveVal(TRUE)\nif (isTRUE(wait_for_event)) {\npoll_rct(FALSE)\n}\nbg_job <- reactive({\nreq(isTRUE(poll_rct()))\ndo.call(fun_async, fun_args)\n}) |> bindEvent(poll_rct())\nobserve({\nreq(isTRUE(poll_rct()))\ninvalidateLater(250)\nif (verbose) {\nmessage(sprintf(\"checking: %s\", id))\n}\nalive <- mirai::unresolved(bg_job())\nif (isFALSE(alive)) {\nres_rct(bg_job()$data)\nif (verbose) {\nmessage(sprintf(\"done: %s\", id))\n}\npoll_rct(FALSE)\n}\n})\nreturn(list(\nstart_job = function() poll_rct(TRUE),\nget_result = reactive(res_rct())\n))\n})\n}\nIn the app’s\nserver\n, or better yet\nglobal.R\nor equivalents, we need to\ninitialize the\ndaemons\n:\nmirai::daemons(2L)\nonStop(function() mirai::daemons(0L))\nIn this setup, our shiny can run up to two parallel async jobs handled by the\nmirai\nqueue. These\ndaemons\nare shared across\nall users\nof our application,\nirrespective of the\nshiny\nsession. This is because\nmirai\n’s daemons apply to\nthe entire\nR\nsession, not individual\nshiny\nsessions.\nGist\nFor a running example of\nmirai\nasync with the module, visit this gist:\nSummary\nIn this post I went over an approach to organize\nmirai\nbackground async jobs using\na\nshiny\nmodule, in order to make the async code faster to write, less error prone\nand overall cleaner.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR | Discindo\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "In my previous post, I developed a shiny module to encapsulate the logic of sending and monitoring background async tasks. The main advantage of this approach was to simplify making repeated async calls in larger applications. In the first version of t...",
      "meta_keywords": null,
      "og_description": "In my previous post, I developed a shiny module to encapsulate the logic of sending and monitoring background async tasks. The main advantage of this approach was to simplify making repeated async calls in larger applications. In the first version of t...",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "A simple workflow for async `{shiny}` with `{mirai}` | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 4.3,
      "sitemap_lastmod": "2024-01-15T00:00:00+00:00",
      "twitter_description": "In my previous post, I developed a shiny module to encapsulate the logic of sending and monitoring background async tasks. The main advantage of this approach was to simplify making repeated async calls in larger applications. In the first version of t...",
      "twitter_title": "A simple workflow for async `{shiny}` with `{mirai}` | R-bloggers",
      "url": "https://www.r-bloggers.com/2024/01/a-simple-workflow-for-async-shiny-with-mirai/",
      "word_count": 869
    }
  }
}