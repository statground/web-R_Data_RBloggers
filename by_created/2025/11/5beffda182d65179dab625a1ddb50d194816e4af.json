{
  "id": "5beffda182d65179dab625a1ddb50d194816e4af",
  "url": "https://www.r-bloggers.com/2025/06/rethinking-image-formats/",
  "created_at_utc": "2025-11-22T19:58:25Z",
  "data": null,
  "raw_original": {
    "uuid": "78f2f04b-13b5-425e-9952-a1465264c96b",
    "created_at": "2025-11-22 19:58:25",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/06/rethinking-image-formats/",
      "crawled_at": "2025-11-22T10:47:46.996061",
      "external_links": [
        {
          "href": "https://www.jumpingrivers.com/blog/rethinking-image-formats/",
          "text": "The Jumping Rivers Blog"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://www.jumpingrivers.com/blog/rethinking-image-formats/",
          "text": null
        },
        {
          "href": "https://css-tricks.com/a-guide-to-the-responsive-images-syntax-in-html/",
          "text": "CSS Tricks"
        },
        {
          "href": "https://caniuse.com/?search=webp",
          "text": "95.4% for WebP"
        },
        {
          "href": "https://caniuse.com/?search=avif",
          "text": "93.5% for AVIF"
        },
        {
          "href": "https://www.thecatalystnewcastle.co.uk/",
          "text": "The Catalyst"
        },
        {
          "href": "https://en.wikipedia.org/wiki/Gamut#:~:text=In%20color%20reproduction%20and%20colorimetry,e.g.%20camera%20or%20visual%20system",
          "text": "colour gamuts"
        },
        {
          "href": "https://www.jumpingrivers.com/blog/rethinking-image-formats/",
          "text": "original post"
        },
        {
          "href": "https://www.jumpingrivers.com/blog/rethinking-image-formats/",
          "text": "The Jumping Rivers Blog"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Rethinking Image Formats | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/www.jumpingrivers.com/blog/rethinking-image-formats/featured.jpg?w=400&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/the-jumping-rivers-blog/",
          "text": "The Jumping Rivers Blog"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
          "text": "[email protected]"
        },
        {
          "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
          "text": "[email protected]"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-392853 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Rethinking Image Formats</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">June 5, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/the-jumping-rivers-blog/\">The Jumping Rivers Blog</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.jumpingrivers.com/blog/rethinking-image-formats/\"> The Jumping Rivers Blog</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<p>\n<a href=\"https://www.jumpingrivers.com/blog/rethinking-image-formats/\">\n<img class=\"image-center\" data-lazy-src=\"https://i1.wp.com/www.jumpingrivers.com/blog/rethinking-image-formats/featured.jpg?w=400&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width:400px\"/><noscript><img class=\"image-center\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.jumpingrivers.com/blog/rethinking-image-formats/featured.jpg?w=400&amp;ssl=1\" style=\"width:400px\"/></noscript>\n</a>\n</p>\n<link href=\"https://www.jumpingrivers.com/blog/rethinking-image-formats/assets/style.css\" rel=\"stylesheet\"/>\n\n<p>Adding images to a web page used to be straightforward. You’d add the <code>img</code> tag to the HTML, set the <em>src</em> attribute to the appropriate URL and, hopefully, write some informative <em>alt</em> text. (You might also add some CSS, either inline or via a stylesheet.)</p>\n<pre>&lt;img src=\"plot.png\" alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\" /&gt;\n</pre><p>It’s slightly more complicated today, with monitor and browser technology changing the requirements, at least if you are using raster images (like JPEGS, PNGs and GIFs) and want things to look good for <em>all</em> your users. High density screens on smartphones have been popular for a while but 4k and 5k monitors are also becoming more affordable. To make text easy to read, these are often set to 200% scaling so that one measured pixel corresponds to 2 real pixels in each dimension. (For smartphones and tablets this scaling can even be 300%, though their true pixel counts are lower than those of 4k and 5k monitors.) A result of all this is that, for images not to look pixelated on these screens, they need twice as many pixels in each direction – that’s four times the number of pixels for a given image display size. So what can we do about this?</p>\n\n<h2 id=\"using-the-_srcset_temp_-attribute\">Using the <em>srcset_temp</em> Attribute</h2>\n<p>Fortunately, browsers added the <em>srcset_temp</em> attribute to make it easier for the developer to specify multiple images to use. The browser then picks the “best” option for a given user based on the information given in the <em>srcset_temp</em> attribute and information the browser already has about the device on which the page is being viewed. The simplest way to utilise this attribute is to specify an image that is twice as large in the srcset_temp property alongside a “2x” marker. By convention, we name the larger image the same as the smaller image, but with @2x in the name just before the extension:</p>\n<pre>&lt;img src=\"plot.png\" srcset_temp=\"<a class=\"__cf_email__\" data-cfemail=\"12627e7d6652206a3c627c75\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a> 2x\" alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\"&gt;\n</pre><p>This tells the browser to serve the base image to users with “regular” screens and the larger image to those with scaled screens. You could also add a “3x” version here if you wanted, though that would require an image with nine times as many pixels as the base image. The actual file size in memory may not be nine times that of the base image due to the compression algorithms scaling well, but they’ll still be considerably bigger.</p>\n<p>The shortcoming with the above syntax is that it’s not really targetting the right thing. It tells the browser to choose based only on scaling factors and not on the actual rendered image sizes. An image could be set to display at 600 “CSS” pixels on a wide screen, like a desktop monitor, and 300 CSS pixels on a narrower one, like a phone. For a phone with 2 times scaling the 600 pixel image would then look fine but the browser doesn’t inherently know that the 1200 pixel image is unnecessary. So it will (probably) load the 1200 pixel image, making page-load slower than necessary and potentially gobbling up more of the user’s mobile data than warranted.</p>\n<p>The specification for <em>srcset_temp</em> offers an alternative that seems to solve this issue: just directly list the widths of available images by specifying a number and the letter “w”:</p>\n<pre>&lt;img\n srcset_temp=\"plot-small.png 300w, plot.png 600w, plot-large.png 1200w\"\n alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\"&gt;\n</pre><p>If the browser knows what size the <code>img</code> element will be rendered at, the sizes of the image options and the pixel density of the screen it can pick the best image for the job. The catch is that, at least when the browser sees the <code>img</code> tag for the first time, it won’t know what size it will be rendered at unless we specifically tell it. We can do that using the <em>sizes</em> attribute on the <code>img</code> element. Unfortunately, for responsive layouts this can get very messy and very confusing very quickly.</p>\n<p>If you want to get into the nitty gritty of using <em>srcset_temp</em> with <em>sizes</em> then there is a great article on <a href=\"https://css-tricks.com/a-guide-to-the-responsive-images-syntax-in-html/\" rel=\"nofollow\" target=\"_blank\">CSS Tricks</a> that goes into way more detail than we have space for here. Let’s, instead, look at alternative ways of reducing the burden of large images.</p>\n<h2 id=\"using-vector-graphics\">Using Vector Graphics</h2>\n<p>The solution that makes life easy… when it’s applicable. Instead of using a PNG (or JPEG), use an SVG – a scalable vector graphic.</p>\n<h3 id=\"advantages-of-svg\">Advantages of SVG</h3>\n<ul>\n<li>Instead of storing data about the colours of millions of pixels, these files store a set of instruction for constructing an image. This is usually the perfect solution for company logos and most common chart types because they can be scaled however you like precisely because they’re just a list of instructions. No need to serve multiple images.</li>\n<li>They can be added to the page in a number of ways, including using a simple <code>img</code> tag.</li>\n<li>With a bit of JavaScript they can be made interactive and they’re easy to animate.</li>\n</ul>\n<h3 id=\"shortcomings-of-svg\">Shortcomings of SVG</h3>\n<ul>\n<li>They’re essentially useless for detailed images, like photography.</li>\n<li>Fonts may not be rendered properly when added through the <em>src</em> attribute of an image tag if that font isn’t already on the users system. A work-around for this is to open a vector-image editor and find the option for rendering text as paths. While this will likely increase the file size a bit and cause minor imperfections in text rendering, it may be more problematic that this adds an extra step in the workflow when the SVGs are generated programatically.</li>\n</ul>\n<h3 id=\"illustrative-example\">Illustrative example</h3>\n<p>Use the controls below to change between image formats and scaling to see the effect.\nIt should be apparent that when you scale up a PNG or JPEG the image becomes more blurred\nand that the SVG, for the most part, remains crisp regardless of the scale-factor. (You may notice small artefacts with the SVG text when scaled up. These are seen because the characters are rendered using SVG paths rather than fonts, as described in the previous section.)</p>\n<div class=\"img-demo\" id=\"rvc\">\n<label>Select an image<br/><select></select></label>\n<label>Scale factor<br/><input min=\"1\" type=\"number\" value=\"1\"/></label>\n<span class=\"info\"></span>\n<div class=\"img-wrapper\">\n<img alt=\"Litmus dashboard hex logo: a purple hexagon with charts in the background and the words 'Litmus Dashboard' written in the centre.\"/>\n</div>\n</div>\n<h2 id=\"using-new-image-formats\">Using New Image Formats</h2>\n<p>Given the above, you may think the available image options for the web looks something like this:</p>\n<ul>\n<li>JPEG (with lossy compression) for images with (up to) millions of colours;</li>\n<li>PNG for images with large consistent blocks of colours (like logos) or images that require transparency;</li>\n<li>SVG for vector graphics;</li>\n<li>GIF for your favourite animated meme.</li>\n</ul>\n<p>But for images that can’t be easily represented in vector format there are several newer raster image formats: JPEG XL, WebP, AVIF and HEIC (A.K.A. HEIF) that offer better compression (lossy and lossless) than PNG, JPEG and GIF. Of these new formats, only WebP and AVIF have meaningful browser support, but that support is actually very good: currently <a href=\"https://caniuse.com/?search=webp\" rel=\"nofollow\" target=\"_blank\">95.4% for WebP</a> and <a href=\"https://caniuse.com/?search=avif\" rel=\"nofollow\" target=\"_blank\">93.5% for AVIF</a>. In fact, you may think support is good enough for both formats to not need to provide a fallback. However, if you want to, you can use the <code>picture</code> and <code>source</code> elements to cover even more browsers:</p>\n<pre>&lt;picture&gt;\n &lt;source srcset_temp=\"/images/home/whale-deep-dive-light-blue.webp 1x, /images/home/<a class=\"__cf_email__\" data-cfemail=\"ccbba4ada0a9e1a8a9a9bce1a8a5baa9e1a0a5aba4b8e1aea0b9a98cfeb4e2bba9aebc\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a> 2x\" type=\"image/webp\"&gt;\n &lt;img src=\"/images/home/whale-deep-dive-light-blue.png\" alt=\"Jumping Rivers' cartoon whale with Moon in background\"&gt;\n&lt;/picture&gt;\n</pre><p>In the above example we use the <em>srcset_temp</em> attribute to provide two different sizes in the WebP format and the <code>img</code> tag to provide a PNG fallback for older browsers (we assume users of older browsers aren’t using modern high-definition screens). The <em>alt</em> text also still needs to be included in the <code>img</code> tag rather than moved into the <code>source</code> or <code>picture</code> tags.</p>\n<p>When it comes to choosing between WebP and AVIF, WebP has marignally better browser support, but consensus is that AVIF offers better compression. This is maybe not surprising since it’s a much newer new format than WebP, which actually turns fifteen in 2025. The downside to that is that we have found support for AVIF in editing tools to be much lower than it is for WebP. That landscape is always changing, however. WebP has one other advantage over AVIF: it supports lossy images <em>with</em> transparency so if you need small image sizes and transparency it’s the only format in town.</p>\n<p>Both WebP and AVIF support image animation but, as you will see in the next section, there’s another alternative for replacing our old friend the GIF.</p>\n<p>The example below shows a 300-pixel-wide image of <a href=\"https://www.thecatalystnewcastle.co.uk/\" rel=\"nofollow\" target=\"_blank\">The Catalyst</a> building in Newcastle, where Jumping Rivers is headquartered. You can choose between viewing a lossless PNG, lossless WebP, lossy JPEG, and a lossy WebP image. The two lossless formats should look the same, but the WebP image is about 20% smaller in file size than the PNG. The lossy images both have “medium” levels of compression so should be of roughly comparable quality, but not identical (since they use different compression algorithms). The lossy WebP image is only about one third the file size of the JPEG!</p>\n<div class=\"img-demo\" id=\"fmt\">\n<label>Select an image<br/><select></select></label>\n<label>Scale factor<br/><input min=\"1\" type=\"number\" value=\"1\"/></label>\n<span class=\"info\"></span>\n<div class=\"img-wrapper\">\n<img alt=\"Photo of The Catalyst building in Newcastle\"/>\n</div>\n</div>\n<h2 id=\"using-videos-instead-of-gifs\">Using Videos Instead of GIFs</h2>\n<p>GIFs, particularly animated GIFs, have been a big part of internet culture. However, they are a very old format with large file sizes and poor <a href=\"https://en.wikipedia.org/wiki/Gamut#:~:text=In%20color%20reproduction%20and%20colorimetry,e.g.%20camera%20or%20visual%20system\" rel=\"nofollow\" target=\"_blank\">colour gamuts</a>.): they are limited to a max of just 256 different pixel colours. All modern browsers support video natively through the <code>video</code> element and these offer much better compression and huge colour palettes.</p>\n<pre>&lt;video src=\"assets/hex-dissolve.mp4\" aria-label=\"Litmusverse hex sticker animation\" autoplay=\"true\" loop=\"true\" muted=\"true\"&gt;&lt;video&gt;\n</pre><p>The <em>aria-label</em> attribute is used like the <em>alt</em> text of an <code>img</code> element. The other attributes should be fairly self-explanatory: <em>autoplay</em> tells the browser to play the video automatically, <em>loop</em> to loop the video around back to the start when it finishes and <em>muted</em> not to play any sound. The latter is required because, thankfully, browsers will no longer autoplay videos with sound.</p>\n<div class=\"video-wrapper\">\n<video aria-label=\"Litmusverse hex sticker animation\" autoplay=\"true\" loop=\"true\" muted=\"true\" src=\"assets/hex-dissolve.mp4\"><video>\n</video></video></div>\n<p>\nFor updates and revisions to this article, see the <a href=\"https://www.jumpingrivers.com/blog/rethinking-image-formats/\">original post</a>\n</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.jumpingrivers.com/blog/rethinking-image-formats/\"> The Jumping Rivers Blog</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Rethinking Image Formats\nPosted on\nJune 5, 2025\nby\nThe Jumping Rivers Blog\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nThe Jumping Rivers Blog\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAdding images to a web page used to be straightforward. You’d add the\nimg\ntag to the HTML, set the\nsrc\nattribute to the appropriate URL and, hopefully, write some informative\nalt\ntext. (You might also add some CSS, either inline or via a stylesheet.)\n<img src=\"plot.png\" alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\" />\nIt’s slightly more complicated today, with monitor and browser technology changing the requirements, at least if you are using raster images (like JPEGS, PNGs and GIFs) and want things to look good for\nall\nyour users. High density screens on smartphones have been popular for a while but 4k and 5k monitors are also becoming more affordable. To make text easy to read, these are often set to 200% scaling so that one measured pixel corresponds to 2 real pixels in each dimension. (For smartphones and tablets this scaling can even be 300%, though their true pixel counts are lower than those of 4k and 5k monitors.) A result of all this is that, for images not to look pixelated on these screens, they need twice as many pixels in each direction – that’s four times the number of pixels for a given image display size. So what can we do about this?\nUsing the\nsrcset_temp\nAttribute\nFortunately, browsers added the\nsrcset_temp\nattribute to make it easier for the developer to specify multiple images to use. The browser then picks the “best” option for a given user based on the information given in the\nsrcset_temp\nattribute and information the browser already has about the device on which the page is being viewed. The simplest way to utilise this attribute is to specify an image that is twice as large in the srcset_temp property alongside a “2x” marker. By convention, we name the larger image the same as the smaller image, but with @2x in the name just before the extension:\n<img src=\"plot.png\" srcset_temp=\"\n[email protected]\n2x\" alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\">\nThis tells the browser to serve the base image to users with “regular” screens and the larger image to those with scaled screens. You could also add a “3x” version here if you wanted, though that would require an image with nine times as many pixels as the base image. The actual file size in memory may not be nine times that of the base image due to the compression algorithms scaling well, but they’ll still be considerably bigger.\nThe shortcoming with the above syntax is that it’s not really targetting the right thing. It tells the browser to choose based only on scaling factors and not on the actual rendered image sizes. An image could be set to display at 600 “CSS” pixels on a wide screen, like a desktop monitor, and 300 CSS pixels on a narrower one, like a phone. For a phone with 2 times scaling the 600 pixel image would then look fine but the browser doesn’t inherently know that the 1200 pixel image is unnecessary. So it will (probably) load the 1200 pixel image, making page-load slower than necessary and potentially gobbling up more of the user’s mobile data than warranted.\nThe specification for\nsrcset_temp\noffers an alternative that seems to solve this issue: just directly list the widths of available images by specifying a number and the letter “w”:\n<img\n srcset_temp=\"plot-small.png 300w, plot.png 600w, plot-large.png 1200w\"\n alt=\"Scatter plot of age vs score. Line of best fit runs through the points, and an outlier can be seen at age 28, score 40.\">\nIf the browser knows what size the\nimg\nelement will be rendered at, the sizes of the image options and the pixel density of the screen it can pick the best image for the job. The catch is that, at least when the browser sees the\nimg\ntag for the first time, it won’t know what size it will be rendered at unless we specifically tell it. We can do that using the\nsizes\nattribute on the\nimg\nelement. Unfortunately, for responsive layouts this can get very messy and very confusing very quickly.\nIf you want to get into the nitty gritty of using\nsrcset_temp\nwith\nsizes\nthen there is a great article on\nCSS Tricks\nthat goes into way more detail than we have space for here. Let’s, instead, look at alternative ways of reducing the burden of large images.\nUsing Vector Graphics\nThe solution that makes life easy… when it’s applicable. Instead of using a PNG (or JPEG), use an SVG – a scalable vector graphic.\nAdvantages of SVG\nInstead of storing data about the colours of millions of pixels, these files store a set of instruction for constructing an image. This is usually the perfect solution for company logos and most common chart types because they can be scaled however you like precisely because they’re just a list of instructions. No need to serve multiple images.\nThey can be added to the page in a number of ways, including using a simple\nimg\ntag.\nWith a bit of JavaScript they can be made interactive and they’re easy to animate.\nShortcomings of SVG\nThey’re essentially useless for detailed images, like photography.\nFonts may not be rendered properly when added through the\nsrc\nattribute of an image tag if that font isn’t already on the users system. A work-around for this is to open a vector-image editor and find the option for rendering text as paths. While this will likely increase the file size a bit and cause minor imperfections in text rendering, it may be more problematic that this adds an extra step in the workflow when the SVGs are generated programatically.\nIllustrative example\nUse the controls below to change between image formats and scaling to see the effect.\nIt should be apparent that when you scale up a PNG or JPEG the image becomes more blurred\nand that the SVG, for the most part, remains crisp regardless of the scale-factor. (You may notice small artefacts with the SVG text when scaled up. These are seen because the characters are rendered using SVG paths rather than fonts, as described in the previous section.)\nSelect an image\nScale factor\nUsing New Image Formats\nGiven the above, you may think the available image options for the web looks something like this:\nJPEG (with lossy compression) for images with (up to) millions of colours;\nPNG for images with large consistent blocks of colours (like logos) or images that require transparency;\nSVG for vector graphics;\nGIF for your favourite animated meme.\nBut for images that can’t be easily represented in vector format there are several newer raster image formats: JPEG XL, WebP, AVIF and HEIC (A.K.A. HEIF) that offer better compression (lossy and lossless) than PNG, JPEG and GIF. Of these new formats, only WebP and AVIF have meaningful browser support, but that support is actually very good: currently\n95.4% for WebP\nand\n93.5% for AVIF\n. In fact, you may think support is good enough for both formats to not need to provide a fallback. However, if you want to, you can use the\npicture\nand\nsource\nelements to cover even more browsers:\n<picture>\n <source srcset_temp=\"/images/home/whale-deep-dive-light-blue.webp 1x, /images/home/\n[email protected]\n2x\" type=\"image/webp\">\n <img src=\"/images/home/whale-deep-dive-light-blue.png\" alt=\"Jumping Rivers' cartoon whale with Moon in background\">\n</picture>\nIn the above example we use the\nsrcset_temp\nattribute to provide two different sizes in the WebP format and the\nimg\ntag to provide a PNG fallback for older browsers (we assume users of older browsers aren’t using modern high-definition screens). The\nalt\ntext also still needs to be included in the\nimg\ntag rather than moved into the\nsource\nor\npicture\ntags.\nWhen it comes to choosing between WebP and AVIF, WebP has marignally better browser support, but consensus is that AVIF offers better compression. This is maybe not surprising since it’s a much newer new format than WebP, which actually turns fifteen in 2025. The downside to that is that we have found support for AVIF in editing tools to be much lower than it is for WebP. That landscape is always changing, however. WebP has one other advantage over AVIF: it supports lossy images\nwith\ntransparency so if you need small image sizes and transparency it’s the only format in town.\nBoth WebP and AVIF support image animation but, as you will see in the next section, there’s another alternative for replacing our old friend the GIF.\nThe example below shows a 300-pixel-wide image of\nThe Catalyst\nbuilding in Newcastle, where Jumping Rivers is headquartered. You can choose between viewing a lossless PNG, lossless WebP, lossy JPEG, and a lossy WebP image. The two lossless formats should look the same, but the WebP image is about 20% smaller in file size than the PNG. The lossy images both have “medium” levels of compression so should be of roughly comparable quality, but not identical (since they use different compression algorithms). The lossy WebP image is only about one third the file size of the JPEG!\nSelect an image\nScale factor\nUsing Videos Instead of GIFs\nGIFs, particularly animated GIFs, have been a big part of internet culture. However, they are a very old format with large file sizes and poor\ncolour gamuts\n.): they are limited to a max of just 256 different pixel colours. All modern browsers support video natively through the\nvideo\nelement and these offer much better compression and huge colour palettes.\n<video src=\"assets/hex-dissolve.mp4\" aria-label=\"Litmusverse hex sticker animation\" autoplay=\"true\" loop=\"true\" muted=\"true\"><video>\nThe\naria-label\nattribute is used like the\nalt\ntext of an\nimg\nelement. The other attributes should be fairly self-explanatory:\nautoplay\ntells the browser to play the video automatically,\nloop\nto loop the video around back to the start when it finishes and\nmuted\nnot to play any sound. The latter is required because, thankfully, browsers will no longer autoplay videos with sound.\nFor updates and revisions to this article, see the\noriginal post\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nThe Jumping Rivers Blog\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "Adding images to a web page used to be straightforward. You’d add the img tag to the HTML, set the src attribute to the appropriate URL and, hopefully, write some informative alt text. (You might also add some CSS, either inline or via a styles...",
      "meta_keywords": null,
      "og_description": "Adding images to a web page used to be straightforward. You’d add the img tag to the HTML, set the src attribute to the appropriate URL and, hopefully, write some informative alt text. (You might also add some CSS, either inline or via a styles...",
      "og_image": "https://www.jumpingrivers.com/blog/rethinking-image-formats/featured.jpg",
      "og_title": "Rethinking Image Formats | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 9.5,
      "sitemap_lastmod": null,
      "twitter_description": "Adding images to a web page used to be straightforward. You’d add the img tag to the HTML, set the src attribute to the appropriate URL and, hopefully, write some informative alt text. (You might also add some CSS, either inline or via a styles...",
      "twitter_title": "Rethinking Image Formats | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/06/rethinking-image-formats/",
      "word_count": 1897
    }
  }
}