{
  "id": "c87fac4f1db30b7f7f0e89e423209fcbf224703b",
  "url": "https://www.r-bloggers.com/2025/07/whats-r-vector-victor/",
  "created_at_utc": "2025-11-22T19:57:59Z",
  "data": null,
  "raw_original": {
    "uuid": "d85f18bf-7195-4be7-a605-204d72d067cf",
    "created_at": "2025-11-22 19:57:59",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/07/whats-r-vector-victor/",
      "crawled_at": "2025-11-22T10:44:57.489179",
      "external_links": [
        {
          "href": "https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/",
          "text": "R on Biofunctor"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://www.nobelprize.org/about/developer-zone-2/",
          "text": "an\nAPI"
        },
        {
          "href": "https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/#fn:1",
          "text": "1"
        },
        {
          "href": "https://www.biobits.be/biofunctor//2025/07/23/lets-talk-about-nas",
          "text": "Previously"
        },
        {
          "href": "https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/#fnref:1",
          "text": "↩︎"
        },
        {
          "href": "https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/",
          "text": "R on Biofunctor"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "What’s R vector, Victor? | R-bloggers",
      "images": [
        {
          "alt": "Cook with flatmap",
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": "Cook with flatmap",
          "base64": null,
          "src": "https://i2.wp.com/www.biobits.be/biofunctor/post/2025-07-30-what-s-r-vector-victor/flatmap_meme_bestProgram2020.jpg?w=578&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/r-on-biofunctor/",
          "text": "R on Biofunctor"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-394437 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">What’s R vector, Victor?</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">July 29, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-on-biofunctor/\">R on Biofunctor</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/\"> R on Biofunctor</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p><img alt=\"Cook with flatmap\" data-lazy-src=\"https://i2.wp.com/www.biobits.be/biofunctor/post/2025-07-30-what-s-r-vector-victor/flatmap_meme_bestProgram2020.jpg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" title=\"A meme with a tiny hard-boiled egg within a hard boiled egg, captioned: When you cook with 'map' instead of 'flatmap' @bestProgram_2020\"/><noscript><img alt=\"Cook with flatmap\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.biobits.be/biofunctor/post/2025-07-30-what-s-r-vector-victor/flatmap_meme_bestProgram2020.jpg?w=578&amp;ssl=1\" title=\"A meme with a tiny hard-boiled egg within a hard boiled egg, captioned: When you cook with 'map' instead of 'flatmap' @bestProgram_2020\"/></noscript></p>\n<p>In this week’s episode of the “Hidden Monads in R” series,\nI’ll explore the vector aspect of R data structures, and see how the flatmap\noperation can be quite useful.</p>\n<h2 id=\"flatmap-arent-all-maps-flat\">Flatmap? Aren’t all maps flat?</h2>\n<p>The Nobel Prize organisation provides <a href=\"https://www.nobelprize.org/about/developer-zone-2/\" rel=\"nofollow\" target=\"_blank\">an\nAPI</a> with information about\nthe prizes and laureates. We can retrieve a JSON file, which is what I did. I\nread the file and examine one of the entries below.</p>\n<pre># Source: http://api.nobelprize.org/v1/prize.json\nprizes &lt;- jsonlite::fromJSON(\"./prize.json\", simplifyDataFrame = FALSE)[[\"prizes\"]]\n\nstr(prizes[[11]])\n\n## List of 3\n##  $ year     : chr \"2023\"\n##  $ category : chr \"physics\"\n##  $ laureates:List of 3\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1026\"\n##   .. ..$ firstname : chr \"Pierre\"\n##   .. ..$ surname   : chr \"Agostini\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1027\"\n##   .. ..$ firstname : chr \"Ferenc\"\n##   .. ..$ surname   : chr \"Krausz\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1028\"\n##   .. ..$ firstname : chr \"Anne\"\n##   .. ..$ surname   : chr \"L’Huillier\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\n</pre><p>Let’s say I want a character vector containing the full names of Nobel laureates\nin medicine since 2020. First, I can concoct a function that gets such a\nvector from a single entry (I know, this one is physics).</p>\n<pre>who_got_it &lt;- function(prize) {\n    laureates &lt;- vapply(\n        X = prize[[\"laureates\"]],\n        FUN = \\(l) c(l[[\"surname\"]] %||% \"\", l[[\"firstname\"]] %||% \"\"),\n        FUN.VALUE = c(\"Doe\", \"John\")\n    )\n    trimws(paste(laureates[2,], laureates[1,]))\n}\n\nwho_got_it(prizes[[11]])\n\n## [1] \"Pierre Agostini\" \"Ferenc Krausz\"   \"Anne L’Huillier\"\n</pre><p>To achieve my goal, I just have to filter the list accordingly, and <code>lapply</code> the\nfunction on the matching entries.</p>\n<pre>(medicine_since_2020 &lt;- Filter(\n    f = \\(p) p[[\"category\"]] == \"medicine\" &amp; as.numeric(p[[\"year\"]]) &gt;= 2020,\n    x = prizes\n    ) |&gt;\n    lapply(who_got_it)\n)\n\n## [[1]]\n## [1] \"Victor Ambros\" \"Gary Ruvkun\"  \n## \n## [[2]]\n## [1] \"Katalin Karikó\" \"Drew Weissman\" \n## \n## [[3]]\n## [1] \"Svante Pääbo\"\n## \n## [[4]]\n## [1] \"David Julius\"      \"Ardem Patapoutian\"\n## \n## [[5]]\n## [1] \"Harvey Alter\"     \"Michael Houghton\" \"Charles Rice\"\n</pre><p>Neat! But I want them in a single vector. so I need an <em>unlist</em> step at the\nend.</p>\n<pre>unlist(medicine_since_2020)\n\n##  [1] \"Victor Ambros\"     \"Gary Ruvkun\"       \"Katalin Karikó\"   \n##  [4] \"Drew Weissman\"     \"Svante Pääbo\"      \"David Julius\"     \n##  [7] \"Ardem Patapoutian\" \"Harvey Alter\"      \"Michael Houghton\" \n## [10] \"Charles Rice\"\n</pre><p>Yes, it’s that simple. This is a <em>flatmap</em> process for vectors, and it’s a\ncomposition of a <em>map</em> and a <em>flatten</em> step (lapply and unlist in this case). It\nalmost looks silly to write a flatmap function, after all it’s not that\ndifficult to lapply and unlist sequentially. But it’s used often, so it saves\ntime and reduces mistakes. In this case – to be correct – I should have used\n<code>unlist(recursive = FALSE)</code>, otherwise it flattens nested lists, and that would\nbe wrong.</p>\n<h2 id=\"a-biology-related-problem\">A biology-related problem</h2>\n<p>Laboratory experiments are often performed in 96-well plastic plates, with 8\nrows (labeled A-H) and 12 columns (labeled 1-12). Each microwell is a separate\nmicro-experiment (labeled A1-H12). Let’s generate well labels for such a\ndataset!</p>\n<pre>rows &lt;- LETTERS[1:8]\ncolumns &lt;- 1:12 |&gt; sprintf(fmt = \"%02i\")\n</pre><p>So all we have to do is combine one vector of values with another, using the\nhandy <code>paste0()</code> function, right? Wrong.</p>\n<pre>paste0(rows, columns) |&gt; noquote()\n\n##  [1] A01 B02 C03 D04 E05 F06 G07 H08 A09 B10 C11 D12\n</pre><p>We’ve only got 12 values instead of 96, and the shorter vector (letters) is\nrecycled as needed. It’s often what you want, so it’s done this way for a good\nreason. But in this case, we’d prefer to have an each-with-each combination.</p>\n<p>Some readers may already have started daydreaming of nested for loops (please\ndon’t). More experienced R programmers would probably go for <code>expand.grid()</code> or\n<code>rep(rows, each = length(columns)</code> to match up the vectors, and then <code>paste()</code>\nthem together. But R is a versatile language, and there are many paths to the\nsame destination. A <strong>functional</strong> R programmer could just take <code>flatmap</code> off\nthe shelf, and here is how.</p>\n<p>For purely didactic reasons, let’s define a non-vectorized paste function,\ncalled paste01 <sup id=\"fnref:1\"><a class=\"footnote-ref\" href=\"https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/#fn:1\" rel=\"nofollow\" role=\"doc-noteref\" target=\"_blank\">1</a></sup>. It takes a single value and a character vector, and returns\na character vector – the combination of the value with each member of the\nvector.</p>\n<p><code>$$paste01 :: Str \\rightarrow [Str] \\rightarrow [Str]$$</code></p>\n<pre>paste01 &lt;- \\(x, y) { stopifnot(length(x) == 1L); paste0(x, y)}\npaste01(rows[1], columns)\n\n##  [1] \"A01\" \"A02\" \"A03\" \"A04\" \"A05\" \"A06\" \"A07\" \"A08\" \"A09\" \"A10\" \"A11\" \"A12\"\n</pre><p>When we map this function on our <code>rows</code> vector, we <em>almost</em> get what we\nneed.</p>\n<p><code>$$lapply(paste01) :: [Str] \\rightarrow [Str] \\rightarrow [[Str]]$$</code></p>\n<pre>lapply(rows, paste01, columns) |&gt; head(3L)\n\n## [[1]]\n##  [1] \"A01\" \"A02\" \"A03\" \"A04\" \"A05\" \"A06\" \"A07\" \"A08\" \"A09\" \"A10\" \"A11\" \"A12\"\n## \n## [[2]]\n##  [1] \"B01\" \"B02\" \"B03\" \"B04\" \"B05\" \"B06\" \"B07\" \"B08\" \"B09\" \"B10\" \"B11\" \"B12\"\n## \n## [[3]]\n##  [1] \"C01\" \"C02\" \"C03\" \"C04\" \"C05\" \"C06\" \"C07\" \"C08\" \"C09\" \"C10\" \"C11\" \"C12\"\n</pre><p>It’s a list of vectors, so we have to flatten it. Yupp, it’s a flatmap.</p>\n<p><code>$$unlist(lapply(paste01)) :: [Str] \\rightarrow [Str] \\rightarrow [Str]$$</code></p>\n<pre>unlist(lapply(rows, paste01, columns)) |&gt;\n    noquote()\n\n##  [1] A01 A02 A03 A04 A05 A06 A07 A08 A09 A10 A11 A12 B01 B02 B03 B04 B05 B06 B07\n## [20] B08 B09 B10 B11 B12 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 D01 D02\n## [39] D03 D04 D05 D06 D07 D08 D09 D10 D11 D12 E01 E02 E03 E04 E05 E06 E07 E08 E09\n## [58] E10 E11 E12 F01 F02 F03 F04 F05 F06 F07 F08 F09 F10 F11 F12 G01 G02 G03 G04\n## [77] G05 G06 G07 G08 G09 G10 G11 G12 H01 H02 H03 H04 H05 H06 H07 H08 H09 H10 H11\n## [96] H12\n</pre><p>Tadaa!</p>\n<p>So, a flatmap function for vectors can be defined. It takes:</p>\n<ol>\n<li>a vector of values</li>\n<li>a function that turns <em>one</em> of those into a (potentially different kind of)\nvector</li>\n</ol>\n<p>The output type matches the 2nd kind of vector.</p>\n<p>$$ flatmap :: [a] \\rightarrow (a \\rightarrow [b]) \\rightarrow [b] $$</p>\n<pre>flatmap &lt;- function(X, FUN, ..., USE.NAMES = TRUE) {\n    unlist(lapply(X, FUN, ...), recursive = FALSE, USE.NAMES = USE.NAMES)\n}\n</pre><h2 id=\"debrief\">Debrief</h2>\n<p>Such a function could also be defined as an infix operator, and could take the\nform of <code>%&gt;&gt;=%</code>, for example. If that looks familiar, it’s not a coincidence:\nflatmap <em>is</em> the bind operation for the vector monad.\n<a href=\"https://www.biobits.be/biofunctor//2025/07/23/lets-talk-about-nas\" rel=\"nofollow\" target=\"_blank\">Previously</a>, I assumed that yet\nanother infix operator is not what R needs the most, and I created a function\nwrapper instead.</p>\n<p>The same could be done here! R already has a very similar wrapper,\n<code>base::Vectorize()</code>, which only needs a tiny tweak, <code>unlist()</code>-ing the results.\nIt’s so trivial that I won’t even write it out here.</p>\n<p>What excites me much more is the possibility of combining the two ideas:\nhandling NA-s and flatmapping in a single <del>bind</del> wrapper function, which would\ntruly allow focusing on the logic, and let the “expert” wrapper deal with the\nrest. As customary, some more exploration is needed.</p>\n<div class=\"footnotes\" role=\"doc-endnotes\">\n<hr/>\n<ol>\n<li id=\"fn:1\">\n<p>Actually, this works equally well with the original <code>paste0</code>, because\nlapply will map on the first argument anyway, which guarantees that we’ll deal\nwith a single value in each iteration. <a class=\"footnote-backref\" href=\"https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/#fnref:1\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">↩︎</a></p>\n</li>\n</ol>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.biobits.be/biofunctor/2025/07/30/what-s-r-vector-victor/\"> R on Biofunctor</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "What’s R vector, Victor?\nPosted on\nJuly 29, 2025\nby\nR on Biofunctor\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR on Biofunctor\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn this week’s episode of the “Hidden Monads in R” series,\nI’ll explore the vector aspect of R data structures, and see how the flatmap\noperation can be quite useful.\nFlatmap? Aren’t all maps flat?\nThe Nobel Prize organisation provides\nan\nAPI\nwith information about\nthe prizes and laureates. We can retrieve a JSON file, which is what I did. I\nread the file and examine one of the entries below.\n# Source: http://api.nobelprize.org/v1/prize.json\nprizes <- jsonlite::fromJSON(\"./prize.json\", simplifyDataFrame = FALSE)[[\"prizes\"]]\n\nstr(prizes[[11]])\n\n## List of 3\n##  $ year     : chr \"2023\"\n##  $ category : chr \"physics\"\n##  $ laureates:List of 3\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1026\"\n##   .. ..$ firstname : chr \"Pierre\"\n##   .. ..$ surname   : chr \"Agostini\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1027\"\n##   .. ..$ firstname : chr \"Ferenc\"\n##   .. ..$ surname   : chr \"Krausz\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\n##   ..$ :List of 5\n##   .. ..$ id        : chr \"1028\"\n##   .. ..$ firstname : chr \"Anne\"\n##   .. ..$ surname   : chr \"L’Huillier\"\n##   .. ..$ motivation: chr \"\\\"for experimental methods that generate attosecond pulses of light for the study of electron dynamics in matter\\\"\"\n##   .. ..$ share     : chr \"3\"\nLet’s say I want a character vector containing the full names of Nobel laureates\nin medicine since 2020. First, I can concoct a function that gets such a\nvector from a single entry (I know, this one is physics).\nwho_got_it <- function(prize) {\n    laureates <- vapply(\n        X = prize[[\"laureates\"]],\n        FUN = \\(l) c(l[[\"surname\"]] %||% \"\", l[[\"firstname\"]] %||% \"\"),\n        FUN.VALUE = c(\"Doe\", \"John\")\n    )\n    trimws(paste(laureates[2,], laureates[1,]))\n}\n\nwho_got_it(prizes[[11]])\n\n## [1] \"Pierre Agostini\" \"Ferenc Krausz\"   \"Anne L’Huillier\"\nTo achieve my goal, I just have to filter the list accordingly, and\nlapply\nthe\nfunction on the matching entries.\n(medicine_since_2020 <- Filter(\n    f = \\(p) p[[\"category\"]] == \"medicine\" & as.numeric(p[[\"year\"]]) >= 2020,\n    x = prizes\n    ) |>\n    lapply(who_got_it)\n)\n\n## [[1]]\n## [1] \"Victor Ambros\" \"Gary Ruvkun\"  \n## \n## [[2]]\n## [1] \"Katalin Karikó\" \"Drew Weissman\" \n## \n## [[3]]\n## [1] \"Svante Pääbo\"\n## \n## [[4]]\n## [1] \"David Julius\"      \"Ardem Patapoutian\"\n## \n## [[5]]\n## [1] \"Harvey Alter\"     \"Michael Houghton\" \"Charles Rice\"\nNeat! But I want them in a single vector. so I need an\nunlist\nstep at the\nend.\nunlist(medicine_since_2020)\n\n##  [1] \"Victor Ambros\"     \"Gary Ruvkun\"       \"Katalin Karikó\"   \n##  [4] \"Drew Weissman\"     \"Svante Pääbo\"      \"David Julius\"     \n##  [7] \"Ardem Patapoutian\" \"Harvey Alter\"      \"Michael Houghton\" \n## [10] \"Charles Rice\"\nYes, it’s that simple. This is a\nflatmap\nprocess for vectors, and it’s a\ncomposition of a\nmap\nand a\nflatten\nstep (lapply and unlist in this case). It\nalmost looks silly to write a flatmap function, after all it’s not that\ndifficult to lapply and unlist sequentially. But it’s used often, so it saves\ntime and reduces mistakes. In this case – to be correct – I should have used\nunlist(recursive = FALSE)\n, otherwise it flattens nested lists, and that would\nbe wrong.\nA biology-related problem\nLaboratory experiments are often performed in 96-well plastic plates, with 8\nrows (labeled A-H) and 12 columns (labeled 1-12). Each microwell is a separate\nmicro-experiment (labeled A1-H12). Let’s generate well labels for such a\ndataset!\nrows <- LETTERS[1:8]\ncolumns <- 1:12 |> sprintf(fmt = \"%02i\")\nSo all we have to do is combine one vector of values with another, using the\nhandy\npaste0()\nfunction, right? Wrong.\npaste0(rows, columns) |> noquote()\n\n##  [1] A01 B02 C03 D04 E05 F06 G07 H08 A09 B10 C11 D12\nWe’ve only got 12 values instead of 96, and the shorter vector (letters) is\nrecycled as needed. It’s often what you want, so it’s done this way for a good\nreason. But in this case, we’d prefer to have an each-with-each combination.\nSome readers may already have started daydreaming of nested for loops (please\ndon’t). More experienced R programmers would probably go for\nexpand.grid()\nor\nrep(rows, each = length(columns)\nto match up the vectors, and then\npaste()\nthem together. But R is a versatile language, and there are many paths to the\nsame destination. A\nfunctional\nR programmer could just take\nflatmap\noff\nthe shelf, and here is how.\nFor purely didactic reasons, let’s define a non-vectorized paste function,\ncalled paste01\n1\n. It takes a single value and a character vector, and returns\na character vector – the combination of the value with each member of the\nvector.\n$$paste01 :: Str \\rightarrow [Str] \\rightarrow [Str]$$\npaste01 <- \\(x, y) { stopifnot(length(x) == 1L); paste0(x, y)}\npaste01(rows[1], columns)\n\n##  [1] \"A01\" \"A02\" \"A03\" \"A04\" \"A05\" \"A06\" \"A07\" \"A08\" \"A09\" \"A10\" \"A11\" \"A12\"\nWhen we map this function on our\nrows\nvector, we\nalmost\nget what we\nneed.\n$$lapply(paste01) :: [Str] \\rightarrow [Str] \\rightarrow [[Str]]$$\nlapply(rows, paste01, columns) |> head(3L)\n\n## [[1]]\n##  [1] \"A01\" \"A02\" \"A03\" \"A04\" \"A05\" \"A06\" \"A07\" \"A08\" \"A09\" \"A10\" \"A11\" \"A12\"\n## \n## [[2]]\n##  [1] \"B01\" \"B02\" \"B03\" \"B04\" \"B05\" \"B06\" \"B07\" \"B08\" \"B09\" \"B10\" \"B11\" \"B12\"\n## \n## [[3]]\n##  [1] \"C01\" \"C02\" \"C03\" \"C04\" \"C05\" \"C06\" \"C07\" \"C08\" \"C09\" \"C10\" \"C11\" \"C12\"\nIt’s a list of vectors, so we have to flatten it. Yupp, it’s a flatmap.\n$$unlist(lapply(paste01)) :: [Str] \\rightarrow [Str] \\rightarrow [Str]$$\nunlist(lapply(rows, paste01, columns)) |>\n    noquote()\n\n##  [1] A01 A02 A03 A04 A05 A06 A07 A08 A09 A10 A11 A12 B01 B02 B03 B04 B05 B06 B07\n## [20] B08 B09 B10 B11 B12 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 D01 D02\n## [39] D03 D04 D05 D06 D07 D08 D09 D10 D11 D12 E01 E02 E03 E04 E05 E06 E07 E08 E09\n## [58] E10 E11 E12 F01 F02 F03 F04 F05 F06 F07 F08 F09 F10 F11 F12 G01 G02 G03 G04\n## [77] G05 G06 G07 G08 G09 G10 G11 G12 H01 H02 H03 H04 H05 H06 H07 H08 H09 H10 H11\n## [96] H12\nTadaa!\nSo, a flatmap function for vectors can be defined. It takes:\na vector of values\na function that turns\none\nof those into a (potentially different kind of)\nvector\nThe output type matches the 2nd kind of vector.\n$$ flatmap :: [a] \\rightarrow (a \\rightarrow [b]) \\rightarrow [b] $$\nflatmap <- function(X, FUN, ..., USE.NAMES = TRUE) {\n    unlist(lapply(X, FUN, ...), recursive = FALSE, USE.NAMES = USE.NAMES)\n}\nDebrief\nSuch a function could also be defined as an infix operator, and could take the\nform of\n%>>=%\n, for example. If that looks familiar, it’s not a coincidence:\nflatmap\nis\nthe bind operation for the vector monad.\nPreviously\n, I assumed that yet\nanother infix operator is not what R needs the most, and I created a function\nwrapper instead.\nThe same could be done here! R already has a very similar wrapper,\nbase::Vectorize()\n, which only needs a tiny tweak,\nunlist()\n-ing the results.\nIt’s so trivial that I won’t even write it out here.\nWhat excites me much more is the possibility of combining the two ideas:\nhandling NA-s and flatmapping in a single\nbind\nwrapper function, which would\ntruly allow focusing on the logic, and let the “expert” wrapper deal with the\nrest. As customary, some more exploration is needed.\nActually, this works equally well with the original\npaste0\n, because\nlapply will map on the first argument anyway, which guarantees that we’ll deal\nwith a single value in each iteration.\n↩︎\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR on Biofunctor\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "In this week’s episode of the “Hidden Monads in R” series, I’ll explore the vector aspect of R data structures, and see how the flatmap operation can be quite useful. Flatmap? Aren’t all maps flat? The Nobel Prize organis...",
      "meta_keywords": null,
      "og_description": "In this week’s episode of the “Hidden Monads in R” series, I’ll explore the vector aspect of R data structures, and see how the flatmap operation can be quite useful. Flatmap? Aren’t all maps flat? The Nobel Prize organis...",
      "og_image": "https://www.biobits.be/biofunctor/post/2025-07-30-what-s-r-vector-victor/flatmap_meme_bestProgram2020.jpg",
      "og_title": "What’s R vector, Victor? | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 6.8,
      "sitemap_lastmod": null,
      "twitter_description": "In this week’s episode of the “Hidden Monads in R” series, I’ll explore the vector aspect of R data structures, and see how the flatmap operation can be quite useful. Flatmap? Aren’t all maps flat? The Nobel Prize organis...",
      "twitter_title": "What’s R vector, Victor? | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/07/whats-r-vector-victor/",
      "word_count": 1352
    }
  }
}