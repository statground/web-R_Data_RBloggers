{
  "id": "9fc67a06f38e7d90f648c43586935fc2d0c6b2c8",
  "url": "https://www.r-bloggers.com/2025/10/orchestrating-polyglot-reproducible-data-science-with-nix-and-rixpress/",
  "created_at_utc": "2025-11-22T19:57:32Z",
  "data": null,
  "raw_original": {
    "uuid": "776ce9bb-2f97-489d-81ca-b92871837359",
    "created_at": "2025-11-22 19:57:32",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/10/orchestrating-polyglot-reproducible-data-science-with-nix-and-rixpress/",
      "crawled_at": "2025-11-22T10:42:07.260013",
      "external_links": [
        {
          "href": "https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html",
          "text": "Econometrics and Free Software"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://github.com/b-rodrigues/rixpress_demos/blob/master/rbc/",
          "text": "here"
        },
        {
          "href": "https://docs.ropensci.org/rix/articles/e-configuring-ide.html",
          "text": "read this"
        },
        {
          "href": "https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html",
          "text": "Econometrics and Free Software"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress} | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/b-rodrigues.github.io/assets/img/polyglot-dag.png?w=578&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/econometrics-and-free-software/",
          "text": "Econometrics and Free Software"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-396278 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress}</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">October 22, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/econometrics-and-free-software/\">Econometrics and Free Software</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html\"> Econometrics and Free Software</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"text-align: center;\">\n<p>\n<a> <img data-lazy-src=\"https://i1.wp.com/b-rodrigues.github.io/assets/img/polyglot-dag.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width: 100%; height: auto;\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/b-rodrigues.github.io/assets/img/polyglot-dag.png?w=578&amp;ssl=1\" style=\"width: 100%; height: auto;\"/></noscript> </a>\n</p>\n</div>\n<p><em>TL;DR: <code>{rixpress}</code> lets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI!</em></p>\n<p><code>{rixpress}</code> is now on CRAN! As discussed in previous blog posts, <code>{rixpress}</code> is a package heavily inspired by <code>{targets}</code> that uses Nix as the underlying build automation tool to build reproducible data science pipelines.</p>\n<p>But I also wanted <code>{rixpress}</code> to be a language-agnostic build automation tool: pipelines do get defined as an R list, but they can include R, Julia and Python <em>derivations</em> (think of a derivation as a build step).</p>\n<p><code>{rixpress}</code> allows you to define and execute complex, multi-language pipelines where each step runs in its own perfectly reproducible, hermetically sealed environment.</p>\n<p>Because installing stuff is so easy with Nix, the cost of using Python or Julia for a project is really low. Before Nix, I’d try my hardest to find equivalent R packages, just to avoid having to setup a Python environment, but now, if I really have to use Python, I don’t mind that much (also because since I can delegate writing Python to an LLM).</p>\n<p>Suppose you have a project that uses Julia, Python and R: without Nix, <code>{rix}</code> and <code>{rixpress}</code>, setting everything up and executing the code is going to be quite annoying. But with the aforementioned tools? Easy as pie.</p>\n<p>Let’s consider an example from economics, where Julia is used to define a structural Real Business Cycle model (and simulate data from it), Python (with its package <code>xgboost</code>) is used to make predictions from the simulated data, and R to visualise, using <code>{ggplot2}</code>. In truth, one could have use just one of these three languages, but for the sake of argument, let’s use them all.</p>\n<p>With <code>{rixpress}</code>, this entire polyglot workflow is defined declaratively in a single R script. Each step is a function call, making the pipeline easy to read and manage.</p>\n<p>Start the project with <code>rixpress::rxp_init()</code>, which generates two files, <code>gen-env.R</code> and <code>gen-pipeline.R</code>. In <code>gen-env.R</code>, you’ll define the environment you need:</p>\n<pre>library(rix)\n\nrix(\n  # Pin the environment to a specific date to ensure that all package\n  # versions are resolved as they were on this day.\n  date = \"2025-10-14\",\n\n  # 1. R Packages\n  # We need packages for plotting, data manipulation, and reading arrow files.\n  # We also include reticulate as it can be useful for rixpress internals.\n  r_pkgs = c(\n    \"ggplot2\",\n    \"ggdag\",\n    \"dplyr\",\n    \"arrow\",\n    \"rix\",\n    \"rixpress\",\n    \"quarto\"\n  ),\n\n  # 2. Julia Configuration\n  # We specify the Julia version and the list of packages needed\n  # for our manual RBC model simulation.\n  jl_conf = list(\n    jl_version = \"lts\",\n    jl_pkgs = c(\n      \"Distributions\", # For creating random shocks\n      \"DataFrames\", # For structuring the output\n      \"Arrow\", # For saving the data in a cross-language format\n      \"Random\"\n    )\n  ),\n\n  # 3. Python Configuration\n  # We specify the Python version and the packages needed for the\n  # machine learning step.\n  py_conf = list(\n    py_version = \"3.13\",\n    py_pkgs = c(\n      \"pandas\",\n      \"scikit-learn\",\n      \"xgboost\",\n      \"pyarrow\",\n      \"ryxpress\" # Python port of rixpress\n    )\n  ),\n\n  # We set the IDE to 'none' for a minimal environment. You could change\n  # this to \"rstudio\" if you prefer to work interactively in RStudio.\n  ide = \"none\",\n\n  # Define the project path and allow overwriting the default.nix file.\n  project_path = \".\",\n  overwrite = TRUE\n)</pre>\n<p>If you are on a system where Nix is available, you can drop into a temporary shell with R and <code>{rix}</code> available to generate the required <code>default.nix</code> (which is the Nix expression that once built, provides the environment):</p>\n<pre>nix-shell -I \\\n  nixpkgs=https://github.com/rstats-on-nix/nixpkgs/tarball/2025-10-20 -p \\\n  R rPackages.rix</pre>\n<p>then simply start R, and then <code>source(\"gen-env.R\")</code>. This will generate the <code>default.nix</code>. Then leave R, leave the temporary shell (by typing <code>exit</code> or using <code>CTRL-D</code>) and build the environment with <code>nix-build</code>. Wait for it to finish. Then we can tackle the pipeline. I show the full script below, but you won’t be writing this in one go. Instead, you would add a derivation, build the pipeline, load the artefact into memory by using <code>rxp_load(\"artefact_name\")</code>, look at it, play with it, and then continue. If you’re familiar with <code>{targets}</code> you should feel at ease.</p>\n<p>Here’s the full script:</p>\n<pre># This script defines and orchestrates the entire reproducible analytical\n# pipeline using the {rixpress} package.\n\nlibrary(rixpress)\n\nlist(\n  # STEP 0: Define RBC Model Parameters as Derivations\n  # This makes the parameters an explicit part of the pipeline.\n  # Changing a parameter will cause downstream steps to rebuild.\n  rxp_jl(alpha, 0.3), # Capital's share of income\n  rxp_jl(beta, 1 / 1.01), # Discount factor\n  rxp_jl(delta, 0.025), # Depreciation rate\n  rxp_jl(rho, 0.95), # Technology shock persistence\n  rxp_jl(sigma, 1.0), # Risk aversion (log-utility)\n  rxp_jl(sigma_z, 0.01), # Technology shock standard deviation\n\n  # STEP 1: Julia - Simulate a Real Business Cycle (RBC) model.\n  # This derivation runs our Julia script to generate the source data.\n  rxp_jl(\n    name = simulated_rbc_data,\n    expr = \"simulate_rbc_model(alpha, beta, delta, rho, sigma, sigma_z)\",\n    user_functions = \"functions/functions.jl\", # The file containing the function\n    encoder = \"arrow_write\" # The function to use for saving the output\n  ),\n\n  # STEP 2.1: Python - Prepare features (lagging data)\n  rxp_py(\n    name = processed_data,\n    expr = \"prepare_features(simulated_rbc_data)\",\n    user_functions = \"functions/functions.py\",\n    # Decode the Arrow file from Julia into a pandas DataFrame\n    decoder = \"feather.read_feather\"\n    # Note: No encoder needed here. {rixpress} will use pickle by default\n    # to pass the DataFrame between Python steps.\n  ),\n\n  # STEP 2.2: Python - Split data into training and testing sets\n  rxp_py(\n    name = X_train,\n    expr = \"get_X_train(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = y_train,\n    expr = \"get_y_train(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = X_test,\n    expr = \"get_X_test(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = y_test,\n    expr = \"get_y_test(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.3: Python - Train the model\n  rxp_py(\n    name = trained_model,\n    expr = \"train_model(X_train, y_train)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.4: Python - Make predictions\n  rxp_py(\n    name = model_predictions,\n    expr = \"make_predictions(trained_model, X_test)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.5: Python - Format final results for R\n  rxp_py(\n    name = predictions,\n    expr = \"format_results(y_test, model_predictions)\",\n    user_functions = \"functions/functions.py\",\n    # We need an encoder here to save the final DataFrame as an Arrow file\n    # so the R step can read it.\n    encoder = \"save_arrow\"\n  ),\n\n  # STEP 3: R - Visualize the predictions from the Python model.\n  # This final derivation depends on the output of the Python step.\n  rxp_r(\n    name = output_plot,\n    expr = plot_predictions(predictions), # The function to call from functions.R\n    user_functions = \"functions/functions.R\",\n    # Specify how to load the upstream data (from Python) into R.\n    decoder = arrow::read_feather\n  ),\n\n  # STEP 4: Quarto - Compile the final report.\n  rxp_qmd(\n    name = final_report,\n    additional_files = \"_rixpress\",\n    qmd_file = \"readme.qmd\"\n  )\n) |&gt;\n  rxp_populate(\n    py_imports = c(\n      pandas = \"import pandas as pd\",\n      pyarrow = \"import pyarrow.feather as feather\",\n      sklearn = \"from sklearn.model_selection import train_test_split\",\n      xgboost = \"import xgboost as xgb\"\n    ),\n    project_path = \".\", # The root of our project\n    build = TRUE, # Set to TRUE to execute the pipeline immediately\n    verbose = 1\n  )</pre>\n<p><em>(helper functions are defined in separate scripts, inside the <code>functions/</code> folder which I don’t show here)</em></p>\n<p>The magic here is twofold. First, <code>{rixpress}</code> seamlessly handles passing data between language environments, using efficient formats like Apache Arrow via <code>encoder</code> and <code>decoder</code> functions. Second, because each step is a Nix derivation, it runs in its own isolated environment. The Julia simulation can have its own dependencies, completely separate from the Python and R steps, eliminating “dependency hell” forever. Also, the artefacts built by the pipeline are actually children of the environment. Meaning, that if you change the environment (for example, by adding a package), this invalidates everything, and the whole pipeline gets rebuilt. This is quite useful, because sometimes changing the environment could break the downstream artefacts in subtle ways, but with classical build automation tools, the artefacts and the environment are not tied, and so a rebuild would not be triggered.</p>\n<p>Once built, you can interactively explore artifacts:</p>\n<pre># From R\nrxp_load(\"simulated_rbc_data\")\nrxp_load(\"output_plot\")\n# Or from Python (using ryxpress)\nfrom ryxpress import rxp_make, rxp_load\nrxp_load(\"predictions\")</pre>\n<p>The pipeline automatically caches results, so changing one step only rebuilds what’s affected. <code>{rixpress}</code> (and <code>ryxpress</code>) will try its best to show you to convert objects seamlessly from R to Python and vice-versa. If you try to load an object built inside a Python environment, <code>{rixpress}</code> will use <code>{reticulate}</code> (if you’ve added it to the list of R packages) to convert it to an equivalent R object. From a Python session, if you added the <code>rds2py</code> Python package, the same will happen, but converting an R object into the equivalent Python object (since Python doesn’t have a native data frame implementation, use <code>biocframe</code> to convert from R data frames into Python <em>bioc</em>frames, which come with a method to convert to <code>pandas</code> or <code>polars</code> data frames).</p>\n<p>You can find the code for this example <a href=\"https://github.com/b-rodrigues/rixpress_demos/blob/master/rbc/\" rel=\"nofollow\" target=\"_blank\">here</a>.</p>\n<p>If you’re primary a Python user, I think that you could still find <code>{rixpress}</code> useful. Defining the pipeline as an R list shouldn’t be too much of an issue, and you can explore the pipeline and artefacts with the Python port, <code>ryxpress</code>. This Python port makes it easy to build the pipeline and load and explore artefacts from a Python session.</p>\n<p>Another Python-related caveat is that while Nix’s package repository, <code>nixpkgs</code>, is vast, the Python ecosystem (PyPI) is famously heterogeneous. Not every Python package or specific version you might need is available directly in <code>nixpkgs</code>.</p>\n<p>To solve this, it is possible to install <code>uv</code>, a modern and fast Python package manager, with Nix, and let <code>uv</code> handle the Python packages and Python interpreter, but let Nix handle everything else:</p>\n<pre>rix(date = \"2025-10-20\",\n  r_pkgs = c(\"rix\", \"dplyr\", \"chronicler\"),\n  system_pkgs = c(\"uv\"),\n  project_path = \".\",\n  overwrite = TRUE)</pre>\n<p>This approach gives you the best of both worlds: you use <code>{rix}</code> to define the core, reproducible environment. This includes, critical system libraries (like GDAL or HDF5), and all your R and Julia dependencies. This part of your environment is bit-for-bit reproducible. Then, within this Nix-managed environment, you use standard <code>uv</code> commands (e.g., <code>uv pip install pandas</code>) to manage your Python packages. <code>uv</code> creates a <code>uv.lock</code> file that pins the exact versions and hashes of your Python dependencies, ensuring a reproducible Python package set.</p>\n<p>While this hybrid model trades the full build-time determinism of a pure-Nix approach for Python packages, it offers immense flexibility and solves the issue of <code>nixpkgs</code> not mirrorring PyPI.</p>\n<p>I think that the biggest hurdle for <code>{rix}</code> and <code>{rixpress}</code> adoption for Python data scientists is their love of Jupyter Notebooks.</p>\n<p>By the way, it’s possible to use an IDE alongside Nix and <code>{rix}</code> and <code>{rixpress}</code>. I think I’ll make a video for that, though, but for those of you that prefer reading, <a href=\"https://docs.ropensci.org/rix/articles/e-configuring-ide.html\" rel=\"nofollow\" target=\"_blank\">read this</a>.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://b-rodrigues.github.io/posts/2025-10-23-rixpress_cran.html\"> Econometrics and Free Software</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress}\nPosted on\nOctober 22, 2025\nby\nEconometrics and Free Software\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nEconometrics and Free Software\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nTL;DR:\n{rixpress}\nlets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI!\n{rixpress}\nis now on CRAN! As discussed in previous blog posts,\n{rixpress}\nis a package heavily inspired by\n{targets}\nthat uses Nix as the underlying build automation tool to build reproducible data science pipelines.\nBut I also wanted\n{rixpress}\nto be a language-agnostic build automation tool: pipelines do get defined as an R list, but they can include R, Julia and Python\nderivations\n(think of a derivation as a build step).\n{rixpress}\nallows you to define and execute complex, multi-language pipelines where each step runs in its own perfectly reproducible, hermetically sealed environment.\nBecause installing stuff is so easy with Nix, the cost of using Python or Julia for a project is really low. Before Nix, I’d try my hardest to find equivalent R packages, just to avoid having to setup a Python environment, but now, if I really have to use Python, I don’t mind that much (also because since I can delegate writing Python to an LLM).\nSuppose you have a project that uses Julia, Python and R: without Nix,\n{rix}\nand\n{rixpress}\n, setting everything up and executing the code is going to be quite annoying. But with the aforementioned tools? Easy as pie.\nLet’s consider an example from economics, where Julia is used to define a structural Real Business Cycle model (and simulate data from it), Python (with its package\nxgboost\n) is used to make predictions from the simulated data, and R to visualise, using\n{ggplot2}\n. In truth, one could have use just one of these three languages, but for the sake of argument, let’s use them all.\nWith\n{rixpress}\n, this entire polyglot workflow is defined declaratively in a single R script. Each step is a function call, making the pipeline easy to read and manage.\nStart the project with\nrixpress::rxp_init()\n, which generates two files,\ngen-env.R\nand\ngen-pipeline.R\n. In\ngen-env.R\n, you’ll define the environment you need:\nlibrary(rix)\n\nrix(\n  # Pin the environment to a specific date to ensure that all package\n  # versions are resolved as they were on this day.\n  date = \"2025-10-14\",\n\n  # 1. R Packages\n  # We need packages for plotting, data manipulation, and reading arrow files.\n  # We also include reticulate as it can be useful for rixpress internals.\n  r_pkgs = c(\n    \"ggplot2\",\n    \"ggdag\",\n    \"dplyr\",\n    \"arrow\",\n    \"rix\",\n    \"rixpress\",\n    \"quarto\"\n  ),\n\n  # 2. Julia Configuration\n  # We specify the Julia version and the list of packages needed\n  # for our manual RBC model simulation.\n  jl_conf = list(\n    jl_version = \"lts\",\n    jl_pkgs = c(\n      \"Distributions\", # For creating random shocks\n      \"DataFrames\", # For structuring the output\n      \"Arrow\", # For saving the data in a cross-language format\n      \"Random\"\n    )\n  ),\n\n  # 3. Python Configuration\n  # We specify the Python version and the packages needed for the\n  # machine learning step.\n  py_conf = list(\n    py_version = \"3.13\",\n    py_pkgs = c(\n      \"pandas\",\n      \"scikit-learn\",\n      \"xgboost\",\n      \"pyarrow\",\n      \"ryxpress\" # Python port of rixpress\n    )\n  ),\n\n  # We set the IDE to 'none' for a minimal environment. You could change\n  # this to \"rstudio\" if you prefer to work interactively in RStudio.\n  ide = \"none\",\n\n  # Define the project path and allow overwriting the default.nix file.\n  project_path = \".\",\n  overwrite = TRUE\n)\nIf you are on a system where Nix is available, you can drop into a temporary shell with R and\n{rix}\navailable to generate the required\ndefault.nix\n(which is the Nix expression that once built, provides the environment):\nnix-shell -I \\\n  nixpkgs=https://github.com/rstats-on-nix/nixpkgs/tarball/2025-10-20 -p \\\n  R rPackages.rix\nthen simply start R, and then\nsource(\"gen-env.R\")\n. This will generate the\ndefault.nix\n. Then leave R, leave the temporary shell (by typing\nexit\nor using\nCTRL-D\n) and build the environment with\nnix-build\n. Wait for it to finish. Then we can tackle the pipeline. I show the full script below, but you won’t be writing this in one go. Instead, you would add a derivation, build the pipeline, load the artefact into memory by using\nrxp_load(\"artefact_name\")\n, look at it, play with it, and then continue. If you’re familiar with\n{targets}\nyou should feel at ease.\nHere’s the full script:\n# This script defines and orchestrates the entire reproducible analytical\n# pipeline using the {rixpress} package.\n\nlibrary(rixpress)\n\nlist(\n  # STEP 0: Define RBC Model Parameters as Derivations\n  # This makes the parameters an explicit part of the pipeline.\n  # Changing a parameter will cause downstream steps to rebuild.\n  rxp_jl(alpha, 0.3), # Capital's share of income\n  rxp_jl(beta, 1 / 1.01), # Discount factor\n  rxp_jl(delta, 0.025), # Depreciation rate\n  rxp_jl(rho, 0.95), # Technology shock persistence\n  rxp_jl(sigma, 1.0), # Risk aversion (log-utility)\n  rxp_jl(sigma_z, 0.01), # Technology shock standard deviation\n\n  # STEP 1: Julia - Simulate a Real Business Cycle (RBC) model.\n  # This derivation runs our Julia script to generate the source data.\n  rxp_jl(\n    name = simulated_rbc_data,\n    expr = \"simulate_rbc_model(alpha, beta, delta, rho, sigma, sigma_z)\",\n    user_functions = \"functions/functions.jl\", # The file containing the function\n    encoder = \"arrow_write\" # The function to use for saving the output\n  ),\n\n  # STEP 2.1: Python - Prepare features (lagging data)\n  rxp_py(\n    name = processed_data,\n    expr = \"prepare_features(simulated_rbc_data)\",\n    user_functions = \"functions/functions.py\",\n    # Decode the Arrow file from Julia into a pandas DataFrame\n    decoder = \"feather.read_feather\"\n    # Note: No encoder needed here. {rixpress} will use pickle by default\n    # to pass the DataFrame between Python steps.\n  ),\n\n  # STEP 2.2: Python - Split data into training and testing sets\n  rxp_py(\n    name = X_train,\n    expr = \"get_X_train(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = y_train,\n    expr = \"get_y_train(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = X_test,\n    expr = \"get_X_test(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  rxp_py(\n    name = y_test,\n    expr = \"get_y_test(processed_data)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.3: Python - Train the model\n  rxp_py(\n    name = trained_model,\n    expr = \"train_model(X_train, y_train)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.4: Python - Make predictions\n  rxp_py(\n    name = model_predictions,\n    expr = \"make_predictions(trained_model, X_test)\",\n    user_functions = \"functions/functions.py\"\n  ),\n\n  # STEP 2.5: Python - Format final results for R\n  rxp_py(\n    name = predictions,\n    expr = \"format_results(y_test, model_predictions)\",\n    user_functions = \"functions/functions.py\",\n    # We need an encoder here to save the final DataFrame as an Arrow file\n    # so the R step can read it.\n    encoder = \"save_arrow\"\n  ),\n\n  # STEP 3: R - Visualize the predictions from the Python model.\n  # This final derivation depends on the output of the Python step.\n  rxp_r(\n    name = output_plot,\n    expr = plot_predictions(predictions), # The function to call from functions.R\n    user_functions = \"functions/functions.R\",\n    # Specify how to load the upstream data (from Python) into R.\n    decoder = arrow::read_feather\n  ),\n\n  # STEP 4: Quarto - Compile the final report.\n  rxp_qmd(\n    name = final_report,\n    additional_files = \"_rixpress\",\n    qmd_file = \"readme.qmd\"\n  )\n) |>\n  rxp_populate(\n    py_imports = c(\n      pandas = \"import pandas as pd\",\n      pyarrow = \"import pyarrow.feather as feather\",\n      sklearn = \"from sklearn.model_selection import train_test_split\",\n      xgboost = \"import xgboost as xgb\"\n    ),\n    project_path = \".\", # The root of our project\n    build = TRUE, # Set to TRUE to execute the pipeline immediately\n    verbose = 1\n  )\n(helper functions are defined in separate scripts, inside the\nfunctions/\nfolder which I don’t show here)\nThe magic here is twofold. First,\n{rixpress}\nseamlessly handles passing data between language environments, using efficient formats like Apache Arrow via\nencoder\nand\ndecoder\nfunctions. Second, because each step is a Nix derivation, it runs in its own isolated environment. The Julia simulation can have its own dependencies, completely separate from the Python and R steps, eliminating “dependency hell” forever. Also, the artefacts built by the pipeline are actually children of the environment. Meaning, that if you change the environment (for example, by adding a package), this invalidates everything, and the whole pipeline gets rebuilt. This is quite useful, because sometimes changing the environment could break the downstream artefacts in subtle ways, but with classical build automation tools, the artefacts and the environment are not tied, and so a rebuild would not be triggered.\nOnce built, you can interactively explore artifacts:\n# From R\nrxp_load(\"simulated_rbc_data\")\nrxp_load(\"output_plot\")\n# Or from Python (using ryxpress)\nfrom ryxpress import rxp_make, rxp_load\nrxp_load(\"predictions\")\nThe pipeline automatically caches results, so changing one step only rebuilds what’s affected.\n{rixpress}\n(and\nryxpress\n) will try its best to show you to convert objects seamlessly from R to Python and vice-versa. If you try to load an object built inside a Python environment,\n{rixpress}\nwill use\n{reticulate}\n(if you’ve added it to the list of R packages) to convert it to an equivalent R object. From a Python session, if you added the\nrds2py\nPython package, the same will happen, but converting an R object into the equivalent Python object (since Python doesn’t have a native data frame implementation, use\nbiocframe\nto convert from R data frames into Python\nbioc\nframes, which come with a method to convert to\npandas\nor\npolars\ndata frames).\nYou can find the code for this example\nhere\n.\nIf you’re primary a Python user, I think that you could still find\n{rixpress}\nuseful. Defining the pipeline as an R list shouldn’t be too much of an issue, and you can explore the pipeline and artefacts with the Python port,\nryxpress\n. This Python port makes it easy to build the pipeline and load and explore artefacts from a Python session.\nAnother Python-related caveat is that while Nix’s package repository,\nnixpkgs\n, is vast, the Python ecosystem (PyPI) is famously heterogeneous. Not every Python package or specific version you might need is available directly in\nnixpkgs\n.\nTo solve this, it is possible to install\nuv\n, a modern and fast Python package manager, with Nix, and let\nuv\nhandle the Python packages and Python interpreter, but let Nix handle everything else:\nrix(date = \"2025-10-20\",\n  r_pkgs = c(\"rix\", \"dplyr\", \"chronicler\"),\n  system_pkgs = c(\"uv\"),\n  project_path = \".\",\n  overwrite = TRUE)\nThis approach gives you the best of both worlds: you use\n{rix}\nto define the core, reproducible environment. This includes, critical system libraries (like GDAL or HDF5), and all your R and Julia dependencies. This part of your environment is bit-for-bit reproducible. Then, within this Nix-managed environment, you use standard\nuv\ncommands (e.g.,\nuv pip install pandas\n) to manage your Python packages.\nuv\ncreates a\nuv.lock\nfile that pins the exact versions and hashes of your Python dependencies, ensuring a reproducible Python package set.\nWhile this hybrid model trades the full build-time determinism of a pure-Nix approach for Python packages, it offers immense flexibility and solves the issue of\nnixpkgs\nnot mirrorring PyPI.\nI think that the biggest hurdle for\n{rix}\nand\n{rixpress}\nadoption for Python data scientists is their love of Jupyter Notebooks.\nBy the way, it’s possible to use an IDE alongside Nix and\n{rix}\nand\n{rixpress}\n. I think I’ll make a video for that, though, but for those of you that prefer reading,\nread this\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nEconometrics and Free Software\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "TL;DR: {rixpress} lets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI! {rixpress} is now on ...",
      "meta_keywords": null,
      "og_description": "TL;DR: {rixpress} lets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI! {rixpress} is now on ...",
      "og_image": "https://b-rodrigues.github.io/assets/img/polyglot-dag.png",
      "og_title": "Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress} | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 9.6,
      "sitemap_lastmod": null,
      "twitter_description": "TL;DR: {rixpress} lets you build multi-language data pipelines (R, Python, Julia) where each step runs in its own reproducible environment. Uses Nix under the hood. Now on CRAN, and there’s even a Python port on PyPI! {rixpress} is now on ...",
      "twitter_title": "Orchestrating Polyglot, Reproducible Data Science with Nix and {rixpress} | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/10/orchestrating-polyglot-reproducible-data-science-with-nix-and-rixpress/",
      "word_count": 1929
    }
  }
}