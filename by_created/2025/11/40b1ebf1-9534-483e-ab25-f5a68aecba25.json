{
  "uuid": "40b1ebf1-9534-483e-ab25-f5a68aecba25",
  "created_at": "2025-11-22 19:59:02",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/03/announcing-rixpress/",
    "crawled_at": "2025-11-22T10:52:18.689603",
    "external_links": [
      {
        "href": "https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://docs.ropensci.org/rix/articles/z-advanced-topic-reproducible-analytical-pipelines-with-nix.html",
        "text": "this vignette of my {rix} package"
      },
      {
        "href": "https://b-rodrigues.github.io/posts/2024-08-28-nix_for_r_part_12.html",
        "text": "this blog post"
      },
      {
        "href": "https://github.com/b-rodrigues/rixpress_pipeline_demo",
        "text": "here"
      },
      {
        "href": "https://books.ropensci.org/targets/walkthrough.html",
        "text": "intro video"
      },
      {
        "href": "https://grantmcdermott.com/",
        "text": "Grant McDermott"
      },
      {
        "href": "https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Announcing rixpress | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/b-rodrigues.github.io/assets/img/announcing_rixpress.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/b-rodrigues.github.io/assets/img/rixpress_dag.png?w=450&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/econometrics-and-free-software/",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-391358 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Announcing rixpress</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">March 19, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/econometrics-and-free-software/\">Econometrics and Free Software</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html\"> Econometrics and Free Software</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"text-align: center;\">\n<p>\n<a> <img data-lazy-src=\"https://i2.wp.com/b-rodrigues.github.io/assets/img/announcing_rixpress.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width: 50%; height: auto;\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/b-rodrigues.github.io/assets/img/announcing_rixpress.png?w=578&amp;ssl=1\" style=\"width: 50%; height: auto;\"/></noscript> </a>\n</p>\n</div>\n<p>As I’ve already discussed in <a href=\"https://docs.ropensci.org/rix/articles/z-advanced-topic-reproducible-analytical-pipelines-with-nix.html\" rel=\"nofollow\" target=\"_blank\">this vignette of my {rix} package</a>, it is very easy to run a <code>{targets}</code> pipeline inside of a Nix environment for increased reproduciblity. The main drawback of <code>{targets}</code> though, is that it is not possible to compute one particular object in one particular environment, and another object in another environment. It is also not possible to compute a target using Python for instance, unless you use <code>{reticulate}</code>.</p>\n<p>But we can go a step further: you see, Nix is a very versatile tool, and the Nix programming language is a domain-specific language made to package software. If you assume that, say, a statistical or machine learning model is just software, then why not use Nix to build it? This thought is what made me want to write <code>{rixpress}</code>.</p>\n<section class=\"level2\" id=\"rixpress-a-package-to-define-reproducible-analytical-pipelines\">\n<h2 class=\"anchored\" data-anchor-id=\"rixpress-a-package-to-define-reproducible-analytical-pipelines\">rixpress, a package to define reproducible analytical pipelines</h2>\n<p>The Nix programming language is a domain specific language used to package and build software, and “software” can have a very broad definition. As I explored in <a href=\"https://b-rodrigues.github.io/posts/2024-08-28-nix_for_r_part_12.html\" rel=\"nofollow\" target=\"_blank\">this blog post</a>, Nix (the programming language) can be used to define a polyglot pipeline to build, for example, a Quarto report using R and Python. I have now built a package called <code>{rixpress}</code> which is heavily inspired by <code>{targets}</code> (if you are not familiar with <code>{targets}</code>, I introduce it at the end of this blog post) to generate such pipelines and build them using Nix. Below is a complete example which starts by using Python and the Polars library to load a dataset, then transforms it a bit, and converts the data to a Pandas dataframe then passes it to R (conversion is done via <code>reticulate::py_load_object()</code> under the hood, also why I had to convert the Polars dataframe to a Pandas dataframe) and finally compiles a Quarto document (you can find the code <a href=\"https://github.com/b-rodrigues/rixpress_pipeline_demo\" rel=\"nofollow\" target=\"_blank\">here</a>):</p>\n<div class=\"cell\">\n<pre>library(rixpress)\n\nd0 &lt;- rxp_py_file(\n  name = mtcars_pl,\n  path = 'data/mtcars.csv',\n  read_function = \"lambda x: polars.read_csv(x, separator='|')\",\n  nix_env = \"py-env.nix\"\n)\n\nd1 &lt;- rxp_py(\n  # reticulate doesn't support polars DFs yet, so need to convert\n  # first to pandas DF\n  name = mtcars_pl_am,\n  py_expr = \"mtcars_pl.filter(polars.col('am') == 1).to_pandas()\",\n  nix_env = \"py-env.nix\"\n)\n\nd2 &lt;- rxp_py2r(\n  name = mtcars_am,\n  expr = mtcars_pl_am\n)\n\nd3 &lt;- rxp_r(\n  name = mtcars_head,\n  expr = my_head(mtcars_am),\n  additional_files = \"functions.R\"\n)\n\nd4 &lt;- rxp_r(\n  name = mtcars_tail,\n  expr = tail(mtcars_head)\n)\n\nd5 &lt;- rxp_r(\n  name = mtcars_mpg,\n  expr = dplyr::select(mtcars_tail, mpg)\n)\n\ndoc &lt;- rxp_quarto(\n  name = page,\n  qmd_file = \"page.qmd\",\n  additional_files = c(\"content.qmd\", \"images\"),\n  nix_env = \"quarto-env.nix\"\n)\n\nrxp_list &lt;- list(d0, d1, d2, d3, d4, d5, doc)\n\nrixpress(rxp_list, project_path = \".\")\n\nplot_dag()</pre>\n</div>\n<p>Let’s go through this code:</p>\n<div class=\"cell\">\n<pre>d0 &lt;- rxp_py_file(\n  name = mtcars_pl,\n  path = 'data/mtcars.csv',\n  read_function = \"lambda x: polars.read_csv(x, separator='|')\",\n  nix_env = \"py-env.nix\"\n)</pre>\n</div>\n<p><code>rxp_py_file()</code> uses Python to load a local file. In this case, it’s the <code>mtcars.csv</code> dataset under the <code>data/</code> folder. The read function must be a function of only one parameter, the path to the data, so I use an anonymous function wrapping <code>polars.read_csv</code> which allows me to set the separator to the unix pipe <code>|</code>. Also, this code is executed inside the environment defined by the <code>py-env.nix</code> file. This file can be generated by my other package, <code>{rix}</code> and lists the Python packages needed (you’ll find it in the repo).</p>\n<p>Then:</p>\n<div class=\"cell\">\n<pre>d1 &lt;- rxp_py(\n  # reticulate doesn't support polars DFs yet, so need to convert\n  # first to pandas DF\n  name = mtcars_pl_am,\n  py_expr = \"mtcars_pl.filter(polars.col('am') == 1).to_pandas()\",\n  nix_env = \"py-env.nix\"\n)</pre>\n</div>\n<p><code>rxp_py()</code> executes Python code, and saves the output into the <code>name</code> argument. In this case, I filter the Polars dataframe and convert it to a Pandas dataframe. This again happens inside the environment defined by <code>py-env.nix</code>, it’s a pure Python env, no <code>{reticulate}</code> needed at this stage.</p>\n<p>Then:</p>\n<div class=\"cell\">\n<pre>d2 &lt;- rxp_py2r(\n  name = mtcars_am,\n  expr = mtcars_pl_am\n)</pre>\n</div>\n<p><code>rxp_py2r()</code> calls <code>reticulate::py_load_object()</code> to convert the Pandas dataframe to an R dataframe. We can now continue using it using R! You’ll notice that no <code>nix_env</code> argument is passed to this function. When no argument is provided to <code>nix_env</code>, the default environment, <code>default.nix</code> gets used. This one must always be present and in this case contains the required R packages for the pipeline.</p>\n<p>Then:</p>\n<div class=\"cell\">\n<pre>d3 &lt;- rxp_r(\n  name = mtcars_head,\n  expr = my_head(mtcars_am),\n  additional_files = \"functions.R\"\n)</pre>\n</div>\n<p>This one uses an argument we don’t know yet, <code>additional_files</code>. It allows you to pass R scripts that define functions. In this case, <code>functions.R</code> contains the definition of <code>my_head()</code> which is used on <code>mtcars_am</code>.</p>\n<p><code>d4</code> and <code>d5</code> are self-explanatory, so now let’s take a look at <code>rxp_quarto()</code>:</p>\n<div class=\"cell\">\n<pre>doc &lt;- rxp_quarto(\n  name = page,\n  qmd_file = \"page.qmd\",\n  additional_files = c(\"content.qmd\", \"images\"),\n  nix_env = \"quarto-env.nix\"\n)</pre>\n</div>\n<p>This compiles the <code>page.qmd</code> document, which requires additional files: <code>content.qmd</code> which gets included into <code>page.qmd</code> and the <code>images/</code> folder, that contains images required to compile the document. This file is compiled using the <code>quarto-env.nix</code> environment.</p>\n<p>Putting all these derivations into a list and passing it to <code>rixpress()</code> doesn’t build the pipeline just yet, but generates a <code>pipeline.nix</code> file which is the Nix expression that will build the output, in this case our Quarto document. You can also take a look at the DAG using <code>plot_dag()</code>:</p>\n<div style=\"text-align:center;\">\n<p>\n<img data-lazy-src=\"https://i2.wp.com/b-rodrigues.github.io/assets/img/rixpress_dag.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/b-rodrigues.github.io/assets/img/rixpress_dag.png?w=450&amp;ssl=1\"/></noscript>\n</p>\n</div>\n<p>and it’s also possible to retrieve objects in an interactive sessions using <code>rxp_read()</code> (to read them) or <code>rxp_load()</code> (to load them in the global environment). When reading or loading Python objects, this will get converted using <code>{reticulate}</code> on the fly.</p>\n<p>To build the pipeline, run <code>rxp_make()</code>. Subsequent runs don’t build everything, as intermediary outputs are cached in the <em>Nix store</em>. So if you change only the Quarto document, only this one derivation gets built anew. It is also possible to export and import the outputs using <code>export_nix_archive()</code> and <code>import_nix_archive()</code>, pretty useful for CI!</p>\n</section>\n<section class=\"level2\" id=\"caveats\">\n<h2 class=\"anchored\" data-anchor-id=\"caveats\">Caveats</h2>\n<p>This package is still in the prototype stage, so don’t use it for anything serious. There are still some things I need to work on, for now debugging a faulty pipeline is really hard because intermediary outputs are difficult to find if the pipeline wasn’t completely built.</p>\n<p>Also, due to how Nix works, every computation happens in a completely isolated sandbox. This is why the <code>rxp_*()</code> functions have that <code>additional_files</code> argument, because in case something external is required, Nix needs to copy it over into the sandbox. This means also that functions that require Internet access to work will fail. But I was able to work around that for <code>rxp_file()</code>: so if a resource is online, the function that reads it should be able to get to it.</p>\n<p>Now, let me introduce <code>{targets}</code>, my main source of inspiration for this package</p>\n</section>\n<section class=\"level2\" id=\"the-targets-package-my-source-of-inspiration-for-rixpress\">\n<h2 class=\"anchored\" data-anchor-id=\"the-targets-package-my-source-of-inspiration-for-rixpress\">The targets package, my source of inspiration for rixpress</h2>\n<p>I’m a huge fan of the <code>{targets}</code> package and think that it’s truly one of the best packages ever made. No other build/pipeline automation tool comes close in my opinion. Most of these tools require you to define your pipeline in another language (such as yaml) or force you to use some very specific syntax where you explicitely need to define the objects to compute, their inputs and outputs. But <code>{targets}</code> allows you to define your pipeline as a series of R calls:</p>\n<div class=\"cell\">\n<pre># _targets.R file\nlibrary(targets)\nlibrary(tarchetypes)\ntar_source()\ntar_option_set(packages = c(\"readr\", \"dplyr\", \"ggplot2\"))\nlist(\n  tar_target(file, \"data.csv\", format = \"file\"),\n  tar_target(data, get_data(file)),\n  tar_target(model, fit_model(data)),\n  tar_target(plot, plot_model(model, data))\n)</pre>\n</div>\n<p>This may look foreign to many R users, but if you look closely, you’ll realise that most of this code is boilerplate:</p>\n<div class=\"cell\">\n<pre># _targets.R file\nlibrary(targets)\nlibrary(tarchetypes)\ntar_source()\ntar_option_set(packages = c(\"readr\", \"dplyr\", \"ggplot2\"))\nlist(\n  tar_target(....),\n  tar_target(....),\n  tar_target(....),\n  tar_target(....)\n)</pre>\n</div>\n<p>and what matters is defined inside the <code>tar_target()</code> functions. Remove the boilerplate, and you end up with essentially correct R code, after a few adjustments:</p>\n<div class=\"cell\">\n<pre>file &lt;- \"data.csv\"\ndata &lt;- get_data(file)\nmodel &lt;- fit_model(data)\nplot &lt;- plot_model(model, data)</pre>\n</div>\n<p>but why go through the trouble of using <code>{targets}</code>? Well, the biggest reason is that <code>{targets}</code> figures out the dependencies between the objects you want to compute, and caches them. So in the example above, if you only change the code of the <code>fit_model()</code> function, only <code>model</code> and <code>plot</code> are re-computed. But if you change <code>file</code> and point the path to an updated <code>data.csv</code> file, then everything gets computed anew. Watch the <a href=\"https://books.ropensci.org/targets/walkthrough.html\" rel=\"nofollow\" target=\"_blank\">intro video</a> from the official walkthrough for a visual explanation: but trust me, <code>{targets}</code> is in this class of tools that make you wonder how you could possibly have gotten anything done before using it.</p>\n</section>\n<section class=\"level2\" id=\"conclusion\">\n<h2 class=\"anchored\" data-anchor-id=\"conclusion\">Conclusion</h2>\n<p>I think that <code>{rixpress}</code> can become quite an useful package, so I will likely submit it for rOpenSci peer review in due time.</p>\n<p>And thanks to <a href=\"https://grantmcdermott.com/\" rel=\"nofollow\" target=\"_blank\">Grant McDermott</a> for suggesting the name “rixpress”!</p>\n</section>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://b-rodrigues.github.io/posts/2025-03-20-announcing_rixpress.html\"> Econometrics and Free Software</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Announcing rixpress\nPosted on\nMarch 19, 2025\nby\nEconometrics and Free Software\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nEconometrics and Free Software\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAs I’ve already discussed in\nthis vignette of my {rix} package\n, it is very easy to run a\n{targets}\npipeline inside of a Nix environment for increased reproduciblity. The main drawback of\n{targets}\nthough, is that it is not possible to compute one particular object in one particular environment, and another object in another environment. It is also not possible to compute a target using Python for instance, unless you use\n{reticulate}\n.\nBut we can go a step further: you see, Nix is a very versatile tool, and the Nix programming language is a domain-specific language made to package software. If you assume that, say, a statistical or machine learning model is just software, then why not use Nix to build it? This thought is what made me want to write\n{rixpress}\n.\nrixpress, a package to define reproducible analytical pipelines\nThe Nix programming language is a domain specific language used to package and build software, and “software” can have a very broad definition. As I explored in\nthis blog post\n, Nix (the programming language) can be used to define a polyglot pipeline to build, for example, a Quarto report using R and Python. I have now built a package called\n{rixpress}\nwhich is heavily inspired by\n{targets}\n(if you are not familiar with\n{targets}\n, I introduce it at the end of this blog post) to generate such pipelines and build them using Nix. Below is a complete example which starts by using Python and the Polars library to load a dataset, then transforms it a bit, and converts the data to a Pandas dataframe then passes it to R (conversion is done via\nreticulate::py_load_object()\nunder the hood, also why I had to convert the Polars dataframe to a Pandas dataframe) and finally compiles a Quarto document (you can find the code\nhere\n):\nlibrary(rixpress)\n\nd0 <- rxp_py_file(\n  name = mtcars_pl,\n  path = 'data/mtcars.csv',\n  read_function = \"lambda x: polars.read_csv(x, separator='|')\",\n  nix_env = \"py-env.nix\"\n)\n\nd1 <- rxp_py(\n  # reticulate doesn't support polars DFs yet, so need to convert\n  # first to pandas DF\n  name = mtcars_pl_am,\n  py_expr = \"mtcars_pl.filter(polars.col('am') == 1).to_pandas()\",\n  nix_env = \"py-env.nix\"\n)\n\nd2 <- rxp_py2r(\n  name = mtcars_am,\n  expr = mtcars_pl_am\n)\n\nd3 <- rxp_r(\n  name = mtcars_head,\n  expr = my_head(mtcars_am),\n  additional_files = \"functions.R\"\n)\n\nd4 <- rxp_r(\n  name = mtcars_tail,\n  expr = tail(mtcars_head)\n)\n\nd5 <- rxp_r(\n  name = mtcars_mpg,\n  expr = dplyr::select(mtcars_tail, mpg)\n)\n\ndoc <- rxp_quarto(\n  name = page,\n  qmd_file = \"page.qmd\",\n  additional_files = c(\"content.qmd\", \"images\"),\n  nix_env = \"quarto-env.nix\"\n)\n\nrxp_list <- list(d0, d1, d2, d3, d4, d5, doc)\n\nrixpress(rxp_list, project_path = \".\")\n\nplot_dag()\nLet’s go through this code:\nd0 <- rxp_py_file(\n  name = mtcars_pl,\n  path = 'data/mtcars.csv',\n  read_function = \"lambda x: polars.read_csv(x, separator='|')\",\n  nix_env = \"py-env.nix\"\n)\nrxp_py_file()\nuses Python to load a local file. In this case, it’s the\nmtcars.csv\ndataset under the\ndata/\nfolder. The read function must be a function of only one parameter, the path to the data, so I use an anonymous function wrapping\npolars.read_csv\nwhich allows me to set the separator to the unix pipe\n|\n. Also, this code is executed inside the environment defined by the\npy-env.nix\nfile. This file can be generated by my other package,\n{rix}\nand lists the Python packages needed (you’ll find it in the repo).\nThen:\nd1 <- rxp_py(\n  # reticulate doesn't support polars DFs yet, so need to convert\n  # first to pandas DF\n  name = mtcars_pl_am,\n  py_expr = \"mtcars_pl.filter(polars.col('am') == 1).to_pandas()\",\n  nix_env = \"py-env.nix\"\n)\nrxp_py()\nexecutes Python code, and saves the output into the\nname\nargument. In this case, I filter the Polars dataframe and convert it to a Pandas dataframe. This again happens inside the environment defined by\npy-env.nix\n, it’s a pure Python env, no\n{reticulate}\nneeded at this stage.\nThen:\nd2 <- rxp_py2r(\n  name = mtcars_am,\n  expr = mtcars_pl_am\n)\nrxp_py2r()\ncalls\nreticulate::py_load_object()\nto convert the Pandas dataframe to an R dataframe. We can now continue using it using R! You’ll notice that no\nnix_env\nargument is passed to this function. When no argument is provided to\nnix_env\n, the default environment,\ndefault.nix\ngets used. This one must always be present and in this case contains the required R packages for the pipeline.\nThen:\nd3 <- rxp_r(\n  name = mtcars_head,\n  expr = my_head(mtcars_am),\n  additional_files = \"functions.R\"\n)\nThis one uses an argument we don’t know yet,\nadditional_files\n. It allows you to pass R scripts that define functions. In this case,\nfunctions.R\ncontains the definition of\nmy_head()\nwhich is used on\nmtcars_am\n.\nd4\nand\nd5\nare self-explanatory, so now let’s take a look at\nrxp_quarto()\n:\ndoc <- rxp_quarto(\n  name = page,\n  qmd_file = \"page.qmd\",\n  additional_files = c(\"content.qmd\", \"images\"),\n  nix_env = \"quarto-env.nix\"\n)\nThis compiles the\npage.qmd\ndocument, which requires additional files:\ncontent.qmd\nwhich gets included into\npage.qmd\nand the\nimages/\nfolder, that contains images required to compile the document. This file is compiled using the\nquarto-env.nix\nenvironment.\nPutting all these derivations into a list and passing it to\nrixpress()\ndoesn’t build the pipeline just yet, but generates a\npipeline.nix\nfile which is the Nix expression that will build the output, in this case our Quarto document. You can also take a look at the DAG using\nplot_dag()\n:\nand it’s also possible to retrieve objects in an interactive sessions using\nrxp_read()\n(to read them) or\nrxp_load()\n(to load them in the global environment). When reading or loading Python objects, this will get converted using\n{reticulate}\non the fly.\nTo build the pipeline, run\nrxp_make()\n. Subsequent runs don’t build everything, as intermediary outputs are cached in the\nNix store\n. So if you change only the Quarto document, only this one derivation gets built anew. It is also possible to export and import the outputs using\nexport_nix_archive()\nand\nimport_nix_archive()\n, pretty useful for CI!\nCaveats\nThis package is still in the prototype stage, so don’t use it for anything serious. There are still some things I need to work on, for now debugging a faulty pipeline is really hard because intermediary outputs are difficult to find if the pipeline wasn’t completely built.\nAlso, due to how Nix works, every computation happens in a completely isolated sandbox. This is why the\nrxp_*()\nfunctions have that\nadditional_files\nargument, because in case something external is required, Nix needs to copy it over into the sandbox. This means also that functions that require Internet access to work will fail. But I was able to work around that for\nrxp_file()\n: so if a resource is online, the function that reads it should be able to get to it.\nNow, let me introduce\n{targets}\n, my main source of inspiration for this package\nThe targets package, my source of inspiration for rixpress\nI’m a huge fan of the\n{targets}\npackage and think that it’s truly one of the best packages ever made. No other build/pipeline automation tool comes close in my opinion. Most of these tools require you to define your pipeline in another language (such as yaml) or force you to use some very specific syntax where you explicitely need to define the objects to compute, their inputs and outputs. But\n{targets}\nallows you to define your pipeline as a series of R calls:\n# _targets.R file\nlibrary(targets)\nlibrary(tarchetypes)\ntar_source()\ntar_option_set(packages = c(\"readr\", \"dplyr\", \"ggplot2\"))\nlist(\n  tar_target(file, \"data.csv\", format = \"file\"),\n  tar_target(data, get_data(file)),\n  tar_target(model, fit_model(data)),\n  tar_target(plot, plot_model(model, data))\n)\nThis may look foreign to many R users, but if you look closely, you’ll realise that most of this code is boilerplate:\n# _targets.R file\nlibrary(targets)\nlibrary(tarchetypes)\ntar_source()\ntar_option_set(packages = c(\"readr\", \"dplyr\", \"ggplot2\"))\nlist(\n  tar_target(....),\n  tar_target(....),\n  tar_target(....),\n  tar_target(....)\n)\nand what matters is defined inside the\ntar_target()\nfunctions. Remove the boilerplate, and you end up with essentially correct R code, after a few adjustments:\nfile <- \"data.csv\"\ndata <- get_data(file)\nmodel <- fit_model(data)\nplot <- plot_model(model, data)\nbut why go through the trouble of using\n{targets}\n? Well, the biggest reason is that\n{targets}\nfigures out the dependencies between the objects you want to compute, and caches them. So in the example above, if you only change the code of the\nfit_model()\nfunction, only\nmodel\nand\nplot\nare re-computed. But if you change\nfile\nand point the path to an updated\ndata.csv\nfile, then everything gets computed anew. Watch the\nintro video\nfrom the official walkthrough for a visual explanation: but trust me,\n{targets}\nis in this class of tools that make you wonder how you could possibly have gotten anything done before using it.\nConclusion\nI think that\n{rixpress}\ncan become quite an useful package, so I will likely submit it for rOpenSci peer review in due time.\nAnd thanks to\nGrant McDermott\nfor suggesting the name “rixpress”!\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nEconometrics and Free Software\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "As I’ve already discussed in this vignette of my {rix} package, it is very easy to run a {targets} pipeline inside of a Nix environment for increased reproduciblity. The main drawback of {targets} though, is that it is not possible to comp...",
    "meta_keywords": null,
    "og_description": "As I’ve already discussed in this vignette of my {rix} package, it is very easy to run a {targets} pipeline inside of a Nix environment for increased reproduciblity. The main drawback of {targets} though, is that it is not possible to comp...",
    "og_image": "https://b-rodrigues.github.io/assets/img/announcing_rixpress.png",
    "og_title": "Announcing rixpress | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 8,
    "sitemap_lastmod": null,
    "twitter_description": "As I’ve already discussed in this vignette of my {rix} package, it is very easy to run a {targets} pipeline inside of a Nix environment for increased reproduciblity. The main drawback of {targets} though, is that it is not possible to comp...",
    "twitter_title": "Announcing rixpress | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/03/announcing-rixpress/",
    "word_count": 1595
  }
}