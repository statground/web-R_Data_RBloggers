{
  "uuid": "2b63c064-8991-477b-a8b8-4e093d9f6443",
  "created_at": "2025-11-22 19:57:23",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/11/behavior-driven-development-in-r-shiny-setting-up-test-preconditions-with-given-steps/",
    "crawled_at": "2025-11-22T10:41:15.796151",
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/bdd-shiny-given",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://jakubsobolewski.com/blog/bdd-shiny-feature/",
        "text": "Behavior-Driven Development in R Shiny: A Step-By-Step Example"
      },
      {
        "href": "https://jakubsobolewski.com/get-roadmap/",
        "text": "Level-up your testing game! Grab your copy of the R testing roadmap."
      },
      {
        "href": "https://jakubsobolewski.com/cucumber/",
        "text": "cucumber"
      },
      {
        "href": "https://rstudio.github.io/shinytest2/reference/AppDriver.html#method-new-",
        "text": "shinytest2::AppDriver"
      },
      {
        "href": "https://jakubsobolewski.com/blog/bdd-shiny-given",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Behavior-Driven Development in R Shiny: Setting Up Test Preconditions with Given Steps | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
        "text": "[email protected]"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-396526 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Behavior-Driven Development in R Shiny: Setting Up Test Preconditions with Given Steps</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 2, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/bdd-shiny-given\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>As the system grows, there are more moving parts to manage.</p>\n<p>External services, databases, and feature flags all introduce complexity. To keep specifications reliable and maintainable, we need a structured way to set up the system state before interactions happen, so that we know precisely what we’re testing.</p>\n<p>This is what the Given keywords are for.</p>\n<hr/>\n<p>This article is continuation of the previous article on building a Shiny app using Behavior-Driven Development (BDD). There we built a data submission form using Behavior-Driven Development. We wrote specifications that described user behaviors and implemented just enough code to make them pass.</p>\n<p>Read it to get up to speed on BDD for Shiny apps, or continue here to focus on how to setup complex preconditions using Given steps.</p>\n<p><strong><a href=\"https://jakubsobolewski.com/blog/bdd-shiny-feature/\" rel=\"nofollow\" target=\"_blank\">Behavior-Driven Development in R Shiny: A Step-By-Step Example</a></strong></p>\n<hr/>\n<blockquote>\n<p><a href=\"https://jakubsobolewski.com/get-roadmap/\" rel=\"nofollow\" target=\"_blank\">Level-up your testing game! Grab your copy of the R testing roadmap.</a></p>\n</blockquote>\n<h2 id=\"the-purpose-of-given\">The Purpose of Given</h2>\n<p>Given steps answer one question: <strong>What is the state of the system before I interact with it?</strong></p>\n<p>They set up preconditions like:</p>\n<ul>\n<li>Test data in storage</li>\n<li>External service configurations</li>\n<li>Feature flags or application settings</li>\n</ul>\n<p>Let’s build on our previous example.</p>\n<p>Let’s imagine we need to send an email notification when a new entry is submitted. This introduces an external dependency: an email service.</p>\n<p>Before we can test that behavior, we need to:</p>\n<ul>\n<li>Set up storage (where will the data go?)</li>\n<li>Configure the email service (which provider? what credentials?)</li>\n<li>Define who the current user is (who’s submitting the form?)</li>\n</ul>\n<p>We can control these preconditions using Given steps.</p>\n<h2 id=\"building-on-the-data-submission-form\">Building on the Data Submission Form</h2>\n<p>Let’s extend the form from the previous article.</p>\n<p>Now, when someone submits an entry, the app sends an email notification to a designated recipient. This adds a new external dependency: an email service.</p>\n<p>Here’s a specification that describes this behavior:</p>\n<pre>#' tests/testthat/test-acceptance-email_notification.R\ndescribe(\"email notification\", {\n  it(\"should send email when entry is submitted\", {\n    given_no_content() |&gt;\n      given_an_authenticated_user() |&gt;\n      given_email_service_is_available() |&gt;\n      when_i_submit_entry_with_all_required_fields() |&gt;\n      then_email_notification_is_sent()\n  })\n\n  it(\"should handle email service failure gracefully\", {\n    given_no_content() |&gt;\n      given_an_authenticated_user() |&gt;\n      given_email_service_is_unavailable() |&gt;\n      when_i_submit_entry_with_all_required_fields() |&gt;\n      then_i_am_informed_email_was_not_sent()\n  })\n})</pre>\n<blockquote>\n<p>If you prefer plain-text specifications, you can express them using Cucumber-style feature files and use <a href=\"https://jakubsobolewski.com/cucumber/\" rel=\"nofollow\" target=\"_blank\">cucumber</a> package to run them.</p>\n</blockquote>\n<p>Notice we have <strong>three Given steps</strong> in the first specification. Each sets up a different part of the system:</p>\n<ul>\n<li><code>given_no_content()</code> sets up storage</li>\n<li><code>given_an_authenticated_user()</code> sets up the current user with their email</li>\n<li><code>given_email_service_is_available()</code> sets up the email service</li>\n</ul>\n<p>This separation is intentional.</p>\n<p>It lets us compose different preconditions for different scenarios. In the second specification, we swap <code>given_email_service_is_available()</code> for <code>given_email_service_is_unavailable()</code> to test failure handling. We might also test what happens for unauthenticated users, if this is an intended behavior that needs to be implemented.</p>\n<h2 id=\"implementing-given-steps\">Implementing Given Steps</h2>\n<p>You might wonder: we can set up something separate to the app, but how do we pass this configuration to the Shiny app when it launches?</p>\n<p>We make Given steps collect configuration that will be passed to the Shiny app. We can store this configuration in a context that will be available when the app starts.</p>\n<p>Here’s how we can implement the storage precondition:</p>\n<pre>#' tests/testthat/setup-dsl.R\ngiven_no_content &lt;- function(context = new.env()) {\n  context$storage &lt;- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context\n}</pre>\n<p>This creates an in-memory disk-based storage and the storage object is stored in <code>context$storage</code>.</p>\n<p>Now for the authenticated user precondition:</p>\n<pre>given_an_authenticated_user &lt;- function(\n  context = new.env(),\n  email = \"<a class=\"__cf_email__\" data-cfemail=\"5e2b2d3b2c1e3b263f332e323b703d3133\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\"\n) {\n  context$user &lt;- email\n  context\n}</pre>\n<p>This sets up a user with their email address that will be used for sending notifications. It’s just an email as it suffices for our purposes. It could be a more complex object if needed. If needed, this step could also create a user in a service that we use for authentication, or we could create the authentication service test double here, with this user pre-configured.</p>\n<p>And here are the email service preconditions:</p>\n<pre>given_email_service_is_available &lt;- function(context = new.env()) {\n  context$email_service &lt;- structure(\n    list(\n      send_email = function(from, to, content) {\n        list(success = TRUE, error = NULL)\n      }\n    ),\n    class = \"EmailService\"\n  )\n  context\n}\n\ngiven_email_service_is_unavailable &lt;- function(context = new.env()) {\n  context$email_service &lt;- structure(\n    list(\n      send_email = function(from, to, content) {\n        list(success = FALSE, error = \"Server error\")\n      }\n    ),\n    class = \"EmailService\"\n  )\n  context\n}</pre>\n<ul>\n<li><code>given_email_service_is_available()</code> creates an interface that mimics a working email service.</li>\n<li><code>given_email_service_is_unavailable()</code> creates an interface that simulates a failure when sending emails.</li>\n</ul>\n<p>Notice we’re not launching the Shiny app yet. We’re just collecting configuration.</p>\n<h2 id=\"passing-options-to-shinytest2\">Passing Options to shinytest2</h2>\n<p>The context object accumulates configuration from each Given step. When we’re ready to interact with the app (in a When step), we start the driver and pass this configuration.</p>\n<p>Here’s the helper function that starts the driver:</p>\n<pre>#' tests/testthat/setup-dsl.R\n.start_driver &lt;- function(context) {\n  if (is.null(context$driver)) {\n    context$driver &lt;- ShinyDriver$new(\n      app = \"path/to/app\",\n      options = list(\n        storage = context$storage,\n        email_service = context$email_service,\n        user = context$user\n      )\n    )\n  }\n  context\n}</pre>\n<p>This function is called by When steps right before they interact with the app:</p>\n<pre>when_i_submit_entry_with_all_required_fields &lt;- function(context) {\n  .start_driver(context)  # App launches here\n  context$driver$fill_required_fields(\n    url = \"https://example.com/\",\n    title = \"Example\"\n  )\n  context\n}</pre>\n<p><strong>The app launches lazily, only when we need to interact with it.</strong></p>\n<p>This is crucial. If we launched the app in Given steps, we’d need a much smarter mechanism for launching the app. By delaying the launch until the first When step, we can compose multiple Given steps and start the app once with all configuration in place.</p>\n<p>The app launches with the collected options, if something was not defined explicitly, default values defined in the app code are used.</p>\n<h2 id=\"understanding-the-options-parameter\">Understanding the <code>options</code> Parameter</h2>\n<p>When we call <code>ShinyDriver$new(options = list(...))</code> (which inherits from <a href=\"https://rstudio.github.io/shinytest2/reference/AppDriver.html#method-new-\" rel=\"nofollow\" target=\"_blank\"><code>shinytest2::AppDriver</code></a>) we’re passing objects to another R process where the Shiny app runs. This is key to understanding what we can and cannot pass.</p>\n<p>But when we’re extending <code>AppDriver</code>, we can make all available all options more explicit, by making them arguments of the constructor:</p>\n<pre>#' tests/testthat/setup-driver.R\nMyAppDriver &lt;- R6::R6Class(\n  classname = \"MyAppDriver\",\n  inherit = ShinyDriver,\n  public = list(\n    initialize = function(\n      app,\n      storage = make_storage(),\n      email_service = make_email_service(),\n      user = NULL,\n      ...\n    ) {\n      super$initialize(\n        app = app,\n        options = list(\n          storage = storage,\n          email_service = email_service,\n          user = user\n        ),\n        ...\n      )\n    }\n  )\n)</pre>\n<p>It’ll make it clearer what options are expected by the app and what should be set up in specifications.</p>\n<p>The <code>options</code> list becomes available in the app through <code>getOption()</code>:</p>\n<pre>#' app.R\napp_server &lt;- function(input, output, session) {\n  storage &lt;- getOption(\"storage\", make_storage())\n  email_service &lt;- getOption(\"email_service\", make_email_service())\n  user &lt;- getOption(\"user\", session$user)\n  # ... rest of server code\n}</pre>\n<p>This pattern provides defaults (<code>make_storage()</code> and <code>make_email_service()</code>) while allowing tests to inject specific implementations through options. The user’s email is used as the sender when notifications are sent.</p>\n<h3 id=\"limitations-of-passing-objects-between-processes\">Limitations of Passing Objects Between Processes</h3>\n<p>Not all objects can be transferred between R processes. When <code>shinytest2</code> starts your app, it serializes the <code>options</code> list, sends it to the new process, and deserializes it there.</p>\n<p>This means objects like database connections (<code>DBI</code>, <code>dbplyr</code>) cannot be passed directly. Instead, pass configuration parameters and create the connections inside the app process.</p>\n<h2 id=\"implementing-the-email-service\">Implementing the Email Service</h2>\n<p>Let’s look at the email service implementation that makes this testing possible:</p>\n<pre>#' R/email_service.R\nEmailService &lt;- R6::R6Class(\n  classname = \"EmailService\",\n  public = list(\n    send_email = function(from, to, content) {\n      rlang::abort(\"Not implemented\")\n    }\n  )\n)\n\nEmailServiceBlastula &lt;- R6::R6Class(\n  classname = \"EmailServiceBlastula\",\n  inherit = EmailService,\n  public = list(\n    send_email = function(from, to, content) {\n      tryCatch(\n        {\n          blastula::smtp_send(\n            email = content,\n            to = to,\n            from = from,\n            subject = \"New Entry Submitted\",\n            credentials = blastula::creds_envvar(\n              user = Sys.getenv(\"SMTP_USER\"),\n              pass_envvar = \"SMTP_PASSWORD\",\n              host = Sys.getenv(\"SMTP_HOST\", \"smtp.gmail.com\"),\n              port = as.integer(Sys.getenv(\"SMTP_PORT\")),\n              use_ssl = as.logical(Sys.getenv(\"SMTP_USE_SSL\"))\n            )\n          )\n          list(success = TRUE, error = NULL)\n        },\n        error = function(e) {\n          list(success = FALSE, error = conditionMessage(e))\n        }\n      )\n    }\n  )\n)\n\nmake_email_service &lt;- function(type = \"blastula\") {\n  switch(\n    type,\n    blastula = EmailServiceBlastula$new(),\n    rlang::abort(sprintf(\"Unknown email service type: %s\", type))\n  )\n}</pre>\n<p>The base <code>EmailService</code> class defines the interface. It is the same interface we used in tests. <code>EmailServiceBlastula</code> is the production implementation using the <code>blastula</code> package.</p>\n<p>In tests, we can use a fake implementation that behaves exactly as needed for tests. In production, the app uses <code>EmailServiceBlastula</code> by default.</p>\n<h2 id=\"setting-up-test-data\">Setting Up Test Data</h2>\n<p>Sometimes you need more than an empty state. You might test how the app behaves when data already exists:</p>\n<pre>given_existing_entries &lt;- function(context = new.env()) {\n  context$storage &lt;- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context$storage$add(\n    make_storage_item(\n      url = \"https://google.com\",\n      title = \"Google\",\n      description = \"Search engine\"\n    )\n  )\n  context$storage$add(\n    make_storage_item(\n      url = \"https://github.com\",\n      title = \"GitHub\",\n      description = \"Code hosting\"\n    )\n  )\n  context\n}</pre>\n<p>Then test how the app lists existing entries:</p>\n<pre>it(\"should display existing entries\", {\n  given_existing_entries() |&gt;\n    given_an_authenticated_user() |&gt;\n    given_email_service_is_available() |&gt;\n    then_there_are_entries_displayed(n = 2)\n})</pre>\n<h2 id=\"the-pattern-in-practice\">The Pattern in Practice</h2>\n<p>Let’s see the full flow of a specification:</p>\n<ol>\n<li><strong>Given steps</strong> collect configuration in a context object</li>\n<li><strong>First When step</strong> calls <code>.start_driver()</code> which launches the app with collected configuration</li>\n<li><strong>Subsequent When steps</strong> interact with the running app</li>\n<li><strong>Then steps</strong> make assertions about the app’s state or behavior</li>\n</ol>\n<pre>it(\"should save entry and send notification\", {\n  # Step 1: Set up preconditions\n  given_no_content() |&gt;\n    given_an_authenticated_user() |&gt;\n    given_email_service_is_available() |&gt;\n\n    # Step 2: First When launches app with configuration\n    when_i_submit_entry_with_all_required_fields() |&gt;\n    # Inside: .start_driver(context) creates driver with options\n    # Then: interacts with app\n\n    # Step 3: Make assertions\n    then_there_are_entries(n = 1) |&gt;\n    then_email_notification_is_sent()\n})</pre>\n<p>The beauty of this pattern is that Given steps can be developed, and reused independently. They’re pure setup code with no side effects beyond setting context properties.</p>\n<h2 id=\"why-this-approach-works\">Why This Approach Works</h2>\n<p>This pattern for Given steps provides several benefits:</p>\n<ul>\n<li><strong>Reliability</strong>: Tests don’t depend on external services. Email doesn’t need to actually send. Databases can be in-memory or local. When we write code test-first, we don’t focus on connecting to real services right away, it’s actually easier to create test doubles first, making tests way more reliable.</li>\n<li><strong>Speed</strong>: Fake services respond instantly. No network latency, no waiting for external servers. We can write tests focused on testing their availability elsewhere. Or if you want to test timeouts, just program them into the test double. But save this for unit tests, acceptance tests should focus on user-visible behaviors, so avoid testing implementation details like timeouts unless they directly impact user experience (like changing the user flow – e.g. being redirected to an error page, or being prompted to submit an error report).</li>\n<li><strong>Isolation</strong>: Each test starts with a clean state. You can see what preconditions are set up. Make sure resources are cleaned up after tests (e.g., temporary files deleted).</li>\n<li><strong>Readability</strong>: Each Given step clearly states what it sets up. Specifications read like documentation.</li>\n<li><strong>Composability</strong>: Mix and match Given steps to create different scenarios without duplicating setup code. Code reusability is built-in in this pattern.</li>\n</ul>\n<h2 id=\"when-given-steps-get-complex\">When Given Steps Get Complex</h2>\n<p>If a Given step becomes too complex, it’s a signal that the setup might be too complicated. Consider:</p>\n<h3 id=\"breaking-it-into-smaller-given-steps\">Breaking it into smaller Given steps</h3>\n<pre># Instead of:\ngiven_complex_state &lt;- function(context) {\n  # 50 lines of setup\n}\n\n# Do:\ngiven_storage_with_sample_data() |&gt;\n  given_email_service_configured() |&gt;\n  given_an_authenticated_user() |&gt;\n  given_feature_flags_set()</pre>\n<h3 id=\"creating-helper-functions\">Creating helper functions</h3>\n<pre>given_existing_entries &lt;- function(\n  context = new.env(),\n  entries = default_entries()\n) {\n  context$storage &lt;- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context$storage$clear()\n  for (entry in entries) {\n    context$storage$add(entry)\n  }\n  context\n}\n\ndefault_entries &lt;- function() {\n  list(\n    make_storage_item(url = \"https://google.com\", title = \"Google\"),\n    make_storage_item(url = \"https://github.com\", title = \"GitHub\")\n  )\n}</pre>\n<h3 id=\"extracting-fixtures\">Extracting fixtures</h3>\n<pre>#' tests/testthat/setup-fixtures-sample_entries.R\nsample_entries &lt;- list(\n  make_storage_item(url = \"https://google.com\", title = \"Google\"),\n  make_storage_item(url = \"https://github.com\", title = \"GitHub\"),\n  make_storage_item(url = \"https://stackoverflow.com\", title = \"Stack Overflow\")\n)</pre>\n<h2 id=\"wrapping-up\">Wrapping Up</h2>\n<p>The Given keyword is where you control your test environment. By carefully setting up preconditions through composable Given steps, you make tests reliable, fast, and maintainable.</p>\n<p><strong>Start small.</strong></p>\n<p><strong>Add Given steps as you discover new preconditions.</strong></p>\n<p><strong>Keep steps focused and composable.</strong></p>\n<p>With this approach, your BDD specifications for Shiny apps will remain robust and easy to maintain as your application grows in complexity.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/bdd-shiny-given\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Behavior-Driven Development in R Shiny: Setting Up Test Preconditions with Given Steps\nPosted on\nNovember 2, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAs the system grows, there are more moving parts to manage.\nExternal services, databases, and feature flags all introduce complexity. To keep specifications reliable and maintainable, we need a structured way to set up the system state before interactions happen, so that we know precisely what we’re testing.\nThis is what the Given keywords are for.\nThis article is continuation of the previous article on building a Shiny app using Behavior-Driven Development (BDD). There we built a data submission form using Behavior-Driven Development. We wrote specifications that described user behaviors and implemented just enough code to make them pass.\nRead it to get up to speed on BDD for Shiny apps, or continue here to focus on how to setup complex preconditions using Given steps.\nBehavior-Driven Development in R Shiny: A Step-By-Step Example\nLevel-up your testing game! Grab your copy of the R testing roadmap.\nThe Purpose of Given\nGiven steps answer one question:\nWhat is the state of the system before I interact with it?\nThey set up preconditions like:\nTest data in storage\nExternal service configurations\nFeature flags or application settings\nLet’s build on our previous example.\nLet’s imagine we need to send an email notification when a new entry is submitted. This introduces an external dependency: an email service.\nBefore we can test that behavior, we need to:\nSet up storage (where will the data go?)\nConfigure the email service (which provider? what credentials?)\nDefine who the current user is (who’s submitting the form?)\nWe can control these preconditions using Given steps.\nBuilding on the Data Submission Form\nLet’s extend the form from the previous article.\nNow, when someone submits an entry, the app sends an email notification to a designated recipient. This adds a new external dependency: an email service.\nHere’s a specification that describes this behavior:\n#' tests/testthat/test-acceptance-email_notification.R\ndescribe(\"email notification\", {\n  it(\"should send email when entry is submitted\", {\n    given_no_content() |>\n      given_an_authenticated_user() |>\n      given_email_service_is_available() |>\n      when_i_submit_entry_with_all_required_fields() |>\n      then_email_notification_is_sent()\n  })\n\n  it(\"should handle email service failure gracefully\", {\n    given_no_content() |>\n      given_an_authenticated_user() |>\n      given_email_service_is_unavailable() |>\n      when_i_submit_entry_with_all_required_fields() |>\n      then_i_am_informed_email_was_not_sent()\n  })\n})\nIf you prefer plain-text specifications, you can express them using Cucumber-style feature files and use\ncucumber\npackage to run them.\nNotice we have\nthree Given steps\nin the first specification. Each sets up a different part of the system:\ngiven_no_content()\nsets up storage\ngiven_an_authenticated_user()\nsets up the current user with their email\ngiven_email_service_is_available()\nsets up the email service\nThis separation is intentional.\nIt lets us compose different preconditions for different scenarios. In the second specification, we swap\ngiven_email_service_is_available()\nfor\ngiven_email_service_is_unavailable()\nto test failure handling. We might also test what happens for unauthenticated users, if this is an intended behavior that needs to be implemented.\nImplementing Given Steps\nYou might wonder: we can set up something separate to the app, but how do we pass this configuration to the Shiny app when it launches?\nWe make Given steps collect configuration that will be passed to the Shiny app. We can store this configuration in a context that will be available when the app starts.\nHere’s how we can implement the storage precondition:\n#' tests/testthat/setup-dsl.R\ngiven_no_content <- function(context = new.env()) {\n  context$storage <- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context\n}\nThis creates an in-memory disk-based storage and the storage object is stored in\ncontext$storage\n.\nNow for the authenticated user precondition:\ngiven_an_authenticated_user <- function(\n  context = new.env(),\n  email = \"\n[email protected]\n\"\n) {\n  context$user <- email\n  context\n}\nThis sets up a user with their email address that will be used for sending notifications. It’s just an email as it suffices for our purposes. It could be a more complex object if needed. If needed, this step could also create a user in a service that we use for authentication, or we could create the authentication service test double here, with this user pre-configured.\nAnd here are the email service preconditions:\ngiven_email_service_is_available <- function(context = new.env()) {\n  context$email_service <- structure(\n    list(\n      send_email = function(from, to, content) {\n        list(success = TRUE, error = NULL)\n      }\n    ),\n    class = \"EmailService\"\n  )\n  context\n}\n\ngiven_email_service_is_unavailable <- function(context = new.env()) {\n  context$email_service <- structure(\n    list(\n      send_email = function(from, to, content) {\n        list(success = FALSE, error = \"Server error\")\n      }\n    ),\n    class = \"EmailService\"\n  )\n  context\n}\ngiven_email_service_is_available()\ncreates an interface that mimics a working email service.\ngiven_email_service_is_unavailable()\ncreates an interface that simulates a failure when sending emails.\nNotice we’re not launching the Shiny app yet. We’re just collecting configuration.\nPassing Options to shinytest2\nThe context object accumulates configuration from each Given step. When we’re ready to interact with the app (in a When step), we start the driver and pass this configuration.\nHere’s the helper function that starts the driver:\n#' tests/testthat/setup-dsl.R\n.start_driver <- function(context) {\n  if (is.null(context$driver)) {\n    context$driver <- ShinyDriver$new(\n      app = \"path/to/app\",\n      options = list(\n        storage = context$storage,\n        email_service = context$email_service,\n        user = context$user\n      )\n    )\n  }\n  context\n}\nThis function is called by When steps right before they interact with the app:\nwhen_i_submit_entry_with_all_required_fields <- function(context) {\n  .start_driver(context)  # App launches here\n  context$driver$fill_required_fields(\n    url = \"https://example.com/\",\n    title = \"Example\"\n  )\n  context\n}\nThe app launches lazily, only when we need to interact with it.\nThis is crucial. If we launched the app in Given steps, we’d need a much smarter mechanism for launching the app. By delaying the launch until the first When step, we can compose multiple Given steps and start the app once with all configuration in place.\nThe app launches with the collected options, if something was not defined explicitly, default values defined in the app code are used.\nUnderstanding the\noptions\nParameter\nWhen we call\nShinyDriver$new(options = list(...))\n(which inherits from\nshinytest2::AppDriver\n) we’re passing objects to another R process where the Shiny app runs. This is key to understanding what we can and cannot pass.\nBut when we’re extending\nAppDriver\n, we can make all available all options more explicit, by making them arguments of the constructor:\n#' tests/testthat/setup-driver.R\nMyAppDriver <- R6::R6Class(\n  classname = \"MyAppDriver\",\n  inherit = ShinyDriver,\n  public = list(\n    initialize = function(\n      app,\n      storage = make_storage(),\n      email_service = make_email_service(),\n      user = NULL,\n      ...\n    ) {\n      super$initialize(\n        app = app,\n        options = list(\n          storage = storage,\n          email_service = email_service,\n          user = user\n        ),\n        ...\n      )\n    }\n  )\n)\nIt’ll make it clearer what options are expected by the app and what should be set up in specifications.\nThe\noptions\nlist becomes available in the app through\ngetOption()\n:\n#' app.R\napp_server <- function(input, output, session) {\n  storage <- getOption(\"storage\", make_storage())\n  email_service <- getOption(\"email_service\", make_email_service())\n  user <- getOption(\"user\", session$user)\n  # ... rest of server code\n}\nThis pattern provides defaults (\nmake_storage()\nand\nmake_email_service()\n) while allowing tests to inject specific implementations through options. The user’s email is used as the sender when notifications are sent.\nLimitations of Passing Objects Between Processes\nNot all objects can be transferred between R processes. When\nshinytest2\nstarts your app, it serializes the\noptions\nlist, sends it to the new process, and deserializes it there.\nThis means objects like database connections (\nDBI\n,\ndbplyr\n) cannot be passed directly. Instead, pass configuration parameters and create the connections inside the app process.\nImplementing the Email Service\nLet’s look at the email service implementation that makes this testing possible:\n#' R/email_service.R\nEmailService <- R6::R6Class(\n  classname = \"EmailService\",\n  public = list(\n    send_email = function(from, to, content) {\n      rlang::abort(\"Not implemented\")\n    }\n  )\n)\n\nEmailServiceBlastula <- R6::R6Class(\n  classname = \"EmailServiceBlastula\",\n  inherit = EmailService,\n  public = list(\n    send_email = function(from, to, content) {\n      tryCatch(\n        {\n          blastula::smtp_send(\n            email = content,\n            to = to,\n            from = from,\n            subject = \"New Entry Submitted\",\n            credentials = blastula::creds_envvar(\n              user = Sys.getenv(\"SMTP_USER\"),\n              pass_envvar = \"SMTP_PASSWORD\",\n              host = Sys.getenv(\"SMTP_HOST\", \"smtp.gmail.com\"),\n              port = as.integer(Sys.getenv(\"SMTP_PORT\")),\n              use_ssl = as.logical(Sys.getenv(\"SMTP_USE_SSL\"))\n            )\n          )\n          list(success = TRUE, error = NULL)\n        },\n        error = function(e) {\n          list(success = FALSE, error = conditionMessage(e))\n        }\n      )\n    }\n  )\n)\n\nmake_email_service <- function(type = \"blastula\") {\n  switch(\n    type,\n    blastula = EmailServiceBlastula$new(),\n    rlang::abort(sprintf(\"Unknown email service type: %s\", type))\n  )\n}\nThe base\nEmailService\nclass defines the interface. It is the same interface we used in tests.\nEmailServiceBlastula\nis the production implementation using the\nblastula\npackage.\nIn tests, we can use a fake implementation that behaves exactly as needed for tests. In production, the app uses\nEmailServiceBlastula\nby default.\nSetting Up Test Data\nSometimes you need more than an empty state. You might test how the app behaves when data already exists:\ngiven_existing_entries <- function(context = new.env()) {\n  context$storage <- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context$storage$add(\n    make_storage_item(\n      url = \"https://google.com\",\n      title = \"Google\",\n      description = \"Search engine\"\n    )\n  )\n  context$storage$add(\n    make_storage_item(\n      url = \"https://github.com\",\n      title = \"GitHub\",\n      description = \"Code hosting\"\n    )\n  )\n  context\n}\nThen test how the app lists existing entries:\nit(\"should display existing entries\", {\n  given_existing_entries() |>\n    given_an_authenticated_user() |>\n    given_email_service_is_available() |>\n    then_there_are_entries_displayed(n = 2)\n})\nThe Pattern in Practice\nLet’s see the full flow of a specification:\nGiven steps\ncollect configuration in a context object\nFirst When step\ncalls\n.start_driver()\nwhich launches the app with collected configuration\nSubsequent When steps\ninteract with the running app\nThen steps\nmake assertions about the app’s state or behavior\nit(\"should save entry and send notification\", {\n  # Step 1: Set up preconditions\n  given_no_content() |>\n    given_an_authenticated_user() |>\n    given_email_service_is_available() |>\n\n    # Step 2: First When launches app with configuration\n    when_i_submit_entry_with_all_required_fields() |>\n    # Inside: .start_driver(context) creates driver with options\n    # Then: interacts with app\n\n    # Step 3: Make assertions\n    then_there_are_entries(n = 1) |>\n    then_email_notification_is_sent()\n})\nThe beauty of this pattern is that Given steps can be developed, and reused independently. They’re pure setup code with no side effects beyond setting context properties.\nWhy This Approach Works\nThis pattern for Given steps provides several benefits:\nReliability\n: Tests don’t depend on external services. Email doesn’t need to actually send. Databases can be in-memory or local. When we write code test-first, we don’t focus on connecting to real services right away, it’s actually easier to create test doubles first, making tests way more reliable.\nSpeed\n: Fake services respond instantly. No network latency, no waiting for external servers. We can write tests focused on testing their availability elsewhere. Or if you want to test timeouts, just program them into the test double. But save this for unit tests, acceptance tests should focus on user-visible behaviors, so avoid testing implementation details like timeouts unless they directly impact user experience (like changing the user flow – e.g. being redirected to an error page, or being prompted to submit an error report).\nIsolation\n: Each test starts with a clean state. You can see what preconditions are set up. Make sure resources are cleaned up after tests (e.g., temporary files deleted).\nReadability\n: Each Given step clearly states what it sets up. Specifications read like documentation.\nComposability\n: Mix and match Given steps to create different scenarios without duplicating setup code. Code reusability is built-in in this pattern.\nWhen Given Steps Get Complex\nIf a Given step becomes too complex, it’s a signal that the setup might be too complicated. Consider:\nBreaking it into smaller Given steps\n# Instead of:\ngiven_complex_state <- function(context) {\n  # 50 lines of setup\n}\n\n# Do:\ngiven_storage_with_sample_data() |>\n  given_email_service_configured() |>\n  given_an_authenticated_user() |>\n  given_feature_flags_set()\nCreating helper functions\ngiven_existing_entries <- function(\n  context = new.env(),\n  entries = default_entries()\n) {\n  context$storage <- make_storage(\n    type = \"disk\",\n    store = cachem::cache_disk(tempdir())\n  )\n  context$storage$clear()\n  for (entry in entries) {\n    context$storage$add(entry)\n  }\n  context\n}\n\ndefault_entries <- function() {\n  list(\n    make_storage_item(url = \"https://google.com\", title = \"Google\"),\n    make_storage_item(url = \"https://github.com\", title = \"GitHub\")\n  )\n}\nExtracting fixtures\n#' tests/testthat/setup-fixtures-sample_entries.R\nsample_entries <- list(\n  make_storage_item(url = \"https://google.com\", title = \"Google\"),\n  make_storage_item(url = \"https://github.com\", title = \"GitHub\"),\n  make_storage_item(url = \"https://stackoverflow.com\", title = \"Stack Overflow\")\n)\nWrapping Up\nThe Given keyword is where you control your test environment. By carefully setting up preconditions through composable Given steps, you make tests reliable, fast, and maintainable.\nStart small.\nAdd Given steps as you discover new preconditions.\nKeep steps focused and composable.\nWith this approach, your BDD specifications for Shiny apps will remain robust and easy to maintain as your application grows in complexity.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Learn how to set up test preconditions in Shiny BDD using Given steps. Master dependency injection, test doubles, and composable setup patterns for reliable R testing.",
    "meta_keywords": null,
    "og_description": "Learn how to set up test preconditions in Shiny BDD using Given steps. Master dependency injection, test doubles, and composable setup patterns for reliable R testing.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "Behavior-Driven Development in R Shiny: Setting Up Test Preconditions with Given Steps | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 10.4,
    "sitemap_lastmod": null,
    "twitter_description": "Learn how to set up test preconditions in Shiny BDD using Given steps. Master dependency injection, test doubles, and composable setup patterns for reliable R testing.",
    "twitter_title": "Behavior-Driven Development in R Shiny: Setting Up Test Preconditions with Given Steps | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/11/behavior-driven-development-in-r-shiny-setting-up-test-preconditions-with-given-steps/",
    "word_count": 2087
  }
}