{
  "id": "a3f5c57136512ee3938aeff8c85b734acf680e07",
  "url": "https://www.r-bloggers.com/2023/11/r-universe-now-builds-wasm-binaries-for-all-r-packages/",
  "created_at_utc": "2025-11-17T20:39:14Z",
  "data": null,
  "raw_original": {
    "uuid": "eba86962-b365-4f7b-b03e-4350a52d240d",
    "created_at": "2025-11-17 20:39:14",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/11/r-universe-now-builds-wasm-binaries-for-all-r-packages/",
      "crawled_at": "2025-11-17T09:55:47.605379",
      "external_links": [
        {
          "href": "https://ropensci.org/blog/2023/11/17/runiverse-wasm/",
          "text": "rOpenSci - open tools for open science"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://r-universe.dev/",
          "text": "R-universe"
        },
        {
          "href": "https://shinylive.io/r",
          "text": "shinylive"
        },
        {
          "href": "https://webr.r-wasm.org/latest/",
          "text": "WebR demo"
        },
        {
          "href": "https://ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png",
          "text": null
        },
        {
          "href": "https://docs.r-wasm.org/webr/latest/",
          "text": "WebR"
        },
        {
          "href": "https://webassembly.org/",
          "text": "WebAssembly"
        },
        {
          "href": "https://developers.cloudflare.com/workers/runtime-apis/webassembly/",
          "text": "run wasm binaries in the cdn workers"
        },
        {
          "href": "https://jeroen.r-universe.dev/V8",
          "text": "V8"
        },
        {
          "href": "https://github.com/r-wasm/webr/tree/main/patches/R-4.3.0",
          "text": "slightly modified"
        },
        {
          "href": "https://www.youtube.com/watch?v=Mpq9a6yMl_w",
          "text": "video presentation"
        },
        {
          "href": "https://georgestagg.github.io/shiny-without-a-server-2023/",
          "text": "these slides"
        },
        {
          "href": "https://emscripten.org/",
          "text": "emscripten"
        },
        {
          "href": "https://www.rust-lang.org/",
          "text": "rust"
        },
        {
          "href": "https://ropensci.org/blog/2023/11/17/runiverse-wasm/packagepage.png",
          "text": null
        },
        {
          "href": "https://github.com/r-wasm/webr/tree/main/libs/recipes",
          "text": "r-wasm recipes"
        },
        {
          "href": "https://repo.r-wasm.org/",
          "text": "shiny app to monitor WASM status for CRAN packages"
        },
        {
          "href": "https://ropensci.org/blog/2023/11/17/runiverse-wasm/",
          "text": "rOpenSci - open tools for open science"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "R-universe now builds WASM binaries for all R packages | R-bloggers",
      "images": [
        {
          "alt": "Screenshot of rOpenSci dashboard with WebAssembly icons highlighted",
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": "Screenshot of rOpenSci dashboard with WebAssembly icons highlighted",
          "base64": null,
          "src": "https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png?w=578&ssl=1"
        },
        {
          "alt": "Screenshot of dplyr package homepage on r-universe",
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": "Screenshot of dplyr package homepage on r-universe",
          "base64": null,
          "src": "https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/packagepage.png?w=578&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/ropensci-open-tools-for-open-science/",
          "text": "rOpenSci - open tools for open science"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-380101 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">R-universe now builds WASM binaries for all R packages</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 16, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/ropensci-open-tools-for-open-science/\">rOpenSci - open tools for open science</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://ropensci.org/blog/2023/11/17/runiverse-wasm/\"> rOpenSci - open tools for open science</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<h2>\nAbstract / TLDR\n</h2><p><a href=\"https://r-universe.dev/\" rel=\"nofollow\" target=\"_blank\">R-universe</a> now builds WASM binaries of all R packages for use in WebR applications (such as <a href=\"https://shinylive.io/r\" rel=\"nofollow\" target=\"_blank\">shinylive</a>). For example to test the dev version of dplyr, you can open the <a href=\"https://webr.r-wasm.org/latest/\" rel=\"nofollow\" target=\"_blank\">WebR demo</a> page and run:</p>\n<pre>install.packages('dplyr',\n repos = c('https://tidyverse.r-universe.dev', 'https://repo.r-wasm.org'))\n</pre><p>As explained below, not all R packages are supported yet; some packages need some fixes to work in WebAssembly, but coverage is rapidly growing. The r-universe dashboards shows which packages are available and link to the build logs to help you debug issues.</p>\n<div class=\"box\">\n<figure>\n<div class=\"img\">\n<img alt=\"Screenshot of rOpenSci dashboard with WebAssembly icons highlighted\" data-lazy-src=\"https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Screenshot of rOpenSci dashboard with WebAssembly icons highlighted\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png?w=578&amp;ssl=1\"/></noscript>\n</div>\n<a href=\"https://ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png\" rel=\"nofollow\" target=\"_blank\"></a>\n</figure>\n</div>\n<h2>\nWhat is WebAssembly\n</h2><p>One of the most exciting recent developments in the R ecosystem is the <a href=\"https://docs.r-wasm.org/webr/latest/\" rel=\"nofollow\" target=\"_blank\">WebR</a> project by George Stagg from Posit, to port R to WebAssembly (for short: WASM).</p>\n<p>Without going into much technical detail, <a href=\"https://webassembly.org/\" rel=\"nofollow\" target=\"_blank\">WebAssembly</a> is a new portable binary-code format that makes it possible to safely run compiled code (from e.g. C/C++/Fortran/Rust) within a website. All major browsers support WASM, and the format is now also getting adopted in other environments. For example cloudflare lets you <a href=\"https://developers.cloudflare.com/workers/runtime-apis/webassembly/\" rel=\"nofollow\" target=\"_blank\">run wasm binaries in the cdn workers</a>, and the R package <a href=\"https://jeroen.r-universe.dev/V8\" rel=\"nofollow\" target=\"_blank\">V8</a> provides a very basic experimental WASM engine in R.</p>\n<p>WebAssembly is becoming a ubiquitous binary execution format, that enables us to ship executable code that can run on any platform. Sounds familiar? Indeed, however there are two major differences with Java. Unlike Java, no special language is needed; we just compile existing C/C++/Rust code into WebAssembly. And second, WebAssembly is an open standard designed to be natively supported in browsers, whereas Java required installation of a terrible plugin to run “web applets”. So this time it actually works well.</p>\n<h2>\nPorting R to WebAssembly\n</h2><p>WebR is a port of a (<a href=\"https://github.com/r-wasm/webr/tree/main/patches/R-4.3.0\" rel=\"nofollow\" target=\"_blank\">slightly modified</a>) version of R to WebAssembly. Before continuing, we should appreciate the mountains of work that were invested in this, mainly by George Stagg.</p>\n<p>The R codebase consists of a lot of C and Fortran code. I said above that we can just compile C/Fortran into WASM, but this is only partially true: because WASM has to run safely within any website, it is a fairly restricted platform. A lot of common operations available on most systems are disabled in WASM. For example, we cannot open network sockets, invoke shell commands, or access the local filesystem. Hence porting software to WASM involves adapting the code to work with and around these limitations.</p>\n<p>In this <a href=\"https://www.youtube.com/watch?v=Mpq9a6yMl_w\" rel=\"nofollow\" target=\"_blank\">video presentation</a> George briefly discusses some of the pieces that are used to make R run inside WebAssembly, such as the virtual filesystem and off-screen canvas. Also have a look at <a href=\"https://georgestagg.github.io/shiny-without-a-server-2023/\" rel=\"nofollow\" target=\"_blank\">these slides</a> about shinylive, which is an experimental version of shiny based on WebR that runs entirely in WebAssembly without the need for any server.</p>\n<h2>\nBuilding all the R packages\n</h2><p>Now that we have a working version of R in WebAssembly, the next challenge is to build the 23000+ contributed R packages for WebAssembly.</p>\n<p>One thing that is perhaps not immediately obvious, is that it won’t be possible to install packages directly <em>from source</em> the way we typically do in R, because the toolchains needed to compile WASM themselves to not run under WASM. To make it possible to use R packages in WebR, they first have to be compiled on another platform using e.g. <a href=\"https://emscripten.org/\" rel=\"nofollow\" target=\"_blank\">emscripten</a> and/or <a href=\"https://www.rust-lang.org/\" rel=\"nofollow\" target=\"_blank\">rust</a> toolchains. The resulting <em>binary package</em> can be served in a package repository from where WebR can download and install it.</p>\n<p>As you can imagine, doing this manually is quite an exercise. But with some help from George we were able to create a docker container that has all the tooling to build R packages for WebAssembly, and plugged this into the r-universe build workflow. So now r-universe automated builds WebR compatible binary packages for each upstream commit in any of the packages we are tracking. This allows users and authors of these packages to see if the package builds with WebAssembly or test fixes.</p>\n<p>The packages can be installed simply using as described above <code>install.packages</code>. A direct link to the wasm binary package (if available) is also available on the package homepage.</p>\n<div class=\"box\">\n<figure>\n<div class=\"img\">\n<img alt=\"Screenshot of dplyr package homepage on r-universe\" data-lazy-src=\"https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/packagepage.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Screenshot of dplyr package homepage on r-universe\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/ropensci.org/blog/2023/11/17/runiverse-wasm/packagepage.png?w=578&amp;ssl=1\"/></noscript>\n</div>\n<a href=\"https://ropensci.org/blog/2023/11/17/runiverse-wasm/packagepage.png\" rel=\"nofollow\" target=\"_blank\"></a>\n</figure>\n</div>\n<h2>\nAvailability of System libraries\n</h2><p>The main reason why some popular R packages are not yet available for WebAssembly is because they depend on external system libraries, such as <code>libcurl</code> or <code>gdal</code>. On most platforms such libraries can be installed by a package manager like <code>apt</code> or <code>brew</code>, however no good package manager for WebAssembly currently exists, so we need to port and build these libraries manually, which again is a lot of work.</p>\n<p>The docker build image currently includes about 25 external C/C++ libraries which are built from the <a href=\"https://github.com/r-wasm/webr/tree/main/libs/recipes\" rel=\"nofollow\" target=\"_blank\">r-wasm recipes</a> scripts. This is a pretty arbitrary selection, mainly consisting of libraries used by the R spatial packages (gdal + dependencies) and some libraries related to graphics used to build base R itself.</p>\n<p>In order to expand the coverage of R packages available in WebR, we would need to expand this list. If your R package requires a system library that is currently unavailable, you could try sending a PR to the above recipes (but please make sure that you first test it by building the docker image locally). Hopefully at some point a proper emscripten package manager will appear that provides these libraries for us.</p>\n<h2>\nWebAssembly Coverage\n</h2><p>Currently R-universe is tracking 41086 packages of which 38677 have a WASM binary. However note that these are not all unique packages: for CRAN packages we both track the latest CRAN release, as well as upstream Git repo (aka devel version) if known.</p>\n<p>There is another important caviat: many R packages can themselves be compiled to WebAssembly, but they depend on one or more other R packages that currently are not available, and therefore cannot be used yet. This is actually a significant share: many of the packages mentioned above that require system libraries are actually important packages used by many others. So if that system library is not available, it makes all the dependents unavailable as well.</p>\n<p>The webR project maintains a <a href=\"https://repo.r-wasm.org/\" rel=\"nofollow\" target=\"_blank\">shiny app to monitor WASM status for CRAN packages</a> (the app is slow to load, be patient). So here we can see that currently 19356 out of 20040 CRAN packages can be built for WebAssembly, and 10483 are available in the sense that all their dependencies are available as well.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://ropensci.org/blog/2023/11/17/runiverse-wasm/\"> rOpenSci - open tools for open science</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "R-universe now builds WASM binaries for all R packages\nPosted on\nNovember 16, 2023\nby\nrOpenSci - open tools for open science\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nrOpenSci - open tools for open science\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAbstract / TLDR\nR-universe\nnow builds WASM binaries of all R packages for use in WebR applications (such as\nshinylive\n). For example to test the dev version of dplyr, you can open the\nWebR demo\npage and run:\ninstall.packages('dplyr',\n repos = c('https://tidyverse.r-universe.dev', 'https://repo.r-wasm.org'))\nAs explained below, not all R packages are supported yet; some packages need some fixes to work in WebAssembly, but coverage is rapidly growing. The r-universe dashboards shows which packages are available and link to the build logs to help you debug issues.\nWhat is WebAssembly\nOne of the most exciting recent developments in the R ecosystem is the\nWebR\nproject by George Stagg from Posit, to port R to WebAssembly (for short: WASM).\nWithout going into much technical detail,\nWebAssembly\nis a new portable binary-code format that makes it possible to safely run compiled code (from e.g. C/C++/Fortran/Rust) within a website. All major browsers support WASM, and the format is now also getting adopted in other environments. For example cloudflare lets you\nrun wasm binaries in the cdn workers\n, and the R package\nV8\nprovides a very basic experimental WASM engine in R.\nWebAssembly is becoming a ubiquitous binary execution format, that enables us to ship executable code that can run on any platform. Sounds familiar? Indeed, however there are two major differences with Java. Unlike Java, no special language is needed; we just compile existing C/C++/Rust code into WebAssembly. And second, WebAssembly is an open standard designed to be natively supported in browsers, whereas Java required installation of a terrible plugin to run “web applets”. So this time it actually works well.\nPorting R to WebAssembly\nWebR is a port of a (\nslightly modified\n) version of R to WebAssembly. Before continuing, we should appreciate the mountains of work that were invested in this, mainly by George Stagg.\nThe R codebase consists of a lot of C and Fortran code. I said above that we can just compile C/Fortran into WASM, but this is only partially true: because WASM has to run safely within any website, it is a fairly restricted platform. A lot of common operations available on most systems are disabled in WASM. For example, we cannot open network sockets, invoke shell commands, or access the local filesystem. Hence porting software to WASM involves adapting the code to work with and around these limitations.\nIn this\nvideo presentation\nGeorge briefly discusses some of the pieces that are used to make R run inside WebAssembly, such as the virtual filesystem and off-screen canvas. Also have a look at\nthese slides\nabout shinylive, which is an experimental version of shiny based on WebR that runs entirely in WebAssembly without the need for any server.\nBuilding all the R packages\nNow that we have a working version of R in WebAssembly, the next challenge is to build the 23000+ contributed R packages for WebAssembly.\nOne thing that is perhaps not immediately obvious, is that it won’t be possible to install packages directly\nfrom source\nthe way we typically do in R, because the toolchains needed to compile WASM themselves to not run under WASM. To make it possible to use R packages in WebR, they first have to be compiled on another platform using e.g.\nemscripten\nand/or\nrust\ntoolchains. The resulting\nbinary package\ncan be served in a package repository from where WebR can download and install it.\nAs you can imagine, doing this manually is quite an exercise. But with some help from George we were able to create a docker container that has all the tooling to build R packages for WebAssembly, and plugged this into the r-universe build workflow. So now r-universe automated builds WebR compatible binary packages for each upstream commit in any of the packages we are tracking. This allows users and authors of these packages to see if the package builds with WebAssembly or test fixes.\nThe packages can be installed simply using as described above\ninstall.packages\n. A direct link to the wasm binary package (if available) is also available on the package homepage.\nAvailability of System libraries\nThe main reason why some popular R packages are not yet available for WebAssembly is because they depend on external system libraries, such as\nlibcurl\nor\ngdal\n. On most platforms such libraries can be installed by a package manager like\napt\nor\nbrew\n, however no good package manager for WebAssembly currently exists, so we need to port and build these libraries manually, which again is a lot of work.\nThe docker build image currently includes about 25 external C/C++ libraries which are built from the\nr-wasm recipes\nscripts. This is a pretty arbitrary selection, mainly consisting of libraries used by the R spatial packages (gdal + dependencies) and some libraries related to graphics used to build base R itself.\nIn order to expand the coverage of R packages available in WebR, we would need to expand this list. If your R package requires a system library that is currently unavailable, you could try sending a PR to the above recipes (but please make sure that you first test it by building the docker image locally). Hopefully at some point a proper emscripten package manager will appear that provides these libraries for us.\nWebAssembly Coverage\nCurrently R-universe is tracking 41086 packages of which 38677 have a WASM binary. However note that these are not all unique packages: for CRAN packages we both track the latest CRAN release, as well as upstream Git repo (aka devel version) if known.\nThere is another important caviat: many R packages can themselves be compiled to WebAssembly, but they depend on one or more other R packages that currently are not available, and therefore cannot be used yet. This is actually a significant share: many of the packages mentioned above that require system libraries are actually important packages used by many others. So if that system library is not available, it makes all the dependents unavailable as well.\nThe webR project maintains a\nshiny app to monitor WASM status for CRAN packages\n(the app is slow to load, be patient). So here we can see that currently 19356 out of 20040 CRAN packages can be built for WebAssembly, and 10483 are available in the sense that all their dependencies are available as well.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nrOpenSci - open tools for open science\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "Abstract / TLDR R-universe now builds WASM binaries of all R packages for use in WebR applications (such as shinylive). For example to test the dev version of dplyr, you can open the WebR demo page and run: install.packages('dplyr', repos = c('https://tidyverse.r-universe.dev', 'https://repo.r-wasm.org')) As explained below, not all R packages are supported yet; some packages need some fixes to work in WebAssembly, but coverage is rapidly growing. The r-universe dashboards shows which packages are available and link to the build logs to help you debug issues. What is WebAssembly One of the most exciting recent developments in the R ecosystem is the WebR project by George Stagg from Posit, to port R to WebAssembly (for short: WASM). Without going into much technical detail, WebAssembly is a new portable binary-code format that makes it possible to safely run compiled code (from e.g. C/C++/Fortran/Rust) within a website. All major browsers support WASM, and the format is now also getting adopted in other environments. For example cloudflare lets you run wasm binaries in the cdn workers, and the R package V8 provides a very basic experimental WASM engine in R. WebAssembly is becoming a ubiquitous binary execution format, that enables us to ship executable code that can run on any platform. Sounds familiar? Indeed, however there are two major differences with Java. Unlike Java, no special language is needed; we just compile existing C/C++/Rust code into WebAssembly. And second, WebAssembly is an open standard designed to be natively supported in browsers, whereas Java required installation of a terrible plugin to run “web applets”. So this time it actually works well. Porting R to WebAssembly WebR is a port of a (slightly modified) version of R to WebAssembly. Before continuing, we should appreciate the mountains of work that were invested in this, mainly by George Stagg. The R codebase consists of a lot of C and Fortran code. I said above that we can just compile C/Fortran into WASM, but this is only partially true: because WASM has to run safely within any website, it is a fairly restricted platform. A lot of common operations available on most systems are disabled in WASM. For example, we cannot open network sockets, invoke shell commands, or access the local filesystem. Hence porting software to WASM involves adapting the code to work with and around these limitations. In this video presentation George briefly discusses some of the pieces that are used to make R run inside WebAssembly, such as the virtual filesystem and off-screen canvas. Also have a look at these slides about shinylive, which is an experimental version of shiny based on WebR that runs entirely in WebAssembly without the need for any server. Building all the R packages Now that we have a working version of R in WebAssembly, the next challenge is to build the 23000+ contributed R packages for WebAssembly. One thing that is perhaps not immediately obvious, is that it won’t be possible to install packages directly from source the way we typically do in R, because the toolchains needed to compile WASM themselves to not run under WASM. To make it possible to use R packages in WebR, they first have to be compiled on another platform using e.g. emscripten and/or rust toolchains. The resulting binary package can be served in a package repository from where WebR can download and install it. As you can imagine, doing this manually is quite an exercise. But with some help from George we were able to create a docker container that has all the tooling to build R packages for WebAssembly, and plugged this into the r-universe build workflow. So now r-universe automated builds WebR compatible binary packages for each upstream commit in any of the packages we are tracking. This allows users and authors of these packages to see if the package builds with WebAssembly or test fixes. The packages can be installed simply using as described above install.packages. A direct link to the wasm binary package (if available) is also available on the package homepage. Availability of System libraries The main reason why some popular R packages are not yet available for WebAssembly is because they depend on external system libraries, such as libcurl or gdal. On most platforms such libraries can be installed by a package manager like apt or brew, however no good package manager for WebAssembly currently exists, so we need to port and build these libraries manually, which again is a lot of work. The docker build image currently includes about 25 external C/C++ libraries which are built from the r-wasm recipes scripts. This is a pretty arbitrary selection, mainly consisting of libraries used by the R spatial packages (gdal + dependencies) and some libraries related to graphics used to build base R itself. In order to expand the coverage of R packages available in WebR, we would need to expand this list. If your R package requires a system library that is currently unavailable, you could try sending a PR to the above recipes (but please make sure that you first test it by building the docker image locally). Hopefully at some point a proper emscripten package manager will appear that provides these libraries for us. WebAssembly Coverage Currently R-universe is tracking 41086 packages of which 38677 have a WASM binary. However note that these are not all unique packages: for CRAN packages we both track the latest CRAN release, as well as upstream Git repo (aka devel version) if known. There is another important caviat: many R packages can themselves be compiled to WebAssembly, but they depend on one or more other R packages that currently are not available, and therefore cannot be used yet. This is actually a significant share: many of the packages mentioned above that require system libraries are actually important packages used by many others. So if that system library is not available, it makes all the dependents unavailable as well. The webR project maintains a shiny app to monitor WASM status for CRAN packages (the app is slow to load, be patient). So here we can see that currently 19356 out of 20040 CRAN packages can be built for WebAssembly, and 10483 are available in the sense that all their dependencies are available as well.",
      "meta_keywords": null,
      "og_description": "Abstract / TLDR R-universe now builds WASM binaries of all R packages for use in WebR applications (such as shinylive). For example to test the dev version of dplyr, you can open the WebR demo page and run: install.packages('dplyr', repos = c('https://tidyverse.r-universe.dev', 'https://repo.r-wasm.org')) As explained below, not all R packages are supported yet; some packages need some fixes to work in WebAssembly, but coverage is rapidly growing. The r-universe dashboards shows which packages are available and link to the build logs to help you debug issues. What is WebAssembly One of the most exciting recent developments in the R ecosystem is the WebR project by George Stagg from Posit, to port R to WebAssembly (for short: WASM). Without going into much technical detail, WebAssembly is a new portable binary-code format that makes it possible to safely run compiled code (from e.g. C/C++/Fortran/Rust) within a website. All major browsers support WASM, and the format is now also getting adopted in other environments. For example cloudflare lets you run wasm binaries in the cdn workers, and the R package V8 provides a very basic experimental WASM engine in R. WebAssembly is becoming a ubiquitous binary execution format, that enables us to ship executable code that can run on any platform. Sounds familiar? Indeed, however there are two major differences with Java. Unlike Java, no special language is needed; we just compile existing C/C++/Rust code into WebAssembly. And second, WebAssembly is an open standard designed to be natively supported in browsers, whereas Java required installation of a terrible plugin to run “web applets”. So this time it actually works well. Porting R to WebAssembly WebR is a port of a (slightly modified) version of R to WebAssembly. Before continuing, we should appreciate the mountains of work that were invested in this, mainly by George Stagg. The R codebase consists of a lot of C and Fortran code. I said above that we can just compile C/Fortran into WASM, but this is only partially true: because WASM has to run safely within any website, it is a fairly restricted platform. A lot of common operations available on most systems are disabled in WASM. For example, we cannot open network sockets, invoke shell commands, or access the local filesystem. Hence porting software to WASM involves adapting the code to work with and around these limitations. In this video presentation George briefly discusses some of the pieces that are used to make R run inside WebAssembly, such as the virtual filesystem and off-screen canvas. Also have a look at these slides about shinylive, which is an experimental version of shiny based on WebR that runs entirely in WebAssembly without the need for any server. Building all the R packages Now that we have a working version of R in WebAssembly, the next challenge is to build the 23000+ contributed R packages for WebAssembly. One thing that is perhaps not immediately obvious, is that it won’t be possible to install packages directly from source the way we typically do in R, because the toolchains needed to compile WASM themselves to not run under WASM. To make it possible to use R packages in WebR, they first have to be compiled on another platform using e.g. emscripten and/or rust toolchains. The resulting binary package can be served in a package repository from where WebR can download and install it. As you can imagine, doing this manually is quite an exercise. But with some help from George we were able to create a docker container that has all the tooling to build R packages for WebAssembly, and plugged this into the r-universe build workflow. So now r-universe automated builds WebR compatible binary packages for each upstream commit in any of the packages we are tracking. This allows users and authors of these packages to see if the package builds with WebAssembly or test fixes. The packages can be installed simply using as described above install.packages. A direct link to the wasm binary package (if available) is also available on the package homepage. Availability of System libraries The main reason why some popular R packages are not yet available for WebAssembly is because they depend on external system libraries, such as libcurl or gdal. On most platforms such libraries can be installed by a package manager like apt or brew, however no good package manager for WebAssembly currently exists, so we need to port and build these libraries manually, which again is a lot of work. The docker build image currently includes about 25 external C/C++ libraries which are built from the r-wasm recipes scripts. This is a pretty arbitrary selection, mainly consisting of libraries used by the R spatial packages (gdal + dependencies) and some libraries related to graphics used to build base R itself. In order to expand the coverage of R packages available in WebR, we would need to expand this list. If your R package requires a system library that is currently unavailable, you could try sending a PR to the above recipes (but please make sure that you first test it by building the docker image locally). Hopefully at some point a proper emscripten package manager will appear that provides these libraries for us. WebAssembly Coverage Currently R-universe is tracking 41086 packages of which 38677 have a WASM binary. However note that these are not all unique packages: for CRAN packages we both track the latest CRAN release, as well as upstream Git repo (aka devel version) if known. There is another important caviat: many R packages can themselves be compiled to WebAssembly, but they depend on one or more other R packages that currently are not available, and therefore cannot be used yet. This is actually a significant share: many of the packages mentioned above that require system libraries are actually important packages used by many others. So if that system library is not available, it makes all the dependents unavailable as well. The webR project maintains a shiny app to monitor WASM status for CRAN packages (the app is slow to load, be patient). So here we can see that currently 19356 out of 20040 CRAN packages can be built for WebAssembly, and 10483 are available in the sense that all their dependencies are available as well.",
      "og_image": "https://ropensci.org/blog/2023/11/17/runiverse-wasm/screenshot.png",
      "og_title": "R-universe now builds WASM binaries for all R packages | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 6.1,
      "sitemap_lastmod": "2023-11-17T00:00:00+00:00",
      "twitter_description": "Abstract / TLDR R-universe now builds WASM binaries of all R packages for use in WebR applications (such as shinylive). For example to test the dev version of dplyr, you can open the WebR demo page and run: install.packages('dplyr', repos = c('https://tidyverse.r-universe.dev', 'https://repo.r-wasm.org')) As explained below, not all R packages are supported yet; some packages need some fixes to work in WebAssembly, but coverage is rapidly growing. The r-universe dashboards shows which packages are available and link to the build logs to help you debug issues. What is WebAssembly One of the most exciting recent developments in the R ecosystem is the WebR project by George Stagg from Posit, to port R to WebAssembly (for short: WASM). Without going into much technical detail, WebAssembly is a new portable binary-code format that makes it possible to safely run compiled code (from e.g. C/C++/Fortran/Rust) within a website. All major browsers support WASM, and the format is now also getting adopted in other environments. For example cloudflare lets you run wasm binaries in the cdn workers, and the R package V8 provides a very basic experimental WASM engine in R. WebAssembly is becoming a ubiquitous binary execution format, that enables us to ship executable code that can run on any platform. Sounds familiar? Indeed, however there are two major differences with Java. Unlike Java, no special language is needed; we just compile existing C/C++/Rust code into WebAssembly. And second, WebAssembly is an open standard designed to be natively supported in browsers, whereas Java required installation of a terrible plugin to run “web applets”. So this time it actually works well. Porting R to WebAssembly WebR is a port of a (slightly modified) version of R to WebAssembly. Before continuing, we should appreciate the mountains of work that were invested in this, mainly by George Stagg. The R codebase consists of a lot of C and Fortran code. I said above that we can just compile C/Fortran into WASM, but this is only partially true: because WASM has to run safely within any website, it is a fairly restricted platform. A lot of common operations available on most systems are disabled in WASM. For example, we cannot open network sockets, invoke shell commands, or access the local filesystem. Hence porting software to WASM involves adapting the code to work with and around these limitations. In this video presentation George briefly discusses some of the pieces that are used to make R run inside WebAssembly, such as the virtual filesystem and off-screen canvas. Also have a look at these slides about shinylive, which is an experimental version of shiny based on WebR that runs entirely in WebAssembly without the need for any server. Building all the R packages Now that we have a working version of R in WebAssembly, the next challenge is to build the 23000+ contributed R packages for WebAssembly. One thing that is perhaps not immediately obvious, is that it won’t be possible to install packages directly from source the way we typically do in R, because the toolchains needed to compile WASM themselves to not run under WASM. To make it possible to use R packages in WebR, they first have to be compiled on another platform using e.g. emscripten and/or rust toolchains. The resulting binary package can be served in a package repository from where WebR can download and install it. As you can imagine, doing this manually is quite an exercise. But with some help from George we were able to create a docker container that has all the tooling to build R packages for WebAssembly, and plugged this into the r-universe build workflow. So now r-universe automated builds WebR compatible binary packages for each upstream commit in any of the packages we are tracking. This allows users and authors of these packages to see if the package builds with WebAssembly or test fixes. The packages can be installed simply using as described above install.packages. A direct link to the wasm binary package (if available) is also available on the package homepage. Availability of System libraries The main reason why some popular R packages are not yet available for WebAssembly is because they depend on external system libraries, such as libcurl or gdal. On most platforms such libraries can be installed by a package manager like apt or brew, however no good package manager for WebAssembly currently exists, so we need to port and build these libraries manually, which again is a lot of work. The docker build image currently includes about 25 external C/C++ libraries which are built from the r-wasm recipes scripts. This is a pretty arbitrary selection, mainly consisting of libraries used by the R spatial packages (gdal + dependencies) and some libraries related to graphics used to build base R itself. In order to expand the coverage of R packages available in WebR, we would need to expand this list. If your R package requires a system library that is currently unavailable, you could try sending a PR to the above recipes (but please make sure that you first test it by building the docker image locally). Hopefully at some point a proper emscripten package manager will appear that provides these libraries for us. WebAssembly Coverage Currently R-universe is tracking 41086 packages of which 38677 have a WASM binary. However note that these are not all unique packages: for CRAN packages we both track the latest CRAN release, as well as upstream Git repo (aka devel version) if known. There is another important caviat: many R packages can themselves be compiled to WebAssembly, but they depend on one or more other R packages that currently are not available, and therefore cannot be used yet. This is actually a significant share: many of the packages mentioned above that require system libraries are actually important packages used by many others. So if that system library is not available, it makes all the dependents unavailable as well. The webR project maintains a shiny app to monitor WASM status for CRAN packages (the app is slow to load, be patient). So here we can see that currently 19356 out of 20040 CRAN packages can be built for WebAssembly, and 10483 are available in the sense that all their dependencies are available as well.",
      "twitter_title": "R-universe now builds WASM binaries for all R packages | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/11/r-universe-now-builds-wasm-binaries-for-all-r-packages/",
      "word_count": 1228
    }
  }
}