{
  "uuid": "b3c2fe18-141a-49f2-b2c3-6f0e1172e879",
  "created_at": "2025-11-17 20:39:04",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/11/maximizing-efficiency-a-guide-to-benchmarking-memory-usage-in-shiny-apps/",
    "crawled_at": "2025-11-17T09:44:28.705410",
    "external_links": [
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/",
        "text": "Tag: r - Appsilon | Enterprise R Shiny Dashboards"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#memory-usage",
        "text": "How to Measure Memory Usage of Shiny"
      },
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#example",
        "text": "Example App"
      },
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#limitations",
        "text": "Limitations"
      },
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#conclusion",
        "text": "Conclusion"
      },
      {
        "href": "https://cran.r-project.org/web/packages/profmem/vignettes/profmem.html",
        "text": "Rprofmemunder the hood"
      },
      {
        "href": "https://cran.r-project.org/web/packages/profmem/profmem.pdf",
        "text": "docs"
      },
      {
        "href": "https://bench.r-lib.org/reference/bench_process_memory.html",
        "text": "bench_process_memoryfunction"
      },
      {
        "href": "https://github.com/shinra-dev/memuse",
        "text": "memuse"
      },
      {
        "href": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm",
        "text": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm"
      },
      {
        "href": "https://appsilon.com/shiny-benchmark-measuring-app-performance/",
        "text": "shiny.benchmark ‚Äì How to Measure Performance Improvements in R Shiny Apps"
      },
      {
        "href": "https://shiny.posit.co/r/articles/improve/scoping/",
        "text": "in the global scope"
      },
      {
        "href": "https://bench.r-lib.org/reference/bench_process_memory.html",
        "text": "bench::bench_process_memory"
      },
      {
        "href": "https://github.com/HenrikBengtsson/future/issues/155",
        "text": "futures are run in child processes of the main R process"
      },
      {
        "href": "https://appsilon.us16.list-manage.com/subscribe?u=c042d7c0dbf57c5c6f8b54598&id=870d5bfc05",
        "text": "subscribe to Shiny Weekly for regular updates and exclusive content"
      },
      {
        "href": "https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/",
        "text": "Tag: r - Appsilon | Enterprise R Shiny Dashboards"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Maximizing Efficiency: A Guide to Benchmarking Memory Usage in Shiny Apps | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/Benchmark.webp"
      },
      {
        "alt": "üìù",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "üìù",
        "base64": null,
        "src": "https://i0.wp.com/s.w.org/images/core/emoji/14.0.0/72x72/1f4dd.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-1.webp"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-2.webp"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-3.webp"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/ryszard-szymanski/",
        "text": "Ryszard Szyma≈Ñski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-380428 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Maximizing Efficiency: A Guide to Benchmarking Memory Usage in Shiny Apps</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 30, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/ryszard-szymanski/\">Ryszard Szyma≈Ñski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/\"> Tag: r - Appsilon | Enterprise R Shiny Dashboards</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><div><img alt=\"\" class=\"attachment-medium size-medium wp-post-image\" data-lazy-src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/Benchmark.webp\" decoding=\"async\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"margin-bottom: 15px;\" width=\"450\"/><noscript><img alt=\"\" class=\"attachment-medium size-medium wp-post-image\" decoding=\"async\" loading=\"lazy\" src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/Benchmark.webp\" style=\"margin-bottom: 15px;\" width=\"450\"/></noscript></div><p>R/Shiny allows you to <strong>prototype</strong> a working web application <strong>quickly</strong> and <strong>easily</strong>. However, with increasing amounts of data, your app may become slow and, in extreme cases, crash due to insufficient memory.</p>\n<p>When the worst-case scenario happens, we need to figure out a way to<strong> lower the memory usage of our app to avoid those crashes</strong>.</p>\n<p>A crucial part of optimization efforts is benchmarking <strong>how much memory our app is consuming</strong>. This allows us to check if the changes we made to the app are indeed moving us in the right direction.</p>\n<p>In this step-by-step guide, we will describe how to do that based on an example application.</p>\n<h3>Table of Contents</h3>\n<ul>\n<li><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#memory-usage\" rel=\"nofollow\" target=\"_blank\">How to Measure Memory Usage of Shiny</a></li>\n<li><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#example\" rel=\"nofollow\" target=\"_blank\">Example App</a></li>\n<li><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#limitations\" rel=\"nofollow\" target=\"_blank\">Limitations</a></li>\n<li><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/#conclusion\" rel=\"nofollow\" target=\"_blank\">Conclusion</a></li>\n</ul>\n<h2 id=\"memory-usage\">How to Measure Memory Usage of Shiny</h2>\n<p>You might already be familiar with the <code>{profmem}</code> package for profiling memory usage of R expressions. <code>{profmem}</code> uses <a href=\"https://cran.r-project.org/web/packages/profmem/vignettes/profmem.html\" rel=\"nofollow\" target=\"_blank\"><code>Rprofmem</code> under the hood</a> and in the <a href=\"https://cran.r-project.org/web/packages/profmem/profmem.pdf\" rel=\"nofollow\" target=\"_blank\">docs</a>, we can find that with <code>utils::Rprofmem()</code> it is not possible to quantify the total memory usage at a given time because it only logs allocations and does, therefore, not reflect deallocations done by the garbage collector.</p>\n<p>Additionally, <code>Rprofmem</code> does not track allocations made by non-R native libraries or packages that use native <code>calloc()</code> or <code>free()</code> for internal objects.</p>\n<p>In the context of Shiny, we are usually interested in how much memory the R process running our app is using. That information allows us to estimate what infrastructure we will need to provision in order to host our app and get an overall feel of how our app scales memory-wise (e.g. does memory usage increase drastically with more users?).</p>\n<p>To achieve that, we will use the {bench} package, which provides the <a href=\"https://bench.r-lib.org/reference/bench_process_memory.html\" rel=\"nofollow\" target=\"_blank\"><code>bench_process_memory</code> function</a>. That function uses operating system APIs to determine how much memory is used by the current R process, including all the memory from child processes and memory allocated outside R‚Äôs garbage collector heap.</p>\n<p><code>bench::bench_process_memory</code> informs us not only about the currently used amount of memory but also about the peak memory usage that occurred during the process lifecycle.</p>\n<p><strong><img alt=\"üìù\" class=\"wp-smiley\" data-lazy-src=\"https://i0.wp.com/s.w.org/images/core/emoji/14.0.0/72x72/1f4dd.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"height: 1em; max-height: 1em;\"/><noscript><img alt=\"üìù\" class=\"wp-smiley\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/s.w.org/images/core/emoji/14.0.0/72x72/1f4dd.png?w=578&amp;ssl=1\" style=\"height: 1em; max-height: 1em;\"/></noscript> Note:</strong> There are also other packages that can be used for measuring process memory usage, like <a href=\"https://github.com/shinra-dev/memuse\" rel=\"nofollow\" target=\"_blank\">memuse</a>. However, as of today, it does not support measuring peak memory usage on MacOS ‚Äì we submitted a Pull Request adding support for that. But later on, we learned that <code>{bench}</code> already supports that. Hence, we recommend using <code>{bench}</code>.</p>\n<p>Throughout our example, we will use the following helper function:</p>\n<pre>\r\nwait_for_app_to_start &lt;- function(url) { httr2::request(url) |&gt; \r\n    httr2::req_retry(\r\n      max_seconds = 5,\r\n      backoff = function(attempt) 2 ** attempt\r\n    )\r\n}\r\n\r\nmeasure_mem_usage &lt;- function() {\r\n  result_file &lt;- tempfile(fileext = \"RDS\")\r\n  port &lt;- httpuv::randomPort()\r\n  app_process &lt;- callr::r_bg(\r\n    function(result_file, port) {\r\n      on.exit({ \r\n        saveRDS(bench::bench_process_memory(), result_file) \r\n      }) \r\n      \r\n      shiny::runApp(port = port)\r\n    }, args = list(result_file = result_file, port = port))\r\n  \r\n  on.exit({ \r\n    if (app_process$is_alive()) {\r\n      app_process$kill() \r\n    }\r\n  })\r\n  \r\n  app_url &lt;- paste0(\"http://127.0.0.1:\", port)\r\n  \r\n  wait_for_app_to_start(app_url)\r\n  \r\n  utils::browseURL(app_url)\r\n  \r\n  cat (\"Press [enter] to finish the test...\")\r\n  line &lt;- readline()\r\n  \r\n  app_process$interrupt()\r\n  \r\n  app_process$wait()\r\n  \r\n  readRDS(result_file)\r\n}\r\n</pre>\n<p><strong>Let‚Äôs break down one by one what is happening in this function:</strong></p>\n<ol>\n<li>We start a shiny app in a separate R process ‚Äì this is important as we don‚Äôt want the work we did previously in our R session to impact the results (e.g. we might have analyzed a large dataset which could be the source of peak memory usage)</li>\n<li>We register a callback on function exit that will save the memory measurements in a temporary file</li>\n<li>After the background R process with our app is started, our function opens the app in our browser and waits for user input. This gives us time to simulate user interactions with our app.</li>\n<li>Once we are done clicking through our app, we can hit enter in our R console, and the background process will be interrupted. Once the background process terminates, we read memory measurements from the temporary file.</li>\n</ol>\n<p>Let‚Äôs see that in action:</p>\n<div class=\"wp-video\" style=\"width: 2872px;\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video autoplay=\"1\" class=\"wp-video-shortcode\" controls=\"controls\" id=\"video-22209-1\" loop=\"1\" preload=\"metadata\" width=\"450\"><source src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm?_=1\" type=\"video/webm\"/><a href=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm\" rel=\"nofollow\" target=\"_blank\">https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm</a></video></div>\n<blockquote><p>Discover more insights on boosting your app‚Äôs speed and efficiency in our detailed piece: <a href=\"https://appsilon.com/shiny-benchmark-measuring-app-performance/\" rel=\"nofollow\" target=\"_blank\">shiny.benchmark ‚Äì How to Measure Performance Improvements in R Shiny Apps</a>.</p></blockquote>\n<h2 id=\"example\">Example App</h2>\n<p>All right, now let‚Äôs use our memory benchmarking function on an actual app. Let‚Äôs assume we are working with credit card data; we will generate a fake dataset using <code>{charlatan}</code> and save it in an SQLite database:</p>\n<pre>\r\nlibrary(charlatan)\r\nlibrary(DBI)\r\nlibrary(dplyr)\r\n\r\nset.seed(123)\r\n\r\n# Generate Fake Data\r\nTABLE_ROW_COUNT &lt;- 1e7\r\n\r\nfake_providers &lt;- ch_credit_card_provider(100)\r\nfake_data &lt;- data.frame(\r\n  provider = sample(fake_providers, size = TABLE_ROW_COUNT, replace = TRUE)\r\n)\r\n\r\n# Save data to sqlite database\r\nconn &lt;- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\r\n\r\ndbWriteTable(\r\n  conn = conn,\r\n  name = \"credit_cards\",\r\n  value = fake_data,\r\n  overwrite = TRUE\r\n)\r\n</pre>\n<p><strong>Now, let‚Äôs create a Shiny App that will display the top 10 most popular card providers:</strong></p>\n<pre>\r\nlibrary(DBI)\r\nlibrary(dplyr)\r\nlibrary(reactable)\r\nlibrary(shiny)\r\n\r\nconn &lt;- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\r\n\r\nshiny::onStop(function() {\r\n  dbDisconnect(conn)\r\n})\r\n\r\nui &lt;- fluidPage(\r\n  titlePanel(\"Credit Cards App\"),\r\n  reactableOutput(\"top_credit_providers\")\r\n)\r\n\r\nserver &lt;- function(input, output, session) {\r\n  credit_cards &lt;- dbGetQuery(\r\n    conn = conn,\r\n    \"SELECT * FROM credit_cards\"\r\n  )\r\n\r\n  output$top_credit_providers &lt;- renderReactable({\r\n    top_providers &lt;- credit_cards |&gt; \r\n      group_by(provider) |&gt; \r\n      summarise(popularity = n()) |&gt; \r\n      arrange(desc(popularity)) |&gt;\r\n      head(10) |&gt; \r\n      collect()\r\n    \r\n    reactable(top_providers)\r\n  })\r\n  \r\n}\r\n\r\nshinyApp(ui, server)\r\n</pre>\n<p><strong>Let‚Äôs see how much memory the app is using using our helper function:</strong></p>\n<pre>\r\n&gt; measure_mem_usage()\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  481MB   481MB \r\n</pre>\n<p>Ok, now let‚Äôs see how that changes if we simulate multiple sessions within the app ‚Äì this can be done by opening multiple tabs with our app. Here are the results for 2, 3, 4 and 5 sessions:</p>\n<pre>\r\n&gt; measure_mem_usage() # 2 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  606MB   606MB \r\n\r\n\r\n&gt; measure_mem_usage() # 3 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  678MB   678MB \r\n\r\n\r\n&gt; measure_mem_usage() # 4 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  769MB   769MB \r\n\r\n\r\n&gt; measure_mem_usage() # 5 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  844MB   844MB\r\n</pre>\n<div class=\"wp-caption aligncenter\" id=\"attachment_22221\" style=\"width: 860px\"><img alt=\"\" aria-describedby=\"caption-attachment-22221\" class=\"size-full wp-image-22221\" data-lazy-src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-1.webp\" decoding=\"async\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"450\"/><noscript><img alt=\"\" aria-describedby=\"caption-attachment-22221\" class=\"size-full wp-image-22221\" decoding=\"async\" loading=\"lazy\" src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-1.webp\" width=\"450\"/></noscript><p class=\"wp-caption-text\" id=\"caption-attachment-22221\">Memory Usage Across Different Numbers of Sessions 1</p></div>\n<p>Based on the above measurements, we can see that for each session we are allocating extra 72MB ‚Äì 100MB of memory.</p>\n<p>Let‚Äôs try to make our app more efficient, some of you probably noticed that we are fetching the data separately for each session which means we store the same data multiple times in our app.</p>\n<p>We can make that more efficient by fetching the data <a href=\"https://shiny.posit.co/r/articles/improve/scoping/\" rel=\"nofollow\" target=\"_blank\">in the global scope</a>.</p>\n<pre>\r\nlibrary(DBI)\r\nlibrary(dplyr)\r\nlibrary(reactable)\r\nlibrary(shiny)\r\n\r\nconn &lt;- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\r\n\r\ncredit_cards &lt;- dbGetQuery(\r\n  conn = conn,\r\n  \"SELECT * FROM credit_cards\"\r\n)\r\n\r\nshiny::onStop(function() {\r\n  dbDisconnect(conn)\r\n})\r\n\r\nui &lt;- fluidPage(\r\n  titlePanel(\"Credit Cards App\"),\r\n  reactableOutput(\"top_credit_providers\")\r\n)\r\n\r\nserver &lt;- function(input, output, session) {\r\n  \r\n  output$top_credit_providers &lt;- renderReactable({\r\n    top_providers &lt;- credit_cards |&gt; \r\n      group_by(provider) |&gt; \r\n      summarise(popularity = n()) |&gt; \r\n      arrange(desc(popularity)) |&gt;\r\n      head(10) |&gt; \r\n      collect()\r\n    \r\n    reactable(top_providers)\r\n  })\r\n  \r\n}\r\n\r\nshinyApp(ui, server)\r\n</pre>\n<p><strong>Let‚Äôs measure if that made our app more memory efficient:</strong></p>\n<pre>\r\n&gt; measure_mem_usage() # 1 session\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  474MB   474MB \r\n\r\n\r\n&gt; measure_mem_usage() # 2 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  497MB   497MB \r\n\r\n\r\n&gt; measure_mem_usage() # 3 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  503MB   503MB  \r\n\r\n\r\n&gt; measure_mem_usage() # 4 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  530MB   530MB\r\n\r\n\r\n&gt; measure_mem_usage() # 5 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  546MB   546MB \r\n</pre>\n<div class=\"wp-caption aligncenter\" id=\"attachment_22223\" style=\"width: 860px\"><img alt=\"\" aria-describedby=\"caption-attachment-22223\" class=\"size-full wp-image-22223\" data-lazy-src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-2.webp\" decoding=\"async\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"450\"/><noscript><img alt=\"\" aria-describedby=\"caption-attachment-22223\" class=\"size-full wp-image-22223\" decoding=\"async\" loading=\"lazy\" src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-2.webp\" width=\"450\"/></noscript><p class=\"wp-caption-text\" id=\"caption-attachment-22223\">Memory Usage Across Different Numbers of Sessions 2</p></div>\n<p>As we can see now our app allocates an extra 6 ‚Äì 27MB per session this is an almost 4x improvement!</p>\n<p>Let‚Äôs try to make it even better! Currently we are fetching the whole credit card data into the R process memory, <strong>but we only display the top 10 values! What a waste of memory!</strong></p>\n<p>Let‚Äôs fix that by extracting computations into the database ‚Äì this is very thanks to <code>{dbplyr}</code> as we can reuse the same <code>{dplyr}</code> functions.</p>\n<pre>\r\nlibrary(DBI)\r\nlibrary(dplyr)\r\nlibrary(reactable)\r\nlibrary(shiny)\r\n\r\nconn &lt;- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\r\n\r\ncredit_cards &lt;- tbl(conn,\"credit_cards\")\r\n\r\nshiny::onStop(function() {\r\n  dbDisconnect(conn)\r\n})\r\n\r\nui &lt;- fluidPage(\r\n  titlePanel(\"Credit Cards App\"),\r\n  reactableOutput(\"top_credit_providers\")\r\n)\r\n\r\nserver &lt;- function(input, output, session) {\r\n  \r\n  output$top_credit_providers &lt;- renderReactable({\r\n    top_providers &lt;- credit_cards |&gt;\r\n      group_by(provider) |&gt; \r\n      summarise(popularity = n()) |&gt; \r\n      arrange(desc(popularity)) |&gt;\r\n      head(10) |&gt; \r\n      collect()\r\n    \r\n    reactable(top_providers)\r\n  })\r\n  \r\n}\r\n\r\nshinyApp(ui, server)\r\n</pre>\n<p><strong>Let‚Äôs repeat our benchmarks again:</strong></p>\n<pre>\r\n&gt; measure_mem_usage() # 1 session\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  229MB   229MB \r\n\r\n\r\n&gt; measure_mem_usage() # 2 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  225MB   225MB \r\n\r\n\r\n&gt; measure_mem_usage() # 2 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  231MB   231MB\r\n\r\n\r\n&gt; measure_mem_usage() # 3 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  232MB   232MB \r\n\r\n\r\n&gt; measure_mem_usage() # 4 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  233MB   233MB \r\n\r\n\r\n&gt; measure_mem_usage() # 5 sessions\r\nPress [enter] to finish the test...\r\n\r\ncurrent     max \r\n  233MB   233MB \r\n</pre>\n<div class=\"wp-caption aligncenter\" id=\"attachment_22225\" style=\"width: 860px\"><img alt=\"\" aria-describedby=\"caption-attachment-22225\" class=\"size-full wp-image-22225\" data-lazy-src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-3.webp\" decoding=\"async\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"450\"/><noscript><img alt=\"\" aria-describedby=\"caption-attachment-22225\" class=\"size-full wp-image-22225\" decoding=\"async\" loading=\"lazy\" src=\"https://wordpress.appsilon.com/wp-content/uploads/2023/11/memory-usage-across-different-numbers-of-sessions-3.webp\" width=\"450\"/></noscript><p class=\"wp-caption-text\" id=\"caption-attachment-22225\">Memory Usage Across Different Numbers of Sessions 3</p></div>\n<p>Now the memory usage of our app seems to be barely increasing; there is only a 4MB difference between the app used by 1 user and the app used by 5 users.</p>\n<p>Not to mention that compared to the apps that were fetching whole datasets into memory, we are saving 245MB of memory!</p>\n<h2 id=\"limitations\">Limitations</h2>\n<p>The described method of measuring memory usage of a memory app has its limitations. For example, if our app is using {promises}, depending on the type of future backend we are using our measurements might be less accurate.</p>\n<p>If our backend uses child processes, <a href=\"https://bench.r-lib.org/reference/bench_process_memory.html\" rel=\"nofollow\" target=\"_blank\">bench::bench_process_memory</a> will include them in the measurements. For example, when using <code>future::multicore</code>, <a href=\"https://github.com/HenrikBengtsson/future/issues/155\" rel=\"nofollow\" target=\"_blank\">futures are run in child processes of the main R process</a>.</p>\n<p>However, if we are using <code>future::multisession</code>, futures are run in separate processes (not child processes), and in that case, memory used by those processes won‚Äôt be included in the measurements.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>In this blog post, we described how to benchmark memory usage of the Shiny app using the <code>{bench}</code> package.</p>\n<p>Additionally, we showed that by extracting computations into a database, we can make an almost 4x improvement in terms of memory usage.</p>\n<p>This improves the scalability of our application and might allow us to cut down on infrastructure costs, as machines with less memory can be used to handle the same traffic.</p>\n<p>If you found this article helpful, don‚Äôt miss out on the latest trends and advancements in R/Shiny ‚Äî <a href=\"https://appsilon.us16.list-manage.com/subscribe?u=c042d7c0dbf57c5c6f8b54598&amp;id=870d5bfc05\" rel=\"nofollow\" target=\"_blank\">subscribe to Shiny Weekly for regular updates and exclusive content</a>.</p>\n<p>The post appeared first on appsilon.com/blog/.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://appsilon.com/benchmarking-memory-usage-in-shiny-apps/\"> Tag: r - Appsilon | Enterprise R Shiny Dashboards</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "Maximizing Efficiency: A Guide to Benchmarking Memory Usage in Shiny Apps\nPosted on\nNovember 30, 2023\nby\nRyszard Szyma≈Ñski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nTag: r - Appsilon | Enterprise R Shiny Dashboards\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nR/Shiny allows you to\nprototype\na working web application\nquickly\nand\neasily\n. However, with increasing amounts of data, your app may become slow and, in extreme cases, crash due to insufficient memory.\nWhen the worst-case scenario happens, we need to figure out a way to\nlower the memory usage of our app to avoid those crashes\n.\nA crucial part of optimization efforts is benchmarking\nhow much memory our app is consuming\n. This allows us to check if the changes we made to the app are indeed moving us in the right direction.\nIn this step-by-step guide, we will describe how to do that based on an example application.\nTable of Contents\nHow to Measure Memory Usage of Shiny\nExample App\nLimitations\nConclusion\nHow to Measure Memory Usage of Shiny\nYou might already be familiar with the\n{profmem}\npackage for profiling memory usage of R expressions.\n{profmem}\nuses\nRprofmem\nunder the hood\nand in the\ndocs\n, we can find that with\nutils::Rprofmem()\nit is not possible to quantify the total memory usage at a given time because it only logs allocations and does, therefore, not reflect deallocations done by the garbage collector.\nAdditionally,\nRprofmem\ndoes not track allocations made by non-R native libraries or packages that use native\ncalloc()\nor\nfree()\nfor internal objects.\nIn the context of Shiny, we are usually interested in how much memory the R process running our app is using. That information allows us to estimate what infrastructure we will need to provision in order to host our app and get an overall feel of how our app scales memory-wise (e.g. does memory usage increase drastically with more users?).\nTo achieve that, we will use the {bench} package, which provides the\nbench_process_memory\nfunction\n. That function uses operating system APIs to determine how much memory is used by the current R process, including all the memory from child processes and memory allocated outside R‚Äôs garbage collector heap.\nbench::bench_process_memory\ninforms us not only about the currently used amount of memory but also about the peak memory usage that occurred during the process lifecycle.\nNote:\nThere are also other packages that can be used for measuring process memory usage, like\nmemuse\n. However, as of today, it does not support measuring peak memory usage on MacOS ‚Äì we submitted a Pull Request adding support for that. But later on, we learned that\n{bench}\nalready supports that. Hence, we recommend using\n{bench}\n.\nThroughout our example, we will use the following helper function:\nwait_for_app_to_start <- function(url) { httr2::request(url) |> \n    httr2::req_retry(\n      max_seconds = 5,\n      backoff = function(attempt) 2 ** attempt\n    )\n}\n\nmeasure_mem_usage <- function() {\n  result_file <- tempfile(fileext = \"RDS\")\n  port <- httpuv::randomPort()\n  app_process <- callr::r_bg(\n    function(result_file, port) {\n      on.exit({ \n        saveRDS(bench::bench_process_memory(), result_file) \n      }) \n      \n      shiny::runApp(port = port)\n    }, args = list(result_file = result_file, port = port))\n  \n  on.exit({ \n    if (app_process$is_alive()) {\n      app_process$kill() \n    }\n  })\n  \n  app_url <- paste0(\"http://127.0.0.1:\", port)\n  \n  wait_for_app_to_start(app_url)\n  \n  utils::browseURL(app_url)\n  \n  cat (\"Press [enter] to finish the test...\")\n  line <- readline()\n  \n  app_process$interrupt()\n  \n  app_process$wait()\n  \n  readRDS(result_file)\n}\nLet‚Äôs break down one by one what is happening in this function:\nWe start a shiny app in a separate R process ‚Äì this is important as we don‚Äôt want the work we did previously in our R session to impact the results (e.g. we might have analyzed a large dataset which could be the source of peak memory usage)\nWe register a callback on function exit that will save the memory measurements in a temporary file\nAfter the background R process with our app is started, our function opens the app in our browser and waits for user input. This gives us time to simulate user interactions with our app.\nOnce we are done clicking through our app, we can hit enter in our R console, and the background process will be interrupted. Once the background process terminates, we read memory measurements from the temporary file.\nLet‚Äôs see that in action:\nhttps://wordpress.appsilon.com/wp-content/uploads/2023/11/memory_measuring_helper_demo.webm\nDiscover more insights on boosting your app‚Äôs speed and efficiency in our detailed piece:\nshiny.benchmark ‚Äì How to Measure Performance Improvements in R Shiny Apps\n.\nExample App\nAll right, now let‚Äôs use our memory benchmarking function on an actual app. Let‚Äôs assume we are working with credit card data; we will generate a fake dataset using\n{charlatan}\nand save it in an SQLite database:\nlibrary(charlatan)\nlibrary(DBI)\nlibrary(dplyr)\n\nset.seed(123)\n\n# Generate Fake Data\nTABLE_ROW_COUNT <- 1e7\n\nfake_providers <- ch_credit_card_provider(100)\nfake_data <- data.frame(\n  provider = sample(fake_providers, size = TABLE_ROW_COUNT, replace = TRUE)\n)\n\n# Save data to sqlite database\nconn <- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\n\ndbWriteTable(\n  conn = conn,\n  name = \"credit_cards\",\n  value = fake_data,\n  overwrite = TRUE\n)\nNow, let‚Äôs create a Shiny App that will display the top 10 most popular card providers:\nlibrary(DBI)\nlibrary(dplyr)\nlibrary(reactable)\nlibrary(shiny)\n\nconn <- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\n\nshiny::onStop(function() {\n  dbDisconnect(conn)\n})\n\nui <- fluidPage(\n  titlePanel(\"Credit Cards App\"),\n  reactableOutput(\"top_credit_providers\")\n)\n\nserver <- function(input, output, session) {\n  credit_cards <- dbGetQuery(\n    conn = conn,\n    \"SELECT * FROM credit_cards\"\n  )\n\n  output$top_credit_providers <- renderReactable({\n    top_providers <- credit_cards |> \n      group_by(provider) |> \n      summarise(popularity = n()) |> \n      arrange(desc(popularity)) |>\n      head(10) |> \n      collect()\n    \n    reactable(top_providers)\n  })\n  \n}\n\nshinyApp(ui, server)\nLet‚Äôs see how much memory the app is using using our helper function:\n> measure_mem_usage()\nPress [enter] to finish the test...\n\ncurrent     max \n  481MB   481MB\nOk, now let‚Äôs see how that changes if we simulate multiple sessions within the app ‚Äì this can be done by opening multiple tabs with our app. Here are the results for 2, 3, 4 and 5 sessions:\n> measure_mem_usage() # 2 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  606MB   606MB \n\n> measure_mem_usage() # 3 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  678MB   678MB \n\n> measure_mem_usage() # 4 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  769MB   769MB \n\n> measure_mem_usage() # 5 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  844MB   844MB\nMemory Usage Across Different Numbers of Sessions 1\nBased on the above measurements, we can see that for each session we are allocating extra 72MB ‚Äì 100MB of memory.\nLet‚Äôs try to make our app more efficient, some of you probably noticed that we are fetching the data separately for each session which means we store the same data multiple times in our app.\nWe can make that more efficient by fetching the data\nin the global scope\n.\nlibrary(DBI)\nlibrary(dplyr)\nlibrary(reactable)\nlibrary(shiny)\n\nconn <- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\n\ncredit_cards <- dbGetQuery(\n  conn = conn,\n  \"SELECT * FROM credit_cards\"\n)\n\nshiny::onStop(function() {\n  dbDisconnect(conn)\n})\n\nui <- fluidPage(\n  titlePanel(\"Credit Cards App\"),\n  reactableOutput(\"top_credit_providers\")\n)\n\nserver <- function(input, output, session) {\n  \n  output$top_credit_providers <- renderReactable({\n    top_providers <- credit_cards |> \n      group_by(provider) |> \n      summarise(popularity = n()) |> \n      arrange(desc(popularity)) |>\n      head(10) |> \n      collect()\n    \n    reactable(top_providers)\n  })\n  \n}\n\nshinyApp(ui, server)\nLet‚Äôs measure if that made our app more memory efficient:\n> measure_mem_usage() # 1 session\nPress [enter] to finish the test...\n\ncurrent     max \n  474MB   474MB \n\n> measure_mem_usage() # 2 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  497MB   497MB \n\n> measure_mem_usage() # 3 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  503MB   503MB  \n\n> measure_mem_usage() # 4 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  530MB   530MB\n\n> measure_mem_usage() # 5 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  546MB   546MB\nMemory Usage Across Different Numbers of Sessions 2\nAs we can see now our app allocates an extra 6 ‚Äì 27MB per session this is an almost 4x improvement!\nLet‚Äôs try to make it even better! Currently we are fetching the whole credit card data into the R process memory,\nbut we only display the top 10 values! What a waste of memory!\nLet‚Äôs fix that by extracting computations into the database ‚Äì this is very thanks to\n{dbplyr}\nas we can reuse the same\n{dplyr}\nfunctions.\nlibrary(DBI)\nlibrary(dplyr)\nlibrary(reactable)\nlibrary(shiny)\n\nconn <- dbConnect(drv = RSQLite::SQLite(), \"database.sqlite\")\n\ncredit_cards <- tbl(conn,\"credit_cards\")\n\nshiny::onStop(function() {\n  dbDisconnect(conn)\n})\n\nui <- fluidPage(\n  titlePanel(\"Credit Cards App\"),\n  reactableOutput(\"top_credit_providers\")\n)\n\nserver <- function(input, output, session) {\n  \n  output$top_credit_providers <- renderReactable({\n    top_providers <- credit_cards |>\n      group_by(provider) |> \n      summarise(popularity = n()) |> \n      arrange(desc(popularity)) |>\n      head(10) |> \n      collect()\n    \n    reactable(top_providers)\n  })\n  \n}\n\nshinyApp(ui, server)\nLet‚Äôs repeat our benchmarks again:\n> measure_mem_usage() # 1 session\nPress [enter] to finish the test...\n\ncurrent     max \n  229MB   229MB \n\n> measure_mem_usage() # 2 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  225MB   225MB \n\n> measure_mem_usage() # 2 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  231MB   231MB\n\n> measure_mem_usage() # 3 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  232MB   232MB \n\n> measure_mem_usage() # 4 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  233MB   233MB \n\n> measure_mem_usage() # 5 sessions\nPress [enter] to finish the test...\n\ncurrent     max \n  233MB   233MB\nMemory Usage Across Different Numbers of Sessions 3\nNow the memory usage of our app seems to be barely increasing; there is only a 4MB difference between the app used by 1 user and the app used by 5 users.\nNot to mention that compared to the apps that were fetching whole datasets into memory, we are saving 245MB of memory!\nLimitations\nThe described method of measuring memory usage of a memory app has its limitations. For example, if our app is using {promises}, depending on the type of future backend we are using our measurements might be less accurate.\nIf our backend uses child processes,\nbench::bench_process_memory\nwill include them in the measurements. For example, when using\nfuture::multicore\n,\nfutures are run in child processes of the main R process\n.\nHowever, if we are using\nfuture::multisession\n, futures are run in separate processes (not child processes), and in that case, memory used by those processes won‚Äôt be included in the measurements.\nConclusion\nIn this blog post, we described how to benchmark memory usage of the Shiny app using the\n{bench}\npackage.\nAdditionally, we showed that by extracting computations into a database, we can make an almost 4x improvement in terms of memory usage.\nThis improves the scalability of our application and might allow us to cut down on infrastructure costs, as machines with less memory can be used to handle the same traffic.\nIf you found this article helpful, don‚Äôt miss out on the latest trends and advancements in R/Shiny ‚Äî\nsubscribe to Shiny Weekly for regular updates and exclusive content\n.\nThe post appeared first on appsilon.com/blog/.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nTag: r - Appsilon | Enterprise R Shiny Dashboards\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "R/Shiny allows you to prototype a working web application quickly and easily. However, with increasing amounts of data, your app may become slow and, in extreme cases, crash due to insufficient memory. When the worst-case scenario happens, we need to figure out a way to lower the memory usage of our app to avoid those [‚Ä¶] The post appeared first on appsilon.com/blog/.",
    "meta_keywords": null,
    "og_description": "R/Shiny allows you to prototype a working web application quickly and easily. However, with increasing amounts of data, your app may become slow and, in extreme cases, crash due to insufficient memory. When the worst-case scenario happens, we need to figure out a way to lower the memory usage of our app to avoid those [‚Ä¶] The post appeared first on appsilon.com/blog/.",
    "og_image": "https://wordpress.appsilon.com/wp-content/uploads/2023/11/Benchmark.webp",
    "og_title": "Maximizing Efficiency: A Guide to Benchmarking Memory Usage in Shiny Apps | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 9.2,
    "sitemap_lastmod": "2023-11-30T13:01:30+00:00",
    "twitter_description": "R/Shiny allows you to prototype a working web application quickly and easily. However, with increasing amounts of data, your app may become slow and, in extreme cases, crash due to insufficient memory. When the worst-case scenario happens, we need to figure out a way to lower the memory usage of our app to avoid those [‚Ä¶] The post appeared first on appsilon.com/blog/.",
    "twitter_title": "Maximizing Efficiency: A Guide to Benchmarking Memory Usage in Shiny Apps | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/11/maximizing-efficiency-a-guide-to-benchmarking-memory-usage-in-shiny-apps/",
    "word_count": 1846
  }
}