{
  "uuid": "80980370-6515-48a3-87b1-66cc6ee85b12",
  "created_at": "2025-11-22 19:57:52",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/08/nonparametric-serial-interval-estimation/",
    "crawled_at": "2025-11-22T10:44:14.647996",
    "external_links": [
      {
        "href": "https://statsandr.com/blog/nonparametric-serial-interval-estimation/",
        "text": "R on Stats and R"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://doi.org/10.1371/journal.pcbi.1013338",
        "text": "Gressani and Hens (2025)"
      },
      {
        "href": "https://github.com/oswaldogressani/EpiDelays",
        "text": "EpiDelays package"
      },
      {
        "href": "https://doi.org/10.1371/journal.pcbi.1013338",
        "text": "article"
      },
      {
        "href": "https://www.nejm.org/doi/full/10.1056/NEJMoa0906089",
        "text": "Lessler et al. (2009)"
      },
      {
        "href": "https://doi.org/10.1371/journal.pcbi.1013338",
        "text": "Gressani and Hens (2025)"
      },
      {
        "href": "https://doi.org/10.1371/journal.pcbi.1013338",
        "text": "https://doi.org/10.1371/journal.pcbi.1013338"
      },
      {
        "href": "https://github.com/oswaldogressani/EpiDelays",
        "text": "https://github.com/oswaldogressani/EpiDelays"
      },
      {
        "href": "https://www.nejm.org/doi/full/10.1056/NEJMoa0906089",
        "text": "https://www.nejm.org/doi/full/10.1056/NEJMoa0906089"
      },
      {
        "href": "https://statsandr.com/blog/nonparametric-serial-interval-estimation/",
        "text": "R on Stats and R"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Nonparametric serial interval estimation | R-bloggers",
    "images": [
      {
        "alt": "Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.",
        "base64": null,
        "src": "https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/images/SIcoarse.PNG?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/index_files/figure-html/comparecdfs-1.png?w=450&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/r-on-stats-and-r/",
        "text": "R on Stats and R"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-394839 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Nonparametric serial interval estimation</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">August 17, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-on-stats-and-r/\">R on Stats and R</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://statsandr.com/blog/nonparametric-serial-interval-estimation/\"> R on Stats and R</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div class=\"section level2\" id=\"motivation\">\n<h2>Motivation</h2>\n<p>Epidemiological delays inform about the time between two well-defined events related to a disease. The serial interval (SI) of an infectious disease is defined as the time between symptom onset in a primary case (infector) and symptom onset in a secondary case (infectee). It is a widely used epidemiological delay quantity and plays a central role in mathematical/statistical models of disease transmission. There exists a tight link between the reproduction number (average number of secondary infections generated by an infected individual) and the serial interval. Therefore, getting accurate knowledge about the SI distribution is key to gain a clear understanding of transmission dynamics during outbreaks. Timings of symptom onset for infector-infectee pairs can be obtained from line list data and observations usually consist of calendar dates. From a mathematical perspective, it is more convenient to work with numbers than with calendar dates and the latter are typically transformed to integers for the sake of statistical analysis.</p>\n<p>The main challenge when working with SI data is censoring in the sense that exact symptom onset times are usually unobserved and only known to have occurred between two time points. If the time resolution of a reported timing of illness onset is a calendar day, for instance July 15, there is not enough information to determine the exact time of illness onset within that day. As such, symptom onset is assumed to have occurred between July 15 and July 16 and we say that serial interval data are interval-censored. The figure below illustrates the coarse structure of SI data that adds a layer of complexity to the estimation problem.</p>\n<div class=\"float\">\n<img alt=\"Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.\" data-lazy-src=\"https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/images/SIcoarse.PNG?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width:100.0%\"/><noscript><img alt=\"Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/images/SIcoarse.PNG?w=578&amp;ssl=1\" style=\"width:100.0%\"/></noscript>\n<div class=\"figcaption\">Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.</div>\n</div>\n<p><br/></p>\n<p>A recent article by <a href=\"https://doi.org/10.1371/journal.pcbi.1013338\" rel=\"nofollow\" target=\"_blank\">Gressani and Hens (2025)</a> published in PLOS Computational Biology proposes a new estimator of the cumulative distribution function of the serial interval without making parametric assumptions regarding the underlying SI distribution. The estimator is based on mixtures of uniform distributions and only requires left and right bounds of serial interval windows of infector-infectee pairs as a main input (<span class=\"math inline\">\\(s_{iL}\\)</span> and <span class=\"math inline\">\\(s_{iR}\\)</span> in the above figure). Point estimates of different serial interval features are available in closed-form and the bootstrap is used to compute confidence intervals. The nonparametric methodology is relatively simple and computationally fast and stable. Moreover, a user-friendly routine is available in the <a href=\"https://github.com/oswaldogressani/EpiDelays\" rel=\"nofollow\" target=\"_blank\">EpiDelays package</a> written in R. This post aims at giving users a simple first experience with this new nonparametric methodology for serial interval estimation. The package can be installed from GitHub (using devtools) as follows:</p>\n<pre>install.packages(\"devtools\")\ndevtools::install_github(\"oswaldogressani/EpiDelays\")</pre>\n</div>\n<div class=\"section level2\" id=\"simulated-data\">\n<h2>Simulated data</h2>\n<p>The <code>estimSI()</code> routine of the EpiDelays package can be used to compute nonparametric estimates (point estimates with standard errors and confidence intervals) of different serial interval features (e.g. the mean, median, standard deviation). The routine is simple to use and requires only two inputs:</p>\n<ul>\n<li><p><code>x</code>: A data frame with <span class=\"math inline\">\\(n\\)</span> rows (corresponding to the number of transmission pairs for which illness onset data is available) and two columns containing the lower bound of the SI window <span class=\"math inline\">\\(s_{iL}\\)</span> (first column) and the upper bound of the SI window <span class=\"math inline\">\\(s_{iR}\\)</span> (second column).</p></li>\n<li><p><code>nboot</code>: An integer for the bootstrap sample size (default is 2000) used to construct (<span class=\"math inline\">\\(90\\%\\)</span> and <span class=\"math inline\">\\(95\\%\\)</span>) confidence intervals (CIs).</p></li>\n</ul>\n<p>We start by illustrating the use of <code>estimSI()</code> on simulated data. The <code>simSI()</code> routine can be used to simulate artificial serial interval data with SI windows having a width (coarseness) of at least two days. The underlying target SI distribution is assumed to have a Gaussian distribution with mean <code>muS</code> and standard deviation <code>sdS</code> that have to be specified by the user. The code below can be used to generate <span class=\"math inline\">\\(n=15\\)</span> SI windows from a Gaussian distribution with a mean of <span class=\"math inline\">\\(3\\)</span> days and standard deviation of <span class=\"math inline\">\\(2\\)</span> days. More details regarding the data generating mechanism can be found in the <a href=\"https://doi.org/10.1371/journal.pcbi.1013338\" rel=\"nofollow\" target=\"_blank\">article</a>.</p>\n<pre>set.seed(2025)\nsimdata &lt;- simSI(muS = 3, sdS = 2, n = 15)\ngt::gt(round(simdata, 2))</pre>\n<div id=\"kwsipvprqq\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n\n<table class=\"gt_table\" data-quarto-bootstrap=\"false\" data-quarto-disable-processing=\"false\">\n<thead>\n<tr class=\"gt_col_headings\">\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"s\" rowspan=\"1\" scope=\"col\">s</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"sl\" rowspan=\"1\" scope=\"col\">sl</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"sr\" rowspan=\"1\" scope=\"col\">sr</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"sw\" rowspan=\"1\" scope=\"col\">sw</th>\n</tr>\n</thead>\n<tbody class=\"gt_table_body\">\n<tr><td class=\"gt_row gt_right\" headers=\"s\">4.24</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">3.07</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">2</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">4</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">4.55</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">4</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">6</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">5.54</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">7</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">3.74</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">2.67</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">2</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">4</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">3.79</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">2.84</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">2</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">4</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">2.31</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">1</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">4</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">4.40</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">6</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">3</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">2.21</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">1</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">-0.51</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">-2</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">1</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">3</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">2.16</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">1</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">2</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">4.53</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">2</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">5</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">3</td></tr>\n<tr><td class=\"gt_row gt_right\" headers=\"s\">5.13</td>\n<td class=\"gt_row gt_right\" headers=\"sl\">3</td>\n<td class=\"gt_row gt_right\" headers=\"sr\">7</td>\n<td class=\"gt_row gt_right\" headers=\"sw\">4</td></tr>\n</tbody>\n</table>\n</div>\n<p><br/></p>\n<p>The first column of the simulated dataset contains the true (unobserved) serial interval value generated from the chosen Gaussian distribution. The second and third columns contain the left and right bound of the SI window (<code>sl</code> and <code>sr</code>). Finally, the last column contains the width of the observed SI window, i.e. <code>sw=sr-sl</code>. The underlying target SI distribution is specified to be Gaussian with a mean of <span class=\"math inline\">\\(3\\)</span> days and standard deviation of <span class=\"math inline\">\\(2\\)</span> days. The 5th, 25th, 75th and 95th quantiles of the latter distribution are:</p>\n<pre>round(qnorm(p = c(0.05, 0.25, 0.75, 0.95), mean = 3, sd = 2), 1)\n## [1] -0.3  1.7  4.3  6.3</pre>\n<p>We now create a data frame containing <code>sl</code> and <code>sr</code> and use the latter as an input in the <code>estimSI()</code> routine. Nonparametric estimates of different SI features can be accessed with <code>$npestim$</code>.</p>\n<pre>xdf &lt;- data.frame(sl = simdata$sl, sr = simdata$sr)\nSIfit &lt;- estimSI(x = xdf, nboot = 2000)\ngt::gt(round(SIfit$npestim, 1),\n  rownames_to_stub = TRUE\n)</pre>\n<div id=\"aomvniacfb\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n\n<table class=\"gt_table\" data-quarto-bootstrap=\"false\" data-quarto-disable-processing=\"false\">\n<thead>\n<tr class=\"gt_col_headings\">\n<th class=\"gt_col_heading gt_columns_bottom_border gt_left\" colspan=\"1\" id=\"a::stub\" rowspan=\"1\" scope=\"col\"></th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"mean\" rowspan=\"1\" scope=\"col\">mean</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"sd\" rowspan=\"1\" scope=\"col\">sd</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.05\" rowspan=\"1\" scope=\"col\">q0.05</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.25\" rowspan=\"1\" scope=\"col\">q0.25</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.5\" rowspan=\"1\" scope=\"col\">q0.5</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.75\" rowspan=\"1\" scope=\"col\">q0.75</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.95\" rowspan=\"1\" scope=\"col\">q0.95</th>\n</tr>\n</thead>\n<tbody class=\"gt_table_body\">\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_1\" scope=\"row\">point</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 mean\">3.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 sd\">1.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.05\">0.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.25\">2.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.5\">3.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.75\">4.6</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.95\">6.0</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_2\" scope=\"row\">se</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 mean\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 sd\">0.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.05\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.25\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.5\">0.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.75\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.95\">0.5</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_3\" scope=\"row\">ci90l</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 mean\">2.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 sd\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.05\">-1.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.25\">1.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.5\">2.9</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.75\">3.9</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.95\">5.0</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_4\" scope=\"row\">ci90r</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 mean\">4.0</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 sd\">2.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.05\">2.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.25\">3.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.5\">4.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.75\">5.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.95\">6.6</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_5\" scope=\"row\">ci95l</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 mean\">2.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 sd\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.05\">-1.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.25\">1.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.5\">2.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.75\">3.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.95\">4.9</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_6\" scope=\"row\">ci95r</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 mean\">4.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 sd\">2.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.05\">2.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.25\">3.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.5\">4.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.75\">5.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.95\">6.6</td></tr>\n</tbody>\n</table>\n</div>\n<p><br/></p>\n<p>The output shows point estimates (point), standard errors (se) and confidence intervals bounds (ci) for the serial interval mean, standard deviation (sd) and 5th, 25th, 50th, 75th and 95th quantiles denoted by q0.05, q0.25, etc. We can also plot the estimated cumulative distribution function (cdf) obtained with the nonparametric approach and compare it with the target Gaussian cdf. The quality of the fit will typically depend on the sample size <span class=\"math inline\">\\(n\\)</span> and on the degree of coarseness present in the data. Note that the nonparametric methodology naturally deals with negative SI values.</p>\n<pre>sl &lt;- simdata$sl\nsr &lt;- simdata$sr\nFhat &lt;- function(s) (1 / SIfit$n) * sum((s - sl) / (sr - sl) * (s &gt;= sl &amp; s &lt;= sr) + (s &gt; sr))\nsf &lt;- seq(-3, 8, length = 100)\nplot(sf, sapply(sf, Fhat), type = \"l\", lwd = 2, xlab = \"Serial interval\", ylab = \"cdf\")\ngrid()\nlines(sf, pnorm(sf, mean = 3, sd = 2), col = \"blue\", lwd = 2)\nlegend(\"topleft\", c(\"Estimated cdf of SI\", \"Target cdf of SI\"), col = c(\"black\", \"blue\"), lwd = c(2, 2), bty = \"n\")</pre>\n<p><img data-lazy-src=\"https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/index_files/figure-html/comparecdfs-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"display: block; margin: auto;\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/statsandr.com/blog/nonparametric-serial-interval-estimation/index_files/figure-html/comparecdfs-1.png?w=450&amp;ssl=1\" style=\"display: block; margin: auto;\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"real-data\">\n<h2>Real data</h2>\n<p><a href=\"https://www.nejm.org/doi/full/10.1056/NEJMoa0906089\" rel=\"nofollow\" target=\"_blank\">Lessler et al. (2009)</a> share a dataset containing serial interval windows obtained from <span class=\"math inline\">\\(n=16\\)</span> infector-infectee pairs for Influenza A (2009 H1N1 influenza) at a New York City school. The SI windows are directly available from the supplementary appendix of the latter reference and are encoded in a data frame <code>xNY</code>. Nonparametric estimates of serial interval features are then obtained with <code>estimSI()</code>.</p>\n<pre>xNY &lt;- data.frame(sl = c(1, 1, 1, 0, 0, 4, 2, 3, 0, 3, 0, 3, 4, 1, 3, 3), sr = c(3, 3, 3, 2, 2, 6, 4, 5, 2, 5, 2, 5, 6, 3, 5, 5))\nset.seed(123)\nSIfitNY &lt;- estimSI(xNY, nboot = 2000)\ngt::gt(round(SIfitNY$npestim, 1),\n  rownames_to_stub = TRUE\n)</pre>\n<div id=\"lkmlioxfax\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n\n<table class=\"gt_table\" data-quarto-bootstrap=\"false\" data-quarto-disable-processing=\"false\">\n<thead>\n<tr class=\"gt_col_headings\">\n<th class=\"gt_col_heading gt_columns_bottom_border gt_left\" colspan=\"1\" id=\"a::stub\" rowspan=\"1\" scope=\"col\"></th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"mean\" rowspan=\"1\" scope=\"col\">mean</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"sd\" rowspan=\"1\" scope=\"col\">sd</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.05\" rowspan=\"1\" scope=\"col\">q0.05</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.25\" rowspan=\"1\" scope=\"col\">q0.25</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.5\" rowspan=\"1\" scope=\"col\">q0.5</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.75\" rowspan=\"1\" scope=\"col\">q0.75</th>\n<th class=\"gt_col_heading gt_columns_bottom_border gt_right\" colspan=\"1\" id=\"q0.95\" rowspan=\"1\" scope=\"col\">q0.95</th>\n</tr>\n</thead>\n<tbody class=\"gt_table_body\">\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_1\" scope=\"row\">point</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 mean\">2.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 sd\">1.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.05\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.25\">1.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.5\">2.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.75\">4.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_1 q0.95\">5.2</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_2\" scope=\"row\">se</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 mean\">0.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 sd\">0.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.05\">0.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.25\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.5\">0.6</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.75\">0.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_2 q0.95\">0.3</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_3\" scope=\"row\">ci90l</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 mean\">2.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 sd\">1.3</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.05\">0.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.25\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.5\">1.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.75\">3.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_3 q0.95\">4.7</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_4\" scope=\"row\">ci90r</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 mean\">3.4</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 sd\">1.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.05\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.25\">2.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.5\">3.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.75\">4.6</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_4 q0.95\">5.6</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_5\" scope=\"row\">ci95l</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 mean\">2.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 sd\">1.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.05\">0.2</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.25\">1.0</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.5\">1.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.75\">3.0</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_5 q0.95\">4.6</td></tr>\n<tr><th class=\"gt_row gt_left gt_stub\" id=\"stub_1_6\" scope=\"row\">ci95r</th>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 mean\">3.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 sd\">1.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.05\">1.1</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.25\">2.5</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.5\">3.8</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.75\">4.7</td>\n<td class=\"gt_row gt_right\" headers=\"stub_1_6 q0.95\">5.7</td></tr>\n</tbody>\n</table>\n</div>\n<p><br/></p>\n<p>Interested readers can find more real data examples in <a href=\"https://doi.org/10.1371/journal.pcbi.1013338\" rel=\"nofollow\" target=\"_blank\">Gressani and Hens (2025)</a> and learn about the strengths and limitations of this new nonparametric methodology for serial interval estimation.</p>\n<div class=\"section level3\" id=\"references\">\n<h3>References</h3>\n<p>Gressani, O. and Hens, N. (2025). Nonparametric serial interval estimation with uniform mixtures.\n<em>PLoS Computational Biology</em> <strong>21</strong>(8):e101338. <a class=\"uri\" href=\"https://doi.org/10.1371/journal.pcbi.1013338\" rel=\"nofollow\" target=\"_blank\">https://doi.org/10.1371/journal.pcbi.1013338</a></p>\n<p>Gressani; O. (2025). EpiDelays: A Software for Estimation of Epidemiological Delays (version 0.0.1). <a class=\"uri\" href=\"https://github.com/oswaldogressani/EpiDelays\" rel=\"nofollow\" target=\"_blank\">https://github.com/oswaldogressani/EpiDelays</a></p>\n<p>Lessler, J., Reich, N. G., Cummings, D. A., and the New York City Department of Health and Mental Hygiene Swine Influenza Investigation Team. (2009). Outbreak of 2009 pandemic influenza A (H1N1) at a New York City school. <em>New England Journal of Medicine</em> <strong>361</strong>(27), 2628-2636. <a class=\"uri\" href=\"https://www.nejm.org/doi/full/10.1056/NEJMoa0906089\" rel=\"nofollow\" target=\"_blank\">https://www.nejm.org/doi/full/10.1056/NEJMoa0906089</a></p>\n</div>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://statsandr.com/blog/nonparametric-serial-interval-estimation/\"> R on Stats and R</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Nonparametric serial interval estimation\nPosted on\nAugust 17, 2025\nby\nR on Stats and R\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR on Stats and R\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nMotivation\nEpidemiological delays inform about the time between two well-defined events related to a disease. The serial interval (SI) of an infectious disease is defined as the time between symptom onset in a primary case (infector) and symptom onset in a secondary case (infectee). It is a widely used epidemiological delay quantity and plays a central role in mathematical/statistical models of disease transmission. There exists a tight link between the reproduction number (average number of secondary infections generated by an infected individual) and the serial interval. Therefore, getting accurate knowledge about the SI distribution is key to gain a clear understanding of transmission dynamics during outbreaks. Timings of symptom onset for infector-infectee pairs can be obtained from line list data and observations usually consist of calendar dates. From a mathematical perspective, it is more convenient to work with numbers than with calendar dates and the latter are typically transformed to integers for the sake of statistical analysis.\nThe main challenge when working with SI data is censoring in the sense that exact symptom onset times are usually unobserved and only known to have occurred between two time points. If the time resolution of a reported timing of illness onset is a calendar day, for instance July 15, there is not enough information to determine the exact time of illness onset within that day. As such, symptom onset is assumed to have occurred between July 15 and July 16 and we say that serial interval data are interval-censored. The figure below illustrates the coarse structure of SI data that adds a layer of complexity to the estimation problem.\nSource: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338.\nA recent article by\nGressani and Hens (2025)\npublished in PLOS Computational Biology proposes a new estimator of the cumulative distribution function of the serial interval without making parametric assumptions regarding the underlying SI distribution. The estimator is based on mixtures of uniform distributions and only requires left and right bounds of serial interval windows of infector-infectee pairs as a main input (\n\\(s_{iL}\\)\nand\n\\(s_{iR}\\)\nin the above figure). Point estimates of different serial interval features are available in closed-form and the bootstrap is used to compute confidence intervals. The nonparametric methodology is relatively simple and computationally fast and stable. Moreover, a user-friendly routine is available in the\nEpiDelays package\nwritten in R. This post aims at giving users a simple first experience with this new nonparametric methodology for serial interval estimation. The package can be installed from GitHub (using devtools) as follows:\ninstall.packages(\"devtools\")\ndevtools::install_github(\"oswaldogressani/EpiDelays\")\nSimulated data\nThe\nestimSI()\nroutine of the EpiDelays package can be used to compute nonparametric estimates (point estimates with standard errors and confidence intervals) of different serial interval features (e.g. the mean, median, standard deviation). The routine is simple to use and requires only two inputs:\nx\n: A data frame with\n\\(n\\)\nrows (corresponding to the number of transmission pairs for which illness onset data is available) and two columns containing the lower bound of the SI window\n\\(s_{iL}\\)\n(first column) and the upper bound of the SI window\n\\(s_{iR}\\)\n(second column).\nnboot\n: An integer for the bootstrap sample size (default is 2000) used to construct (\n\\(90\\%\\)\nand\n\\(95\\%\\)\n) confidence intervals (CIs).\nWe start by illustrating the use of\nestimSI()\non simulated data. The\nsimSI()\nroutine can be used to simulate artificial serial interval data with SI windows having a width (coarseness) of at least two days. The underlying target SI distribution is assumed to have a Gaussian distribution with mean\nmuS\nand standard deviation\nsdS\nthat have to be specified by the user. The code below can be used to generate\n\\(n=15\\)\nSI windows from a Gaussian distribution with a mean of\n\\(3\\)\ndays and standard deviation of\n\\(2\\)\ndays. More details regarding the data generating mechanism can be found in the\narticle\n.\nset.seed(2025)\nsimdata <- simSI(muS = 3, sdS = 2, n = 15)\ngt::gt(round(simdata, 2))\ns\nsl\nsr\nsw\n4.24\n3\n5\n2\n3.07\n2\n4\n2\n4.55\n4\n6\n2\n5.54\n5\n7\n2\n3.74\n3\n5\n2\n2.67\n2\n4\n2\n3.79\n3\n5\n2\n2.84\n2\n4\n2\n2.31\n1\n5\n4\n4.40\n3\n6\n3\n2.21\n1\n3\n2\n-0.51\n-2\n1\n3\n2.16\n1\n3\n2\n4.53\n2\n5\n3\n5.13\n3\n7\n4\nThe first column of the simulated dataset contains the true (unobserved) serial interval value generated from the chosen Gaussian distribution. The second and third columns contain the left and right bound of the SI window (\nsl\nand\nsr\n). Finally, the last column contains the width of the observed SI window, i.e.\nsw=sr-sl\n. The underlying target SI distribution is specified to be Gaussian with a mean of\n\\(3\\)\ndays and standard deviation of\n\\(2\\)\ndays. The 5th, 25th, 75th and 95th quantiles of the latter distribution are:\nround(qnorm(p = c(0.05, 0.25, 0.75, 0.95), mean = 3, sd = 2), 1)\n## [1] -0.3  1.7  4.3  6.3\nWe now create a data frame containing\nsl\nand\nsr\nand use the latter as an input in the\nestimSI()\nroutine. Nonparametric estimates of different SI features can be accessed with\n$npestim$\n.\nxdf <- data.frame(sl = simdata$sl, sr = simdata$sr)\nSIfit <- estimSI(x = xdf, nboot = 2000)\ngt::gt(round(SIfit$npestim, 1),\n  rownames_to_stub = TRUE\n)\nmean\nsd\nq0.05\nq0.25\nq0.5\nq0.75\nq0.95\npoint\n3.4\n1.7\n0.3\n2.5\n3.5\n4.6\n6.0\nse\n0.4\n0.3\n1.1\n0.4\n0.3\n0.4\n0.5\nci90l\n2.8\n1.1\n-1.3\n1.8\n2.9\n3.9\n5.0\nci90r\n4.0\n2.1\n2.1\n3.2\n4.1\n5.2\n6.6\nci95l\n2.7\n1.1\n-1.3\n1.5\n2.8\n3.8\n4.9\nci95r\n4.2\n2.2\n2.1\n3.3\n4.2\n5.4\n6.6\nThe output shows point estimates (point), standard errors (se) and confidence intervals bounds (ci) for the serial interval mean, standard deviation (sd) and 5th, 25th, 50th, 75th and 95th quantiles denoted by q0.05, q0.25, etc. We can also plot the estimated cumulative distribution function (cdf) obtained with the nonparametric approach and compare it with the target Gaussian cdf. The quality of the fit will typically depend on the sample size\n\\(n\\)\nand on the degree of coarseness present in the data. Note that the nonparametric methodology naturally deals with negative SI values.\nsl <- simdata$sl\nsr <- simdata$sr\nFhat <- function(s) (1 / SIfit$n) * sum((s - sl) / (sr - sl) * (s >= sl & s <= sr) + (s > sr))\nsf <- seq(-3, 8, length = 100)\nplot(sf, sapply(sf, Fhat), type = \"l\", lwd = 2, xlab = \"Serial interval\", ylab = \"cdf\")\ngrid()\nlines(sf, pnorm(sf, mean = 3, sd = 2), col = \"blue\", lwd = 2)\nlegend(\"topleft\", c(\"Estimated cdf of SI\", \"Target cdf of SI\"), col = c(\"black\", \"blue\"), lwd = c(2, 2), bty = \"n\")\nReal data\nLessler et al. (2009)\nshare a dataset containing serial interval windows obtained from\n\\(n=16\\)\ninfector-infectee pairs for Influenza A (2009 H1N1 influenza) at a New York City school. The SI windows are directly available from the supplementary appendix of the latter reference and are encoded in a data frame\nxNY\n. Nonparametric estimates of serial interval features are then obtained with\nestimSI()\n.\nxNY <- data.frame(sl = c(1, 1, 1, 0, 0, 4, 2, 3, 0, 3, 0, 3, 4, 1, 3, 3), sr = c(3, 3, 3, 2, 2, 6, 4, 5, 2, 5, 2, 5, 6, 3, 5, 5))\nset.seed(123)\nSIfitNY <- estimSI(xNY, nboot = 2000)\ngt::gt(round(SIfitNY$npestim, 1),\n  rownames_to_stub = TRUE\n)\nmean\nsd\nq0.05\nq0.25\nq0.5\nq0.75\nq0.95\npoint\n2.8\n1.5\n0.4\n1.5\n2.8\n4.1\n5.2\nse\n0.3\n0.1\n0.2\n0.4\n0.6\n0.4\n0.3\nci90l\n2.2\n1.3\n0.2\n1.1\n1.8\n3.2\n4.7\nci90r\n3.4\n1.7\n1.1\n2.2\n3.7\n4.6\n5.6\nci95l\n2.1\n1.2\n0.2\n1.0\n1.8\n3.0\n4.6\nci95r\n3.5\n1.7\n1.1\n2.5\n3.8\n4.7\n5.7\nInterested readers can find more real data examples in\nGressani and Hens (2025)\nand learn about the strengths and limitations of this new nonparametric methodology for serial interval estimation.\nReferences\nGressani, O. and Hens, N. (2025). Nonparametric serial interval estimation with uniform mixtures.\nPLoS Computational Biology\n21\n(8):e101338.\nhttps://doi.org/10.1371/journal.pcbi.1013338\nGressani; O. (2025). EpiDelays: A Software for Estimation of Epidemiological Delays (version 0.0.1).\nhttps://github.com/oswaldogressani/EpiDelays\nLessler, J., Reich, N. G., Cummings, D. A., and the New York City Department of Health and Mental Hygiene Swine Influenza Investigation Team. (2009). Outbreak of 2009 pandemic influenza A (H1N1) at a New York City school.\nNew England Journal of Medicine\n361\n(27), 2628-2636.\nhttps://www.nejm.org/doi/full/10.1056/NEJMoa0906089\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR on Stats and R\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Motivation Epidemiological delays inform about the time between two well-defined events related to a disease. The serial interval (SI) of an infectious disease is defined as the time between symptom onset in a primary case (infector) and symptom onset in a secondary case (infectee). It is a widely used epidemiological delay quantity and plays a central role in mathematical/statistical models of disease transmission. There exists a tight link between the reproduction number (average number of secondary infections generated by an infected individual) and the serial interval. Therefore, getting accurate knowledge about the SI distribution is key to gain a clear understanding of transmission dynamics during outbreaks. Timings of symptom onset for infector-infectee pairs can be obtained from line list data and observations usually consist of calendar dates. From a mathematical perspective, it is more convenient to work with numbers than with calendar dates and the latter are typically transformed to integers for the sake of statistical analysis. The main challenge when working with SI data is censoring in the sense that exact symptom onset times are usually unobserved and only known to have occurred between two time points. If the time resolution of a reported timing of illness onset is a calendar day, for instance July 15, there is not enough information to determine the exact time of illness onset within that day. As such, symptom onset is assumed to have occurred between July 15 and July 16 and we say that serial interval data are interval-censored. The figure below illustrates the coarse structure of SI data that adds a layer of complexity to the estimation problem. Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338. A recent article by Gressani and Hens (2025) published in PLOS Computational Biology proposes a new estimator of the cumulative distribution function of the serial interval without making parametric assumptions regarding the underlying SI distribution. The estimator is based on mixtures of uniform distributions and only requires left and right bounds of serial interval windows of infector-infectee pairs as a main input (\\(s_{iL}\\) and \\(s_{iR}\\) in the above figure). Point estimates of different serial interval features are available in closed-form and the bootstrap is used to compute confidence intervals. The nonparametric methodology is relatively simple and computationally fast and stable. Moreover, a user-friendly routine is available in the EpiDelays package written in R. This post aims at giving users a simple first experience with this new nonparametric methodology for serial interval estimation. The package can be installed from GitHub (using devtools) as follows: install.packages(\"devtools\") devtools::install_github(\"oswaldogressani/EpiDelays\") Simulated data The estimSI() routine of the EpiDelays package can be used to compute nonparametric estimates (point estimates with standard errors and confidence intervals) of different serial interval features (e.g. the mean, median, standard deviation). The routine is simple to use and requires only two inputs: x: A data frame with \\(n\\) rows (corresponding to the number of transmission pairs for which illness onset data is available) and two columns containing the lower bound of the SI window \\(s_{iL}\\) (first column) and the upper bound of the SI window \\(s_{iR}\\) (second column). nboot: An integer for the bootstrap sample size (default is 2000) used to construct (\\(90\\%\\) and \\(95\\%\\)) confidence intervals (CIs). We start by illustrating the use of estimSI() on simulated data. The simSI() routine can be used to simulate artificial serial interval data with SI windows having a width (coarseness) of at least two days. The underlying target SI distribution is assumed to have a Gaussian distribution with mean muS and standard deviation sdS that have to be specified by the user. The code below can be used to generate \\(n=15\\) SI windows from a Gaussian distribution with a mean of \\(3\\) days and standard deviation of \\(2\\) days. More details regarding the data generating mechanism can be found in the article. set.seed(2025) simdata",
    "meta_keywords": null,
    "og_description": "Motivation Epidemiological delays inform about the time between two well-defined events related to a disease. The serial interval (SI) of an infectious disease is defined as the time between symptom onset in a primary case (infector) and symptom onset in a secondary case (infectee). It is a widely used epidemiological delay quantity and plays a central role in mathematical/statistical models of disease transmission. There exists a tight link between the reproduction number (average number of secondary infections generated by an infected individual) and the serial interval. Therefore, getting accurate knowledge about the SI distribution is key to gain a clear understanding of transmission dynamics during outbreaks. Timings of symptom onset for infector-infectee pairs can be obtained from line list data and observations usually consist of calendar dates. From a mathematical perspective, it is more convenient to work with numbers than with calendar dates and the latter are typically transformed to integers for the sake of statistical analysis. The main challenge when working with SI data is censoring in the sense that exact symptom onset times are usually unobserved and only known to have occurred between two time points. If the time resolution of a reported timing of illness onset is a calendar day, for instance July 15, there is not enough information to determine the exact time of illness onset within that day. As such, symptom onset is assumed to have occurred between July 15 and July 16 and we say that serial interval data are interval-censored. The figure below illustrates the coarse structure of SI data that adds a layer of complexity to the estimation problem. Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338. A recent article by Gressani and Hens (2025) published in PLOS Computational Biology proposes a new estimator of the cumulative distribution function of the serial interval without making parametric assumptions regarding the underlying SI distribution. The estimator is based on mixtures of uniform distributions and only requires left and right bounds of serial interval windows of infector-infectee pairs as a main input (\\(s_{iL}\\) and \\(s_{iR}\\) in the above figure). Point estimates of different serial interval features are available in closed-form and the bootstrap is used to compute confidence intervals. The nonparametric methodology is relatively simple and computationally fast and stable. Moreover, a user-friendly routine is available in the EpiDelays package written in R. This post aims at giving users a simple first experience with this new nonparametric methodology for serial interval estimation. The package can be installed from GitHub (using devtools) as follows: install.packages(\"devtools\") devtools::install_github(\"oswaldogressani/EpiDelays\") Simulated data The estimSI() routine of the EpiDelays package can be used to compute nonparametric estimates (point estimates with standard errors and confidence intervals) of different serial interval features (e.g. the mean, median, standard deviation). The routine is simple to use and requires only two inputs: x: A data frame with \\(n\\) rows (corresponding to the number of transmission pairs for which illness onset data is available) and two columns containing the lower bound of the SI window \\(s_{iL}\\) (first column) and the upper bound of the SI window \\(s_{iR}\\) (second column). nboot: An integer for the bootstrap sample size (default is 2000) used to construct (\\(90\\%\\) and \\(95\\%\\)) confidence intervals (CIs). We start by illustrating the use of estimSI() on simulated data. The simSI() routine can be used to simulate artificial serial interval data with SI windows having a width (coarseness) of at least two days. The underlying target SI distribution is assumed to have a Gaussian distribution with mean muS and standard deviation sdS that have to be specified by the user. The code below can be used to generate \\(n=15\\) SI windows from a Gaussian distribution with a mean of \\(3\\) days and standard deviation of \\(2\\) days. More details regarding the data generating mechanism can be found in the article. set.seed(2025) simdata",
    "og_image": "https://statsandr.com/blog/nonparametric-serial-interval-estimation/images/SIcoarse.PNG",
    "og_title": "Nonparametric serial interval estimation | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 8.5,
    "sitemap_lastmod": null,
    "twitter_description": "Motivation Epidemiological delays inform about the time between two well-defined events related to a disease. The serial interval (SI) of an infectious disease is defined as the time between symptom onset in a primary case (infector) and symptom onset in a secondary case (infectee). It is a widely used epidemiological delay quantity and plays a central role in mathematical/statistical models of disease transmission. There exists a tight link between the reproduction number (average number of secondary infections generated by an infected individual) and the serial interval. Therefore, getting accurate knowledge about the SI distribution is key to gain a clear understanding of transmission dynamics during outbreaks. Timings of symptom onset for infector-infectee pairs can be obtained from line list data and observations usually consist of calendar dates. From a mathematical perspective, it is more convenient to work with numbers than with calendar dates and the latter are typically transformed to integers for the sake of statistical analysis. The main challenge when working with SI data is censoring in the sense that exact symptom onset times are usually unobserved and only known to have occurred between two time points. If the time resolution of a reported timing of illness onset is a calendar day, for instance July 15, there is not enough information to determine the exact time of illness onset within that day. As such, symptom onset is assumed to have occurred between July 15 and July 16 and we say that serial interval data are interval-censored. The figure below illustrates the coarse structure of SI data that adds a layer of complexity to the estimation problem. Source: Gressani O, Hens N. (2025). Nonparametric serial interval estimation with uniform mixtures. PLoS Comput Biol 21(8): e1013338. A recent article by Gressani and Hens (2025) published in PLOS Computational Biology proposes a new estimator of the cumulative distribution function of the serial interval without making parametric assumptions regarding the underlying SI distribution. The estimator is based on mixtures of uniform distributions and only requires left and right bounds of serial interval windows of infector-infectee pairs as a main input (\\(s_{iL}\\) and \\(s_{iR}\\) in the above figure). Point estimates of different serial interval features are available in closed-form and the bootstrap is used to compute confidence intervals. The nonparametric methodology is relatively simple and computationally fast and stable. Moreover, a user-friendly routine is available in the EpiDelays package written in R. This post aims at giving users a simple first experience with this new nonparametric methodology for serial interval estimation. The package can be installed from GitHub (using devtools) as follows: install.packages(\"devtools\") devtools::install_github(\"oswaldogressani/EpiDelays\") Simulated data The estimSI() routine of the EpiDelays package can be used to compute nonparametric estimates (point estimates with standard errors and confidence intervals) of different serial interval features (e.g. the mean, median, standard deviation). The routine is simple to use and requires only two inputs: x: A data frame with \\(n\\) rows (corresponding to the number of transmission pairs for which illness onset data is available) and two columns containing the lower bound of the SI window \\(s_{iL}\\) (first column) and the upper bound of the SI window \\(s_{iR}\\) (second column). nboot: An integer for the bootstrap sample size (default is 2000) used to construct (\\(90\\%\\) and \\(95\\%\\)) confidence intervals (CIs). We start by illustrating the use of estimSI() on simulated data. The simSI() routine can be used to simulate artificial serial interval data with SI windows having a width (coarseness) of at least two days. The underlying target SI distribution is assumed to have a Gaussian distribution with mean muS and standard deviation sdS that have to be specified by the user. The code below can be used to generate \\(n=15\\) SI windows from a Gaussian distribution with a mean of \\(3\\) days and standard deviation of \\(2\\) days. More details regarding the data generating mechanism can be found in the article. set.seed(2025) simdata",
    "twitter_title": "Nonparametric serial interval estimation | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/08/nonparametric-serial-interval-estimation/",
    "word_count": 1702
  }
}