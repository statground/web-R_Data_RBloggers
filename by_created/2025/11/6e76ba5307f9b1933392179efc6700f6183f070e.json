{
  "id": "6e76ba5307f9b1933392179efc6700f6183f070e",
  "url": "https://www.r-bloggers.com/2023/11/efficient-row-min-calculation-from-r-to-c-2/",
  "created_at_utc": "2025-11-17T20:39:16Z",
  "data": null,
  "raw_original": {
    "uuid": "75cf10c5-8b1a-40cf-9996-b5f5410743e1",
    "created_at": "2025-11-17 20:39:16",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/11/efficient-row-min-calculation-from-r-to-c-2/",
      "crawled_at": "2025-11-17T09:56:28.146264",
      "external_links": [
        {
          "href": "http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c/",
          "text": "schochastics - all things R"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "http://archive.schochastics.net/post/efficient-row-min-calculation-from-r-to-c/",
          "text": "archive"
        },
        {
          "href": "https://github.com/chainsawriot",
          "text": "Chung-hong Chan"
        },
        {
          "href": "https://github.com/gesistsa/quanteda.proximity",
          "text": "new package"
        },
        {
          "href": "https://github.com/gesistsa",
          "text": "GitHub organization"
        },
        {
          "href": "https://github.com/gesistsa/quanteda.proximity/issues/20#issue-1995146464",
          "text": "An issue"
        },
        {
          "href": "https://github.com/gesistsa/quanteda.proximity/blob/34377dc140a02dd473e7be53f0f249c676d198ce/R/get_dist.R#L1-L38",
          "text": "auxiliary"
        },
        {
          "href": "https://creativecommons.org/licenses/by/4.0/",
          "text": "CC BY 4.0"
        },
        {
          "href": "http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c",
          "text": "http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c"
        },
        {
          "href": "http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c/",
          "text": "schochastics - all things R"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Efficient row min calculation: From R to C | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/david-schoch/",
          "text": "David Schoch"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-381250 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Efficient row min calculation: From R to C</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 15, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/david-schoch/\">David Schoch</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c/\"> schochastics - all things R</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<p><em>This post was semi automatically converted from blogdown to Quarto and may contain errors. The original can be found in the <a href=\"http://archive.schochastics.net/post/efficient-row-min-calculation-from-r-to-c/\" rel=\"nofollow\" target=\"_blank\">archive</a>.</em></p>\n<p>My colleague <a href=\"https://github.com/chainsawriot\" rel=\"nofollow\" target=\"_blank\">Chung-hong Chan</a> started a <a href=\"https://github.com/gesistsa/quanteda.proximity\" rel=\"nofollow\" target=\"_blank\">new package</a> in our teams <a href=\"https://github.com/gesistsa\" rel=\"nofollow\" target=\"_blank\">GitHub organization</a>. <a href=\"https://github.com/gesistsa/quanteda.proximity/issues/20#issue-1995146464\" rel=\"nofollow\" target=\"_blank\">An issue</a> there caught my attention. The performance was very slow of the main function. The issue lay somewhere in the <a href=\"https://github.com/gesistsa/quanteda.proximity/blob/34377dc140a02dd473e7be53f0f249c676d198ce/R/get_dist.R#L1-L38\" rel=\"nofollow\" target=\"_blank\">auxiliary</a> functions. This lead me down quite a rabbit hole to optimize the calculation of row minimums (you can skip the prelude, if you are not interested in the backstory).</p>\n<section class=\"level2\" id=\"prelude\">\n<h2 class=\"anchored\" data-anchor-id=\"prelude\">Prelude</h2>\n<p>My goal initially was just to try to work around the identified bottleneck of the auxiliary functions I isolated the bottleneck part into a separate function, which looked like this.</p>\n<pre># helper functions taken from the package\n.cal_dist &lt;- function(y, poss) {\n    return(abs(y - poss))\n}\n\n.get_min &lt;- function(pos, x) {\n    min(purrr::map_dbl(x, pos))\n}\n\ntarget_idx &lt;- c(4,7)\nposs &lt;- 1:1547\ncount_from &lt;- 1\npurrr_min &lt;- function(){\n  res &lt;- lapply(target_idx, .cal_dist, poss = poss)\n  purrr::map_dbl(poss, .get_min, x = res) + count_from\n}\nhead(purrr_min())\r\n## [1] 4 3 2 1 2 2</pre>\n<p>There is a lot of code here that is specific to the original structure of the package but in essence <code>purrr_min</code> calculates the distance for each element in <code>poss</code> to the indices <code>target_idx</code>. The output should be the minimum distance to any index in <code>target_idx</code> (incremented by <code>count_from</code>).</p>\n<pre>bench::mark(\n  purrr_min()\n)\r\n## Warning: Some expressions had a GC in every iteration; so filtering is\n## disabled.\r\n## # A tibble: 1 × 6\n##   expression       min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 purrr_min()   79.5ms   81.4ms      12.3    64.8KB     14.1</pre>\n<p>The performance of one call is not too bad, but this has to be done many times over and runtime accumulates quite quickly. The original code was working with lists and purrr, but it is possible to also see this as a matrix problem: Build a matrix with <code>length(target_idx)</code> columns and <code>length(poss)</code> rows and an entry (i,j) of the matrix is the distance of item i in <code>poss</code> to item j in <code>target_idx</code>. All that is left to do, is calculate the minimum in each row to get the same output as above. This can be a “simple” apply call.</p>\n<pre>apply_min &lt;- function(){\n  res &lt;- sapply(target_idx, .cal_dist, poss = poss)\n  apply(res,1,min)+count_from\n}\r\nbench::mark(\n  purrr_min(),\n  apply_min()\n)\r\n## Warning: Some expressions had a GC in every iteration; so filtering is\n## disabled.\r\n## # A tibble: 2 × 6\n##   expression       min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 purrr_min()  82.99ms  83.71ms      11.7    48.5KB     15.6\n## 2 apply_min()   1.74ms   1.84ms     504.    151.3KB     20.0</pre>\n<p>The speed up is insane (it was actually quite surprising to me!). But can this be even faster?</p>\n</section>\n<section class=\"level1\" id=\"calculating-row-minimum-fast\">\n<h1>Calculating row minimum fast</h1>\n<p>The prelude established the following optimization problem: Calculate the minimum in each row of an (integer!) matrix fast. We will work with the following matrix.</p>\n<pre>set.seed(654)\nm &lt;- matrix(sample(1:20, 50000, replace = TRUE), ncol = 5)</pre>\n<section class=\"level2\" id=\"pure-r-solutions\">\n<h2 class=\"anchored\" data-anchor-id=\"pure-r-solutions\">Pure R solutions</h2>\n<p>The function derived in the prelude is based on <code>apply</code>.</p>\n<pre>rowmin_apply &lt;- function(x){\n  apply(x,1,min)\n}\r\nbench::mark(\n  rowmin_apply(m)\n)\r\n## # A tibble: 1 × 6\n##   expression           min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 rowmin_apply(m)   11.9ms   14.3ms      68.7     391KB     22.0</pre>\n<p>Can this be improved? As a matter of fact, it can and the solution might surprise a little.</p>\n<pre>rowmin_pmin &lt;- function(x){\n  do.call(pmin, as.data.frame(x))\n}</pre>\n<p>The function converts the matrix x to a data frame (<code>pmin</code> doesn’t work with matrices) and then applies <code>pmin</code> across it. The <code>pmin</code> function takes multiple vectors as input and returns a vector of the minimum values at each position. <code>do.call</code> is used to apply <code>pmin</code> across all columns of the data frame (which are the rows of your original matrix).</p>\n<p>This method is more efficient because <code>pmin</code> is vectorized and <code>do.call</code> efficiently passes the columns of the data frame as arguments to <code>pmin</code>.</p>\n<pre>bench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m)\n)\r\n## # A tibble: 2 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 apply        13.2ms   14.6ms      67.9     391KB     26.6\n## 2 pmin        355.2µs  446.2µs    2050.      430KB     17.7</pre>\n<p>That is quite a speedup for a function that looks totally off. You can squeeze out a little bit more by using the fact the matrix has only integer values.</p>\n<pre>rowmin_pmin.int &lt;- function(x){\n  do.call(pmin.int, as.data.frame(x))\n}\r\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n)\r\n## # A tibble: 3 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 apply        13.2ms   14.1ms      68.3     391KB     21.8\n## 2 pmin        356.9µs  406.4µs    2418.      430KB     19.5\n## 3 pmin.int    354.4µs  411.7µs    2371.      433KB     19.6</pre>\n<p>At this point, I was sure that I will not be able to squeeze out more in pure R (maybe there is a way?).</p>\n</section>\n<section class=\"level2\" id=\"cc-solutions\">\n<h2 class=\"anchored\" data-anchor-id=\"cc-solutions\">C++/C solutions</h2>\n<p>An obvious way to keep optimizing the solution is to switch to Rcpp. Now my C++ skills are still not the best, but I gave a naïve implementation a shot.</p>\n<pre>Rcpp::cppFunction(\n\"\nNumericVector rowmin_cpp_naive(NumericMatrix mat) {\n    int nRows = mat.nrow();\n    int nCols = mat.ncol();\n    NumericVector mins(nRows);\n\n    for(int i = 0; i &lt; nRows; ++i) {\n        double minVal = mat(i, 0);\n        for(int j = 1; j &lt; nCols; ++j) {\n            if(mat(i, j) &lt; minVal) {\n                minVal = mat(i, j);\n            }\n        }\n        mins[i] = minVal;\n    }\n    return mins;\n}\n\"\n)\r\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n  cpp_naive = rowmin_cpp_naive(m)\n)\r\n## # A tibble: 4 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 apply        12.1ms   12.5ms      77.0     391KB     38.5\n## 2 pmin        403.7µs  495.2µs    1772.      430KB     13.6\n## 3 pmin.int    383.8µs  424.8µs    2241.      430KB     19.2\n## 4 cpp_naive   103.8µs  120.9µs    7717.      471KB     70.7</pre>\n<p>Nice, so a straightforward C++ implementation is faster. This can probably be optimized even more, but I didn’t get much further than this.</p>\n<p>Out of pure curiosity, I also ventured into C. My C is really bad, but I got something to work.</p>\n<pre>rowmin_c_naive &lt;- inline::cfunction(\n    signature(mat = \"integer\", nRows = \"integer\", nCols = \"integer\"),\n    body = \"\n    int nrows = INTEGER(nRows)[0];\n    int ncols = INTEGER(nCols)[0];\n    SEXP mins = PROTECT(allocVector(INTSXP, nrows));\n    int *pmat = INTEGER(mat);\n    int *pmins = INTEGER(mins);\n\n    for(int i = 0; i &lt; nrows; i++) {\n        int minVal = pmat[i];\n        for(int j = 1; j &lt; ncols; j++) {\n            int currentVal = pmat[i + j * nrows];\n            if (currentVal &lt; minVal) {\n                minVal = currentVal;\n            }\n        }\n        pmins[i] = minVal;\n    }\n\n    UNPROTECT(1);\n    return mins;\n  \",\n    language = \"C\"\n)\r\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n  cpp_naive = rowmin_cpp_naive(m),\n  c_naive = rowmin_c_naive(m,nrow(m), ncol(m))\n)\r\n## # A tibble: 5 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n## 1 apply        11.9ms   12.8ms      77.1   390.9KB     33.9\n## 2 pmin        346.9µs  400.2µs    2422.    430.2KB     22.4\n## 3 pmin.int    325.8µs  364.5µs    2622.    430.2KB     21.4\n## 4 cpp_naive    90.2µs  106.3µs    8468.    471.3KB     79.7\n## 5 c_naive      29.6µs     31µs   29544.     39.1KB     20.7</pre>\n<p>Again, probably still room for improvement, but I was not expecting to squeeze out that much with C.</p>\n</section>\n</section>\n<div class=\"default\" id=\"quarto-appendix\"><section class=\"quarto-appendix-contents\"><h2 class=\"anchored quarto-appendix-heading\">Reuse</h2><div class=\"quarto-appendix-contents\" id=\"quarto-reuse\"><div><a href=\"https://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\" target=\"_blank\">CC BY 4.0</a></div></div></section><section class=\"quarto-appendix-contents\"><h2 class=\"anchored quarto-appendix-heading\">Citation</h2><div><div class=\"quarto-appendix-secondary-label\">BibTeX citation:</div><pre>@online{schoch2023,\n  author = {Schoch, David},\n  title = {Efficient Row Min Calculation: {From} {R} to {C}},\n  date = {2023-11-16},\n  url = {http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c},\n  langid = {en}\n}\n</pre><div class=\"quarto-appendix-secondary-label\">For attribution, please cite this work as:</div><div class=\"csl-entry quarto-appendix-citeas\" id=\"ref-schoch2023\">\nSchoch, David. 2023. <span>“Efficient Row Min Calculation: From R to\nC.”</span> November 16, 2023. <a href=\"http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c\" rel=\"nofollow\" target=\"_blank\">http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c</a>.\n</div></div></section></div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c/\"> schochastics - all things R</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
      "main_text": "Efficient row min calculation: From R to C\nPosted on\nNovember 15, 2023\nby\nDavid Schoch\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nschochastics - all things R\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nThis post was semi automatically converted from blogdown to Quarto and may contain errors. The original can be found in the\narchive\n.\nMy colleague\nChung-hong Chan\nstarted a\nnew package\nin our teams\nGitHub organization\n.\nAn issue\nthere caught my attention. The performance was very slow of the main function. The issue lay somewhere in the\nauxiliary\nfunctions. This lead me down quite a rabbit hole to optimize the calculation of row minimums (you can skip the prelude, if you are not interested in the backstory).\nPrelude\nMy goal initially was just to try to work around the identified bottleneck of the auxiliary functions I isolated the bottleneck part into a separate function, which looked like this.\n# helper functions taken from the package\n.cal_dist <- function(y, poss) {\n    return(abs(y - poss))\n}\n\n.get_min <- function(pos, x) {\n    min(purrr::map_dbl(x, pos))\n}\n\ntarget_idx <- c(4,7)\nposs <- 1:1547\ncount_from <- 1\npurrr_min <- function(){\n  res <- lapply(target_idx, .cal_dist, poss = poss)\n  purrr::map_dbl(poss, .get_min, x = res) + count_from\n}\nhead(purrr_min())\n## [1] 4 3 2 1 2 2\nThere is a lot of code here that is specific to the original structure of the package but in essence\npurrr_min\ncalculates the distance for each element in\nposs\nto the indices\ntarget_idx\n. The output should be the minimum distance to any index in\ntarget_idx\n(incremented by\ncount_from\n).\nbench::mark(\n  purrr_min()\n)\n## Warning: Some expressions had a GC in every iteration; so filtering is\n## disabled.\n## # A tibble: 1 × 6\n##   expression       min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 purrr_min()   79.5ms   81.4ms      12.3    64.8KB     14.1\nThe performance of one call is not too bad, but this has to be done many times over and runtime accumulates quite quickly. The original code was working with lists and purrr, but it is possible to also see this as a matrix problem: Build a matrix with\nlength(target_idx)\ncolumns and\nlength(poss)\nrows and an entry (i,j) of the matrix is the distance of item i in\nposs\nto item j in\ntarget_idx\n. All that is left to do, is calculate the minimum in each row to get the same output as above. This can be a “simple” apply call.\napply_min <- function(){\n  res <- sapply(target_idx, .cal_dist, poss = poss)\n  apply(res,1,min)+count_from\n}\nbench::mark(\n  purrr_min(),\n  apply_min()\n)\n## Warning: Some expressions had a GC in every iteration; so filtering is\n## disabled.\n## # A tibble: 2 × 6\n##   expression       min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 purrr_min()  82.99ms  83.71ms      11.7    48.5KB     15.6\n## 2 apply_min()   1.74ms   1.84ms     504.    151.3KB     20.0\nThe speed up is insane (it was actually quite surprising to me!). But can this be even faster?\nCalculating row minimum fast\nThe prelude established the following optimization problem: Calculate the minimum in each row of an (integer!) matrix fast. We will work with the following matrix.\nset.seed(654)\nm <- matrix(sample(1:20, 50000, replace = TRUE), ncol = 5)\nPure R solutions\nThe function derived in the prelude is based on\napply\n.\nrowmin_apply <- function(x){\n  apply(x,1,min)\n}\nbench::mark(\n  rowmin_apply(m)\n)\n## # A tibble: 1 × 6\n##   expression           min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 rowmin_apply(m)   11.9ms   14.3ms      68.7     391KB     22.0\nCan this be improved? As a matter of fact, it can and the solution might surprise a little.\nrowmin_pmin <- function(x){\n  do.call(pmin, as.data.frame(x))\n}\nThe function converts the matrix x to a data frame (\npmin\ndoesn’t work with matrices) and then applies\npmin\nacross it. The\npmin\nfunction takes multiple vectors as input and returns a vector of the minimum values at each position.\ndo.call\nis used to apply\npmin\nacross all columns of the data frame (which are the rows of your original matrix).\nThis method is more efficient because\npmin\nis vectorized and\ndo.call\nefficiently passes the columns of the data frame as arguments to\npmin\n.\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m)\n)\n## # A tibble: 2 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 apply        13.2ms   14.6ms      67.9     391KB     26.6\n## 2 pmin        355.2µs  446.2µs    2050.      430KB     17.7\nThat is quite a speedup for a function that looks totally off. You can squeeze out a little bit more by using the fact the matrix has only integer values.\nrowmin_pmin.int <- function(x){\n  do.call(pmin.int, as.data.frame(x))\n}\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n)\n## # A tibble: 3 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 apply        13.2ms   14.1ms      68.3     391KB     21.8\n## 2 pmin        356.9µs  406.4µs    2418.      430KB     19.5\n## 3 pmin.int    354.4µs  411.7µs    2371.      433KB     19.6\nAt this point, I was sure that I will not be able to squeeze out more in pure R (maybe there is a way?).\nC++/C solutions\nAn obvious way to keep optimizing the solution is to switch to Rcpp. Now my C++ skills are still not the best, but I gave a naïve implementation a shot.\nRcpp::cppFunction(\n\"\nNumericVector rowmin_cpp_naive(NumericMatrix mat) {\n    int nRows = mat.nrow();\n    int nCols = mat.ncol();\n    NumericVector mins(nRows);\n\n    for(int i = 0; i < nRows; ++i) {\n        double minVal = mat(i, 0);\n        for(int j = 1; j < nCols; ++j) {\n            if(mat(i, j) < minVal) {\n                minVal = mat(i, j);\n            }\n        }\n        mins[i] = minVal;\n    }\n    return mins;\n}\n\"\n)\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n  cpp_naive = rowmin_cpp_naive(m)\n)\n## # A tibble: 4 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 apply        12.1ms   12.5ms      77.0     391KB     38.5\n## 2 pmin        403.7µs  495.2µs    1772.      430KB     13.6\n## 3 pmin.int    383.8µs  424.8µs    2241.      430KB     19.2\n## 4 cpp_naive   103.8µs  120.9µs    7717.      471KB     70.7\nNice, so a straightforward C++ implementation is faster. This can probably be optimized even more, but I didn’t get much further than this.\nOut of pure curiosity, I also ventured into C. My C is really bad, but I got something to work.\nrowmin_c_naive <- inline::cfunction(\n    signature(mat = \"integer\", nRows = \"integer\", nCols = \"integer\"),\n    body = \"\n    int nrows = INTEGER(nRows)[0];\n    int ncols = INTEGER(nCols)[0];\n    SEXP mins = PROTECT(allocVector(INTSXP, nrows));\n    int *pmat = INTEGER(mat);\n    int *pmins = INTEGER(mins);\n\n    for(int i = 0; i < nrows; i++) {\n        int minVal = pmat[i];\n        for(int j = 1; j < ncols; j++) {\n            int currentVal = pmat[i + j * nrows];\n            if (currentVal < minVal) {\n                minVal = currentVal;\n            }\n        }\n        pmins[i] = minVal;\n    }\n\n    UNPROTECT(1);\n    return mins;\n  \",\n    language = \"C\"\n)\nbench::mark(\n  apply = rowmin_apply(m),\n  pmin = rowmin_pmin(m),\n  pmin.int = rowmin_pmin.int(m),\n  cpp_naive = rowmin_cpp_naive(m),\n  c_naive = rowmin_c_naive(m,nrow(m), ncol(m))\n)\n## # A tibble: 5 × 6\n##   expression      min   median `itr/sec` mem_alloc `gc/sec`\n##   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n## 1 apply        11.9ms   12.8ms      77.1   390.9KB     33.9\n## 2 pmin        346.9µs  400.2µs    2422.    430.2KB     22.4\n## 3 pmin.int    325.8µs  364.5µs    2622.    430.2KB     21.4\n## 4 cpp_naive    90.2µs  106.3µs    8468.    471.3KB     79.7\n## 5 c_naive      29.6µs     31µs   29544.     39.1KB     20.7\nAgain, probably still room for improvement, but I was not expecting to squeeze out that much with C.\nReuse\nCC BY 4.0\nCitation\nBibTeX citation:\n@online{schoch2023,\n  author = {Schoch, David},\n  title = {Efficient Row Min Calculation: {From} {R} to {C}},\n  date = {2023-11-16},\n  url = {http://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSchoch, David. 2023.\n“Efficient Row Min Calculation: From R to\nC.”\nNovember 16, 2023.\nhttp://blog.schochastics.net/posts/2023-11-16_efficient-row-min-calculation-from-r-to-c\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nschochastics - all things R\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "This post was semi automatically converted from blogdown to Quarto and may contain errors. The original can be found in the archive. My colleague Chung-hong Chan started a new package in our teams GitHub organization. An issue there caught my at...",
      "meta_keywords": null,
      "og_description": "This post was semi automatically converted from blogdown to Quarto and may contain errors. The original can be found in the archive. My colleague Chung-hong Chan started a new package in our teams GitHub organization. An issue there caught my at...",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Efficient row min calculation: From R to C | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 7.5,
      "sitemap_lastmod": "2023-11-15T23:00:00+00:00",
      "twitter_description": "This post was semi automatically converted from blogdown to Quarto and may contain errors. The original can be found in the archive. My colleague Chung-hong Chan started a new package in our teams GitHub organization. An issue there caught my at...",
      "twitter_title": "Efficient row min calculation: From R to C | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/11/efficient-row-min-calculation-from-r-to-c-2/",
      "word_count": 1492
    }
  }
}