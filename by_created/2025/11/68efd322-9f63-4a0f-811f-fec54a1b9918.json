{
  "uuid": "68efd322-9f63-4a0f-811f-fec54a1b9918",
  "created_at": "2025-11-22 19:57:52",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/08/how-to-write-robust-shinytest2-tests-for-r-shiny-apps/",
    "crawled_at": "2025-11-22T10:44:15.772644",
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/robust-shinytest2",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://rstudio.github.io/htmltools/reference/tagAppendAttributes.html",
        "text": "htmltools::tagApendAttributes"
      },
      {
        "href": "https://jakubsobolewski.com/cucumber/",
        "text": "Cucumber"
      },
      {
        "href": "https://jakubsobolewski.com/cucumber/",
        "text": "Cucumber"
      },
      {
        "href": "https://jakubsobolewski.com/blog/robust-shinytest2",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "How to Write Robust shinytest2 Tests for R Shiny Apps | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-394889 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">How to Write Robust shinytest2 Tests for R Shiny Apps</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">August 17, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/robust-shinytest2\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Most shinytest2 tests break too easily.</p>\n<p>They expose fragile details of your app that break your tests as your implementation changes. It’s either by doing snapshots or by using raw input IDs. But you can take back control: make tests describe <em>behavior</em>, not wiring.</p>\n<h2 id=\"the-problem-with-raw-shinytest2\">The problem with raw shinytest2</h2>\n<p>shinytest2 is great.</p>\n<p>It really democratizes testing for Shiny apps. It’s easy to install. It’s easy to get your Shiny tests up and running.</p>\n<p>But unfortunately it couples your tests tightly with internals of Shiny and entices you to use fragile snapshots. A default, very minimal <code>shinytest2</code> test will looks like this (and this probably as simple as you can get):</p>\n<pre>test_that(\"...\", {\n  driver &lt;- shinytest2::AppDriver$new()\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$set_inputs(\"plots-colorby\" = \"AGE\")\n  # Verify outcome\n})</pre>\n<p>It works, but it leaks app internals. Input IDs change when you refactor, redesign, or just evolve your app. Setting inputs through raw IDs ties your tests to the “how,” not the “what.”</p>\n<p>Your test can fail not because behavior changed, but because your selectors did.</p>\n<h2 id=\"step-1-use-data-testid-instead-of-input-ids\">Step 1. Use <code>data-testid</code> instead of input IDs</h2>\n<p><a href=\"https://rstudio.github.io/htmltools/reference/tagAppendAttributes.html\" rel=\"nofollow\" target=\"_blank\">htmltools::tagApendAttributes</a> allows you to decorate widgets with attributes. One of the best gifts you can give your tests: add <code>data-testid</code> (or use a different attribute name, but use it for testing only).</p>\n<ul>\n<li><code>id</code> of an input or output changes when your Shiny code evolves.</li>\n<li><code>data-testid</code> changes only when <em>business meaning</em> changes.</li>\n</ul>\n<p>This keeps tests aligned with logic, not code structure.</p>\n<h3 id=\"refactor-your-components-to-attach-data-testid\">Refactor your components to attach <code>data-testid</code></h3>\n<pre>picker_input &lt;- function(inputId, ..., testid) {\n  shinyWidgets::pickerInput(\n    inputId,\n    ...\n  ) |&gt;\n    htmltools::tagAppendAttributes(\n      `data-testid` = testid,\n      .cssSelector = \"select\"\n    )\n}</pre>\n<p>Ensure you attach <code>data-testid</code> to the HTML tag with input ID. In case of <code>shinyWidgets::pickerInput</code> it’s the <code>select</code> tag. Then in the app code, replace <code>pickerInput(...)</code> with for example <code>picker_input(..., testid = \"plot_color_variable\")</code>.</p>\n<p>It’s a very safe refactoring, don’t worry.</p>\n<p>Then instead of using input IDs in test code we can use <code>data-testid</code> to get the input ID:</p>\n<pre>driver &lt;- shinytest2::AppDriver$new()\nid &lt;- driver$get_js(\n  sprintf(\"$('[data-testid=%s]').attr('id')\", testable_id)\n)\ndriver$set_inputs(!!!rlang::list2(!!id := \"AGE\"))</pre>\n<p>Now it looks quite complex, but it’ll get better.</p>\n<h3 id=\"use-data-testtype-for-smarter-dispatch\">Use <code>data-testtype</code> for smarter dispatch</h3>\n<p>Another simple refactoring that will make our testing lives easier is adding <code>data-testtype</code>.</p>\n<p>Why do this?</p>\n<ul>\n<li><code>data-testid</code> tells us which is the component we want to interact with,</li>\n<li><code>data-testtype</code> tells us how to interact with the component.</li>\n</ul>\n<p>Let’s create a unique <code>data-testtype</code> for each component in our library:</p>\n<pre>picker_input &lt;- function(inputId, ..., testid) {\n  shinyWidgets::pickerInput(\n    inputId,\n    ...\n  ) |&gt;\n    htmltools::tagAppendAttributes(\n      `data-testid` = testid,\n      `data-testtype` = \"picker_input\",\n      .cssSelector = \"select\"\n    )\n}</pre>\n<p>The easiest choice is to just use the name of component we’re using. It will be easy to correlate with from the test code.</p>\n<h2 id=\"step-3-refactor-test-code\">Step 3. Refactor test code</h2>\n<p>Now instead of using <code>AppDriver</code> directly, we extend it with our own driver class that uses <code>data-testid</code> and <code>data-testtype</code> to localize components.</p>\n<pre>action &lt;- function(type, id, ..., driver) {\n  switch(type,\n    action_button = driver$click(id),\n    picker_input = driver$set_inputs(\n      !!!rlang::list2(!!id := rlang::list2(...)[[1]])\n    )\n  )\n}\n\nShinyDriver &lt;- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    dispatch = function(testable_id = missing_arg(), ...) {\n      id &lt;- self$get_js(\n        sprintf(\"$('[data-testid=%s]').attr('id')\", testable_id)\n      )\n      type &lt;- self$get_js(\n        sprintf(\"$('[data-testid=%s]').attr('data-testtype')\", testable_id)\n      )\n      action(type, id, ..., driver = self)\n    }\n  )\n)</pre>\n<p>Then our test becomes:</p>\n<pre>test_that(\"...\", {\n  # Given\n  driver &lt;- ShinyDriver$new()\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n\n  # When\n  driver$dispatch(\"plot_color_variable\", c(\"AGE\"))\n\n  # Then\n  # Verify the outcome\n\n  # Teardown\n  driver$stop()\n})</pre>\n<h2 id=\"step-4-wrap-reusable-actions-in-step-functions\">Step 4. Wrap reusable actions in step-functions</h2>\n<p>Tests are for humans to read first, machines second. Wrapping common interactions in functions gives your test language:</p>\n<pre>i_use_default_mapping &lt;- function(driver) {\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n}\n\ni_set &lt;- function(what, to, driver) {\n  driver$dispatch(what, to)\n}</pre>\n<p>Now your test looks like this:</p>\n<pre>test_that(\"...\", {\n  # Given\n  driver &lt;- ShinyDriver$new()\n  i_use_default_mapping(driver)\n\n  # When\n  i_set(\"plot_color_variable\", to = \"AGE\", driver)\n\n  # Then\n  # Verify the outcome\n\n  # Teardown\n  driver$stop()\n})</pre>\n<p>You read it as: <em>Given I use the default mapping, when I set the plot color variable to AGE, then I should see the plot.</em></p>\n<p>That’s <strong>executable specification.</strong></p>\n<h2 id=\"step-5-use-cucumber-optional\">Step 5. Use <a href=\"https://jakubsobolewski.com/cucumber/\" rel=\"nofollow\" target=\"_blank\">Cucumber</a> (Optional)</h2>\n<p>From there you can see that we almost obtained <a href=\"https://jakubsobolewski.com/cucumber/\" rel=\"nofollow\" target=\"_blank\">Cucumber</a> syntax with code.</p>\n<p>To facilitate collaboration between developers and non-developers, you can use Cucumber to write your tests in an even more natural language format. This allows stakeholders to understand and contribute to the testing process more easily.</p>\n<p>Then this test case would become:</p>\n<pre>Given I use default mapping\nWhen I set \"plot_color_variable\" to \"AGE\"\n# Then verify the outcome</pre>\n<hr/>\n<p>With this approach we organize our test code towards:</p>\n<ul>\n<li><strong>Readability</strong>: Tests are easier to read and understand.</li>\n<li><strong>Reusability</strong>: Common actions are encapsulated in functions.</li>\n<li><strong>Maintainability</strong>: Changes in the app’s UI require minimal (<strong>or no!</strong>) changes in tests.</li>\n</ul>\n<p>This approach preserves business meaning of tests, enables tests to evolve alongside your codebase, allowing you to keep your development speed high.</p>\n<hr/>\n<p><strong>Don’t let your tests chase implementation details.</strong></p>\n<p>Equip them with stable hooks, let the driver dispatch actions smartly, and express behavior with reusable steps. With these four steps, your <code>shinytest2</code> suite speaks the same language as your users: actions, not wiring, and makes tests maintenance easier.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/robust-shinytest2\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "How to Write Robust shinytest2 Tests for R Shiny Apps\nPosted on\nAugust 17, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nMost shinytest2 tests break too easily.\nThey expose fragile details of your app that break your tests as your implementation changes. It’s either by doing snapshots or by using raw input IDs. But you can take back control: make tests describe\nbehavior\n, not wiring.\nThe problem with raw shinytest2\nshinytest2 is great.\nIt really democratizes testing for Shiny apps. It’s easy to install. It’s easy to get your Shiny tests up and running.\nBut unfortunately it couples your tests tightly with internals of Shiny and entices you to use fragile snapshots. A default, very minimal\nshinytest2\ntest will looks like this (and this probably as simple as you can get):\ntest_that(\"...\", {\n  driver <- shinytest2::AppDriver$new()\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$click(\"setup-data-next\")\n  driver$set_inputs(\"plots-colorby\" = \"AGE\")\n  # Verify outcome\n})\nIt works, but it leaks app internals. Input IDs change when you refactor, redesign, or just evolve your app. Setting inputs through raw IDs ties your tests to the “how,” not the “what.”\nYour test can fail not because behavior changed, but because your selectors did.\nStep 1. Use\ndata-testid\ninstead of input IDs\nhtmltools::tagApendAttributes\nallows you to decorate widgets with attributes. One of the best gifts you can give your tests: add\ndata-testid\n(or use a different attribute name, but use it for testing only).\nid\nof an input or output changes when your Shiny code evolves.\ndata-testid\nchanges only when\nbusiness meaning\nchanges.\nThis keeps tests aligned with logic, not code structure.\nRefactor your components to attach\ndata-testid\npicker_input <- function(inputId, ..., testid) {\n  shinyWidgets::pickerInput(\n    inputId,\n    ...\n  ) |>\n    htmltools::tagAppendAttributes(\n      `data-testid` = testid,\n      .cssSelector = \"select\"\n    )\n}\nEnsure you attach\ndata-testid\nto the HTML tag with input ID. In case of\nshinyWidgets::pickerInput\nit’s the\nselect\ntag. Then in the app code, replace\npickerInput(...)\nwith for example\npicker_input(..., testid = \"plot_color_variable\")\n.\nIt’s a very safe refactoring, don’t worry.\nThen instead of using input IDs in test code we can use\ndata-testid\nto get the input ID:\ndriver <- shinytest2::AppDriver$new()\nid <- driver$get_js(\n  sprintf(\"$('[data-testid=%s]').attr('id')\", testable_id)\n)\ndriver$set_inputs(!!!rlang::list2(!!id := \"AGE\"))\nNow it looks quite complex, but it’ll get better.\nUse\ndata-testtype\nfor smarter dispatch\nAnother simple refactoring that will make our testing lives easier is adding\ndata-testtype\n.\nWhy do this?\ndata-testid\ntells us which is the component we want to interact with,\ndata-testtype\ntells us how to interact with the component.\nLet’s create a unique\ndata-testtype\nfor each component in our library:\npicker_input <- function(inputId, ..., testid) {\n  shinyWidgets::pickerInput(\n    inputId,\n    ...\n  ) |>\n    htmltools::tagAppendAttributes(\n      `data-testid` = testid,\n      `data-testtype` = \"picker_input\",\n      .cssSelector = \"select\"\n    )\n}\nThe easiest choice is to just use the name of component we’re using. It will be easy to correlate with from the test code.\nStep 3. Refactor test code\nNow instead of using\nAppDriver\ndirectly, we extend it with our own driver class that uses\ndata-testid\nand\ndata-testtype\nto localize components.\naction <- function(type, id, ..., driver) {\n  switch(type,\n    action_button = driver$click(id),\n    picker_input = driver$set_inputs(\n      !!!rlang::list2(!!id := rlang::list2(...)[[1]])\n    )\n  )\n}\n\nShinyDriver <- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    dispatch = function(testable_id = missing_arg(), ...) {\n      id <- self$get_js(\n        sprintf(\"$('[data-testid=%s]').attr('id')\", testable_id)\n      )\n      type <- self$get_js(\n        sprintf(\"$('[data-testid=%s]').attr('data-testtype')\", testable_id)\n      )\n      action(type, id, ..., driver = self)\n    }\n  )\n)\nThen our test becomes:\ntest_that(\"...\", {\n  # Given\n  driver <- ShinyDriver$new()\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n\n  # When\n  driver$dispatch(\"plot_color_variable\", c(\"AGE\"))\n\n  # Then\n  # Verify the outcome\n\n  # Teardown\n  driver$stop()\n})\nStep 4. Wrap reusable actions in step-functions\nTests are for humans to read first, machines second. Wrapping common interactions in functions gives your test language:\ni_use_default_mapping <- function(driver) {\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n  driver$dispatch(\"next\")\n}\n\ni_set <- function(what, to, driver) {\n  driver$dispatch(what, to)\n}\nNow your test looks like this:\ntest_that(\"...\", {\n  # Given\n  driver <- ShinyDriver$new()\n  i_use_default_mapping(driver)\n\n  # When\n  i_set(\"plot_color_variable\", to = \"AGE\", driver)\n\n  # Then\n  # Verify the outcome\n\n  # Teardown\n  driver$stop()\n})\nYou read it as:\nGiven I use the default mapping, when I set the plot color variable to AGE, then I should see the plot.\nThat’s\nexecutable specification.\nStep 5. Use\nCucumber\n(Optional)\nFrom there you can see that we almost obtained\nCucumber\nsyntax with code.\nTo facilitate collaboration between developers and non-developers, you can use Cucumber to write your tests in an even more natural language format. This allows stakeholders to understand and contribute to the testing process more easily.\nThen this test case would become:\nGiven I use default mapping\nWhen I set \"plot_color_variable\" to \"AGE\"\n# Then verify the outcome\nWith this approach we organize our test code towards:\nReadability\n: Tests are easier to read and understand.\nReusability\n: Common actions are encapsulated in functions.\nMaintainability\n: Changes in the app’s UI require minimal (\nor no!\n) changes in tests.\nThis approach preserves business meaning of tests, enables tests to evolve alongside your codebase, allowing you to keep your development speed high.\nDon’t let your tests chase implementation details.\nEquip them with stable hooks, let the driver dispatch actions smartly, and express behavior with reusable steps. With these four steps, your\nshinytest2\nsuite speaks the same language as your users: actions, not wiring, and makes tests maintenance easier.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "A step-by-step guide to stronger R Shiny testing with stable selectors and reusable actions.",
    "meta_keywords": null,
    "og_description": "A step-by-step guide to stronger R Shiny testing with stable selectors and reusable actions.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "How to Write Robust shinytest2 Tests for R Shiny Apps | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 5.2,
    "sitemap_lastmod": null,
    "twitter_description": "A step-by-step guide to stronger R Shiny testing with stable selectors and reusable actions.",
    "twitter_title": "How to Write Robust shinytest2 Tests for R Shiny Apps | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/08/how-to-write-robust-shinytest2-tests-for-r-shiny-apps/",
    "word_count": 1030
  }
}