{
  "id": "5b704c110a7e5ba1207512feceba54dd017202c3",
  "url": "https://www.r-bloggers.com/2023/12/dicom-parsing-with-r/",
  "created_at_utc": "2025-11-17T20:38:52Z",
  "data": null,
  "raw_original": {
    "uuid": "f01ea368-35b6-453c-8631-0cc08c3ed441",
    "created_at": "2025-11-17 20:38:52",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2023/12/dicom-parsing-with-r/",
      "crawled_at": "2025-11-17T09:33:19.800308",
      "external_links": [
        {
          "href": "http://r-posts.com/dicom-parsing-with-r/",
          "text": "R-posts.com"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://www.dicomstandard.org/",
          "text": "dicomstandard.org"
        },
        {
          "href": "https://ismrmrd.github.io/apidocs/1.5.0/",
          "text": "ISMRMRD"
        },
        {
          "href": "https://pubmed.ncbi.nlm.nih.gov/26822475/",
          "text": "NIH"
        },
        {
          "href": "http://r-posts.com/dicom-parsing-with-r/",
          "text": "DICOM Parsing with R"
        },
        {
          "href": "http://r-posts.com/dicom-parsing-with-r/",
          "text": "R-posts.com"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "DICOM Parsing with R | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/r-posts.com/wp-content/uploads/2023/11/Process.jpg?w=450"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/centrum-fur-medizinische-datenintegration-bhc/",
          "text": "Centrum für medizinische Datenintegration BHC"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-380909 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">DICOM Parsing with R</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">December 16, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/centrum-fur-medizinische-datenintegration-bhc/\">Centrum für medizinische Datenintegration BHC</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"http://r-posts.com/dicom-parsing-with-r/\"> R-posts.com</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p><strong>Abstract</strong></p>\n<p>This blog post is to describe how to parse medically relevant non-image meta information from DICOM files using the programming language R. The resulting structure of the whole parsing process is an R data frame in form of a <em>name – value</em> table that is both easy to handle and flexible.</p>\n<p>We first describe the general structure of DICOM files and which kind of information they contain. Following this, our <em>DicomParseR</em> module in R is explained in detail. The package has been developed as part of practical DICOM parsing from our hospital’s cardiac magnetic resonance (CMR) modalities in order to populate a scientific database. The given examples hence refer to CMR information parsing, however, due to its generic nature, <em>DicomParseR </em>may be used to parse information from any type of DICOM file.</p>\n<p>The following graph illustrates the use of <em>DicomParseR </em>in our use case as an example:</p>\n<p><img alt=\"\" class=\"alignnone size-full wp-image-10792\" data-lazy-sizes=\"(max-width: 1028px) 100vw, 1028px\" data-lazy-src=\"https://i1.wp.com/r-posts.com/wp-content/uploads/2023/11/Process.jpg?w=450\" data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" srcset_temp=\"https://i1.wp.com/r-posts.com/wp-content/uploads/2023/11/Process.jpg?w=450 1028w, http://r-posts.com/wp-content/uploads/2023/11/Process-450x60.jpg 450w, http://r-posts.com/wp-content/uploads/2023/11/Process-768x103.jpg 768w\"/><noscript><img alt=\"\" class=\"alignnone size-full wp-image-10792\" data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" sizes=\"(max-width: 1028px) 100vw, 1028px\" src=\"https://i1.wp.com/r-posts.com/wp-content/uploads/2023/11/Process.jpg?w=450\" srcset_temp=\"https://i1.wp.com/r-posts.com/wp-content/uploads/2023/11/Process.jpg?w=450 1028w, http://r-posts.com/wp-content/uploads/2023/11/Process-450x60.jpg 450w, http://r-posts.com/wp-content/uploads/2023/11/Process-768x103.jpg 768w\"/></noscript></p>\n<p><strong>Structure of CMR DICOM files</strong></p>\n<p>On top level, a DICOM file generated by a CMR modality consists of a <em>header (hdr) </em>section and the <em>image (img)</em> information. In between an XML part can be found.</p>\n<p>The <em>hdr</em> section mainly contains baseline information about the patient, including name, birth date and system ID. It also contains contextual information about the observation, such as date and time, ID of the modality and the observation protocol.</p>\n<p>The XML section contains quantified information generated by the modality’s embedded AI, e. g. regarding myocardial blood flow (MBF). All information is stored between specifically named sub tags. These tags will serve to search for specific information. For further information on DICOM files, please refer to <a href=\"https://www.dicomstandard.org/\" rel=\"nofollow\" target=\"_blank\">dicomstandard.org</a>.</p>\n<p>The heterogeneous structure of DICOM files as described above requires the use of distinct submodules to compose a technically harmonized <em>name – value</em> table. The information from the XML section will be extended by information from the <em>hdr</em> section. The key benefit of our DicomParseR module is to parse these syntactically distinct sections, which will be described in the following.</p>\n<p><strong>Technical Approach</strong></p>\n<p>To extract information from the sub tags in the XML section and any additional relevant meta information from the <em>hdr</em> section of the DICOM file, following steps are performed:</p>\n<ol>\n<li style=\"list-style-type: none\">\n<ol>\n<li>Check if a DICOM file contains desired XML tag</li>\n<li>If the desired tag is present, extract and transform baseline information from <em>hdr</em> part</li>\n<li>If step 1 applied, extract and transform desired tag information from XML part</li>\n<li>Combine the two sets of information into an integrated R data frame</li>\n<li>Write the data frame into a suitable database for future scientific analysis</li>\n</ol>\n</li>\n</ol>\n<p>The steps mentioned above will be explained in detail in the following.</p>\n<p><strong>Step 1: Check if a DICOM file contains the desired XML tag</strong></p>\n<p>At the beginning of processing, <em>DicomParseR</em> will check whether a certain tag is present in the DICOM file, in our case <em><ismrmrdmeta></ismrmrdmeta></em>. In case that tag exists, quantified medical information will be stored here. Please refer to <a href=\"https://ismrmrd.github.io/apidocs/1.5.0/\" rel=\"nofollow\" target=\"_blank\">ISMRMRD</a> for further information about the <em>ismrmrd </em>data format.</p>\n<p>For this purpose, <em>DicomParseR</em> offers the function <em>file_has_content() </em>that expects the file and a search tag as parameters. The function will use <em>base::readLines() </em>to read in the file and <em>stringr::str_detect()</em> to detect if the given tag is available in the file. Performance tests with help of the package <em>microbenchmark</em> have proven <em>stringr’s</em> outstanding processing speed in this context. If the given tag was found, TRUE is returned, otherwise FALSE.</p>\n<p>Any surrounding application may hence call</p>\n<pre>if (DicomParseR::file_has_content(file, \"ismrmrdMeta\")) {…}</pre>\n<p>to only continue parsing DICOM files that contain the desired tag.</p>\n<p>It is important to note, that the information generated by the CMR modality is actually not a single DICOM file but rather a composition of a multitude of files. These files may or may not contain the desired XML tag(s). If step 1 were omitted, our parsing module would import many more files than necessary.</p>\n<p><strong>Step 2: Extract and transform baseline <em>hdr</em> information</strong></p>\n<p>Step 2 will extract <em>hdr</em> information from the file. For this purpose, <em>DicomParseR </em>uses the function <em>readDICOMFile() </em>provided by package <em>oro.dicom</em>. By calling</p>\n<pre>oro.dicom::readDICOMFile(dicom_file)[[\"hdr\"]]</pre>\n<p>the XML and image part are removed. The <em>hdr</em> section contains information such as patient’s name, sex and birthdate as well as meta information about the observation, such as date, time and contrast bolus. <em>DicomParseR</em> will save the <em>hdr</em> part as a data frame (in the following called <em>df_hdr</em>) in this step and later append it to the data frame that is generated in the next step.</p>\n<p>Note that the <em>oro.dicom</em> package provides functionality to extract header and image data from a DICOM file as shown in the code snippet. However, it does not provide an out-of-the-box solution to extract the XML section and return it as an R data frame. For this purpose, the DicomParseR wraps the extra functionality required around existing packages for DICOM processing.</p>\n<p><strong>Step 3: Extract and transform information from XML part</strong></p>\n<p>In this step, the data within the provided XML tag is extracted and transformed into a data frame.</p>\n<p>Following snippet shows an example about how myocardial blood flow numbers are stored in the respective DICOM files (values modified in terms of data privacy):</p>\n<table style=\"border-collapse: collapse;width: 100%\">\n<tbody>\n<tr>\n<td style=\"width: 100%\"><span style=\"font-size: 12pt\"><em><ismrmrdmeta><br/>\n</ismrmrdmeta></em><em>                …<br/>\n</em><em>                 <meta/><br/>\n</em><em>                               <name>GADGETRON_FLOW_ENDO_S_1</name><br/>\n</em><em>                               <value>1.95</value><br/>\n</em><em>                               <value>0.37</value><br/>\n</em><em>                               <value>1.29</value><br/>\n</em><em>                               <value>3.72</value><br/>\n</em><em>                               <value>1.89</value><br/>\n</em><em>                               <value>182</value><br/>\n</em><em>                <br/>\n</em><em>                …<br/>\n</em><em></em></span></td>\n</tr>\n</tbody>\n</table>\n<p>Within each meta tag, “name” specifies the context of the observation and “value” stores the myocardial blood flow data. The different data points between the value tags correspond to different descriptive metrics, such as mean, median, minimum and maximum values. Other meta tags may be structured differently. In order to stay flexible, the final extraction of a concrete value is done in the last step of data processing, see step 5.</p>\n<p>Now, to extract and transform the desired information from the DICOM file, <em>DicomParseR</em> will first use its function <em>extract_xml_from_file() </em>for extraction and subsequently the function <em>convert_xml2df()</em> for transformation<em>. </em>With</p>\n<pre>extract_xml_from_file &lt;- function(file, tag) {\r\n  file_content &lt;- readLines(file, encoding = \"UTF-16LE\", skipNul = TRUE)\r\n  indeces &lt;- grep(tag, file_content)\r\n  xml_part &lt;- paste(file_content[indeces[[1]]:indeces[[2]]], collapse = \"\\n\")\r\n  return(xml_part)\r\n}\r\n</pre>\n<p>and <em>“ismrmrdMeta”</em> as tag, the function will return a string in XML structure. That string is then converted to an R data frame in the form of a <em>name – value </em>table by <em>convert_xml2df()</em>. Based on our example above, the resulting data frame will look like this:</p>\n<table style=\"border-collapse: collapse;width: 100%\">\n<tbody>\n<tr>\n<td style=\"width: 50%\"><strong>name</strong></td>\n<td style=\"width: 25%\"><strong>value</strong></td>\n<td style=\"width: 25%\"><strong>[index]</strong></td>\n</tr>\n<tr>\n<td style=\"width: 50%\"><span style=\"font-size: 12pt\">GADGETRON_FLOW_ENDO_S1</span></td>\n<td style=\"width: 25%\"><span style=\"font-size: 12pt\">1.95</span></td>\n<td style=\"width: 25%\"><span style=\"font-size: 12pt\">[1]</span></td>\n</tr>\n<tr>\n<td style=\"width: 50%\"><span style=\"font-size: 12pt\">GADGETRON_FLOW_ENDO_S1</span></td>\n<td style=\"width: 25%\"><span style=\"font-size: 12pt\">0.37</span></td>\n<td style=\"width: 25%\"><span style=\"font-size: 12pt\">[2]</span></td>\n</tr>\n<tr>\n<td style=\"width: 50%\">…</td>\n<td style=\"width: 25%\">…</td>\n<td style=\"width: 25%\"></td>\n</tr>\n</tbody>\n</table>\n<p>That data frame is called <em>df_ismrmrdMeta </em>in the following. A specific value can be accesses with the combination of name and index, see the example in step 5.</p>\n<p><strong>Step 4: Integrate <em>hdr</em> and XML data frames</strong></p>\n<p>At this point in time, two data frames have resulted from processing the original DICOM file: <em>df_hdr</em> and <em>df_ismrmrdMeta</em>.</p>\n<p>In this step, those two data frames are combined into one single data frame called <em>df_filtered. </em>This is done by using <em>base::rbind().</em></p>\n<p>For example, executing</p>\n<pre>df_filtered &lt;- rbind(c(\"Pat_Weight\", df_hdr$value[df_hdr$name==\"PatientsWeight\"][1]), df_ismrmrdMeta)</pre>\n<p>will extend the data frame <em>df_ismrmrdMeta</em> by the patient’s weight. The result is returned in form of the target data frame <em>df_filtered. </em>As with <em>df_ismrmrdMeta</em>, <em>df_filtered</em> will be a <em>name – value </em>table. This design has been chosen in order to stay as flexible as possible when it comes to subsequent data analysis.</p>\n<p><strong>Step 5: Populate scientific database</strong></p>\n<p>The data frame <em>df_filtered</em> contains all information from the DICOM file as a <em>name – value </em>table. In the final step 5, <em>df_filtered</em> may now be split again as required to match the use case specific schema of the scientific database.</p>\n<p>For example, in our use case, the table <em>“cmr_data”</em> in the scientific database is dedicated to persist MBF values. An external program (in this case, an R Shiny application providing a GUI for end-user interaction) will call its function <em>transform_input_to_cmr_data() </em>to generate a data frame in format of the <em>“cmr_data”</em> table. By calling</p>\n<pre>transform_input_to_cmr_data &lt;- function(df) {\r\n  mbf_endo_s1 = as.double(df$value[df$name==\"GADGETRON_FLOW_ENDO_S_1\"][1])\r\n  mbf_endo_s2 = ...\r\n}</pre>\n<p>with <em>df_filtered </em>as parameter, the mean MBF values of the heart segments are extracted and can now be sent to the database. Another sub step would be to call <em>transform_input_to_baseline_data()</em> to persist baseline information in the database.</p>\n<p><strong>Summary and Outlook</strong></p>\n<p>This blog post has described the way DICOM files from CMR observations can be processed with R in order to extract quantified myocardial blood flow values for scientific analysis. Apart from R, different approaches by other institutes have been discussed publicly as well, e. g. by using MATLAB. Interested readers may refer to <a href=\"https://pubmed.ncbi.nlm.nih.gov/26822475/\" rel=\"nofollow\" target=\"_blank\">NIH</a>, among others, for further information.</p>\r\n\r\nThe chosen approach tries to respect both the properties of DICOM files, that is, their heterogeneous inner structure, the different types of information and their file size, as well as the specific data requirements by our institute’s use cases. With a single R data frame in form of a <em>name – value </em>table, the result of the process is easy to handle for further data analysis. At the same time, due to its flexible setup, <em>DicomParseR</em> may serve as a module in any kind of DICOM-related use case.<br/>\n<br/>\n<span style=\"font-size: 12pt\"><em>Thomas Schröder<br/>\r\nCentrum für medizinische Datenintegration BHC Stuttgart</em></span><hr style=\"border-top:black solid 1px\"><a href=\"http://r-posts.com/dicom-parsing-with-r/\" rel=\"nofollow\" target=\"_blank\">DICOM Parsing with R</a> was first posted on December 16, 2023 at 7:55 pm.<br/>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"http://r-posts.com/dicom-parsing-with-r/\"> R-posts.com</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div> </hr></div>\n</article>",
      "main_text": "DICOM Parsing with R\nPosted on\nDecember 16, 2023\nby\nCentrum für medizinische Datenintegration BHC\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR-posts.com\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAbstract\nThis blog post is to describe how to parse medically relevant non-image meta information from DICOM files using the programming language R. The resulting structure of the whole parsing process is an R data frame in form of a\nname – value\ntable that is both easy to handle and flexible.\nWe first describe the general structure of DICOM files and which kind of information they contain. Following this, our\nDicomParseR\nmodule in R is explained in detail. The package has been developed as part of practical DICOM parsing from our hospital’s cardiac magnetic resonance (CMR) modalities in order to populate a scientific database. The given examples hence refer to CMR information parsing, however, due to its generic nature,\nDicomParseR\nmay be used to parse information from any type of DICOM file.\nThe following graph illustrates the use of\nDicomParseR\nin our use case as an example:\nStructure of CMR DICOM files\nOn top level, a DICOM file generated by a CMR modality consists of a\nheader (hdr)\nsection and the\nimage (img)\ninformation. In between an XML part can be found.\nThe\nhdr\nsection mainly contains baseline information about the patient, including name, birth date and system ID. It also contains contextual information about the observation, such as date and time, ID of the modality and the observation protocol.\nThe XML section contains quantified information generated by the modality’s embedded AI, e. g. regarding myocardial blood flow (MBF). All information is stored between specifically named sub tags. These tags will serve to search for specific information. For further information on DICOM files, please refer to\ndicomstandard.org\n.\nThe heterogeneous structure of DICOM files as described above requires the use of distinct submodules to compose a technically harmonized\nname – value\ntable. The information from the XML section will be extended by information from the\nhdr\nsection. The key benefit of our DicomParseR module is to parse these syntactically distinct sections, which will be described in the following.\nTechnical Approach\nTo extract information from the sub tags in the XML section and any additional relevant meta information from the\nhdr\nsection of the DICOM file, following steps are performed:\nCheck if a DICOM file contains desired XML tag\nIf the desired tag is present, extract and transform baseline information from\nhdr\npart\nIf step 1 applied, extract and transform desired tag information from XML part\nCombine the two sets of information into an integrated R data frame\nWrite the data frame into a suitable database for future scientific analysis\nThe steps mentioned above will be explained in detail in the following.\nStep 1: Check if a DICOM file contains the desired XML tag\nAt the beginning of processing,\nDicomParseR\nwill check whether a certain tag is present in the DICOM file, in our case\n. In case that tag exists, quantified medical information will be stored here. Please refer to\nISMRMRD\nfor further information about the\nismrmrd\ndata format.\nFor this purpose,\nDicomParseR\noffers the function\nfile_has_content()\nthat expects the file and a search tag as parameters. The function will use\nbase::readLines()\nto read in the file and\nstringr::str_detect()\nto detect if the given tag is available in the file. Performance tests with help of the package\nmicrobenchmark\nhave proven\nstringr’s\noutstanding processing speed in this context. If the given tag was found, TRUE is returned, otherwise FALSE.\nAny surrounding application may hence call\nif (DicomParseR::file_has_content(file, \"ismrmrdMeta\")) {…}\nto only continue parsing DICOM files that contain the desired tag.\nIt is important to note, that the information generated by the CMR modality is actually not a single DICOM file but rather a composition of a multitude of files. These files may or may not contain the desired XML tag(s). If step 1 were omitted, our parsing module would import many more files than necessary.\nStep 2: Extract and transform baseline\nhdr\ninformation\nStep 2 will extract\nhdr\ninformation from the file. For this purpose,\nDicomParseR\nuses the function\nreadDICOMFile()\nprovided by package\noro.dicom\n. By calling\noro.dicom::readDICOMFile(dicom_file)[[\"hdr\"]]\nthe XML and image part are removed. The\nhdr\nsection contains information such as patient’s name, sex and birthdate as well as meta information about the observation, such as date, time and contrast bolus.\nDicomParseR\nwill save the\nhdr\npart as a data frame (in the following called\ndf_hdr\n) in this step and later append it to the data frame that is generated in the next step.\nNote that the\noro.dicom\npackage provides functionality to extract header and image data from a DICOM file as shown in the code snippet. However, it does not provide an out-of-the-box solution to extract the XML section and return it as an R data frame. For this purpose, the DicomParseR wraps the extra functionality required around existing packages for DICOM processing.\nStep 3: Extract and transform information from XML part\nIn this step, the data within the provided XML tag is extracted and transformed into a data frame.\nFollowing snippet shows an example about how myocardial blood flow numbers are stored in the respective DICOM files (values modified in terms of data privacy):\n…\nGADGETRON_FLOW_ENDO_S_1\n1.95\n0.37\n1.29\n3.72\n1.89\n182\n…\nWithin each meta tag, “name” specifies the context of the observation and “value” stores the myocardial blood flow data. The different data points between the value tags correspond to different descriptive metrics, such as mean, median, minimum and maximum values. Other meta tags may be structured differently. In order to stay flexible, the final extraction of a concrete value is done in the last step of data processing, see step 5.\nNow, to extract and transform the desired information from the DICOM file,\nDicomParseR\nwill first use its function\nextract_xml_from_file()\nfor extraction and subsequently the function\nconvert_xml2df()\nfor transformation\n.\nWith\nextract_xml_from_file <- function(file, tag) {\n  file_content <- readLines(file, encoding = \"UTF-16LE\", skipNul = TRUE)\n  indeces <- grep(tag, file_content)\n  xml_part <- paste(file_content[indeces[[1]]:indeces[[2]]], collapse = \"\\n\")\n  return(xml_part)\n}\nand\n“ismrmrdMeta”\nas tag, the function will return a string in XML structure. That string is then converted to an R data frame in the form of a\nname – value\ntable by\nconvert_xml2df()\n. Based on our example above, the resulting data frame will look like this:\nname\nvalue\n[index]\nGADGETRON_FLOW_ENDO_S1\n1.95\n[1]\nGADGETRON_FLOW_ENDO_S1\n0.37\n[2]\n…\n…\nThat data frame is called\ndf_ismrmrdMeta\nin the following. A specific value can be accesses with the combination of name and index, see the example in step 5.\nStep 4: Integrate\nhdr\nand XML data frames\nAt this point in time, two data frames have resulted from processing the original DICOM file:\ndf_hdr\nand\ndf_ismrmrdMeta\n.\nIn this step, those two data frames are combined into one single data frame called\ndf_filtered.\nThis is done by using\nbase::rbind().\nFor example, executing\ndf_filtered <- rbind(c(\"Pat_Weight\", df_hdr$value[df_hdr$name==\"PatientsWeight\"][1]), df_ismrmrdMeta)\nwill extend the data frame\ndf_ismrmrdMeta\nby the patient’s weight. The result is returned in form of the target data frame\ndf_filtered.\nAs with\ndf_ismrmrdMeta\n,\ndf_filtered\nwill be a\nname – value\ntable. This design has been chosen in order to stay as flexible as possible when it comes to subsequent data analysis.\nStep 5: Populate scientific database\nThe data frame\ndf_filtered\ncontains all information from the DICOM file as a\nname – value\ntable. In the final step 5,\ndf_filtered\nmay now be split again as required to match the use case specific schema of the scientific database.\nFor example, in our use case, the table\n“cmr_data”\nin the scientific database is dedicated to persist MBF values. An external program (in this case, an R Shiny application providing a GUI for end-user interaction) will call its function\ntransform_input_to_cmr_data()\nto generate a data frame in format of the\n“cmr_data”\ntable. By calling\ntransform_input_to_cmr_data <- function(df) {\n  mbf_endo_s1 = as.double(df$value[df$name==\"GADGETRON_FLOW_ENDO_S_1\"][1])\n  mbf_endo_s2 = ...\n}\nwith\ndf_filtered\nas parameter, the mean MBF values of the heart segments are extracted and can now be sent to the database. Another sub step would be to call\ntransform_input_to_baseline_data()\nto persist baseline information in the database.\nSummary and Outlook\nThis blog post has described the way DICOM files from CMR observations can be processed with R in order to extract quantified myocardial blood flow values for scientific analysis. Apart from R, different approaches by other institutes have been discussed publicly as well, e. g. by using MATLAB. Interested readers may refer to\nNIH\n, among others, for further information.\nThe chosen approach tries to respect both the properties of DICOM files, that is, their heterogeneous inner structure, the different types of information and their file size, as well as the specific data requirements by our institute’s use cases. With a single R data frame in form of a\nname – value\ntable, the result of the process is easy to handle for further data analysis. At the same time, due to its flexible setup,\nDicomParseR\nmay serve as a module in any kind of DICOM-related use case.\nThomas Schröder\nCentrum für medizinische Datenintegration BHC Stuttgart\nDICOM Parsing with R\nwas first posted on December 16, 2023 at 7:55 pm.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR-posts.com\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "Abstract This blog post is to describe how to parse medically relevant non-image meta information from DICOM files using the programming language R. The resulting structure of the whole parsing process is an R data frame in form of a name – value table that is both easy to handle and flexible. We first describe … Continue reading DICOM Parsing with RDICOM Parsing with R was first posted on December 16, 2023 at 7:55 pm.",
      "meta_keywords": null,
      "og_description": "Abstract This blog post is to describe how to parse medically relevant non-image meta information from DICOM files using the programming language R. The resulting structure of the whole parsing process is an R data frame in form of a name – value table that is both easy to handle and flexible. We first describe … Continue reading DICOM Parsing with RDICOM Parsing with R was first posted on December 16, 2023 at 7:55 pm.",
      "og_image": "https://r-posts.com/wp-content/uploads/2023/11/Process.jpg",
      "og_title": "DICOM Parsing with R | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 8.3,
      "sitemap_lastmod": "2023-12-16T19:55:26+00:00",
      "twitter_description": "Abstract This blog post is to describe how to parse medically relevant non-image meta information from DICOM files using the programming language R. The resulting structure of the whole parsing process is an R data frame in form of a name – value table that is both easy to handle and flexible. We first describe … Continue reading DICOM Parsing with RDICOM Parsing with R was first posted on December 16, 2023 at 7:55 pm.",
      "twitter_title": "DICOM Parsing with R | R-bloggers",
      "url": "https://www.r-bloggers.com/2023/12/dicom-parsing-with-r/",
      "word_count": 1668
    }
  }
}