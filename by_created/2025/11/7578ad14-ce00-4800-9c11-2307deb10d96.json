{
  "uuid": "7578ad14-ce00-4800-9c11-2307deb10d96",
  "created_at": "2025-11-22 19:57:38",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/09/clean-r-tests-with-local_mocked_bindings-and-dependency-wrapping/",
    "crawled_at": "2025-11-22T10:42:47.466725",
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/clean-tests-with-local_mocked_bindings",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://github.com/r-lib/mockery",
        "text": "mockery"
      },
      {
        "href": "https://jakubsobolewski.com/blog/clean-tests-with-local_mocked_bindings",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Clean R Tests with `local_mocked_bindings` and Dependency Wrapping | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-395679 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Clean R Tests with `local_mocked_bindings` and Dependency Wrapping</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">September 22, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/clean-tests-with-local_mocked_bindings\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Testing functions that rely on external dependencies is hard.</p>\n<p>Your tests become slow, fragile, and unreliable when they depend on external APIs, file systems, or services. Worse yet, some dependencies like <code>Sys.time()</code> return values that change constantly, making consistent testing nearly impossible.</p>\n<p>The solution is simple: wrap external dependencies in your own functions and stub them with <code>testthat::local_mocked_bindings</code>.</p>\n<h2 id=\"why-wrap-external-dependencies\">Why Wrap External Dependencies?</h2>\n<p>External dependencies make testing painful in three ways:</p>\n<ul>\n<li>First, they can be unpredictable. APIs go down. File systems change. Network requests timeout.</li>\n<li>Second, they can be uncontrollable. You can’t force <code>Sys.time()</code> to return a specific value or make a random API response predictable.</li>\n<li>Third, they can be slow. Real database queries and HTTP requests add seconds to test suites that should run in milliseconds.</li>\n</ul>\n<p>Wrapping dependencies solves all three problems at once.</p>\n<h2 id=\"the-pattern-wrap-stub-test\">The Pattern: Wrap, Stub, Test</h2>\n<p>Here’s how to build testable functions with external dependencies:</p>\n<h3 id=\"step-1-wrap-external-calls\">Step 1: Wrap External Calls</h3>\n<p>Instead of calling <code>Sys.time()</code> directly, create a wrapper function:</p>\n<pre>get_current_time &lt;- function() {\n  Sys.time()\n}\n\ncalculate_elapsed_time &lt;- function(start_time) {\n  current &lt;- get_current_time()\n  difftime(current, start_time, units = \"secs\")\n}</pre>\n<h3 id=\"step-2-test-with-stubs\">Step 2: Test with Stubs</h3>\n<p>Use <code>local_mocked_bindings</code> to replace your wrapper with a predictable stub:</p>\n<pre>test_that(\"calculate_elapsed_time returns time difference\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n  )\n  start_time &lt;- as.POSIXct(\"2023-01-01 12:00:00\")\n\n  # Act\n  result &lt;- calculate_elapsed_time(start_time)\n\n  # Assert\n  expect_equal(as.numeric(result), 1800) # 30 minutes = 1800 seconds\n})</pre>\n<p>Look how clean that test is. No setup. No teardown. No flaky timing issues.</p>\n<h2 id=\"why-local_mocked_bindings-encourages-good-design\">Why <code>local_mocked_bindings</code> Encourages Good Design</h2>\n<p>For a long time I’ve only used <a href=\"https://github.com/r-lib/mockery\" rel=\"nofollow\" target=\"_blank\"><code>mockery</code></a> for stubbing, but <code>local_mocked_bindings</code> starts to grow on me.</p>\n<p>The key insight: you get the most out of <code>local_mocked_bindings</code> when you don’t use the <code>.package</code> argument.</p>\n<p>I bet this was intentional design of this interface: you get the cleanest test code, when not using extra arguments. Without <code>.package</code> you can only stub functions that are defined in the current namespace. This forces you to apply good design principles: wrap external dependencies in your own functions.</p>\n<p>Try to stub <code>Sys.time</code> directly and you’ll need:</p>\n<pre># Messy - requires .package argument\nlocal_mocked_bindings(\n  Sys.time = function() as.POSIXct(\"2023-01-01 12:30:00\"),\n  .package = \"base\"\n)</pre>\n<p>But wrap it first:</p>\n<pre># Clean - no .package needed\nlocal_mocked_bindings(\n  get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n)</pre>\n<p>The function teaches you better design (if you pay attention).</p>\n<h2 id=\"three-benefits-of-wrapping\">Three Benefits of Wrapping</h2>\n<p>Wrapping external dependencies gives you three powerful capabilities:</p>\n<ul>\n<li><strong>Stubbing for Testing</strong>: Replace unpredictable external calls with controlled test doubles using <code>local_mocked_bindings</code>.</li>\n<li><strong>Dependency Injection</strong>: It opens doors for injecting different implementations for different environments. Maybe production uses <code>Sys.time()</code> but your staging environment reads from a mock time server. Then in tests we can use dependency injection of a fake, or still use a stub with <code>local_mocked_bindings</code>.</li>\n<li><strong>Easy Migration</strong>: Change implementations without touching calling code. Today you read time from the system clock, tomorrow from a solar clock camera, next week from an atomic time API.</li>\n</ul>\n<h2 id=\"the-systime-problem\">The <code>Sys.time()</code> Problem</h2>\n<p><code>Sys.time()</code> exemplifies why wrapping matters.</p>\n<p>Unlike random numbers (controlled by <code>set.seed()</code>), time always changes. Every test run gets different values. You can’t make time-dependent functions deterministic without replacing the time source.</p>\n<p>Consider a function that calculates business hours:</p>\n<pre>is_business_hour &lt;- function() {\n  current_hour &lt;- hour(Sys.time())\n  current_hour &gt;= 9 &amp;&amp; current_hour &lt;= 17\n}</pre>\n<p>How do you test this? You can’t control when your tests run.</p>\n<p>Wrap the time dependency:</p>\n<pre>get_current_time &lt;- function() {\n  Sys.time()\n}\n\nis_business_hour &lt;- function() {\n  current_hour &lt;- hour(get_current_time())\n  current_hour &gt;= 9 &amp;&amp; current_hour &lt;= 17\n}</pre>\n<p>Now testing becomes trivial:</p>\n<pre>test_that(\"is_business_hour returns TRUE during business hours\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 14:00:00\") # 2 PM\n  )\n\n  # Act\n  result &lt;- is_business_hour()\n\n  # Act\n  expect_true(result)\n})\n\ntest_that(\"is_business_hour returns FALSE outside business hours\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 22:00:00\") # 10 PM\n  )\n\n  # Act\n  result &lt;- is_business_hour()\n\n  # Assert\n  expect_false(result)\n})</pre>\n<p>Perfect control. Perfect reliability.</p>\n<h2 id=\"real-world-example\">Real-World Example</h2>\n<p>Here’s how the pattern works with more complex dependencies:</p>\n<pre># Wrapper functions for external dependencies\nget_system_info &lt;- function() {\n  Sys.info()\n}\n\nget_package_versions &lt;- function(path) {\n  if (!rlang::is_installed(\"yaml\")) {\n    stop(\"Packages \\\"yaml\\\" not installed\", call. = FALSE)\n  }\n  if (!rlang::is_installed(\"here\")) {\n    stop(\"Package \\\"here\\\" not installed\", call. = FALSE)\n  }\n  yaml::read_yaml(here::here(path, \"renv.lock\"))\n}\n\nget_test_results &lt;- function(...) {\n  testthat::test_local(..., stop_on_failure = FALSE)\n}\n\n# Function that uses wrapped dependencies\ngenerate_system_report &lt;- function(project_path = \".\") {\n  system_info &lt;- get_system_info()\n  packages &lt;- get_package_versions(project_path)\n  tests &lt;- get_test_results(project_path)\n\n  list(\n    os = system_info[[\"sysname\"]],\n    r_version = system_info[[\"version\"]],\n    package_count = length(packages$Packages),\n    test_status = all(tests$passed)\n  )\n}</pre>\n<p>Testing becomes straightforward:</p>\n<pre>test_that(\"generate_system_report creates complete report\", {\n  # Arrange\n  local_mocked_bindings(\n    get_system_info = function() c(sysname = \"Linux\", version = \"4.0.0\"),\n    get_package_versions = function(path) list(Packages = list(a = 1, b = 2)),\n    get_test_results = function(...) data.frame(passed = c(TRUE, TRUE))\n  )\n\n  # Act\n  report &lt;- generate_system_report()\n\n  # Assert\n  expect_equal(report$os, \"Linux\")\n  expect_equal(report$package_count, 2)\n  expect_true(report$test_status)\n})</pre>\n<p>Three external dependencies controlled with three simple stubs. No real file system access. No actual test execution. No system introspection.</p>\n<h2 id=\"interface-over-implementation\">Interface Over Implementation</h2>\n<p>The wrapper pattern creates an interface between your code and external dependencies.</p>\n<p>Interfaces are powerful because they separate “what” from “how”. Your code knows what it needs (current time, system info, test results) but doesn’t care how those needs are met.</p>\n<p>In production, <code>get_current_time()</code> calls <code>Sys.time()</code>. In tests, it returns a fixed timestamp. In a specialized environment, it might read from a network time protocol server or even that solar clock camera.</p>\n<p>Change the implementation without changing a single line of calling code.</p>\n<h2 id=\"clean-tests-win\">Clean Tests Win</h2>\n<p>Compare these two approaches:</p>\n<p><strong>Without wrapping:</strong></p>\n<pre># Brittle, slow, unpredictable\ntest_that(\"time calculation works\", {\n  start &lt;- Sys.time()\n  Sys.sleep(0.1)\n  result &lt;- calculate_duration(start)\n  expect_gt(result, 0.1) # Flaky assertion\n})</pre>\n<p><strong>With wrapping:</strong></p>\n<pre># Reliable, fast, predictable\ntest_that(\"calculate_duration returns time difference between start and current time\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n  )\n  start &lt;- as.POSIXct(\"2023-01-01 12:00:00\")\n\n  # Act\n  result &lt;- calculate_duration(start)\n\n  # Assert\n  expect_equal(result, 1800)\n})</pre>\n<p>The second test runs in microseconds, never fails randomly, and expresses intent clearly.</p>\n<h2 id=\"start-wrapping-today\">Start Wrapping Today</h2>\n<p>Next time you write a function that touches the outside world, wrap the external call. Your future testing self will thank you.</p>\n<p>The pattern is simple: wrap external dependencies, stub in tests, enjoy clean and reliable test suites that run fast and pass consistently.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/clean-tests-with-local_mocked_bindings\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Clean R Tests with `local_mocked_bindings` and Dependency Wrapping\nPosted on\nSeptember 22, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nTesting functions that rely on external dependencies is hard.\nYour tests become slow, fragile, and unreliable when they depend on external APIs, file systems, or services. Worse yet, some dependencies like\nSys.time()\nreturn values that change constantly, making consistent testing nearly impossible.\nThe solution is simple: wrap external dependencies in your own functions and stub them with\ntestthat::local_mocked_bindings\n.\nWhy Wrap External Dependencies?\nExternal dependencies make testing painful in three ways:\nFirst, they can be unpredictable. APIs go down. File systems change. Network requests timeout.\nSecond, they can be uncontrollable. You can’t force\nSys.time()\nto return a specific value or make a random API response predictable.\nThird, they can be slow. Real database queries and HTTP requests add seconds to test suites that should run in milliseconds.\nWrapping dependencies solves all three problems at once.\nThe Pattern: Wrap, Stub, Test\nHere’s how to build testable functions with external dependencies:\nStep 1: Wrap External Calls\nInstead of calling\nSys.time()\ndirectly, create a wrapper function:\nget_current_time <- function() {\n  Sys.time()\n}\n\ncalculate_elapsed_time <- function(start_time) {\n  current <- get_current_time()\n  difftime(current, start_time, units = \"secs\")\n}\nStep 2: Test with Stubs\nUse\nlocal_mocked_bindings\nto replace your wrapper with a predictable stub:\ntest_that(\"calculate_elapsed_time returns time difference\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n  )\n  start_time <- as.POSIXct(\"2023-01-01 12:00:00\")\n\n  # Act\n  result <- calculate_elapsed_time(start_time)\n\n  # Assert\n  expect_equal(as.numeric(result), 1800) # 30 minutes = 1800 seconds\n})\nLook how clean that test is. No setup. No teardown. No flaky timing issues.\nWhy\nlocal_mocked_bindings\nEncourages Good Design\nFor a long time I’ve only used\nmockery\nfor stubbing, but\nlocal_mocked_bindings\nstarts to grow on me.\nThe key insight: you get the most out of\nlocal_mocked_bindings\nwhen you don’t use the\n.package\nargument.\nI bet this was intentional design of this interface: you get the cleanest test code, when not using extra arguments. Without\n.package\nyou can only stub functions that are defined in the current namespace. This forces you to apply good design principles: wrap external dependencies in your own functions.\nTry to stub\nSys.time\ndirectly and you’ll need:\n# Messy - requires .package argument\nlocal_mocked_bindings(\n  Sys.time = function() as.POSIXct(\"2023-01-01 12:30:00\"),\n  .package = \"base\"\n)\nBut wrap it first:\n# Clean - no .package needed\nlocal_mocked_bindings(\n  get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n)\nThe function teaches you better design (if you pay attention).\nThree Benefits of Wrapping\nWrapping external dependencies gives you three powerful capabilities:\nStubbing for Testing\n: Replace unpredictable external calls with controlled test doubles using\nlocal_mocked_bindings\n.\nDependency Injection\n: It opens doors for injecting different implementations for different environments. Maybe production uses\nSys.time()\nbut your staging environment reads from a mock time server. Then in tests we can use dependency injection of a fake, or still use a stub with\nlocal_mocked_bindings\n.\nEasy Migration\n: Change implementations without touching calling code. Today you read time from the system clock, tomorrow from a solar clock camera, next week from an atomic time API.\nThe\nSys.time()\nProblem\nSys.time()\nexemplifies why wrapping matters.\nUnlike random numbers (controlled by\nset.seed()\n), time always changes. Every test run gets different values. You can’t make time-dependent functions deterministic without replacing the time source.\nConsider a function that calculates business hours:\nis_business_hour <- function() {\n  current_hour <- hour(Sys.time())\n  current_hour >= 9 && current_hour <= 17\n}\nHow do you test this? You can’t control when your tests run.\nWrap the time dependency:\nget_current_time <- function() {\n  Sys.time()\n}\n\nis_business_hour <- function() {\n  current_hour <- hour(get_current_time())\n  current_hour >= 9 && current_hour <= 17\n}\nNow testing becomes trivial:\ntest_that(\"is_business_hour returns TRUE during business hours\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 14:00:00\") # 2 PM\n  )\n\n  # Act\n  result <- is_business_hour()\n\n  # Act\n  expect_true(result)\n})\n\ntest_that(\"is_business_hour returns FALSE outside business hours\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 22:00:00\") # 10 PM\n  )\n\n  # Act\n  result <- is_business_hour()\n\n  # Assert\n  expect_false(result)\n})\nPerfect control. Perfect reliability.\nReal-World Example\nHere’s how the pattern works with more complex dependencies:\n# Wrapper functions for external dependencies\nget_system_info <- function() {\n  Sys.info()\n}\n\nget_package_versions <- function(path) {\n  if (!rlang::is_installed(\"yaml\")) {\n    stop(\"Packages \\\"yaml\\\" not installed\", call. = FALSE)\n  }\n  if (!rlang::is_installed(\"here\")) {\n    stop(\"Package \\\"here\\\" not installed\", call. = FALSE)\n  }\n  yaml::read_yaml(here::here(path, \"renv.lock\"))\n}\n\nget_test_results <- function(...) {\n  testthat::test_local(..., stop_on_failure = FALSE)\n}\n\n# Function that uses wrapped dependencies\ngenerate_system_report <- function(project_path = \".\") {\n  system_info <- get_system_info()\n  packages <- get_package_versions(project_path)\n  tests <- get_test_results(project_path)\n\n  list(\n    os = system_info[[\"sysname\"]],\n    r_version = system_info[[\"version\"]],\n    package_count = length(packages$Packages),\n    test_status = all(tests$passed)\n  )\n}\nTesting becomes straightforward:\ntest_that(\"generate_system_report creates complete report\", {\n  # Arrange\n  local_mocked_bindings(\n    get_system_info = function() c(sysname = \"Linux\", version = \"4.0.0\"),\n    get_package_versions = function(path) list(Packages = list(a = 1, b = 2)),\n    get_test_results = function(...) data.frame(passed = c(TRUE, TRUE))\n  )\n\n  # Act\n  report <- generate_system_report()\n\n  # Assert\n  expect_equal(report$os, \"Linux\")\n  expect_equal(report$package_count, 2)\n  expect_true(report$test_status)\n})\nThree external dependencies controlled with three simple stubs. No real file system access. No actual test execution. No system introspection.\nInterface Over Implementation\nThe wrapper pattern creates an interface between your code and external dependencies.\nInterfaces are powerful because they separate “what” from “how”. Your code knows what it needs (current time, system info, test results) but doesn’t care how those needs are met.\nIn production,\nget_current_time()\ncalls\nSys.time()\n. In tests, it returns a fixed timestamp. In a specialized environment, it might read from a network time protocol server or even that solar clock camera.\nChange the implementation without changing a single line of calling code.\nClean Tests Win\nCompare these two approaches:\nWithout wrapping:\n# Brittle, slow, unpredictable\ntest_that(\"time calculation works\", {\n  start <- Sys.time()\n  Sys.sleep(0.1)\n  result <- calculate_duration(start)\n  expect_gt(result, 0.1) # Flaky assertion\n})\nWith wrapping:\n# Reliable, fast, predictable\ntest_that(\"calculate_duration returns time difference between start and current time\", {\n  # Arrange\n  local_mocked_bindings(\n    get_current_time = function() as.POSIXct(\"2023-01-01 12:30:00\")\n  )\n  start <- as.POSIXct(\"2023-01-01 12:00:00\")\n\n  # Act\n  result <- calculate_duration(start)\n\n  # Assert\n  expect_equal(result, 1800)\n})\nThe second test runs in microseconds, never fails randomly, and expresses intent clearly.\nStart Wrapping Today\nNext time you write a function that touches the outside world, wrap the external call. Your future testing self will thank you.\nThe pattern is simple: wrap external dependencies, stub in tests, enjoy clean and reliable test suites that run fast and pass consistently.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Learn how to write reliable R tests by wrapping external dependencies and using `testthat::local_mocked_bindings`. Make your tests fast, clean, and predictable.",
    "meta_keywords": null,
    "og_description": "Learn how to write reliable R tests by wrapping external dependencies and using `testthat::local_mocked_bindings`. Make your tests fast, clean, and predictable.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "Clean R Tests with `local_mocked_bindings` and Dependency Wrapping | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 5.9,
    "sitemap_lastmod": null,
    "twitter_description": "Learn how to write reliable R tests by wrapping external dependencies and using `testthat::local_mocked_bindings`. Make your tests fast, clean, and predictable.",
    "twitter_title": "Clean R Tests with `local_mocked_bindings` and Dependency Wrapping | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/09/clean-r-tests-with-local_mocked_bindings-and-dependency-wrapping/",
    "word_count": 1174
  }
}