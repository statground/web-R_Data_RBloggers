{
  "uuid": "432992be-ae59-41cf-8842-209f2f9cc92e",
  "created_at": "2025-11-17 20:38:57",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/12/advent-of-array-elegance-aoc2023-day-7/",
    "crawled_at": "2025-11-17T09:38:00.947928",
    "external_links": [
      {
        "href": "https://jcarroll.com.au/2023/12/10/advent-of-array-elegance/",
        "text": "rstats on Irregularly Scheduled Programming"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://adventofcode.com/",
        "text": "Advent of Code"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/",
        "text": "last\nyear"
      },
      {
        "href": "https://www.youtube.com/watch?v=C395wCEDvOQ",
        "text": "video recap of an APL solution for Day\n7"
      },
      {
        "href": "https://fosstodon.org/@loke@functional.cafe",
        "text": "Elias\nMårtenson"
      },
      {
        "href": "https://kapdemo.dhsdevelopments.com/",
        "text": "Kap"
      },
      {
        "href": "https://www.uiua.org/",
        "text": "Uiua"
      },
      {
        "href": "https://yihui.org/en/2023/10/section-tabsets/",
        "text": "tabsets"
      },
      {
        "href": "https://aplwiki.com/wiki/Total_array_ordering",
        "text": "“total array\nordering”"
      },
      {
        "href": "https://github.com/mlochbaum/BQN/blob/master/doc/order.md#ordinals",
        "text": "BQN"
      },
      {
        "href": "https://kapdemo.dhsdevelopments.com/kap-comparison.html#_enclose_and_disclose:~:text=If%20%E2%8A%83%20is%20called%20on%20an%20array%2C",
        "text": "ref"
      },
      {
        "href": "https://mastodon.social/@jstepien/111549757943773283",
        "text": "a solution in Uiua on\nMastodon"
      },
      {
        "href": "https://fosstodon.org/@jonocarroll",
        "text": "Mastodon"
      },
      {
        "href": "https://jcarroll.com.au/2023/12/10/advent-of-array-elegance/",
        "text": "rstats on Irregularly Scheduled Programming"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Advent of Array Elegance (AoC2023 Day 7) | R-bloggers",
    "images": [
      {
        "alt": "My laptop with APL stickers on the keys",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "My laptop with APL stickers on the keys",
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/aplkeyboard_800.jpg?w=578&ssl=1"
      },
      {
        "alt": "chart:line mtcars in Kap",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "chart:line mtcars in Kap",
        "base64": null,
        "src": "https://i0.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/kap_mtcars.png?w=578&ssl=1"
      },
      {
        "alt": "Uiua logo, coded in Uiua",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Uiua logo, coded in Uiua",
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uiua.png?w=578&ssl=1"
      },
      {
        "alt": "Uiua coloured glyphs for ‘all’ and ‘transpose’",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Uiua coloured glyphs for ‘all’ and ‘transpose’",
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uaua_all_trans.png?w=578&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jonathan-carroll/",
        "text": "Jonathan Carroll"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-380734 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Advent of Array Elegance (AoC2023 Day 7)</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">December 9, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jonathan-carroll/\">Jonathan Carroll</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://jcarroll.com.au/2023/12/10/advent-of-array-elegance/\"> rstats on Irregularly Scheduled Programming</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>I’m solving <a href=\"https://adventofcode.com/\" rel=\"nofollow\" target=\"_blank\">Advent of Code</a> this year using a\nrelaxed criteria compared to <a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/\" rel=\"nofollow\" target=\"_blank\">last\nyear</a> in that I’m\nallowing myself to use packages where they’re helpful, rather than <em>strictly</em>\nbase R. Last year I re-solved half of the exercises using Rust which helped me\nlearn a lot about Rust. This year I’m enamored with APL, and I wanted to share a\nparticularly beautiful solution.</p>\n<p>⚠⚠⚠⚠⚠</p>\n<p>Spoilers ahead for Day 7, in case you haven’t yet completed it yourself.</p>\n<p>⚠⚠⚠⚠⚠</p>\n<p>I solved Day 7 of Advent of Code using base R by testing whether or not a given\nhand was of each type with an individual function, either returning 0 (if it was\nnot of that type) or <code>N</code> + a score, where <code>N</code> was sufficiently different between\neach type that they would sort nicely. For the score, I initially tried\noffsetting each card in a poor-man’s base-15 as <code>15^(4:0)*card_score</code> but later\nimproved on that by using hex digits (which automatically sort nicer). The large <code>N</code>\nvalues ensured that ‘type’ would be sorted before the first/second/etc.. card.</p>\n<p>That was sufficient to do an <code>apply(strength, hands)</code>, calculate the <code>order</code> of\nthose, and multiply by the relevant bids. Aside from a bug not caught by the\ntest case (the difference between <code>bid*order(x)</code> and\n<code>bid[order(x)]*seq_along(x)</code>) it was an okay solution to the problem, and it\nworked.</p>\n<p>After solving each day, I’ve been trying to re-solve using APL; in particular Dyalog\nAPL. For those who don’t know, APL is an old language (circa 1960s) borne from a\nmathematical notation in which a single glyph (symbol) represents some operation\nor application of a function. This makes it look very different to more modern\nlanguages, partly because of the glyphs, but also because it requires no boilerplate\nwhatsoever. As an array language, it deals with vectors and matrices without needing\nto “loop over columns” or “for i in values”. It looks scary at first, but it’s really\nnot – once you’re familiar with the glyphs it’s actually beautiful!</p>\n<p>Let’s say you have a matrix <code>m</code> which contains the values <code>1</code> through <code>9</code></p>\n<pre>    m\n1 2 3\n4 5 6\n7 8 9</pre>\n<p>and you want to sum the columns. Chances are, the language you normally use will\nrequire you to first calculate the size of the matrix, maybe even perform a loop. In\nAPL, it’s</p>\n<pre>    +⌿m\n12 15 18</pre>\n<p><code>⌿</code> is the glyph for “reduce along first axis”, or perform some operation\n(supplied as its left argument) to its right argument. <code>+⌿</code> is therefore “sum\ncolumns”. No boilerplate, just a direct explanation (the glyphs themselves are\nbetter names than any word you could attach to them) of what needs to be done.</p>\n<p>Sure, you need to learn the glyphs, and potentially even how to enter them; one option\nbeing a prefix key then a corresponding key. How committed am I to learning\nthose, you ask? Well, here’s my laptop</p>\n<div class=\"float\">\n<img alt=\"My laptop with APL stickers on the keys\" data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/aplkeyboard_800.jpg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"My laptop with APL stickers on the keys\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/aplkeyboard_800.jpg?w=578&amp;ssl=1\"/></noscript>\n<div class=\"figcaption\">My laptop with APL stickers on the keys</div>\n</div>\n<p>I considered using APL for my Day 7 solution, but it was so many functions\ndefined, and fiddly if/else logic, I figured it was just ill-suited to APL. Then\nI saw a <a href=\"https://www.youtube.com/watch?v=C395wCEDvOQ\" rel=\"nofollow\" target=\"_blank\">video recap of an APL solution for Day\n7</a> and my mind was blown.</p>\n<p>Meanwhile, I saw a post from <a href=\"https://fosstodon.org/@loke@functional.cafe\" rel=\"nofollow\" target=\"_blank\">Elias\nMårtenson</a>, creator of the Kap\nlanguage, promoting some examples of Kap and was even more interested given that\nit can do some things that (Dyalog) APL can’t, like produce graphics.</p>\n<p>Can your APL do this?</p>\n<pre>    chart:line mtcars \n┌→──────────────────────────────────────────────────────────────┐\n↓1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1│\n│4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4│\n│4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2│\n└───────────────────────────────────────────────────────────────┘</pre>\n<div class=\"float\">\n<img alt=\"chart:line mtcars in Kap\" data-lazy-src=\"https://i0.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/kap_mtcars.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"chart:line mtcars in Kap\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/kap_mtcars.png?w=578&amp;ssl=1\"/></noscript>\n<div class=\"figcaption\">chart:line mtcars in Kap</div>\n</div>\n<p><a href=\"https://kapdemo.dhsdevelopments.com/\" rel=\"nofollow\" target=\"_blank\">Kap</a> is a fairly new APL-based language\n(written in Kotlin) that supports most of Dyalog APL, but adds some cool\nextensions and alterations like lazy evaluation and parallel execution.</p>\n<p><a href=\"https://www.uiua.org/\" rel=\"nofollow\" target=\"_blank\">Uiua</a> is another new language on the scene (written in\nRust) which also supports graphics; the Uiua logo itself is written in Uiua</p>\n<pre>Xy ← °⍉⊞⊟. ÷÷2: -÷2,⇡.200\nRgb ← [:°⊟×.Xy ↯△⊢Xy0.5]\nu ← ↥&lt;0.2:&gt;0.7.+×2 ×.:°⊟Xy\nc ← &lt;:⍜°√/+ Xy\n⍉⊂:-¬u c1 +0.1 ↧¤c0.95Rgb</pre>\n<div class=\"float\">\n<img alt=\"Uiua logo, coded in Uiua\" data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uiua.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Uiua logo, coded in Uiua\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uiua.png?w=578&amp;ssl=1\"/></noscript>\n<div class=\"figcaption\">Uiua logo, coded in Uiua</div>\n</div>\n<p>The online editor for Uiua uses colours to distinguish different\nfunctions/operators, and the author has the flexibility to do what they want\nwith that, so it’s awesome to see what they’ve used for “all” (<code>⋔</code>) and\n“<strong>trans</strong>pose” (<code>⍉</code>)…</p>\n<div class=\"float\">\n<img alt=\"Uiua coloured glyphs for ‘all’ and ‘transpose’\" data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uaua_all_trans.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Uiua coloured glyphs for ‘all’ and ‘transpose’\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/uaua_all_trans.png?w=578&amp;ssl=1\"/></noscript>\n<div class=\"figcaption\">Uiua coloured glyphs for ‘all’ and ‘transpose’</div>\n</div>\n<p>I figured I’d try to reproduce the APL solution in Kap as a way to learn more\nabout that language. The APL/Kap solution is so elegant! Additionally, I tried\nwriting equivalent R code. I’ll interleave all three in this post (a nice excuse\nto get <a href=\"https://yihui.org/en/2023/10/section-tabsets/\" rel=\"nofollow\" target=\"_blank\">tabsets</a> working!).</p>\n<div class=\"section level2\" id=\"reading-input\">\n<h2>Reading Input</h2>\n<p>To start with, get the data into the workspace - this reads in a vector with\neach element representing a row of input</p>\n<div class=\"tabset\">\n</div>\n<ul>\n<li><p>APL</p>\n<p>Reading from a file is performed using <code>⎕NGET</code></p>\n<pre>    ⊃⎕NGET'p07.txt'1\r\n 32T3K 765  T55J5 684  KK677 28  KTJJT 220  QQQJA 483</pre></li>\n<li><p>Kap</p>\n<p>Kap uses some namespaces, which makes reading in a bit nicer, and the output is\nboxed, with explicit quotes for strings</p>\n<pre>p ← io:read \"p07.txt\"\r\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃\"32T3K 765\" \"T55J5 684\" \"KK677 28\" \"KTJJT 220\" \"QQQJA 483\"┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</pre></li>\n<li><p>R</p>\n<p><code>readLines</code> reads in each line as an element of a vector</p>\n<pre>p &lt;- readLines(\"example07.txt\")\np\r\n## [1] \"32T3K 765\" \"T55J5 684\" \"KK677 28\"  \"KTJJT 220\" \"QQQJA 483\"</pre></li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"preprocessing\">\n<h2>Preprocessing</h2>\n<p>The input consists of hands of cards juxtaposed with a bid value, separated by\na space. The approach here is not to treat them individually, but to create a\nmatrix containing columns of hands and columns of bids.</p>\n<div class=\"tabset\">\n</div>\n<ul>\n<li><p>APL</p>\n<p>Partition (<code>(≠⊆⊢)</code>) on spaces (<code>' '</code>) for each (<code>¨</code>) row</p>\n<pre>    ' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\r\n 32T3K  765    T55J5  684    KK677  28    KTJJT  220    QQQJA  483</pre>\n<p>It’s not entirely clear from this layout, but this is a vector of length-2 vectors.</p>\n<p>These are “mixed” (stacked; <code>↑</code>), and the result assigned (<code>←</code>) to <code>p</code></p>\n<pre>p←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\r\n 32T3K  765 \n T55J5  684 \n KK677  28  \n KTJJT  220 \n QQQJA  483 </pre>\n<p>This is now a matrix, where the first column contains the hands, the second\n(last) column contains the bids.</p></li>\n<li><p>Kap</p>\n<p>Rather than the partition idiom, Kap has regex support, so splitting the\ncomponents involes <code>regex:split</code> for each (<code>¨</code>) element of input</p>\n<pre>p←⊃{\" \" regex:split ⍵}¨p\r\n┌→────────────┐\n↓\"32T3K\" \"765\"│\n│\"T55J5\" \"684\"│\n│\"KK677\"  \"28\"│\n│\"KTJJT\" \"220\"│\n│\"QQQJA\" \"483\"│\n└─────────────┘</pre></li>\n<li><p>R</p>\n<p>The boilerplate of R’s matrix construction takes a toll after using APL/Kap…</p>\n<pre>p &lt;- matrix(unlist(strsplit(p, \" \")), ncol = 2, byrow = TRUE)\np\r\n##      [,1]    [,2] \n## [1,] \"32T3K\" \"765\"\n## [2,] \"T55J5\" \"684\"\n## [3,] \"KK677\" \"28\" \n## [4,] \"KTJJT\" \"220\"\n## [5,] \"QQQJA\" \"483\"</pre></li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"extraction\">\n<h2>Extraction</h2>\n<p>The hands and bids can be extracted into their own variables.</p>\n<div class=\"tabset\">\n</div>\n<ul>\n<li><p>APL</p>\n<p>This can be achieved several ways, but a clean way is by reducing (<code>/</code>) with\neither the ‘leftmost’ (<code>⊣</code>) or ‘rightmost’ (<code>⊢</code>) operator, and evaluating\n(executing <code>⍎</code>) each (<code>¨</code>) of the bids to convert from strings to numbers</p>\n<pre>hands←⊣/p\nbids←⍎¨⊢/p</pre></li>\n<li><p>Kap</p>\n<p>Kap uses exactly the same approach as APL for this</p>\n<pre>hands←⊣/p\nbids←⍎¨⊢/p</pre></li>\n<li><p>R</p>\n<p>R’s ‘subset by index’ works just fine, but if this was generalised I’d use\nsomething like <code>p[, ncol(p)]</code> to get to the last column</p>\n<pre>hands &lt;- p[,1]\nhands\r\n## [1] \"32T3K\" \"T55J5\" \"KK677\" \"KTJJT\" \"QQQJA\"\r\nbids &lt;- as.integer(p[,2])\nbids\r\n## [1] 765 684  28 220 483</pre></li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"tabulate\">\n<h2>Tabulate</h2>\n<p>Now comes the interesting part! Rather than deal with the types separately, one\napproach is to identify them by their relative counts; a five-of-a-kind has 5 of\none card and nothing elese; a four-of-a-kind has four of one and one of another.</p>\n<div class=\"tabset\">\n</div>\n<ul>\n<li><p>APL</p>\n<p>APL has a “key” (<code>⌸</code>) which takes a function as a left argument, which can be to\ncount the occurrences of each element with “tally” (<code>≢</code>)</p>\n<pre>      {⍺,≢⍵}⌸'TGGATAACTTGAAC'\r\nT 4\nG 3\nA 5\nC 2</pre>\n<p>In this case, we can get just the tallied count of each card in the hand with</p>\n<pre>    {⊢∘≢⍵}⌸¨hands\r\n2 1 1 1  1 3 1  2 1 2  1 2 2  3 1 1</pre>\n<p>We can then sort (<code>⍵[⍒⍵]</code>) these, take just the first two values (<code>2↑</code>), and\ndecode (<code>⊥</code>) using base 10 to a single number. A nice feature of APL is that\ntrying to take the “first N” elements of a single element pads to the full N\nwith zeroes.</p>\n<pre>    f←{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}\n    f¨hands\r\n21 31 22 22 31</pre></li>\n<li><p>Kap</p>\n<p>Kap doesn’t have the equivalent Key, but after some discussion with the creator,\nit’s entirely possible to get something that does the same</p>\n<pre>  key⇐(⍪+⌿≡⌻)∘∪ ⍝ using outer product - see the R solution\n  key2⇐{u←∪⍵ ⋄ c←⍸˝∧u⍳⍵} ⍝ using inverse 'where' and 'index of'\n\n  key2¨hands\r\n┌→────────────────────────────────────────┐\n│┌→──────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐│\n││2 1 1 1│ │1 3 1│ │2 1 2│ │1 2 2│ │3 1 1││\n│└───────┘ └─────┘ └─────┘ └─────┘ └─────┘│\n└─────────────────────────────────────────┘</pre>\n<p>The rest is the same as APL, except Kap uses a dedicated sort (<code>∨</code>)</p>\n<pre>    handrank⇐{10⊥2↑∨⊢/key ⍵}\n    handrank¨hands\r\n┏━━━━━━━━━━━━━━┓\n┃21 31 22 22 31┃\n┗━━━━━━━━━━━━━━┛</pre></li>\n<li><p>R</p>\n<p>I wanted to recreate the above approach in R, so this will take the long way ’round.</p>\n<p>First, we need a ‘key’ function</p>\n<pre>key &lt;- function(x) {\n  l &lt;- strsplit(x, \"\")[[1]]\n  setNames(colSums(outer(l, unique(l), \"==\")), unique(l))\n}\n\nsapply(hands, key)\r\n## $`32T3K`\n## 3 2 T K \n## 2 1 1 1 \n## \n## $T55J5\n## T 5 J \n## 1 3 1 \n## \n## $KK677\n## K 6 7 \n## 2 1 2 \n## \n## $KTJJT\n## K T J \n## 1 2 2 \n## \n## $QQQJA\n## Q J A \n## 3 1 1</pre>\n<p>The idea of this is to create an outer product between the set of\nunique letters in the string, and the individual letters, performing\nan <code>==</code> check on each combination</p>\n<pre>y &lt;- strsplit(hands[2], \"\")[[1]]\nouter(y, unique(y), \"==\")\r\n##       [,1]  [,2]  [,3]\n## [1,]  TRUE FALSE FALSE\n## [2,] FALSE  TRUE FALSE\n## [3,] FALSE  TRUE FALSE\n## [4,] FALSE FALSE  TRUE\n## [5,] FALSE  TRUE FALSE</pre>\n<p>This is, of course, unnecessary as R has a way to do this</p>\n<pre>table(y)\r\n## y\n## 5 J T \n## 3 1 1</pre>\n<p>but I wanted to see how to do it from scratch.</p>\n<p>Applying this over the hands, we can sort each of the counts again, but now\ntaking the first two values fails for the five-of-a-kind which only has a <code>5</code>,\nso in that case I add the missing 0. Decoding as base 10 can be done a couple\nof ways, but pasting and converting seems to work fine.</p>\n<pre>handrank &lt;- function(x) {\n  rank &lt;- sort(sapply(x, key), decreasing = TRUE)\n  if (length(rank) == 1) rank &lt;- c(rank, 0)\n  as.integer(paste(rank[1:2], collapse = \"\"))\n}\n\nsapply(hands, handrank)\r\n## 32T3K T55J5 KK677 KTJJT QQQJA \n##    21    31    22    22    31</pre></li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"subsequent-rankings-and-answer\">\n<h2>Subsequent Rankings and Answer</h2>\n<p>Finally, the part where the ‘array’ approach shines! Rather than constructing some\nsortable number for each hand, we can just score each card and use an array.</p>\n<div class=\"tabset\">\n</div>\n<ul>\n<li><p>APL</p>\n<p>Creating a vector of all the cards is aided by the ‘numbers as a string’\nhelper <code>⎕D</code>. Drop the first two of these (<code>2↓</code>) then append the ‘face’ cards</p>\n<pre>    r←'TJQKA',⍨2↓⎕D\n    r\r\n23456789TJQKA</pre>\n<p>Stacking the hands into a matrix of cards</p>\n<pre>    ↑hands\r\n32T3K\nT55J5\nKK677\nKTJJT\nQQQJA</pre>\n<p>we can ask for the index of matches to the individual cards with <code>⍳</code></p>\n<pre>    r⍳↑hands\r\n 2  1  9  2 12\n 9  4  4 10  4\n12 12  5  6  6\n12  9 10 10  9\n11 11 11 10 13</pre>\n<p>Prepending (<code>,</code>) each column with the tabulated type of each hand</p>\n<pre>    r{⍵,⍺⍳↑hands}f¨hands\r\n21  2  1  9  2 12\n31  9  4  4 10  4\n22 12 12  5  6  6\n22 12  9 10 10  9\n31 11 11 11 10 13</pre>\n<p>Now, some real magic… APL support <a href=\"https://aplwiki.com/wiki/Total_array_ordering\" rel=\"nofollow\" target=\"_blank\">“total array\nordering”</a> which means we can just\nsort the entire thing - it will sort by the first column, using the second and\nsubsequent columns for ties. Given that the first column is the ‘type’ of hand,\nand subsequent columns are values of each card in order, that’s precisely\nthe sorting we need!</p>\n<pre>    r{⍋⍋⍵,⍺⍳↑hands}f¨hands\r\n1 4 3 2 5</pre>\n<p>There’s a nice discussion about why the double grading from\n<a href=\"https://github.com/mlochbaum/BQN/blob/master/doc/order.md#ordinals\" rel=\"nofollow\" target=\"_blank\">BQN</a></p>\n<p>Finally, multiplying by the bids themselves, and sum-reducing gives the final\nanswer</p>\n<pre>  +/r{bids×⍋⍋⍵,⍺⍳↑hands}f¨hands\r\n6440</pre></li>\n<li><p>Kap</p>\n<p>This is mostly the same solution as APL, except I couldn’t find the ‘numbers\nas string’ so i just typed it out. Kap also uses ‘disclose’ (<code>⊃</code>) in place of\nmix (<code>↑</code>)\n(<a href=\"https://kapdemo.dhsdevelopments.com/kap-comparison.html#_enclose_and_disclose:~:text=If%20%E2%8A%83%20is%20called%20on%20an%20array%2C\" rel=\"nofollow\" target=\"_blank\">ref</a>).</p>\n<pre>    ranks←\"23456789TJQKA\"\n    +/ranks{bids×1+⍋⍋⍵,⍺⍳⊃hands}handrank¨hands\r\n6440</pre></li>\n<li><p>R</p>\n<p>R doesn’t support Total Array Ordering, but it does seem to have a way to do it,\nso say the documentation examples for <code>order</code></p>\n<pre>## or along 1st column, ties along 2nd, ... *arbitrary* no.{columns}:\ndd[ do.call(order, dd), ]</pre>\n<p>That only works for a <code>data.frame</code>, which <em>is</em> a <code>list</code> (per <code>do.call</code>’s requirement). We\ncan still work with that. First, smoosh together all the hands and convert the\nindividual cards to a matrix - again, a long line of commands for what is reasonably\nstraightforward in APL… <code>3 3⍴'abcdefghi'</code> reshapes those 9 letters into a 3x3 matrix.</p>\n<pre>m &lt;- matrix(strsplit(paste0(hands, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\nm\r\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,] \"3\"  \"2\"  \"T\"  \"3\"  \"K\" \n## [2,] \"T\"  \"5\"  \"5\"  \"J\"  \"5\" \n## [3,] \"K\"  \"K\"  \"6\"  \"7\"  \"7\" \n## [4,] \"K\"  \"T\"  \"J\"  \"J\"  \"T\" \n## [5,] \"Q\"  \"Q\"  \"Q\"  \"J\"  \"A\"</pre>\n<p>The individual cards vector benefits from coercing the digits to characters</p>\n<pre>ranks &lt;- c(2:9, \"T\", \"J\", \"Q\", \"K\", \"A\")</pre>\n<p>The index mapping does actually work nicely with <code>match</code>, except it returns a single\nvector, not a matrix, so we need to reshape yet again. Plus, this time, the matches went\ndown columns not along rows, so we need to use <code>byrow = FALSE</code></p>\n<pre>mm &lt;- matrix(match(m, ranks), ncol = 5, byrow = FALSE)\nmm\r\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    2    1    9    2   12\n## [2,]    9    4    4   10    4\n## [3,]   12   12    5    6    6\n## [4,]   12    9   10   10    9\n## [5,]   11   11   11   10   13</pre>\n<p>Prepending with the type rankings does work nicely via <code>cbind</code></p>\n<pre>g &lt;- cbind(sapply(hands, handrank), mm)\ng\r\n##       [,1] [,2] [,3] [,4] [,5] [,6]\n## 32T3K   21    2    1    9    2   12\n## T55J5   31    9    4    4   10    4\n## KK677   22   12   12    5    6    6\n## KTJJT   22   12    9   10   10    9\n## QQQJA   31   11   11   11   10   13</pre>\n<p>Then ordering with the <code>do.call</code> idiom</p>\n<pre>gdf &lt;- as.data.frame(g)\ngdf[do.call(order, gdf), ]\r\n##       V1 V2 V3 V4 V5 V6\n## 32T3K 21  2  1  9  2 12\n## KTJJT 22 12  9 10 10  9\n## KK677 22 12 12  5  6  6\n## T55J5 31  9  4  4 10  4\n## QQQJA 31 11 11 11 10 13</pre>\n<p>Putting this all together into a function</p>\n<pre>sortrank &lt;- function(x, y) {\n  m &lt;- matrix(strsplit(paste0(y, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\n  mm &lt;- matrix(match(m, x), ncol = 5, byrow = FALSE)\n  g &lt;- cbind(sapply(y, handrank), mm)\n  do.call(order, as.data.frame(g))\n}\n\nsortrank(ranks, hands)\r\n## [1] 1 4 3 2 5</pre>\n<p>This <em>isn’t</em> the double sorting that APL and Kap used, and that little\ndifference is what held me up for all too long trying to figure out why my\nsolution passed tests but gave the wrong answer. Annoyingly, this mistake\ndoesn’t show up in the test case because the ranks only differ by a switched\nplace. The true input was not so kind.</p>\n<p>This result <em>is</em> the order in which we need to place the bids, so doing that, then\nmultiplying by the position (since it’s sorted, this is just a vector from <code>1</code> to the\nnumber of elements) we get the answer</p>\n<pre>sum(bids[sortrank(ranks, hands)]*seq_along(bids))\r\n## [1] 6440</pre></li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"summary\">\n<h2>Summary</h2>\n<p>So, how do these solutions all look? I’ll stop with the tabsets for a side-by-side comparison.</p>\n<p>Compacting the APL solution (which does involve some duplication) it’s as simple as</p>\n<pre>p←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\n+/('TJQKA',⍨2↓⎕D){(⍎¨⊢/p)×⍋⍋⍵,⍺⍳↑⊣/p}{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}¨⊣/p</pre>\n<p>which, admittedly, requires a fair amount of unpacking to read. In full form, it’s</p>\n<pre>p←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\nhands←⊣/p\nbids←⍎¨⊢/p\nf←{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}\nr←'TJQKA',⍨2↓⎕D\n+/r{bids×⍋⍋⍵,⍺⍳↑hands}f¨hands</pre>\n<p>which is still pretty nice, considering what it’s doing.</p>\n<p>The R solution, somewhat minimally, and leveraging <code>table</code>, is</p>\n<pre>handrank &lt;- function(x) {\n  rank &lt;- sort(sapply(strsplit(x, \"\"), table), decreasing = TRUE)\n  if (length(rank) == 1) rank &lt;- c(rank, 0)\n  as.integer(paste(rank[1:2], collapse = \"\"))\n}\n\nsortrank &lt;- function(x, y) {\n  m &lt;- matrix(strsplit(paste0(y, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\n  mm &lt;- matrix(match(m, x), ncol = 5, byrow = FALSE)\n  g &lt;- cbind(sapply(y, handrank), mm)\n  do.call(order, as.data.frame(g))\n}\n\nsolve &lt;- function(x) {\n  p &lt;- matrix(unlist(strsplit(x, \" \")), ncol = 2, byrow = TRUE)\n  hands &lt;- p[,1]\n  bids &lt;- as.integer(p[,2])\n  ranks &lt;- c(2:9, \"T\", \"J\", \"Q\", \"K\", \"A\")\n  sum(bids[sortrank(ranks, hands)]*seq_along(bids))\n}\n\nsolve(readLines(\"example07.txt\"))</pre>\n<p>Certainly more typing, but still a much shorter solution than the one I originally\ncame up with.</p>\n</div>\n<div class=\"section level2\" id=\"takeaways\">\n<h2>Takeaways</h2>\n<p>Both APL and Kap (and so many other languages) benefit greatly from treating a string\nas an array of characters. This always hurts in R, where <code>strsplit(x, \"\")</code> is needed.</p>\n<p>The array approach here highlights how one can think differently about a problem, provided\nthe tools are at hand.</p>\n<p>Kap has a lot to offer - it’s (vastly) newer, which comes with both advantages\n(can do new things) and disadvantages (things need to be implemented, and they\nwon’t necessarily carry over 1:1).</p>\n<p>Advent of Code once again proves to be a useful exercise.</p>\n</div>\n<div class=\"section level2\" id=\"one-more-thing\">\n<h2>One more thing</h2>\n<p>I saw <a href=\"https://mastodon.social/@jstepien/111549757943773283\" rel=\"nofollow\" target=\"_blank\">a solution in Uiua on\nMastodon</a> and had to give\nit a go, too…</p>\n<pre>Input ← ⊜(⊜□≠@ .)≠@\\n.&amp;fras\"p07.txt\"\nLabel ← ⇌\"AKQJT98765432\"\nBids ← ⋕⊢↘1⍉\nCards ← ⊐≡(⊗:Label)⊢⍉\nTypes ← 0_1_2_4_8_5_10_9_3_6_12_11_13_7_14_15⊚1_4_3_3_2_2_1\nTypeStr ← ⊏⊗⊙Types≡(°⋯≡/=◫2⊏⍏.)\n/+×+1⍏⍏/+×ⁿ⇌⇡6⧻Label⊂⊃TypeStr⍉⊃Cards Bids Input</pre>\n<p>I <em>think</em> this is taking the same approach, though unpacking this is even\ntrickier.</p>\n<hr/>\n<p>Comments and improvements most welcome. I can be found on\n<a href=\"https://fosstodon.org/@jonocarroll\" rel=\"nofollow\" target=\"_blank\">Mastodon</a> or use the comments below.</p>\n<br/>\n<details>\n<summary>\n<tt>devtools::session_info()</tt>\n</summary>\n<pre>## ─ Session info ───────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.3.2 (2023-10-31)\n##  os       Pop!_OS 22.04 LTS\n##  system   x86_64, linux-gnu\n##  ui       X11\n##  language (EN)\n##  collate  en_AU.UTF-8\n##  ctype    en_AU.UTF-8\n##  tz       Australia/Adelaide\n##  date     2023-12-10\n##  pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ───────────────────────────────────────────────────────────────────\n##  package     * version date (UTC) lib source\n##  blogdown      1.18    2023-06-19 [1] CRAN (R 4.3.2)\n##  bookdown      0.36    2023-10-16 [1] CRAN (R 4.3.2)\n##  bslib         0.5.1   2023-08-11 [3] CRAN (R 4.3.1)\n##  cachem        1.0.8   2023-05-01 [3] CRAN (R 4.3.0)\n##  callr         3.7.3   2022-11-02 [3] CRAN (R 4.2.2)\n##  cli           3.6.1   2023-03-23 [3] CRAN (R 4.2.3)\n##  crayon        1.5.2   2022-09-29 [3] CRAN (R 4.2.1)\n##  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.3.2)\n##  digest        0.6.33  2023-07-07 [3] CRAN (R 4.3.1)\n##  ellipsis      0.3.2   2021-04-29 [3] CRAN (R 4.1.1)\n##  evaluate      0.22    2023-09-29 [3] CRAN (R 4.3.1)\n##  fastmap       1.1.1   2023-02-24 [3] CRAN (R 4.2.2)\n##  fs            1.6.3   2023-07-20 [3] CRAN (R 4.3.1)\n##  glue          1.6.2   2022-02-24 [3] CRAN (R 4.2.0)\n##  htmltools     0.5.6.1 2023-10-06 [3] CRAN (R 4.3.1)\n##  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.2)\n##  httpuv        1.6.12  2023-10-23 [1] CRAN (R 4.3.2)\n##  icecream      0.2.1   2023-09-27 [1] CRAN (R 4.3.2)\n##  jquerylib     0.1.4   2021-04-26 [3] CRAN (R 4.1.2)\n##  jsonlite      1.8.7   2023-06-29 [3] CRAN (R 4.3.1)\n##  knitr         1.44    2023-09-11 [3] CRAN (R 4.3.1)\n##  later         1.3.1   2023-05-02 [1] CRAN (R 4.3.2)\n##  lifecycle     1.0.3   2022-10-07 [3] CRAN (R 4.2.1)\n##  magrittr      2.0.3   2022-03-30 [3] CRAN (R 4.2.0)\n##  memoise       2.0.1   2021-11-26 [3] CRAN (R 4.2.0)\n##  mime          0.12    2021-09-28 [3] CRAN (R 4.2.0)\n##  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.3.2)\n##  pkgbuild      1.4.2   2023-06-26 [1] CRAN (R 4.3.2)\n##  pkgload       1.3.3   2023-09-22 [1] CRAN (R 4.3.2)\n##  prettyunits   1.2.0   2023-09-24 [3] CRAN (R 4.3.1)\n##  processx      3.8.2   2023-06-30 [3] CRAN (R 4.3.1)\n##  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.3.2)\n##  promises      1.2.1   2023-08-10 [1] CRAN (R 4.3.2)\n##  ps            1.7.5   2023-04-18 [3] CRAN (R 4.3.0)\n##  purrr         1.0.2   2023-08-10 [3] CRAN (R 4.3.1)\n##  R6            2.5.1   2021-08-19 [3] CRAN (R 4.2.0)\n##  Rcpp          1.0.11  2023-07-06 [1] CRAN (R 4.3.2)\n##  remotes       2.4.2.1 2023-07-18 [1] CRAN (R 4.3.2)\n##  rlang         1.1.1   2023-04-28 [3] CRAN (R 4.3.0)\n##  rmarkdown     2.25    2023-09-18 [3] CRAN (R 4.3.1)\n##  rstudioapi    0.15.0  2023-07-07 [3] CRAN (R 4.3.1)\n##  sass          0.4.7   2023-07-15 [3] CRAN (R 4.3.1)\n##  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n##  shiny         1.7.5.1 2023-10-14 [1] CRAN (R 4.3.2)\n##  stringi       1.7.12  2023-01-11 [3] CRAN (R 4.2.2)\n##  stringr       1.5.0   2022-12-02 [3] CRAN (R 4.3.0)\n##  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.3.2)\n##  usethis       2.2.2   2023-07-06 [1] CRAN (R 4.3.2)\n##  vctrs         0.6.4   2023-10-12 [3] CRAN (R 4.3.1)\n##  xfun          0.40    2023-08-09 [3] CRAN (R 4.3.1)\n##  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.3.2)\n##  yaml          2.3.7   2023-01-23 [3] CRAN (R 4.2.2)\n## \n##  [1] /home/jono/R/x86_64-pc-linux-gnu-library/4.3\n##  [2] /usr/local/lib/R/site-library\n##  [3] /usr/lib/R/site-library\n##  [4] /usr/lib/R/library\n## \n## ──────────────────────────────────────────────────────────────────────────────</pre>\n</details>\n<p><br/></p>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jcarroll.com.au/2023/12/10/advent-of-array-elegance/\"> rstats on Irregularly Scheduled Programming</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "Advent of Array Elegance (AoC2023 Day 7)\nPosted on\nDecember 9, 2023\nby\nJonathan Carroll\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nrstats on Irregularly Scheduled Programming\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nI’m solving\nAdvent of Code\nthis year using a\nrelaxed criteria compared to\nlast\nyear\nin that I’m\nallowing myself to use packages where they’re helpful, rather than\nstrictly\nbase R. Last year I re-solved half of the exercises using Rust which helped me\nlearn a lot about Rust. This year I’m enamored with APL, and I wanted to share a\nparticularly beautiful solution.\n⚠⚠⚠⚠⚠\nSpoilers ahead for Day 7, in case you haven’t yet completed it yourself.\n⚠⚠⚠⚠⚠\nI solved Day 7 of Advent of Code using base R by testing whether or not a given\nhand was of each type with an individual function, either returning 0 (if it was\nnot of that type) or\nN\n+ a score, where\nN\nwas sufficiently different between\neach type that they would sort nicely. For the score, I initially tried\noffsetting each card in a poor-man’s base-15 as\n15^(4:0)*card_score\nbut later\nimproved on that by using hex digits (which automatically sort nicer). The large\nN\nvalues ensured that ‘type’ would be sorted before the first/second/etc.. card.\nThat was sufficient to do an\napply(strength, hands)\n, calculate the\norder\nof\nthose, and multiply by the relevant bids. Aside from a bug not caught by the\ntest case (the difference between\nbid*order(x)\nand\nbid[order(x)]*seq_along(x)\n) it was an okay solution to the problem, and it\nworked.\nAfter solving each day, I’ve been trying to re-solve using APL; in particular Dyalog\nAPL. For those who don’t know, APL is an old language (circa 1960s) borne from a\nmathematical notation in which a single glyph (symbol) represents some operation\nor application of a function. This makes it look very different to more modern\nlanguages, partly because of the glyphs, but also because it requires no boilerplate\nwhatsoever. As an array language, it deals with vectors and matrices without needing\nto “loop over columns” or “for i in values”. It looks scary at first, but it’s really\nnot – once you’re familiar with the glyphs it’s actually beautiful!\nLet’s say you have a matrix\nm\nwhich contains the values\n1\nthrough\n9\nm\n1 2 3\n4 5 6\n7 8 9\nand you want to sum the columns. Chances are, the language you normally use will\nrequire you to first calculate the size of the matrix, maybe even perform a loop. In\nAPL, it’s\n+⌿m\n12 15 18\n⌿\nis the glyph for “reduce along first axis”, or perform some operation\n(supplied as its left argument) to its right argument.\n+⌿\nis therefore “sum\ncolumns”. No boilerplate, just a direct explanation (the glyphs themselves are\nbetter names than any word you could attach to them) of what needs to be done.\nSure, you need to learn the glyphs, and potentially even how to enter them; one option\nbeing a prefix key then a corresponding key. How committed am I to learning\nthose, you ask? Well, here’s my laptop\nMy laptop with APL stickers on the keys\nI considered using APL for my Day 7 solution, but it was so many functions\ndefined, and fiddly if/else logic, I figured it was just ill-suited to APL. Then\nI saw a\nvideo recap of an APL solution for Day\n7\nand my mind was blown.\nMeanwhile, I saw a post from\nElias\nMårtenson\n, creator of the Kap\nlanguage, promoting some examples of Kap and was even more interested given that\nit can do some things that (Dyalog) APL can’t, like produce graphics.\nCan your APL do this?\nchart:line mtcars \n┌→──────────────────────────────────────────────────────────────┐\n↓1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1│\n│4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4│\n│4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2│\n└───────────────────────────────────────────────────────────────┘\nchart:line mtcars in Kap\nKap\nis a fairly new APL-based language\n(written in Kotlin) that supports most of Dyalog APL, but adds some cool\nextensions and alterations like lazy evaluation and parallel execution.\nUiua\nis another new language on the scene (written in\nRust) which also supports graphics; the Uiua logo itself is written in Uiua\nXy ← °⍉⊞⊟. ÷÷2: -÷2,⇡.200\nRgb ← [:°⊟×.Xy ↯△⊢Xy0.5]\nu ← ↥<0.2:>0.7.+×2 ×.:°⊟Xy\nc ← <:⍜°√/+ Xy\n⍉⊂:-¬u c1 +0.1 ↧¤c0.95Rgb\nUiua logo, coded in Uiua\nThe online editor for Uiua uses colours to distinguish different\nfunctions/operators, and the author has the flexibility to do what they want\nwith that, so it’s awesome to see what they’ve used for “all” (\n⋔\n) and\n“\ntrans\npose” (\n⍉\n)…\nUiua coloured glyphs for ‘all’ and ‘transpose’\nI figured I’d try to reproduce the APL solution in Kap as a way to learn more\nabout that language. The APL/Kap solution is so elegant! Additionally, I tried\nwriting equivalent R code. I’ll interleave all three in this post (a nice excuse\nto get\ntabsets\nworking!).\nReading Input\nTo start with, get the data into the workspace - this reads in a vector with\neach element representing a row of input\nAPL\nReading from a file is performed using\n⎕NGET\n⊃⎕NGET'p07.txt'1\n 32T3K 765  T55J5 684  KK677 28  KTJJT 220  QQQJA 483\nKap\nKap uses some namespaces, which makes reading in a bit nicer, and the output is\nboxed, with explicit quotes for strings\np ← io:read \"p07.txt\"\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃\"32T3K 765\" \"T55J5 684\" \"KK677 28\" \"KTJJT 220\" \"QQQJA 483\"┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\nR\nreadLines\nreads in each line as an element of a vector\np <- readLines(\"example07.txt\")\np\n## [1] \"32T3K 765\" \"T55J5 684\" \"KK677 28\"  \"KTJJT 220\" \"QQQJA 483\"\nPreprocessing\nThe input consists of hands of cards juxtaposed with a bid value, separated by\na space. The approach here is not to treat them individually, but to create a\nmatrix containing columns of hands and columns of bids.\nAPL\nPartition (\n(≠⊆⊢)\n) on spaces (\n' '\n) for each (\n¨\n) row\n' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\n 32T3K  765    T55J5  684    KK677  28    KTJJT  220    QQQJA  483\nIt’s not entirely clear from this layout, but this is a vector of length-2 vectors.\nThese are “mixed” (stacked;\n↑\n), and the result assigned (\n←\n) to\np\np←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\n 32T3K  765 \n T55J5  684 \n KK677  28  \n KTJJT  220 \n QQQJA  483\nThis is now a matrix, where the first column contains the hands, the second\n(last) column contains the bids.\nKap\nRather than the partition idiom, Kap has regex support, so splitting the\ncomponents involes\nregex:split\nfor each (\n¨\n) element of input\np←⊃{\" \" regex:split ⍵}¨p\n┌→────────────┐\n↓\"32T3K\" \"765\"│\n│\"T55J5\" \"684\"│\n│\"KK677\"  \"28\"│\n│\"KTJJT\" \"220\"│\n│\"QQQJA\" \"483\"│\n└─────────────┘\nR\nThe boilerplate of R’s matrix construction takes a toll after using APL/Kap…\np <- matrix(unlist(strsplit(p, \" \")), ncol = 2, byrow = TRUE)\np\n##      [,1]    [,2] \n## [1,] \"32T3K\" \"765\"\n## [2,] \"T55J5\" \"684\"\n## [3,] \"KK677\" \"28\" \n## [4,] \"KTJJT\" \"220\"\n## [5,] \"QQQJA\" \"483\"\nExtraction\nThe hands and bids can be extracted into their own variables.\nAPL\nThis can be achieved several ways, but a clean way is by reducing (\n/\n) with\neither the ‘leftmost’ (\n⊣\n) or ‘rightmost’ (\n⊢\n) operator, and evaluating\n(executing\n⍎\n) each (\n¨\n) of the bids to convert from strings to numbers\nhands←⊣/p\nbids←⍎¨⊢/p\nKap\nKap uses exactly the same approach as APL for this\nhands←⊣/p\nbids←⍎¨⊢/p\nR\nR’s ‘subset by index’ works just fine, but if this was generalised I’d use\nsomething like\np[, ncol(p)]\nto get to the last column\nhands <- p[,1]\nhands\n## [1] \"32T3K\" \"T55J5\" \"KK677\" \"KTJJT\" \"QQQJA\"\nbids <- as.integer(p[,2])\nbids\n## [1] 765 684  28 220 483\nTabulate\nNow comes the interesting part! Rather than deal with the types separately, one\napproach is to identify them by their relative counts; a five-of-a-kind has 5 of\none card and nothing elese; a four-of-a-kind has four of one and one of another.\nAPL\nAPL has a “key” (\n⌸\n) which takes a function as a left argument, which can be to\ncount the occurrences of each element with “tally” (\n≢\n)\n{⍺,≢⍵}⌸'TGGATAACTTGAAC'\nT 4\nG 3\nA 5\nC 2\nIn this case, we can get just the tallied count of each card in the hand with\n{⊢∘≢⍵}⌸¨hands\n2 1 1 1  1 3 1  2 1 2  1 2 2  3 1 1\nWe can then sort (\n⍵[⍒⍵]\n) these, take just the first two values (\n2↑\n), and\ndecode (\n⊥\n) using base 10 to a single number. A nice feature of APL is that\ntrying to take the “first N” elements of a single element pads to the full N\nwith zeroes.\nf←{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}\n    f¨hands\n21 31 22 22 31\nKap\nKap doesn’t have the equivalent Key, but after some discussion with the creator,\nit’s entirely possible to get something that does the same\nkey⇐(⍪+⌿≡⌻)∘∪ ⍝ using outer product - see the R solution\n  key2⇐{u←∪⍵ ⋄ c←⍸˝∧u⍳⍵} ⍝ using inverse 'where' and 'index of'\n\n  key2¨hands\n┌→────────────────────────────────────────┐\n│┌→──────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐│\n││2 1 1 1│ │1 3 1│ │2 1 2│ │1 2 2│ │3 1 1││\n│└───────┘ └─────┘ └─────┘ └─────┘ └─────┘│\n└─────────────────────────────────────────┘\nThe rest is the same as APL, except Kap uses a dedicated sort (\n∨\n)\nhandrank⇐{10⊥2↑∨⊢/key ⍵}\n    handrank¨hands\n┏━━━━━━━━━━━━━━┓\n┃21 31 22 22 31┃\n┗━━━━━━━━━━━━━━┛\nR\nI wanted to recreate the above approach in R, so this will take the long way ’round.\nFirst, we need a ‘key’ function\nkey <- function(x) {\n  l <- strsplit(x, \"\")[[1]]\n  setNames(colSums(outer(l, unique(l), \"==\")), unique(l))\n}\n\nsapply(hands, key)\n## $`32T3K`\n## 3 2 T K \n## 2 1 1 1 \n## \n## $T55J5\n## T 5 J \n## 1 3 1 \n## \n## $KK677\n## K 6 7 \n## 2 1 2 \n## \n## $KTJJT\n## K T J \n## 1 2 2 \n## \n## $QQQJA\n## Q J A \n## 3 1 1\nThe idea of this is to create an outer product between the set of\nunique letters in the string, and the individual letters, performing\nan\n==\ncheck on each combination\ny <- strsplit(hands[2], \"\")[[1]]\nouter(y, unique(y), \"==\")\n##       [,1]  [,2]  [,3]\n## [1,]  TRUE FALSE FALSE\n## [2,] FALSE  TRUE FALSE\n## [3,] FALSE  TRUE FALSE\n## [4,] FALSE FALSE  TRUE\n## [5,] FALSE  TRUE FALSE\nThis is, of course, unnecessary as R has a way to do this\ntable(y)\n## y\n## 5 J T \n## 3 1 1\nbut I wanted to see how to do it from scratch.\nApplying this over the hands, we can sort each of the counts again, but now\ntaking the first two values fails for the five-of-a-kind which only has a\n5\n,\nso in that case I add the missing 0. Decoding as base 10 can be done a couple\nof ways, but pasting and converting seems to work fine.\nhandrank <- function(x) {\n  rank <- sort(sapply(x, key), decreasing = TRUE)\n  if (length(rank) == 1) rank <- c(rank, 0)\n  as.integer(paste(rank[1:2], collapse = \"\"))\n}\n\nsapply(hands, handrank)\n## 32T3K T55J5 KK677 KTJJT QQQJA \n##    21    31    22    22    31\nSubsequent Rankings and Answer\nFinally, the part where the ‘array’ approach shines! Rather than constructing some\nsortable number for each hand, we can just score each card and use an array.\nAPL\nCreating a vector of all the cards is aided by the ‘numbers as a string’\nhelper\n⎕D\n. Drop the first two of these (\n2↓\n) then append the ‘face’ cards\nr←'TJQKA',⍨2↓⎕D\n    r\n23456789TJQKA\nStacking the hands into a matrix of cards\n↑hands\n32T3K\nT55J5\nKK677\nKTJJT\nQQQJA\nwe can ask for the index of matches to the individual cards with\n⍳\nr⍳↑hands\n 2  1  9  2 12\n 9  4  4 10  4\n12 12  5  6  6\n12  9 10 10  9\n11 11 11 10 13\nPrepending (\n,\n) each column with the tabulated type of each hand\nr{⍵,⍺⍳↑hands}f¨hands\n21  2  1  9  2 12\n31  9  4  4 10  4\n22 12 12  5  6  6\n22 12  9 10 10  9\n31 11 11 11 10 13\nNow, some real magic… APL support\n“total array\nordering”\nwhich means we can just\nsort the entire thing - it will sort by the first column, using the second and\nsubsequent columns for ties. Given that the first column is the ‘type’ of hand,\nand subsequent columns are values of each card in order, that’s precisely\nthe sorting we need!\nr{⍋⍋⍵,⍺⍳↑hands}f¨hands\n1 4 3 2 5\nThere’s a nice discussion about why the double grading from\nBQN\nFinally, multiplying by the bids themselves, and sum-reducing gives the final\nanswer\n+/r{bids×⍋⍋⍵,⍺⍳↑hands}f¨hands\n6440\nKap\nThis is mostly the same solution as APL, except I couldn’t find the ‘numbers\nas string’ so i just typed it out. Kap also uses ‘disclose’ (\n⊃\n) in place of\nmix (\n↑\n)\n(\nref\n).\nranks←\"23456789TJQKA\"\n    +/ranks{bids×1+⍋⍋⍵,⍺⍳⊃hands}handrank¨hands\n6440\nR\nR doesn’t support Total Array Ordering, but it does seem to have a way to do it,\nso say the documentation examples for\norder\n## or along 1st column, ties along 2nd, ... *arbitrary* no.{columns}:\ndd[ do.call(order, dd), ]\nThat only works for a\ndata.frame\n, which\nis\na\nlist\n(per\ndo.call\n’s requirement). We\ncan still work with that. First, smoosh together all the hands and convert the\nindividual cards to a matrix - again, a long line of commands for what is reasonably\nstraightforward in APL…\n3 3⍴'abcdefghi'\nreshapes those 9 letters into a 3x3 matrix.\nm <- matrix(strsplit(paste0(hands, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\nm\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,] \"3\"  \"2\"  \"T\"  \"3\"  \"K\" \n## [2,] \"T\"  \"5\"  \"5\"  \"J\"  \"5\" \n## [3,] \"K\"  \"K\"  \"6\"  \"7\"  \"7\" \n## [4,] \"K\"  \"T\"  \"J\"  \"J\"  \"T\" \n## [5,] \"Q\"  \"Q\"  \"Q\"  \"J\"  \"A\"\nThe individual cards vector benefits from coercing the digits to characters\nranks <- c(2:9, \"T\", \"J\", \"Q\", \"K\", \"A\")\nThe index mapping does actually work nicely with\nmatch\n, except it returns a single\nvector, not a matrix, so we need to reshape yet again. Plus, this time, the matches went\ndown columns not along rows, so we need to use\nbyrow = FALSE\nmm <- matrix(match(m, ranks), ncol = 5, byrow = FALSE)\nmm\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    2    1    9    2   12\n## [2,]    9    4    4   10    4\n## [3,]   12   12    5    6    6\n## [4,]   12    9   10   10    9\n## [5,]   11   11   11   10   13\nPrepending with the type rankings does work nicely via\ncbind\ng <- cbind(sapply(hands, handrank), mm)\ng\n##       [,1] [,2] [,3] [,4] [,5] [,6]\n## 32T3K   21    2    1    9    2   12\n## T55J5   31    9    4    4   10    4\n## KK677   22   12   12    5    6    6\n## KTJJT   22   12    9   10   10    9\n## QQQJA   31   11   11   11   10   13\nThen ordering with the\ndo.call\nidiom\ngdf <- as.data.frame(g)\ngdf[do.call(order, gdf), ]\n##       V1 V2 V3 V4 V5 V6\n## 32T3K 21  2  1  9  2 12\n## KTJJT 22 12  9 10 10  9\n## KK677 22 12 12  5  6  6\n## T55J5 31  9  4  4 10  4\n## QQQJA 31 11 11 11 10 13\nPutting this all together into a function\nsortrank <- function(x, y) {\n  m <- matrix(strsplit(paste0(y, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\n  mm <- matrix(match(m, x), ncol = 5, byrow = FALSE)\n  g <- cbind(sapply(y, handrank), mm)\n  do.call(order, as.data.frame(g))\n}\n\nsortrank(ranks, hands)\n## [1] 1 4 3 2 5\nThis\nisn’t\nthe double sorting that APL and Kap used, and that little\ndifference is what held me up for all too long trying to figure out why my\nsolution passed tests but gave the wrong answer. Annoyingly, this mistake\ndoesn’t show up in the test case because the ranks only differ by a switched\nplace. The true input was not so kind.\nThis result\nis\nthe order in which we need to place the bids, so doing that, then\nmultiplying by the position (since it’s sorted, this is just a vector from\n1\nto the\nnumber of elements) we get the answer\nsum(bids[sortrank(ranks, hands)]*seq_along(bids))\n## [1] 6440\nSummary\nSo, how do these solutions all look? I’ll stop with the tabsets for a side-by-side comparison.\nCompacting the APL solution (which does involve some duplication) it’s as simple as\np←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\n+/('TJQKA',⍨2↓⎕D){(⍎¨⊢/p)×⍋⍋⍵,⍺⍳↑⊣/p}{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}¨⊣/p\nwhich, admittedly, requires a fair amount of unpacking to read. In full form, it’s\np←↑' '(≠⊆⊢)¨⊃⎕NGET'p07.txt'1\nhands←⊣/p\nbids←⍎¨⊢/p\nf←{10⊥2↑{⍵[⍒⍵]}⊢∘≢⌸⍵}\nr←'TJQKA',⍨2↓⎕D\n+/r{bids×⍋⍋⍵,⍺⍳↑hands}f¨hands\nwhich is still pretty nice, considering what it’s doing.\nThe R solution, somewhat minimally, and leveraging\ntable\n, is\nhandrank <- function(x) {\n  rank <- sort(sapply(strsplit(x, \"\"), table), decreasing = TRUE)\n  if (length(rank) == 1) rank <- c(rank, 0)\n  as.integer(paste(rank[1:2], collapse = \"\"))\n}\n\nsortrank <- function(x, y) {\n  m <- matrix(strsplit(paste0(y, collapse = \"\"), \"\")[[1]], ncol = 5, byrow = TRUE)\n  mm <- matrix(match(m, x), ncol = 5, byrow = FALSE)\n  g <- cbind(sapply(y, handrank), mm)\n  do.call(order, as.data.frame(g))\n}\n\nsolve <- function(x) {\n  p <- matrix(unlist(strsplit(x, \" \")), ncol = 2, byrow = TRUE)\n  hands <- p[,1]\n  bids <- as.integer(p[,2])\n  ranks <- c(2:9, \"T\", \"J\", \"Q\", \"K\", \"A\")\n  sum(bids[sortrank(ranks, hands)]*seq_along(bids))\n}\n\nsolve(readLines(\"example07.txt\"))\nCertainly more typing, but still a much shorter solution than the one I originally\ncame up with.\nTakeaways\nBoth APL and Kap (and so many other languages) benefit greatly from treating a string\nas an array of characters. This always hurts in R, where\nstrsplit(x, \"\")\nis needed.\nThe array approach here highlights how one can think differently about a problem, provided\nthe tools are at hand.\nKap has a lot to offer - it’s (vastly) newer, which comes with both advantages\n(can do new things) and disadvantages (things need to be implemented, and they\nwon’t necessarily carry over 1:1).\nAdvent of Code once again proves to be a useful exercise.\nOne more thing\nI saw\na solution in Uiua on\nMastodon\nand had to give\nit a go, too…\nInput ← ⊜(⊜□≠@ .)≠@\\n.&fras\"p07.txt\"\nLabel ← ⇌\"AKQJT98765432\"\nBids ← ⋕⊢↘1⍉\nCards ← ⊐≡(⊗:Label)⊢⍉\nTypes ← 0_1_2_4_8_5_10_9_3_6_12_11_13_7_14_15⊚1_4_3_3_2_2_1\nTypeStr ← ⊏⊗⊙Types≡(°⋯≡/=◫2⊏⍏.)\n/+×+1⍏⍏/+×ⁿ⇌⇡6⧻Label⊂⊃TypeStr⍉⊃Cards Bids Input\nI\nthink\nthis is taking the same approach, though unpacking this is even\ntrickier.\nComments and improvements most welcome. I can be found on\nMastodon\nor use the comments below.\ndevtools::session_info()\n## ─ Session info ───────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.3.2 (2023-10-31)\n##  os       Pop!_OS 22.04 LTS\n##  system   x86_64, linux-gnu\n##  ui       X11\n##  language (EN)\n##  collate  en_AU.UTF-8\n##  ctype    en_AU.UTF-8\n##  tz       Australia/Adelaide\n##  date     2023-12-10\n##  pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ───────────────────────────────────────────────────────────────────\n##  package     * version date (UTC) lib source\n##  blogdown      1.18    2023-06-19 [1] CRAN (R 4.3.2)\n##  bookdown      0.36    2023-10-16 [1] CRAN (R 4.3.2)\n##  bslib         0.5.1   2023-08-11 [3] CRAN (R 4.3.1)\n##  cachem        1.0.8   2023-05-01 [3] CRAN (R 4.3.0)\n##  callr         3.7.3   2022-11-02 [3] CRAN (R 4.2.2)\n##  cli           3.6.1   2023-03-23 [3] CRAN (R 4.2.3)\n##  crayon        1.5.2   2022-09-29 [3] CRAN (R 4.2.1)\n##  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.3.2)\n##  digest        0.6.33  2023-07-07 [3] CRAN (R 4.3.1)\n##  ellipsis      0.3.2   2021-04-29 [3] CRAN (R 4.1.1)\n##  evaluate      0.22    2023-09-29 [3] CRAN (R 4.3.1)\n##  fastmap       1.1.1   2023-02-24 [3] CRAN (R 4.2.2)\n##  fs            1.6.3   2023-07-20 [3] CRAN (R 4.3.1)\n##  glue          1.6.2   2022-02-24 [3] CRAN (R 4.2.0)\n##  htmltools     0.5.6.1 2023-10-06 [3] CRAN (R 4.3.1)\n##  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.2)\n##  httpuv        1.6.12  2023-10-23 [1] CRAN (R 4.3.2)\n##  icecream      0.2.1   2023-09-27 [1] CRAN (R 4.3.2)\n##  jquerylib     0.1.4   2021-04-26 [3] CRAN (R 4.1.2)\n##  jsonlite      1.8.7   2023-06-29 [3] CRAN (R 4.3.1)\n##  knitr         1.44    2023-09-11 [3] CRAN (R 4.3.1)\n##  later         1.3.1   2023-05-02 [1] CRAN (R 4.3.2)\n##  lifecycle     1.0.3   2022-10-07 [3] CRAN (R 4.2.1)\n##  magrittr      2.0.3   2022-03-30 [3] CRAN (R 4.2.0)\n##  memoise       2.0.1   2021-11-26 [3] CRAN (R 4.2.0)\n##  mime          0.12    2021-09-28 [3] CRAN (R 4.2.0)\n##  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.3.2)\n##  pkgbuild      1.4.2   2023-06-26 [1] CRAN (R 4.3.2)\n##  pkgload       1.3.3   2023-09-22 [1] CRAN (R 4.3.2)\n##  prettyunits   1.2.0   2023-09-24 [3] CRAN (R 4.3.1)\n##  processx      3.8.2   2023-06-30 [3] CRAN (R 4.3.1)\n##  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.3.2)\n##  promises      1.2.1   2023-08-10 [1] CRAN (R 4.3.2)\n##  ps            1.7.5   2023-04-18 [3] CRAN (R 4.3.0)\n##  purrr         1.0.2   2023-08-10 [3] CRAN (R 4.3.1)\n##  R6            2.5.1   2021-08-19 [3] CRAN (R 4.2.0)\n##  Rcpp          1.0.11  2023-07-06 [1] CRAN (R 4.3.2)\n##  remotes       2.4.2.1 2023-07-18 [1] CRAN (R 4.3.2)\n##  rlang         1.1.1   2023-04-28 [3] CRAN (R 4.3.0)\n##  rmarkdown     2.25    2023-09-18 [3] CRAN (R 4.3.1)\n##  rstudioapi    0.15.0  2023-07-07 [3] CRAN (R 4.3.1)\n##  sass          0.4.7   2023-07-15 [3] CRAN (R 4.3.1)\n##  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n##  shiny         1.7.5.1 2023-10-14 [1] CRAN (R 4.3.2)\n##  stringi       1.7.12  2023-01-11 [3] CRAN (R 4.2.2)\n##  stringr       1.5.0   2022-12-02 [3] CRAN (R 4.3.0)\n##  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.3.2)\n##  usethis       2.2.2   2023-07-06 [1] CRAN (R 4.3.2)\n##  vctrs         0.6.4   2023-10-12 [3] CRAN (R 4.3.1)\n##  xfun          0.40    2023-08-09 [3] CRAN (R 4.3.1)\n##  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.3.2)\n##  yaml          2.3.7   2023-01-23 [3] CRAN (R 4.2.2)\n## \n##  [1] /home/jono/R/x86_64-pc-linux-gnu-library/4.3\n##  [2] /usr/local/lib/R/site-library\n##  [3] /usr/lib/R/site-library\n##  [4] /usr/lib/R/library\n## \n## ──────────────────────────────────────────────────────────────────────────────\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nrstats on Irregularly Scheduled Programming\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "I’m solving Advent of Code this year using a relaxed criteria compared to last year in that I’m allowing myself to use packages where they’re helpful, rather than strictly base R. Last year I re-solved half of the exercises using Rust which helped me l...",
    "meta_keywords": null,
    "og_description": "I’m solving Advent of Code this year using a relaxed criteria compared to last year in that I’m allowing myself to use packages where they’re helpful, rather than strictly base R. Last year I re-solved half of the exercises using Rust which helped me l...",
    "og_image": "https://jcarroll.com.au/2023/12/10/advent-of-array-elegance/images/aplkeyboard_800.jpg",
    "og_title": "Advent of Array Elegance (AoC2023 Day 7) | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 20,
    "sitemap_lastmod": "2023-12-10T00:00:00+00:00",
    "twitter_description": "I’m solving Advent of Code this year using a relaxed criteria compared to last year in that I’m allowing myself to use packages where they’re helpful, rather than strictly base R. Last year I re-solved half of the exercises using Rust which helped me l...",
    "twitter_title": "Advent of Array Elegance (AoC2023 Day 7) | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/12/advent-of-array-elegance-aoc2023-day-7/",
    "word_count": 3997
  }
}