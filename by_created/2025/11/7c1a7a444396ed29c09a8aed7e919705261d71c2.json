{
  "id": "7c1a7a444396ed29c09a8aed7e919705261d71c2",
  "url": "https://www.r-bloggers.com/2025/06/get-your-data-on-2025-06-08-153800/",
  "created_at_utc": "2025-11-22T19:58:25Z",
  "data": null,
  "raw_original": {
    "uuid": "7cfd6cd1-3859-486f-9b18-55071873b451",
    "created_at": "2025-11-22 19:58:25",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/06/get-your-data-on-2025-06-08-153800/",
      "crawled_at": "2025-11-22T10:47:42.566773",
      "external_links": [
        {
          "href": "https://www.getyourdataon.com/2025/06/interpolation-in-frequency-domain.html",
          "text": "Get Your Data On"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://www.getyourdataon.com/2025/06/interpolation-in-frequency-domain.html",
          "text": "Get Your Data On"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Get Your Data On 2025-06-08 15:38:00 | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/LinInterp_rain-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rain-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_ramp-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rampZoom-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_function_ramp-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_functionSine-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/iIFD_ramp-1.png?w=450&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/chris-carbone/",
          "text": "Chris Carbone"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-392934 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Get Your Data On 2025-06-08 15:38:00</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">June 8, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/chris-carbone/\">Chris Carbone</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.getyourdataon.com/2025/06/interpolation-in-frequency-domain.html\"> Get Your Data On</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><!DOCTYPE html>\n\n<meta charset=\"utf-8\"/>\n<meta content=\"pandoc\" name=\"generator\"/>\n<meta content=\"IE=EDGE\" http-equiv=\"X-UA-Compatible\"/>\n<title>Interpolation in the Frequency Domain Improved!</title>\n\n\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\"/>\n<link href=\"https://www.getyourdataon.com/2025/06/InterpInFreqDomain_files/bootstrap-3.3.5/css/bootstrap.min.css\" rel=\"stylesheet\"/>\n\n\n\n\n\n<link href=\"https://www.getyourdataon.com/2025/06/InterpInFreqDomain_files/highlightjs-9.12.0/default.css\" rel=\"stylesheet\"/>\n\n\n\n\n\n<!-- tabsets -->\n\n<!-- code folding -->\n<div class=\"container-fluid main-container\">\n<div id=\"header\">\n<h1 class=\"title toc-ignore\">Interpolation in the Frequency Domain\nImproved!</h1>\n</div>\n<div class=\"section level2\" id=\"introduction\">\n<h2>Introduction</h2>\n<p>This post describes interpolation in the frequency domain (IFD) and\nan improvement to IFD. IFD is a method of interpolation that is easy to\nuse and produces good results on most time series data (data samples\nequally spaced in time). It is easy to use because it does not require\nany prior knowledge of the data. Also, since IFD uses the Fast Fourier\nTransform (FFT), it is fast (even on large data sets). The drawback to\nIFD is that it sometimes produces an interpolation that is not good at\nthe start and end of the sequence (referred to as “end effects”). The\nimproved IFD reduces the end effects. While end effects are not always\nan issue, it is always better to not have them.</p>\n<p>The first section briefly introduces interpolation. The next section\ndefines the standard IFD algorithm and shows examples of its use. The\nfinal section shows an improved IFD that reduces end effects.</p>\n</div>\n<div class=\"section level2\" id=\"interpolation-example\">\n<h2>Interpolation Example</h2>\n<p>Let’s say we check a rain gauge at 7:00 and then once an hour for\nfive hours, resulting in the following measurements: 0.01 cm, 0.19 cm,\n0.31 cm, 0.40 cm, 0.52 cm, and 0.59 cm. We didn’t measure the rain at\n7:30, but we could estimate the rainfall at 7:30 using a linear spline\nto interpolate (connecting the points with straight lines).</p>\n<p>The figure below shows the five rainfall values from above and an\nillustration of interpolating a rainfall value at 730. The figure shows\nthe five measurements as black circles, the interpolating blue line\nconnecting the points 700 and 800, and the interpolated point at 0730\nshown as a red circle. The red circle shows that the rainfall at 730 is\n0.1 cm.\n<img data-lazy-src=\"https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/LinInterp_rain-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/LinInterp_rain-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"interpolation-in-the-frequency-domain\">\n<h2>Interpolation in the Frequency Domain</h2>\n<p>Linear spline interpolation is effective if the underlying data can\nbe modeled by a straight line. IFD works well regardless of the type of\ndata.</p>\n<p>The steps in the algorithm for IFD are enumerated below.</p>\n<ol style=\"list-style-type: decimal\">\n<li>Find the discrete Fourier transform (DFT) of the data using the\nbuilt-in function <code>fft</code>, which is R’s implementation of the\nFFT. The data started in the time domain (data indexed by time). After\nthe transform, the data is in the frequency domain (data indexed by\nfrequency).<br/>\n</li>\n<li>Add zeros to the data. This is called zero padding, and it forces\nthe inverse DFT (IDFT) in the next step to evaluate the data at more\npoints. When adding zeros to the frequency domain data, the zeros must\ngo in the middle. This step is slightly different for even and odd\nlength sequences.</li>\n<li>Perform the IDFT on the zero padded DFT sequence.</li>\n</ol>\n<p>These steps are explained below.</p>\n<div class=\"section level3\" id=\"find-the-dft-of-the-sequence\">\n<h3>Find the DFT of the Sequence</h3>\n<p>To illustrate this step, we use the rain fall values from above.</p>\n<p>First, we use the <code>fft</code> function to find the DFT of the\nsequence. Below, I’m going to stop saying, “Use the <code>fft</code>\nfunction to find the DFT.” I’ll just say find the FFT. Note: to take up\nless space on the screen, I’ll round the output to two decimal\nplaces.</p>\n<pre>N &lt;- length(x)\nX &lt;- fft(x)\nround(X,digits = 2)\n## [1]  1.43+0.00i -0.34+0.37i -0.34+0.11i -0.34-0.11i -0.34-0.37i</pre>\n</div>\n<div class=\"section level3\" id=\"zero-pad-the-data\">\n<h3>Zero Pad the Data</h3>\n<p>In this case, we want to double the number of points, so we add five\nzeros to X. The zeros have to be added in the “middle” of the sequence.\nIf you are familiar with Fourier transform theory, you’ll note that this\nis between the positive and negative frequencies.</p>\n<pre>Xzp &lt;- c(X[1],X[2:3],rep(0,5),X[4:5])\nround(Xzp,digits = 2)\n##  [1]  1.43+0.00i -0.34+0.37i -0.34+0.11i  0.00+0.00i  0.00+0.00i  0.00+0.00i\n##  [7]  0.00+0.00i  0.00+0.00i -0.34-0.11i -0.34-0.37i</pre>\n<p>Note if the DFT samples X had an even number of samples, for instance\n6, then zero padded DFT Xzp would be c(X[1], X[2:3], X[4]/2, rep(0, N),\nX[4]/2, X[5:6]). The X[N/2+1] sample (in this case, X[4]) is used twice\nbut cut in half to keep the energy the same. I show an example of this\nin the IFD Section.</p>\n</div>\n<div class=\"section level3\" id=\"inverse-dft\">\n<h3>Inverse DFT</h3>\n<p>Now, we find the inverse FFT. The inverse FFT is scaled by one over\nthe number of samples. Notice we are dividing by the number of actual\ndata points (five) and not the total number of points in the padded\nsequence (ten). If we divide by ten, we bias the result low because the\nzeros don’t add any energy to the sequence.</p>\n<pre>xinterp &lt;- fft(Xzp,inverse = TRUE)/N\nround(xinterp,digits=2)\n##  [1] 0.01+0i 0.00+0i 0.19+0i 0.33+0i 0.31+0i 0.29+0i 0.40+0i 0.55+0i 0.52+0i\n## [10] 0.26+0i</pre>\n<p>Since we started with a real sequence, we should end with a real\nsequence. However, the <code>fft</code> output is complex, so we convert\nthe sequence to real using the <code>Re</code> function.</p>\n<pre>xinterp &lt;- Re(xinterp)\nround(xinterp,digits = 2)\n##  [1] 0.01 0.00 0.19 0.33 0.31 0.29 0.40 0.55 0.52 0.26</pre>\n<p>The figure below contains two plots. The interpolated sequence in\nblue x’s and the original sequence in black circles (the circles are\nhard to see because they have x’s on them). Note the interpolation\n(especially the points at 7:30 and 12:30) is not great. This method\nsuffers from end effects and performs poorly with short sequences. We\nshow a method that mitigates the end effects in the IFD Function\nImproved section.\n<img data-lazy-src=\"https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rain-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i0.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rain-1.png?w=450&amp;ssl=1\"/></noscript>\n</p><h3>Example IFD with a Longer Sequence</h3>\n<p>Now, let’s try IFD with a longer\nsequence. Below is a 49 sample ramp.</p>\n<pre>N &lt;- 49\nx &lt;-1:N</pre>\n<p>Since we now know the algorithm, I’ll go through the steps with less\nexplanation. First, find the FFT.</p>\n<pre>X &lt;-fft(x)</pre>\n<p>Second, zero pad by 2.</p>\n<pre>Xzp &lt;- c(X[1:ceiling(N/2)],rep(0,N),X[(ceiling(N/2)+1):N])</pre>\n<p>Finally, the IDFT.</p>\n<pre>xInterp &lt;- Re(fft(Xzp,inverse = TRUE)/N)</pre>\n<p>The figure below contains two plots. The interpolated sequence is\nshown as a blue line, and the ramp sequence is shown as black circles.\nYou can see the end effects at the start and end of the plot. After the\nend effects, the interpolated points are close to the ramp.\n<img data-lazy-src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_ramp-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_ramp-1.png?w=450&amp;ssl=1\"/></noscript></p>\n<p>The figure below contains a zoomed-in view of the one above. A blue\nline shows the interpolated sequence, and black circles show the\noriginal ramp samples. You can see that after the effects at the\nbeginning, the interpolation is very good.\n<img data-lazy-src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rampZoom-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_rampZoom-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level3\" id=\"ifd-function\">\n<h3>IFD Function</h3>\n<p>Here, we put the IFD steps into the function <code>findIfd</code>,\nwhich inputs a data sequence <code>dataSet</code> and the interpolation\nfactor <code>M</code>. To keep the function simple, <code>M</code> is\nrestricted to an integer value. The function first checks to see if the\ninterpolation factor is an integer, not less than 1. Next, it finds the\nFFT of <code>dataSet</code> and sets <code>N</code> to the length of\n<code>dataSet</code>. The function determines if <code>dataSet</code>\nhas an even or odd number of samples and then places the zeros in the\nmiddle. After zero padding, it finds the IFFT of the zero-padded\nsequence. Finally, it returns the interpolated sequence, converting the\nsequence to real if the input <code>dataSet</code> was real. Note the R\nfunction <code>is.numeric</code> returns true if the sequence is\nreal.</p>\n<pre>findIfd &lt;- function(dataSet,M=2) {\n  \n  if (round(M)!=M || M&lt;1) {\n    stop(\"M must be an integer larger than zero.\")\n  }\n  \n  X &lt;- fft(dataSet)\n  N &lt;- length(X)\n  \n  if(floor(N/2)==N/2){\n    Xzp &lt;- c(X[1:(N/2)],X[N/2+1]/2,rep(0,(M-1)*N-1),X[N/2+1]/2,X[(N/2+2):N])\n    \n  } else {\n    Xzp &lt;- c(X[1:ceiling(N/2)],rep(0,((M-1)*N)),X[(ceiling(N/2)+1):N])\n  }\n  xint &lt;- fft(Xzp,inverse = TRUE)/N\n  \n  if (is.numeric(dataSet))\n      Re(xint[1:(M*N)])\n  else\n      xint[1:(M*N)]\n}</pre>\n</div>\n<div class=\"section level3\" id=\"example-ifd-function-and-the-ramp\">\n<h3>Example: IFD Function and the Ramp</h3>\n<p>Below, we use the <code>findIfd</code> to interpolate the ramp. You\ncan see we started with a 50 sample ramp and used an interpolation\nfactor of 8, so the length of the interpolated sequence is 400.</p>\n<pre>N &lt;- 50\nx &lt;-1:N\nxInterp &lt;- findIfd(x,M=8)</pre>\n<p>The plot below shows the interpolated sequence in blue (800 points\nmake the plot hard to read), and the ramp sequence is shown in black\npoints. As shown above, we can see that the interpolation is good away\nfrom the middle.<br/>\n<img data-lazy-src=\"https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_function_ramp-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_function_ramp-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level3\" id=\"example-interpolating-a-sine-wave\">\n<h3>Example: Interpolating a Sine Wave</h3>\n<p>IFD works better when the function is periodic and smooth. In this\nexample, we interpolate a sine sequence, and since it is periodic and\nsmooth, we should get a better result.</p>\n<pre>N &lt;- 50\nn &lt;- 0:(N-1)\nf &lt;- 0.02\nx &lt;- sin(2*pi*f*n)\nM &lt;- 4\nxInterp &lt;- findIfd(x,M)\nNdx &lt;- seq(0,N-1/M,1/M)</pre>\n<p>The figure below contains two plots. The black circles are the\noriginal sine sequence, and the blue line shows the interpolation. You\ncan see this is a very good interpolation with no end effects.<br/>\n<img data-lazy-src=\"https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_functionSine-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/IFD_functionSine-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n</div>\n<div class=\"section level2\" id=\"ifd-function-improved\">\n<h2>IFD Function Improved</h2>\n<p>The improved version of the IFD function “mirrors” the sequence\nbefore performing the interpolation. By mirror, I mean appending a\nreversed version of the sequence to the end of the original sequence.\nSee below for an example of mirroring.</p>\n<pre>x &lt;- 1:5\nc(x,rev(x))\n##  [1] 1 2 3 4 5 5 4 3 2 1</pre>\n<p>The function <code>findIfdImproved</code> inputs a sequence\n<code>x</code> and the interpolation factor <code>M</code> and then\noutputs an interpolated sequence. The difference between this function\nand <code>findIfd</code> is this function mirrors the sequence before\nimplementing the IFD algorithm. The extra samples at the end of the\ninterpolated sequence (caused by the mirroring) are removed before\nreturning the interpolated sequence. Note mirroring doubles the\nsequence, making it even. So, we only need to use the zero padding\nmethod for even length sequences. Note that <code>findIfdImproved</code>\ndoubles the sequence but does not take twice as long due to the\nproprieties of the FFT.</p>\n<pre>findIfdImproved &lt;- function(x,M) {\n  \n  if (round(M)!=M || M&lt;1 ) {\n    stop(\"M must be an integer larger than zero.\")\n  }\n  \n  X &lt;- fft(c(x,rev(x)))\n  N &lt;- length(X)\n  \n  Xzp &lt;- c(X[1:(N/2)],X[N/2+1]/2,rep(0,(M-1)*N-1),X[N/2+1]/2,X[(N/2+2):N])\n\n  xint &lt;- fft(Xzp,inverse = TRUE)/N\n  \n  if (is.numeric(x)) {\n    xint &lt;- Re(xint[1:(M*length(x))]) }\n  else{ \n    xint &lt;- xint[1:(M*length(x))] }\n}</pre>\n<p>Below, we use the <code>findIfdImproved</code> to interpolate the 50\npoint ramp, with an interpolation factor of 8.</p>\n<pre>N &lt;- 50\nx &lt;-1:N\nxInterp &lt;- findIfdImproved(x,M=8)</pre>\n<p>The plot below shows the interpolated sequence as a blue line and the\nramp sequence as black points. We see the <code>findIfdImproved</code>\nproduces an improved interpolation with almost no end effects (you can\nsee slight end effects at the end of the sequence).</p>\n<p><img data-lazy-src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/iIFD_ramp-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/iIFD_ramp-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"conclution\">\n<h2>Conclution</h2>\n<p>IFD is an easy-to-use method of interpolation that produces good\nresults, except for the end effects. The improved method significantly\nreduces the end effects, at the cost of additional processing.</p>\n</div>\n</div>\n\n<!-- tabsets -->\n\n<!-- code folding -->\n<!-- dynamically load mathjax for compatibility with self-contained -->\n\n\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.getyourdataon.com/2025/06/interpolation-in-frequency-domain.html\"> Get Your Data On</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Get Your Data On 2025-06-08 15:38:00\nPosted on\nJune 8, 2025\nby\nChris Carbone\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nGet Your Data On\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nInterpolation in the Frequency Domain Improved!\nInterpolation in the Frequency Domain\nImproved!\nIntroduction\nThis post describes interpolation in the frequency domain (IFD) and\nan improvement to IFD. IFD is a method of interpolation that is easy to\nuse and produces good results on most time series data (data samples\nequally spaced in time). It is easy to use because it does not require\nany prior knowledge of the data. Also, since IFD uses the Fast Fourier\nTransform (FFT), it is fast (even on large data sets). The drawback to\nIFD is that it sometimes produces an interpolation that is not good at\nthe start and end of the sequence (referred to as “end effects”). The\nimproved IFD reduces the end effects. While end effects are not always\nan issue, it is always better to not have them.\nThe first section briefly introduces interpolation. The next section\ndefines the standard IFD algorithm and shows examples of its use. The\nfinal section shows an improved IFD that reduces end effects.\nInterpolation Example\nLet’s say we check a rain gauge at 7:00 and then once an hour for\nfive hours, resulting in the following measurements: 0.01 cm, 0.19 cm,\n0.31 cm, 0.40 cm, 0.52 cm, and 0.59 cm. We didn’t measure the rain at\n7:30, but we could estimate the rainfall at 7:30 using a linear spline\nto interpolate (connecting the points with straight lines).\nThe figure below shows the five rainfall values from above and an\nillustration of interpolating a rainfall value at 730. The figure shows\nthe five measurements as black circles, the interpolating blue line\nconnecting the points 700 and 800, and the interpolated point at 0730\nshown as a red circle. The red circle shows that the rainfall at 730 is\n0.1 cm.\nInterpolation in the Frequency Domain\nLinear spline interpolation is effective if the underlying data can\nbe modeled by a straight line. IFD works well regardless of the type of\ndata.\nThe steps in the algorithm for IFD are enumerated below.\nFind the discrete Fourier transform (DFT) of the data using the\nbuilt-in function\nfft\n, which is R’s implementation of the\nFFT. The data started in the time domain (data indexed by time). After\nthe transform, the data is in the frequency domain (data indexed by\nfrequency).\nAdd zeros to the data. This is called zero padding, and it forces\nthe inverse DFT (IDFT) in the next step to evaluate the data at more\npoints. When adding zeros to the frequency domain data, the zeros must\ngo in the middle. This step is slightly different for even and odd\nlength sequences.\nPerform the IDFT on the zero padded DFT sequence.\nThese steps are explained below.\nFind the DFT of the Sequence\nTo illustrate this step, we use the rain fall values from above.\nFirst, we use the\nfft\nfunction to find the DFT of the\nsequence. Below, I’m going to stop saying, “Use the\nfft\nfunction to find the DFT.” I’ll just say find the FFT. Note: to take up\nless space on the screen, I’ll round the output to two decimal\nplaces.\nN <- length(x)\nX <- fft(x)\nround(X,digits = 2)\n## [1]  1.43+0.00i -0.34+0.37i -0.34+0.11i -0.34-0.11i -0.34-0.37i\nZero Pad the Data\nIn this case, we want to double the number of points, so we add five\nzeros to X. The zeros have to be added in the “middle” of the sequence.\nIf you are familiar with Fourier transform theory, you’ll note that this\nis between the positive and negative frequencies.\nXzp <- c(X[1],X[2:3],rep(0,5),X[4:5])\nround(Xzp,digits = 2)\n##  [1]  1.43+0.00i -0.34+0.37i -0.34+0.11i  0.00+0.00i  0.00+0.00i  0.00+0.00i\n##  [7]  0.00+0.00i  0.00+0.00i -0.34-0.11i -0.34-0.37i\nNote if the DFT samples X had an even number of samples, for instance\n6, then zero padded DFT Xzp would be c(X[1], X[2:3], X[4]/2, rep(0, N),\nX[4]/2, X[5:6]). The X[N/2+1] sample (in this case, X[4]) is used twice\nbut cut in half to keep the energy the same. I show an example of this\nin the IFD Section.\nInverse DFT\nNow, we find the inverse FFT. The inverse FFT is scaled by one over\nthe number of samples. Notice we are dividing by the number of actual\ndata points (five) and not the total number of points in the padded\nsequence (ten). If we divide by ten, we bias the result low because the\nzeros don’t add any energy to the sequence.\nxinterp <- fft(Xzp,inverse = TRUE)/N\nround(xinterp,digits=2)\n##  [1] 0.01+0i 0.00+0i 0.19+0i 0.33+0i 0.31+0i 0.29+0i 0.40+0i 0.55+0i 0.52+0i\n## [10] 0.26+0i\nSince we started with a real sequence, we should end with a real\nsequence. However, the\nfft\noutput is complex, so we convert\nthe sequence to real using the\nRe\nfunction.\nxinterp <- Re(xinterp)\nround(xinterp,digits = 2)\n##  [1] 0.01 0.00 0.19 0.33 0.31 0.29 0.40 0.55 0.52 0.26\nThe figure below contains two plots. The interpolated sequence in\nblue x’s and the original sequence in black circles (the circles are\nhard to see because they have x’s on them). Note the interpolation\n(especially the points at 7:30 and 12:30) is not great. This method\nsuffers from end effects and performs poorly with short sequences. We\nshow a method that mitigates the end effects in the IFD Function\nImproved section.\nExample IFD with a Longer Sequence\nNow, let’s try IFD with a longer\nsequence. Below is a 49 sample ramp.\nN <- 49\nx <-1:N\nSince we now know the algorithm, I’ll go through the steps with less\nexplanation. First, find the FFT.\nX <-fft(x)\nSecond, zero pad by 2.\nXzp <- c(X[1:ceiling(N/2)],rep(0,N),X[(ceiling(N/2)+1):N])\nFinally, the IDFT.\nxInterp <- Re(fft(Xzp,inverse = TRUE)/N)\nThe figure below contains two plots. The interpolated sequence is\nshown as a blue line, and the ramp sequence is shown as black circles.\nYou can see the end effects at the start and end of the plot. After the\nend effects, the interpolated points are close to the ramp.\nThe figure below contains a zoomed-in view of the one above. A blue\nline shows the interpolated sequence, and black circles show the\noriginal ramp samples. You can see that after the effects at the\nbeginning, the interpolation is very good.\nIFD Function\nHere, we put the IFD steps into the function\nfindIfd\n,\nwhich inputs a data sequence\ndataSet\nand the interpolation\nfactor\nM\n. To keep the function simple,\nM\nis\nrestricted to an integer value. The function first checks to see if the\ninterpolation factor is an integer, not less than 1. Next, it finds the\nFFT of\ndataSet\nand sets\nN\nto the length of\ndataSet\n. The function determines if\ndataSet\nhas an even or odd number of samples and then places the zeros in the\nmiddle. After zero padding, it finds the IFFT of the zero-padded\nsequence. Finally, it returns the interpolated sequence, converting the\nsequence to real if the input\ndataSet\nwas real. Note the R\nfunction\nis.numeric\nreturns true if the sequence is\nreal.\nfindIfd <- function(dataSet,M=2) {\n  \n  if (round(M)!=M || M<1) {\n    stop(\"M must be an integer larger than zero.\")\n  }\n  \n  X <- fft(dataSet)\n  N <- length(X)\n  \n  if(floor(N/2)==N/2){\n    Xzp <- c(X[1:(N/2)],X[N/2+1]/2,rep(0,(M-1)*N-1),X[N/2+1]/2,X[(N/2+2):N])\n    \n  } else {\n    Xzp <- c(X[1:ceiling(N/2)],rep(0,((M-1)*N)),X[(ceiling(N/2)+1):N])\n  }\n  xint <- fft(Xzp,inverse = TRUE)/N\n  \n  if (is.numeric(dataSet))\n      Re(xint[1:(M*N)])\n  else\n      xint[1:(M*N)]\n}\nExample: IFD Function and the Ramp\nBelow, we use the\nfindIfd\nto interpolate the ramp. You\ncan see we started with a 50 sample ramp and used an interpolation\nfactor of 8, so the length of the interpolated sequence is 400.\nN <- 50\nx <-1:N\nxInterp <- findIfd(x,M=8)\nThe plot below shows the interpolated sequence in blue (800 points\nmake the plot hard to read), and the ramp sequence is shown in black\npoints. As shown above, we can see that the interpolation is good away\nfrom the middle.\nExample: Interpolating a Sine Wave\nIFD works better when the function is periodic and smooth. In this\nexample, we interpolate a sine sequence, and since it is periodic and\nsmooth, we should get a better result.\nN <- 50\nn <- 0:(N-1)\nf <- 0.02\nx <- sin(2*pi*f*n)\nM <- 4\nxInterp <- findIfd(x,M)\nNdx <- seq(0,N-1/M,1/M)\nThe figure below contains two plots. The black circles are the\noriginal sine sequence, and the blue line shows the interpolation. You\ncan see this is a very good interpolation with no end effects.\nIFD Function Improved\nThe improved version of the IFD function “mirrors” the sequence\nbefore performing the interpolation. By mirror, I mean appending a\nreversed version of the sequence to the end of the original sequence.\nSee below for an example of mirroring.\nx <- 1:5\nc(x,rev(x))\n##  [1] 1 2 3 4 5 5 4 3 2 1\nThe function\nfindIfdImproved\ninputs a sequence\nx\nand the interpolation factor\nM\nand then\noutputs an interpolated sequence. The difference between this function\nand\nfindIfd\nis this function mirrors the sequence before\nimplementing the IFD algorithm. The extra samples at the end of the\ninterpolated sequence (caused by the mirroring) are removed before\nreturning the interpolated sequence. Note mirroring doubles the\nsequence, making it even. So, we only need to use the zero padding\nmethod for even length sequences. Note that\nfindIfdImproved\ndoubles the sequence but does not take twice as long due to the\nproprieties of the FFT.\nfindIfdImproved <- function(x,M) {\n  \n  if (round(M)!=M || M<1 ) {\n    stop(\"M must be an integer larger than zero.\")\n  }\n  \n  X <- fft(c(x,rev(x)))\n  N <- length(X)\n  \n  Xzp <- c(X[1:(N/2)],X[N/2+1]/2,rep(0,(M-1)*N-1),X[N/2+1]/2,X[(N/2+2):N])\n\n  xint <- fft(Xzp,inverse = TRUE)/N\n  \n  if (is.numeric(x)) {\n    xint <- Re(xint[1:(M*length(x))]) }\n  else{ \n    xint <- xint[1:(M*length(x))] }\n}\nBelow, we use the\nfindIfdImproved\nto interpolate the 50\npoint ramp, with an interpolation factor of 8.\nN <- 50\nx <-1:N\nxInterp <- findIfdImproved(x,M=8)\nThe plot below shows the interpolated sequence as a blue line and the\nramp sequence as black points. We see the\nfindIfdImproved\nproduces an improved interpolation with almost no end effects (you can\nsee slight end effects at the end of the sequence).\nConclution\nIFD is an easy-to-use method of interpolation that produces good\nresults, except for the end effects. The improved method significantly\nreduces the end effects, at the cost of additional processing.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nGet Your Data On\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "Interpolation in the Frequency Domain Improved! Interpolation in the Frequency Domain Improved! Introduction This post describes interpolation in the frequency domain (IFD) and an improvement to IFD. IFD is a method of interpolation that is easy to use and produces good results on most time series data (data samples equally spaced in time). It is easy to use because it does not require any prior knowledge of the data. Also, since IFD uses the Fast Fourier Transform (FFT), it is fast (even on large data sets). The drawback to IFD is that it sometimes produces an interpolation that is not good at the start and end of the sequence (referred to as “end effects”). The improved IFD reduces the end effects. While end effects are not always an issue, it is always better to not have them. The first section briefly introduces interpolation. The next section defines the standard IFD algorithm and shows examples of its use. The final section shows an improved IFD that reduces end effects. Interpolation Example Let’s say we check a rain gauge at 7:00 and then once an hour for five hours, resulting in the following measurements: 0.01 cm, 0.19 cm, 0.31 cm, 0.40 cm, 0.52 cm, and 0.59 cm. We didn’t measure the rain at 7:30, but we could estimate the rainfall at 7:30 using a linear spline to interpolate (connecting the points with straight lines). The figure below shows the five rainfall values from above and an illustration of interpolating a rainfall value at 730. The figure shows the five measurements as black circles, the interpolating blue line connecting the points 700 and 800, and the interpolated point at 0730 shown as a red circle. The red circle shows that the rainfall at 730 is 0.1 cm. Interpolation in the Frequency Domain Linear spline interpolation is effective if the underlying data can be modeled by a straight line. IFD works well regardless of the type of data. The steps in the algorithm for IFD are enumerated below. Find the discrete Fourier transform (DFT) of the data using the built-in function fft, which is R’s implementation of the FFT. The data started in the time domain (data indexed by time). After the transform, the data is in the frequency domain (data indexed by frequency). Add zeros to the data. This is called zero padding, and it forces the inverse DFT (IDFT) in the next step to evaluate the data at more points. When adding zeros to the frequency domain data, the zeros must go in the middle. This step is slightly different for even and odd length sequences. Perform the IDFT on the zero padded DFT sequence. These steps are explained below. Find the DFT of the Sequence To illustrate this step, we use the rain fall values from above. First, we use the fft function to find the DFT of the sequence. Below, I’m going to stop saying, “Use the fft function to find the DFT.” I’ll just say find the FFT. Note: to take up less space on the screen, I’ll round the output to two decimal places. N",
      "meta_keywords": null,
      "og_description": "Interpolation in the Frequency Domain Improved! Interpolation in the Frequency Domain Improved! Introduction This post describes interpolation in the frequency domain (IFD) and an improvement to IFD. IFD is a method of interpolation that is easy to use and produces good results on most time series data (data samples equally spaced in time). It is easy to use because it does not require any prior knowledge of the data. Also, since IFD uses the Fast Fourier Transform (FFT), it is fast (even on large data sets). The drawback to IFD is that it sometimes produces an interpolation that is not good at the start and end of the sequence (referred to as “end effects”). The improved IFD reduces the end effects. While end effects are not always an issue, it is always better to not have them. The first section briefly introduces interpolation. The next section defines the standard IFD algorithm and shows examples of its use. The final section shows an improved IFD that reduces end effects. Interpolation Example Let’s say we check a rain gauge at 7:00 and then once an hour for five hours, resulting in the following measurements: 0.01 cm, 0.19 cm, 0.31 cm, 0.40 cm, 0.52 cm, and 0.59 cm. We didn’t measure the rain at 7:30, but we could estimate the rainfall at 7:30 using a linear spline to interpolate (connecting the points with straight lines). The figure below shows the five rainfall values from above and an illustration of interpolating a rainfall value at 730. The figure shows the five measurements as black circles, the interpolating blue line connecting the points 700 and 800, and the interpolated point at 0730 shown as a red circle. The red circle shows that the rainfall at 730 is 0.1 cm. Interpolation in the Frequency Domain Linear spline interpolation is effective if the underlying data can be modeled by a straight line. IFD works well regardless of the type of data. The steps in the algorithm for IFD are enumerated below. Find the discrete Fourier transform (DFT) of the data using the built-in function fft, which is R’s implementation of the FFT. The data started in the time domain (data indexed by time). After the transform, the data is in the frequency domain (data indexed by frequency). Add zeros to the data. This is called zero padding, and it forces the inverse DFT (IDFT) in the next step to evaluate the data at more points. When adding zeros to the frequency domain data, the zeros must go in the middle. This step is slightly different for even and odd length sequences. Perform the IDFT on the zero padded DFT sequence. These steps are explained below. Find the DFT of the Sequence To illustrate this step, we use the rain fall values from above. First, we use the fft function to find the DFT of the sequence. Below, I’m going to stop saying, “Use the fft function to find the DFT.” I’ll just say find the FFT. Note: to take up less space on the screen, I’ll round the output to two decimal places. N",
      "og_image": "https://github.com/carbone1853/GetYourDataOn/blob/Interpolation-in-the-Frequency-Domain-Improved/LinInterp_rain-1.png?raw=true",
      "og_title": "Get Your Data On 2025-06-08 15:38:00 | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 10.4,
      "sitemap_lastmod": null,
      "twitter_description": "Interpolation in the Frequency Domain Improved! Interpolation in the Frequency Domain Improved! Introduction This post describes interpolation in the frequency domain (IFD) and an improvement to IFD. IFD is a method of interpolation that is easy to use and produces good results on most time series data (data samples equally spaced in time). It is easy to use because it does not require any prior knowledge of the data. Also, since IFD uses the Fast Fourier Transform (FFT), it is fast (even on large data sets). The drawback to IFD is that it sometimes produces an interpolation that is not good at the start and end of the sequence (referred to as “end effects”). The improved IFD reduces the end effects. While end effects are not always an issue, it is always better to not have them. The first section briefly introduces interpolation. The next section defines the standard IFD algorithm and shows examples of its use. The final section shows an improved IFD that reduces end effects. Interpolation Example Let’s say we check a rain gauge at 7:00 and then once an hour for five hours, resulting in the following measurements: 0.01 cm, 0.19 cm, 0.31 cm, 0.40 cm, 0.52 cm, and 0.59 cm. We didn’t measure the rain at 7:30, but we could estimate the rainfall at 7:30 using a linear spline to interpolate (connecting the points with straight lines). The figure below shows the five rainfall values from above and an illustration of interpolating a rainfall value at 730. The figure shows the five measurements as black circles, the interpolating blue line connecting the points 700 and 800, and the interpolated point at 0730 shown as a red circle. The red circle shows that the rainfall at 730 is 0.1 cm. Interpolation in the Frequency Domain Linear spline interpolation is effective if the underlying data can be modeled by a straight line. IFD works well regardless of the type of data. The steps in the algorithm for IFD are enumerated below. Find the discrete Fourier transform (DFT) of the data using the built-in function fft, which is R’s implementation of the FFT. The data started in the time domain (data indexed by time). After the transform, the data is in the frequency domain (data indexed by frequency). Add zeros to the data. This is called zero padding, and it forces the inverse DFT (IDFT) in the next step to evaluate the data at more points. When adding zeros to the frequency domain data, the zeros must go in the middle. This step is slightly different for even and odd length sequences. Perform the IDFT on the zero padded DFT sequence. These steps are explained below. Find the DFT of the Sequence To illustrate this step, we use the rain fall values from above. First, we use the fft function to find the DFT of the sequence. Below, I’m going to stop saying, “Use the fft function to find the DFT.” I’ll just say find the FFT. Note: to take up less space on the screen, I’ll round the output to two decimal places. N",
      "twitter_title": "Get Your Data On 2025-06-08 15:38:00 | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/06/get-your-data-on-2025-06-08-153800/",
      "word_count": 2071
    }
  }
}