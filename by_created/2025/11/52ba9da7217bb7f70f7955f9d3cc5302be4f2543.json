{
  "id": "52ba9da7217bb7f70f7955f9d3cc5302be4f2543",
  "url": "https://www.r-bloggers.com/2025/03/underrated-gems-in-r-must-know-functions-youre-probably-missing-out-on/",
  "created_at_utc": "2025-11-22T19:59:04Z",
  "data": null,
  "raw_original": {
    "uuid": "c2e96b4d-9c50-4686-ba48-6d5ccbf95578",
    "created_at": "2025-11-22 19:59:04",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/03/underrated-gems-in-r-must-know-functions-youre-probably-missing-out-on/",
      "crawled_at": "2025-11-22T10:52:33.658655",
      "external_links": [
        {
          "href": "https://mfatihtuzen.netlify.app/posts/2025-03-11_underrated_functions/",
          "text": "A Statistician's R Notebook"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "https://www.R-project.org/"
        },
        {
          "href": "https://cran.r-project.org/package=janitor",
          "text": "https://CRAN.R-project.org/package=janitor"
        },
        {
          "href": "https://mfatihtuzen.netlify.app/posts/2025-03-11_underrated_functions/",
          "text": "A Statistician's R Notebook"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Underrated Gems in R: Must-Know Functions You’re Probably Missing Out On | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/m-fatih-tuzen/",
          "text": "M. Fatih Tüzen"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
          "text": "[email protected]"
        },
        {
          "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
          "text": "[email protected]"
        },
        {
          "href": "https://www.r-bloggers.com/cdn-cgi/l/email-protection",
          "text": "[email protected]"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-391142 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Underrated Gems in R: Must-Know Functions You’re Probably Missing Out On</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">March 10, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/m-fatih-tuzen/\">M. Fatih Tüzen</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://mfatihtuzen.netlify.app/posts/2025-03-11_underrated_functions/\"> A Statistician's R Notebook</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<p>R is packed with powerhouse tools—think dplyr for data wrangling, ggplot2 for stunning visuals, or tidyr for tidying up messes. But beyond the headliners, there’s a lineup of lesser-known functions that deserve a spot in your toolkit. These hidden gems can streamline your code, solve tricky problems, and even make you wonder how you managed without them. In this post, we’ll uncover four underrated R functions: <strong><code>Reduce, vapply, do.call</code></strong> and <strong><code>janitor::clean_names</code></strong>. With practical examples ranging from beginner-friendly to advanced, plus outputs to show you what’s possible, this guide will have you itching to try them out in your next project. Let’s dive in and see what these under-the-radar stars can do!</p>\n<section class=\"level2\" id=\"reduce-collapse-with-control\">\n<h2 class=\"anchored\" data-anchor-id=\"reduce-collapse-with-control\">1. Reduce: Collapse with Control</h2>\n<section class=\"level3\" id=\"what-it-does-and-its-arguments\">\n<h3 class=\"anchored\" data-anchor-id=\"what-it-does-and-its-arguments\">What It Does and Its Arguments</h3>\n<p>Reduce is a base R function that iteratively applies a two-argument function to a list or vector, shrinking it down to a single result. It’s like a secret weapon for avoiding loops while keeping things elegant.</p>\n<p><strong>Key Arguments:</strong></p>\n<ul>\n<li><p><code>f:</code> The function to apply (e.g., +, *, or a custom one).</p></li>\n<li><p><code>x:</code> The list or vector to reduce.</p></li>\n<li><p><code>init</code> (optional): A starting value (defaults to the first element of x if omitted).</p></li>\n<li><p><code>accumulate</code> (optional): If TRUE, returns all intermediate results (defaults to FALSE).</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"use-cases\">\n<h3 class=\"anchored\" data-anchor-id=\"use-cases\">Use Cases</h3>\n<ul>\n<li><p>Summing or multiplying without explicit iteration.</p></li>\n<li><p>Combining data structures step-by-step.</p></li>\n<li><p>Simplifying recursive tasks.</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"examples\">\n<h3 class=\"anchored\" data-anchor-id=\"examples\">Examples</h3>\n<section class=\"level4\" id=\"simple-quick-sum\">\n<h4 class=\"anchored\" data-anchor-id=\"simple-quick-sum\">Simple: Quick Sum</h4>\n<div class=\"cell\">\n<pre>numbers &lt;- 1:5\ntotal &lt;- Reduce(`+`, numbers)\nprint(total)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 15</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> Reduce adds 1 + 2 = 3, then 3 + 3 = 6, 6 + 4 = 10, and 10 + 5 = 15. It’s a sleek alternative to sum().</p>\n</section>\n<section class=\"level4\" id=\"intermediate-string-building\">\n<h4 class=\"anchored\" data-anchor-id=\"intermediate-string-building\">Intermediate: String Building</h4>\n<div class=\"cell\">\n<pre>words &lt;- c(\"R\", \"is\", \"awesome\")\nsentence &lt;- Reduce(paste, words, init = \"\")\nprint(sentence)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \" R is awesome\"</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> Starting with an empty string (init = ““), Reduce glues the words together with spaces. Skip init, and it starts with”R”, which might not be what you want.</p>\n</section>\n<section class=\"level4\" id=\"advanced-merging-data-frames\">\n<h4 class=\"anchored\" data-anchor-id=\"advanced-merging-data-frames\">Advanced: Merging Data Frames</h4>\n<div class=\"cell\">\n<pre>df1 &lt;- data.frame(a = 1:2, b = c(\"x\", \"y\"))\ndf2 &lt;- data.frame(a = 3:4, b = c(\"z\", \"w\"))\ndf3 &lt;- data.frame(a = 5:6, b = c(\"p\", \"q\"))\ncombined &lt;- Reduce(rbind, list(df1, df2, df3))\nprint(combined)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>  a b\n1 1 x\n2 2 y\n3 3 z\n4 4 w\n5 5 p\n6 6 q</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> Reduce stacks three data frames row-wise, pairing them up one by one. It’s a loop-free way to handle multiple merges.</p>\n<div class=\"callout callout-style-default callout-note callout-titled\">\n<div class=\"callout-header d-flex align-content-center\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-title-container flex-fill\">\nA Quick Note on purrr::reduce()\n</div>\n</div>\n<div class=\"callout-body-container callout-body\">\n<p>If you’re a fan of the tidyverse, check out purrr::reduce(). It’s a modern take on base R’s Reduce, offering a consistent syntax with other purrr functions (like .x and .y for arguments) and handy shortcuts like ~ .x + .y for inline functions. It also defaults to left-to-right reduction but can go right-to-left with reduce_right(). Worth a look if you want a more polished, tidyverse-friendly alternative!</p>\n<p>Here’s an intermediate-level example of using the <code>reduce()</code> function from the <code>purrr</code> package for joining multiple dataframes:</p>\n<div class=\"cell\">\n<pre>library(purrr)\nlibrary(dplyr)\n\n# Create three sample dataframes representing different aspects of customer data\ncustomers &lt;- data.frame(\n  customer_id = 1:5,\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Edward\"),\n  age = c(32, 45, 28, 36, 52)\n)\n\norders &lt;- data.frame(\n  order_id = 101:108,\n  customer_id = c(1, 2, 2, 3, 3, 3, 4, 5),\n  order_date = as.Date(c(\"2023-01-15\", \"2023-01-20\", \"2023-02-10\", \n                        \"2023-01-05\", \"2023-02-15\", \"2023-03-20\",\n                        \"2023-02-25\", \"2023-03-10\")),\n  amount = c(120.50, 85.75, 200.00, 45.99, 75.25, 150.00, 95.50, 210.25)\n)\n\nfeedback &lt;- data.frame(\n  feedback_id = 201:206,\n  customer_id = c(1, 2, 3, 3, 4, 5),\n  rating = c(4, 5, 3, 4, 5, 4),\n  feedback_date = as.Date(c(\"2023-01-20\", \"2023-01-25\", \"2023-01-10\",\n                          \"2023-02-20\", \"2023-03-01\", \"2023-03-15\"))\n)\n\n# List of dataframes to join with the joining column\ndataframes_to_join &lt;- list(\n  list(df = customers, by = \"customer_id\"),\n  list(df = orders, by = \"customer_id\"),\n  list(df = feedback, by = \"customer_id\")\n)\n\n# Using reduce to join all dataframes\n# Start with customers dataframe and progressively join the others\njoined_data &lt;- reduce(\n  dataframes_to_join[-1],  # Exclude first dataframe as it's our starting point\n  function(acc, x) {\n    left_join(acc, x$df, by = x$by)\n  },\n  .init = dataframes_to_join[[1]]$df  # Start with customers dataframe\n)\n\n# View the result\nprint(joined_data)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>   customer_id    name age order_id order_date amount feedback_id rating\n1            1   Alice  32      101 2023-01-15 120.50         201      4\n2            2     Bob  45      102 2023-01-20  85.75         202      5\n3            2     Bob  45      103 2023-02-10 200.00         202      5\n4            3 Charlie  28      104 2023-01-05  45.99         203      3\n5            3 Charlie  28      104 2023-01-05  45.99         204      4\n6            3 Charlie  28      105 2023-02-15  75.25         203      3\n7            3 Charlie  28      105 2023-02-15  75.25         204      4\n8            3 Charlie  28      106 2023-03-20 150.00         203      3\n9            3 Charlie  28      106 2023-03-20 150.00         204      4\n10           4   Diana  36      107 2023-02-25  95.50         205      5\n11           5  Edward  52      108 2023-03-10 210.25         206      4\n   feedback_date\n1     2023-01-20\n2     2023-01-25\n3     2023-01-25\n4     2023-01-10\n5     2023-02-20\n6     2023-01-10\n7     2023-02-20\n8     2023-01-10\n9     2023-02-20\n10    2023-03-01\n11    2023-03-15</pre>\n</div>\n</div>\n<p>This example demonstrates how to use <code>reduce()</code> to join multiple dataframes in a sequential, elegant way. This pattern is particularly useful when dealing with complex data integration tasks where you need to combine multiple data sources with a common identifier.</p>\n</div>\n</div>\n</section>\n</section>\n</section>\n<section class=\"level2\" id=\"vapply-iteration-with-assurance\">\n<h2 class=\"anchored\" data-anchor-id=\"vapply-iteration-with-assurance\">2. vapply: Iteration with Assurance</h2>\n<section class=\"level3\" id=\"what-it-does-and-its-arguments-1\">\n<h3 class=\"anchored\" data-anchor-id=\"what-it-does-and-its-arguments-1\">What It Does and Its Arguments</h3>\n<p>vapply is another base R gem, similar to lapply but with a twist: it forces you to specify the output type and length upfront. This makes it safer and more predictable, especially for critical tasks.</p>\n<p><strong>Key Arguments:</strong></p>\n<ul>\n<li><p><code>X</code>: The list or vector to process.</p></li>\n<li><p><code>FUN</code>: The function to apply to each element.</p></li>\n<li><p><code>FUN.VALUE</code>: A template for the output (e.g., numeric(1) for a single number).</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"use-cases-1\">\n<h3 class=\"anchored\" data-anchor-id=\"use-cases-1\">Use Cases</h3>\n<ul>\n<li><p>Guaranteeing consistent output types.</p></li>\n<li><p>Extracting specific stats from lists.</p></li>\n<li><p>Writing reliable code for packages or production.</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"examples-1\">\n<h3 class=\"anchored\" data-anchor-id=\"examples-1\">Examples</h3>\n<section class=\"level4\" id=\"simple-doubling-up\">\n<h4 class=\"anchored\" data-anchor-id=\"simple-doubling-up\">Simple: Doubling Up</h4>\n<div class=\"cell\">\n<pre>values &lt;- 1:3\ndoubled &lt;- vapply(values, function(x) x * 2, numeric(1))\nprint(doubled)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 2 4 6</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> Each value doubles, and numeric(1) ensures a numeric vector—simple and rock-solid.</p>\n</section>\n<section class=\"level4\" id=\"intermediate-word-lengths\">\n<h4 class=\"anchored\" data-anchor-id=\"intermediate-word-lengths\">Intermediate: Word Lengths</h4>\n<div class=\"cell\">\n<pre>terms &lt;- c(\"data\", \"science\", \"R\")\nlengths &lt;- vapply(terms, nchar, numeric(1))\nprint(lengths)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>   data science       R \n      4       7       1 </pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> vapply counts characters per word, delivering a numeric vector every time—no surprises like sapply might throw.</p>\n</section>\n<section class=\"level4\" id=\"advanced-stats-snapshot\">\n<h4 class=\"anchored\" data-anchor-id=\"advanced-stats-snapshot\">Advanced: Stats Snapshot</h4>\n<div class=\"cell\">\n<pre>samples &lt;- list(c(1, 2, 3), c(4, 5), c(6, 7, 8))\nstats &lt;- vapply(samples, function(x) c(mean = mean(x), sd = sd(x)), numeric(2))\nprint(stats)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>     [,1]      [,2] [,3]\nmean    2 4.5000000    7\nsd      1 0.7071068    1</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> For each sample, vapply computes mean and standard deviation, returning a matrix (2 rows, 3 columns). It’s a tidy, type-safe summary.</p>\n</section>\n</section>\n</section>\n<section class=\"level2\" id=\"do.call-dynamic-function-magic\">\n<h2 class=\"anchored\" data-anchor-id=\"do.call-dynamic-function-magic\">3. do.call: Dynamic Function Magic</h2>\n<section class=\"level3\" id=\"what-it-does-and-its-arguments-2\">\n<h3 class=\"anchored\" data-anchor-id=\"what-it-does-and-its-arguments-2\">What It Does and Its Arguments</h3>\n<p>do.call in base R lets you call a function with a list of arguments, making it a go-to for flexible, on-the-fly operations. It’s like having a universal remote for your functions.</p>\n<p><strong>Key Arguments:</strong></p>\n<ul>\n<li><p><code>what</code>: The function to call (e.g., rbind, paste).</p></li>\n<li><p><code>args</code>: A list of arguments to pass.</p></li>\n<li><p><code>quote</code> (optional): Rarely used, defaults to FALSE.</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"use-cases-2\">\n<h3 class=\"anchored\" data-anchor-id=\"use-cases-2\">Use Cases</h3>\n<ul>\n<li><p>Combining variable inputs.</p></li>\n<li><p>Running functions dynamically.</p></li>\n<li><p>Simplifying calls with list-based data.</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"examples-2\">\n<h3 class=\"anchored\" data-anchor-id=\"examples-2\">Examples</h3>\n<section class=\"level4\" id=\"simple-vector-mashup\">\n<h4 class=\"anchored\" data-anchor-id=\"simple-vector-mashup\">Simple: Vector Mashup</h4>\n<div class=\"cell\">\n<pre>chunks &lt;- list(1:3, 4:6)\nall &lt;- do.call(c, chunks)\nprint(all)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] 1 2 3 4 5 6</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> do.call feeds the list to c(), stitching the vectors together effortlessly.</p>\n</section>\n<section class=\"level4\" id=\"intermediate-custom-join\">\n<h4 class=\"anchored\" data-anchor-id=\"intermediate-custom-join\">Intermediate: Custom Join</h4>\n<div class=\"cell\">\n<pre>bits &lt;- list(\"Code\", \"Runs\", \"Fast\")\njoined &lt;- do.call(paste, c(bits, list(sep = \"|\")))\nprint(joined)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"Code|Runs|Fast\"</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> do.call combines the list with a sep argument, creating a piped string in one smooth move.</p>\n</section>\n<section class=\"level4\" id=\"advanced-flexible-binding\">\n<h4 class=\"anchored\" data-anchor-id=\"advanced-flexible-binding\">Advanced: Flexible Binding</h4>\n<div class=\"cell\">\n<pre>df_list &lt;- list(data.frame(x = 1:2), data.frame(x = 3:4))\ndirection &lt;- \"vertical\"\nbound &lt;- do.call(if (direction == \"vertical\") rbind else cbind, df_list)\nprint(bound)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>  x\n1 1\n2 2\n3 3\n4 4</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> With direction = “vertical”, do.call uses rbind to stack rows. Change it to “horizontal”, and cbind takes over—dynamic and smart.</p>\n</section>\n</section>\n</section>\n<section class=\"level2\" id=\"janitorclean_names-tame-your-column-chaos\">\n<h2 class=\"anchored\" data-anchor-id=\"janitorclean_names-tame-your-column-chaos\">4. janitor::clean_names: Tame Your Column Chaos</h2>\n<section class=\"level3\" id=\"what-it-does-and-its-arguments-3\">\n<h3 class=\"anchored\" data-anchor-id=\"what-it-does-and-its-arguments-3\">What It Does and Its Arguments</h3>\n<p>From the janitor package, clean_names() transforms messy column names into consistent, code-friendly formats (e.g., lowercase with underscores). It’s a time-saver you’ll wish you’d known sooner.</p>\n<p><strong>Key Arguments:</strong></p>\n<ul>\n<li><p><code>dat</code>: The data frame to clean.</p></li>\n<li><p><code>case</code>: The style for names (e.g., “snake”, “small_camel”, defaults to “snake”).</p></li>\n<li><p><code>replace</code>: A named vector for custom replacements (optional).</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"use-cases-3\">\n<h3 class=\"anchored\" data-anchor-id=\"use-cases-3\">Use Cases</h3>\n<ul>\n<li><p>Standardizing imported data with ugly headers.</p></li>\n<li><p>Prepping data frames for analysis or plotting.</p></li>\n<li><p>Avoiding frustration with inconsistent naming.</p></li>\n</ul>\n</section>\n<section class=\"level3\" id=\"examples-3\">\n<h3 class=\"anchored\" data-anchor-id=\"examples-3\">Examples</h3>\n<section class=\"level4\" id=\"simple-basic-cleanup\">\n<h4 class=\"anchored\" data-anchor-id=\"simple-basic-cleanup\">Simple: Basic Cleanup</h4>\n<div class=\"cell\">\n<pre>library(janitor)\n\n# Create a dataframe with messy column names\ndf &lt;- data.frame(\n  `First Name` = c(\"John\", \"Mary\", \"David\"),\n  `Last.Name` = c(\"Smith\", \"Johnson\", \"Williams\"),\n  `Email-Address` = c(\"<a class=\"__cf_email__\" data-cfemail=\"f69c999e98b6938e979b869a93d895999b\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\", \"<a class=\"__cf_email__\" data-cfemail=\"85e8e4f7fcc5e0fde4e8f5e9e0abe6eae8\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\", \"<a class=\"__cf_email__\" data-cfemail=\"aecacfd8c7caeecbd6cfc3dec2cb80cdc1c3\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\"),\n  `Annual Income ($)` = c(65000, 78000, 52000),\n  check.names = FALSE\n)\n\n# View original column names\nnames(df)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"First Name\"        \"Last.Name\"         \"Email-Address\"    \n[4] \"Annual Income ($)\"</pre>\n</div>\n<pre># Clean the names\nclean_df &lt;- clean_names(df)\n\n# View cleaned column names\nnames(clean_df)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"first_name\"    \"last_name\"     \"email_address\" \"annual_income\"</pre>\n</div>\n</div>\n<p>What <code>clean_names()</code> specifically does:</p>\n<ul>\n<li><p>Converts all names to lowercase</p></li>\n<li><p>Replaces spaces with underscores</p></li>\n<li><p>Removes special characters like periods and hyphens</p></li>\n<li><p>Creates names that are valid R variable names and follow standard naming conventions</p></li>\n</ul>\n<p>This standardization makes your data more consistent, easier to work with, and helps prevent errors when manipulating or joining datasets.</p>\n</section>\n<section class=\"level4\" id=\"intermediate-custom-style\">\n<h4 class=\"anchored\" data-anchor-id=\"intermediate-custom-style\">Intermediate: Custom Style</h4>\n<div class=\"cell\">\n<pre>library(dplyr)\nlibrary(purrr)\n\n# Create multiple dataframes with inconsistent naming\ndf1 &lt;- data.frame(\n  `Customer ID` = 1:3,\n  `First Name` = c(\"John\", \"Mary\", \"David\"),\n  `LAST NAME` = c(\"Smith\", \"Johnson\", \"Williams\"),\n  check.names = FALSE\n)\n\ndf2 &lt;- data.frame(\n  `customer.id` = 4:6,\n  `firstName` = c(\"Michael\", \"Linda\", \"James\"),\n  `lastName` = c(\"Brown\", \"Davis\", \"Miller\"),\n  check.names = FALSE\n)\n\ndf3 &lt;- data.frame(\n  `cust_id` = 7:9,\n  `first-name` = c(\"Robert\", \"Jennifer\", \"Thomas\"),\n  `last-name` = c(\"Wilson\", \"Martinez\", \"Anderson\"),\n  check.names = FALSE\n)\n\n# List of dataframes\ndfs &lt;- list(df1, df2, df3)\n\n# Clean names of all dataframes\nclean_dfs &lt;- map(dfs, clean_names)\n\n# Print column names for each cleaned dataframe\nmap(clean_dfs, names)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[[1]]\n[1] \"customer_id\" \"first_name\"  \"last_name\"  \n\n[[2]]\n[1] \"customer_id\" \"first_name\"  \"last_name\"  \n\n[[3]]\n[1] \"cust_id\"    \"first_name\" \"last_name\" </pre>\n</div>\n<pre># Bind the dataframes (now possible because of standardized column names)\ncombined_df &lt;- bind_rows(clean_dfs)\nprint(combined_df)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>  customer_id first_name last_name cust_id\n1           1       John     Smith      NA\n2           2       Mary   Johnson      NA\n3           3      David  Williams      NA\n4           4    Michael     Brown      NA\n5           5      Linda     Davis      NA\n6           6      James    Miller      NA\n7          NA     Robert    Wilson       7\n8          NA   Jennifer  Martinez       8\n9          NA     Thomas  Anderson       9</pre>\n</div>\n</div>\n<p>This code demonstrates a more advanced use case of the <code>clean_names()</code> function when working with multiple data frames that have inconsistent naming conventions. Note that because of the different column names for customer ID, we have missing values in the combined dataframe. This example demonstrates why standardized naming is important.</p>\n</section>\n<section class=\"level4\" id=\"advanced-targeted-fixes\">\n<h4 class=\"anchored\" data-anchor-id=\"advanced-targeted-fixes\">Advanced: Targeted Fixes</h4>\n<div class=\"cell\">\n<pre>df &lt;- data.frame(\"ID#\" = 1:2, \"Sales_%\" = c(10, 20), \"Q1 Revenue\" = c(100, 200))\ncleaned &lt;- clean_names(df, replace = c(\"#\" = \"_num\", \"%\" = \"_pct\"))\nprint(names(cleaned))</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"id\"         \"sales\"      \"q1_revenue\"</pre>\n</div>\n</div>\n<p><em><strong>Explanation</strong>:</em> Custom replace swaps # for _num and % for _pct, while clean_names handles the rest—precision meets polish.</p>\n<div class=\"cell\">\n<pre>library(readxl)\n\n\n# Create a temporary Excel file with problematic column names\ntemp_file &lt;- tempfile(fileext = \".xlsx\")\ndf &lt;- data.frame(\n  `ID#` = 1:5,\n  `%_Completed` = c(85, 92, 78, 100, 65),\n  `Result (Pass/Fail)` = c(\"Pass\", \"Pass\", \"Fail\", \"Pass\", \"Fail\"),\n  `μg/mL` = c(0.5, 0.8, 0.3, 1.2, 0.4),\n  `p-value` = c(0.03, 0.01, 0.08, 0.002, 0.06),\n  check.names = FALSE\n)\n\n# Save as Excel (simulating real-world data source)\nif (require(writexl)) {\n  write_xlsx(df, temp_file)\n} else {\n  # Fall back to CSV if writexl not available\n  write.csv(df, sub(\"\\\\.xlsx$\", \".csv\", temp_file), row.names = FALSE)\n  temp_file &lt;- sub(\"\\\\.xlsx$\", \".csv\", temp_file)\n}\n\n# Read the file back\nif (temp_file == sub(\"\\\\.xlsx$\", \".csv\", temp_file)) {\n  imported_df &lt;- read.csv(temp_file, check.names = FALSE)\n} else {\n  imported_df &lt;- read_excel(temp_file)\n}\n\n# View original column names\nprint(names(imported_df))</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"ID#\"                \"%_Completed\"        \"Result (Pass/Fail)\"\n[4] \"μg/mL\"              \"p-value\"           </pre>\n</div>\n<pre># Create custom replacements\ncustom_replacements &lt;- c(\n  \"μg\" = \"ug\",  # Replace Greek letter\n  \"%\" = \"percent\",  # Replace percent symbol\n  \"#\" = \"num\"   # Replace hash\n)\n\n# Clean with custom replacements\nclean_df &lt;- imported_df %&gt;%\n  clean_names() %&gt;%\n  rename_with(~ stringr::str_replace_all(., \"p_value\", \"probability\"))\n\n# View cleaned column names\nprint(names(clean_df))</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"id_number\"         \"percent_completed\" \"result_pass_fail\" \n[4] \"mg_m_l\"            \"probability\"      </pre>\n</div>\n<pre># Print the cleaned dataframe\nprint(clean_df)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre># A tibble: 5 × 5\n  id_number percent_completed result_pass_fail mg_m_l probability\n      &lt;dbl&gt;             &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1         1                85 Pass                0.5       0.03 \n2         2                92 Pass                0.8       0.01 \n3         3                78 Fail                0.3       0.08 \n4         4               100 Pass                1.2       0.002\n5         5                65 Fail                0.4       0.06 </pre>\n</div>\n</div>\n<p>The final output shows the transformation from problematic column names to standardized ones:</p>\n<p>From:</p>\n<ul>\n<li><p><code>ID#</code></p></li>\n<li><p><code>%_Completed</code></p></li>\n<li><p><code>Result (Pass/Fail)</code></p></li>\n<li><p><code>μg/mL</code></p></li>\n<li><p><code>p-value</code></p></li>\n</ul>\n<p>To:</p>\n<ul>\n<li><p><code>id_num</code></p></li>\n<li><p><code>percent_completed</code></p></li>\n<li><p><code>result_pass_fail</code></p></li>\n<li><p><code>ug_m_l</code></p></li>\n<li><p><code>probability</code></p></li>\n</ul>\n<p>This example demonstrates how <code>clean_names()</code> can be part of a more sophisticated data preparation workflow, especially when working with real-world data sources that contain problematic characters and naming conventions.</p>\n</section>\n</section>\n</section>\n<section class=\"level2\" id=\"conclusion-why-these-functions-deserve-your-attention\">\n<h2 class=\"anchored\" data-anchor-id=\"conclusion-why-these-functions-deserve-your-attention\">Conclusion: Why These Functions Deserve Your Attention</h2>\n<p>R’s ecosystem is vast, but it’s easy to stick to the familiar and miss out on tools like Reduce, vapply, do.call and clean_names. These functions might not top the popularity charts, yet they pack a punch—whether it’s collapsing data without loops, ensuring type safety, adapting on the fly, fixing messy names, or mining text for gold. The examples here show just a taste of what they can do, from quick fixes to complex tasks. Curious to see how they fit into your workflow? Fire up R, play with them, and discover how these underdogs can become your new go-tos. What other hidden R treasures have you found? Drop them in the comments—I’d love to hear!</p>\n</section>\n<section class=\"level2\" id=\"references\">\n<h2 class=\"anchored\" data-anchor-id=\"references\">References</h2>\n<ul>\n<li><p>R Core Team (2025). <em>R: A Language and Environment for Statistical Computing</em>. R Foundation for Statistical Computing, Vienna, Austria. Available at: <a class=\"uri\" href=\"https://www.r-project.org/\" rel=\"nofollow\" target=\"_blank\">https://www.R-project.org/</a></p></li>\n<li><p>Firke, Sam (2023). <em>janitor: Simple Tools for Examining and Cleaning Dirty Data</em>. CRAN. Available at: <a class=\"uri\" href=\"https://cran.r-project.org/package=janitor\" rel=\"nofollow\" target=\"_blank\">https://CRAN.R-project.org/package=janitor</a></p></li>\n<li><p>R Documentation for Reduce, vapply, do.call, clean_names.</p></li>\n</ul>\n</section>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://mfatihtuzen.netlify.app/posts/2025-03-11_underrated_functions/\"> A Statistician's R Notebook</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Underrated Gems in R: Must-Know Functions You’re Probably Missing Out On\nPosted on\nMarch 10, 2025\nby\nM. Fatih Tüzen\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nA Statistician's R Notebook\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nR is packed with powerhouse tools—think dplyr for data wrangling, ggplot2 for stunning visuals, or tidyr for tidying up messes. But beyond the headliners, there’s a lineup of lesser-known functions that deserve a spot in your toolkit. These hidden gems can streamline your code, solve tricky problems, and even make you wonder how you managed without them. In this post, we’ll uncover four underrated R functions:\nReduce, vapply, do.call\nand\njanitor::clean_names\n. With practical examples ranging from beginner-friendly to advanced, plus outputs to show you what’s possible, this guide will have you itching to try them out in your next project. Let’s dive in and see what these under-the-radar stars can do!\n1. Reduce: Collapse with Control\nWhat It Does and Its Arguments\nReduce is a base R function that iteratively applies a two-argument function to a list or vector, shrinking it down to a single result. It’s like a secret weapon for avoiding loops while keeping things elegant.\nKey Arguments:\nf:\nThe function to apply (e.g., +, *, or a custom one).\nx:\nThe list or vector to reduce.\ninit\n(optional): A starting value (defaults to the first element of x if omitted).\naccumulate\n(optional): If TRUE, returns all intermediate results (defaults to FALSE).\nUse Cases\nSumming or multiplying without explicit iteration.\nCombining data structures step-by-step.\nSimplifying recursive tasks.\nExamples\nSimple: Quick Sum\nnumbers <- 1:5\ntotal <- Reduce(`+`, numbers)\nprint(total)\n[1] 15\nExplanation\n:\nReduce adds 1 + 2 = 3, then 3 + 3 = 6, 6 + 4 = 10, and 10 + 5 = 15. It’s a sleek alternative to sum().\nIntermediate: String Building\nwords <- c(\"R\", \"is\", \"awesome\")\nsentence <- Reduce(paste, words, init = \"\")\nprint(sentence)\n[1] \" R is awesome\"\nExplanation\n:\nStarting with an empty string (init = ““), Reduce glues the words together with spaces. Skip init, and it starts with”R”, which might not be what you want.\nAdvanced: Merging Data Frames\ndf1 <- data.frame(a = 1:2, b = c(\"x\", \"y\"))\ndf2 <- data.frame(a = 3:4, b = c(\"z\", \"w\"))\ndf3 <- data.frame(a = 5:6, b = c(\"p\", \"q\"))\ncombined <- Reduce(rbind, list(df1, df2, df3))\nprint(combined)\na b\n1 1 x\n2 2 y\n3 3 z\n4 4 w\n5 5 p\n6 6 q\nExplanation\n:\nReduce stacks three data frames row-wise, pairing them up one by one. It’s a loop-free way to handle multiple merges.\nA Quick Note on purrr::reduce()\nIf you’re a fan of the tidyverse, check out purrr::reduce(). It’s a modern take on base R’s Reduce, offering a consistent syntax with other purrr functions (like .x and .y for arguments) and handy shortcuts like ~ .x + .y for inline functions. It also defaults to left-to-right reduction but can go right-to-left with reduce_right(). Worth a look if you want a more polished, tidyverse-friendly alternative!\nHere’s an intermediate-level example of using the\nreduce()\nfunction from the\npurrr\npackage for joining multiple dataframes:\nlibrary(purrr)\nlibrary(dplyr)\n\n# Create three sample dataframes representing different aspects of customer data\ncustomers <- data.frame(\n  customer_id = 1:5,\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Edward\"),\n  age = c(32, 45, 28, 36, 52)\n)\n\norders <- data.frame(\n  order_id = 101:108,\n  customer_id = c(1, 2, 2, 3, 3, 3, 4, 5),\n  order_date = as.Date(c(\"2023-01-15\", \"2023-01-20\", \"2023-02-10\", \n                        \"2023-01-05\", \"2023-02-15\", \"2023-03-20\",\n                        \"2023-02-25\", \"2023-03-10\")),\n  amount = c(120.50, 85.75, 200.00, 45.99, 75.25, 150.00, 95.50, 210.25)\n)\n\nfeedback <- data.frame(\n  feedback_id = 201:206,\n  customer_id = c(1, 2, 3, 3, 4, 5),\n  rating = c(4, 5, 3, 4, 5, 4),\n  feedback_date = as.Date(c(\"2023-01-20\", \"2023-01-25\", \"2023-01-10\",\n                          \"2023-02-20\", \"2023-03-01\", \"2023-03-15\"))\n)\n\n# List of dataframes to join with the joining column\ndataframes_to_join <- list(\n  list(df = customers, by = \"customer_id\"),\n  list(df = orders, by = \"customer_id\"),\n  list(df = feedback, by = \"customer_id\")\n)\n\n# Using reduce to join all dataframes\n# Start with customers dataframe and progressively join the others\njoined_data <- reduce(\n  dataframes_to_join[-1],  # Exclude first dataframe as it's our starting point\n  function(acc, x) {\n    left_join(acc, x$df, by = x$by)\n  },\n  .init = dataframes_to_join[[1]]$df  # Start with customers dataframe\n)\n\n# View the result\nprint(joined_data)\ncustomer_id    name age order_id order_date amount feedback_id rating\n1            1   Alice  32      101 2023-01-15 120.50         201      4\n2            2     Bob  45      102 2023-01-20  85.75         202      5\n3            2     Bob  45      103 2023-02-10 200.00         202      5\n4            3 Charlie  28      104 2023-01-05  45.99         203      3\n5            3 Charlie  28      104 2023-01-05  45.99         204      4\n6            3 Charlie  28      105 2023-02-15  75.25         203      3\n7            3 Charlie  28      105 2023-02-15  75.25         204      4\n8            3 Charlie  28      106 2023-03-20 150.00         203      3\n9            3 Charlie  28      106 2023-03-20 150.00         204      4\n10           4   Diana  36      107 2023-02-25  95.50         205      5\n11           5  Edward  52      108 2023-03-10 210.25         206      4\n   feedback_date\n1     2023-01-20\n2     2023-01-25\n3     2023-01-25\n4     2023-01-10\n5     2023-02-20\n6     2023-01-10\n7     2023-02-20\n8     2023-01-10\n9     2023-02-20\n10    2023-03-01\n11    2023-03-15\nThis example demonstrates how to use\nreduce()\nto join multiple dataframes in a sequential, elegant way. This pattern is particularly useful when dealing with complex data integration tasks where you need to combine multiple data sources with a common identifier.\n2. vapply: Iteration with Assurance\nWhat It Does and Its Arguments\nvapply is another base R gem, similar to lapply but with a twist: it forces you to specify the output type and length upfront. This makes it safer and more predictable, especially for critical tasks.\nKey Arguments:\nX\n: The list or vector to process.\nFUN\n: The function to apply to each element.\nFUN.VALUE\n: A template for the output (e.g., numeric(1) for a single number).\nUse Cases\nGuaranteeing consistent output types.\nExtracting specific stats from lists.\nWriting reliable code for packages or production.\nExamples\nSimple: Doubling Up\nvalues <- 1:3\ndoubled <- vapply(values, function(x) x * 2, numeric(1))\nprint(doubled)\n[1] 2 4 6\nExplanation\n:\nEach value doubles, and numeric(1) ensures a numeric vector—simple and rock-solid.\nIntermediate: Word Lengths\nterms <- c(\"data\", \"science\", \"R\")\nlengths <- vapply(terms, nchar, numeric(1))\nprint(lengths)\ndata science       R \n      4       7       1\nExplanation\n:\nvapply counts characters per word, delivering a numeric vector every time—no surprises like sapply might throw.\nAdvanced: Stats Snapshot\nsamples <- list(c(1, 2, 3), c(4, 5), c(6, 7, 8))\nstats <- vapply(samples, function(x) c(mean = mean(x), sd = sd(x)), numeric(2))\nprint(stats)\n[,1]      [,2] [,3]\nmean    2 4.5000000    7\nsd      1 0.7071068    1\nExplanation\n:\nFor each sample, vapply computes mean and standard deviation, returning a matrix (2 rows, 3 columns). It’s a tidy, type-safe summary.\n3. do.call: Dynamic Function Magic\nWhat It Does and Its Arguments\ndo.call in base R lets you call a function with a list of arguments, making it a go-to for flexible, on-the-fly operations. It’s like having a universal remote for your functions.\nKey Arguments:\nwhat\n: The function to call (e.g., rbind, paste).\nargs\n: A list of arguments to pass.\nquote\n(optional): Rarely used, defaults to FALSE.\nUse Cases\nCombining variable inputs.\nRunning functions dynamically.\nSimplifying calls with list-based data.\nExamples\nSimple: Vector Mashup\nchunks <- list(1:3, 4:6)\nall <- do.call(c, chunks)\nprint(all)\n[1] 1 2 3 4 5 6\nExplanation\n:\ndo.call feeds the list to c(), stitching the vectors together effortlessly.\nIntermediate: Custom Join\nbits <- list(\"Code\", \"Runs\", \"Fast\")\njoined <- do.call(paste, c(bits, list(sep = \"|\")))\nprint(joined)\n[1] \"Code|Runs|Fast\"\nExplanation\n:\ndo.call combines the list with a sep argument, creating a piped string in one smooth move.\nAdvanced: Flexible Binding\ndf_list <- list(data.frame(x = 1:2), data.frame(x = 3:4))\ndirection <- \"vertical\"\nbound <- do.call(if (direction == \"vertical\") rbind else cbind, df_list)\nprint(bound)\nx\n1 1\n2 2\n3 3\n4 4\nExplanation\n:\nWith direction = “vertical”, do.call uses rbind to stack rows. Change it to “horizontal”, and cbind takes over—dynamic and smart.\n4. janitor::clean_names: Tame Your Column Chaos\nWhat It Does and Its Arguments\nFrom the janitor package, clean_names() transforms messy column names into consistent, code-friendly formats (e.g., lowercase with underscores). It’s a time-saver you’ll wish you’d known sooner.\nKey Arguments:\ndat\n: The data frame to clean.\ncase\n: The style for names (e.g., “snake”, “small_camel”, defaults to “snake”).\nreplace\n: A named vector for custom replacements (optional).\nUse Cases\nStandardizing imported data with ugly headers.\nPrepping data frames for analysis or plotting.\nAvoiding frustration with inconsistent naming.\nExamples\nSimple: Basic Cleanup\nlibrary(janitor)\n\n# Create a dataframe with messy column names\ndf <- data.frame(\n  `First Name` = c(\"John\", \"Mary\", \"David\"),\n  `Last.Name` = c(\"Smith\", \"Johnson\", \"Williams\"),\n  `Email-Address` = c(\"\n[email protected]\n\", \"\n[email protected]\n\", \"\n[email protected]\n\"),\n  `Annual Income ($)` = c(65000, 78000, 52000),\n  check.names = FALSE\n)\n\n# View original column names\nnames(df)\n[1] \"First Name\"        \"Last.Name\"         \"Email-Address\"    \n[4] \"Annual Income ($)\"\n# Clean the names\nclean_df <- clean_names(df)\n\n# View cleaned column names\nnames(clean_df)\n[1] \"first_name\"    \"last_name\"     \"email_address\" \"annual_income\"\nWhat\nclean_names()\nspecifically does:\nConverts all names to lowercase\nReplaces spaces with underscores\nRemoves special characters like periods and hyphens\nCreates names that are valid R variable names and follow standard naming conventions\nThis standardization makes your data more consistent, easier to work with, and helps prevent errors when manipulating or joining datasets.\nIntermediate: Custom Style\nlibrary(dplyr)\nlibrary(purrr)\n\n# Create multiple dataframes with inconsistent naming\ndf1 <- data.frame(\n  `Customer ID` = 1:3,\n  `First Name` = c(\"John\", \"Mary\", \"David\"),\n  `LAST NAME` = c(\"Smith\", \"Johnson\", \"Williams\"),\n  check.names = FALSE\n)\n\ndf2 <- data.frame(\n  `customer.id` = 4:6,\n  `firstName` = c(\"Michael\", \"Linda\", \"James\"),\n  `lastName` = c(\"Brown\", \"Davis\", \"Miller\"),\n  check.names = FALSE\n)\n\ndf3 <- data.frame(\n  `cust_id` = 7:9,\n  `first-name` = c(\"Robert\", \"Jennifer\", \"Thomas\"),\n  `last-name` = c(\"Wilson\", \"Martinez\", \"Anderson\"),\n  check.names = FALSE\n)\n\n# List of dataframes\ndfs <- list(df1, df2, df3)\n\n# Clean names of all dataframes\nclean_dfs <- map(dfs, clean_names)\n\n# Print column names for each cleaned dataframe\nmap(clean_dfs, names)\n[[1]]\n[1] \"customer_id\" \"first_name\"  \"last_name\"  \n\n[[2]]\n[1] \"customer_id\" \"first_name\"  \"last_name\"  \n\n[[3]]\n[1] \"cust_id\"    \"first_name\" \"last_name\"\n# Bind the dataframes (now possible because of standardized column names)\ncombined_df <- bind_rows(clean_dfs)\nprint(combined_df)\ncustomer_id first_name last_name cust_id\n1           1       John     Smith      NA\n2           2       Mary   Johnson      NA\n3           3      David  Williams      NA\n4           4    Michael     Brown      NA\n5           5      Linda     Davis      NA\n6           6      James    Miller      NA\n7          NA     Robert    Wilson       7\n8          NA   Jennifer  Martinez       8\n9          NA     Thomas  Anderson       9\nThis code demonstrates a more advanced use case of the\nclean_names()\nfunction when working with multiple data frames that have inconsistent naming conventions. Note that because of the different column names for customer ID, we have missing values in the combined dataframe. This example demonstrates why standardized naming is important.\nAdvanced: Targeted Fixes\ndf <- data.frame(\"ID#\" = 1:2, \"Sales_%\" = c(10, 20), \"Q1 Revenue\" = c(100, 200))\ncleaned <- clean_names(df, replace = c(\"#\" = \"_num\", \"%\" = \"_pct\"))\nprint(names(cleaned))\n[1] \"id\"         \"sales\"      \"q1_revenue\"\nExplanation\n:\nCustom replace swaps # for _num and % for _pct, while clean_names handles the rest—precision meets polish.\nlibrary(readxl)\n\n# Create a temporary Excel file with problematic column names\ntemp_file <- tempfile(fileext = \".xlsx\")\ndf <- data.frame(\n  `ID#` = 1:5,\n  `%_Completed` = c(85, 92, 78, 100, 65),\n  `Result (Pass/Fail)` = c(\"Pass\", \"Pass\", \"Fail\", \"Pass\", \"Fail\"),\n  `μg/mL` = c(0.5, 0.8, 0.3, 1.2, 0.4),\n  `p-value` = c(0.03, 0.01, 0.08, 0.002, 0.06),\n  check.names = FALSE\n)\n\n# Save as Excel (simulating real-world data source)\nif (require(writexl)) {\n  write_xlsx(df, temp_file)\n} else {\n  # Fall back to CSV if writexl not available\n  write.csv(df, sub(\"\\\\.xlsx$\", \".csv\", temp_file), row.names = FALSE)\n  temp_file <- sub(\"\\\\.xlsx$\", \".csv\", temp_file)\n}\n\n# Read the file back\nif (temp_file == sub(\"\\\\.xlsx$\", \".csv\", temp_file)) {\n  imported_df <- read.csv(temp_file, check.names = FALSE)\n} else {\n  imported_df <- read_excel(temp_file)\n}\n\n# View original column names\nprint(names(imported_df))\n[1] \"ID#\"                \"%_Completed\"        \"Result (Pass/Fail)\"\n[4] \"μg/mL\"              \"p-value\"\n# Create custom replacements\ncustom_replacements <- c(\n  \"μg\" = \"ug\",  # Replace Greek letter\n  \"%\" = \"percent\",  # Replace percent symbol\n  \"#\" = \"num\"   # Replace hash\n)\n\n# Clean with custom replacements\nclean_df <- imported_df %>%\n  clean_names() %>%\n  rename_with(~ stringr::str_replace_all(., \"p_value\", \"probability\"))\n\n# View cleaned column names\nprint(names(clean_df))\n[1] \"id_number\"         \"percent_completed\" \"result_pass_fail\" \n[4] \"mg_m_l\"            \"probability\"\n# Print the cleaned dataframe\nprint(clean_df)\n# A tibble: 5 × 5\n  id_number percent_completed result_pass_fail mg_m_l probability\n      <dbl>             <dbl> <chr>             <dbl>       <dbl>\n1         1                85 Pass                0.5       0.03 \n2         2                92 Pass                0.8       0.01 \n3         3                78 Fail                0.3       0.08 \n4         4               100 Pass                1.2       0.002\n5         5                65 Fail                0.4       0.06\nThe final output shows the transformation from problematic column names to standardized ones:\nFrom:\nID#\n%_Completed\nResult (Pass/Fail)\nμg/mL\np-value\nTo:\nid_num\npercent_completed\nresult_pass_fail\nug_m_l\nprobability\nThis example demonstrates how\nclean_names()\ncan be part of a more sophisticated data preparation workflow, especially when working with real-world data sources that contain problematic characters and naming conventions.\nConclusion: Why These Functions Deserve Your Attention\nR’s ecosystem is vast, but it’s easy to stick to the familiar and miss out on tools like Reduce, vapply, do.call and clean_names. These functions might not top the popularity charts, yet they pack a punch—whether it’s collapsing data without loops, ensuring type safety, adapting on the fly, fixing messy names, or mining text for gold. The examples here show just a taste of what they can do, from quick fixes to complex tasks. Curious to see how they fit into your workflow? Fire up R, play with them, and discover how these underdogs can become your new go-tos. What other hidden R treasures have you found? Drop them in the comments—I’d love to hear!\nReferences\nR Core Team (2025).\nR: A Language and Environment for Statistical Computing\n. R Foundation for Statistical Computing, Vienna, Austria. Available at:\nhttps://www.R-project.org/\nFirke, Sam (2023).\njanitor: Simple Tools for Examining and Cleaning Dirty Data\n. CRAN. Available at:\nhttps://CRAN.R-project.org/package=janitor\nR Documentation for Reduce, vapply, do.call, clean_names.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nA Statistician's R Notebook\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "R is packed with powerhouse tools—think dplyr for data wrangling, ggplot2 for stunning visuals, or tidyr for tidying up messes. But beyond the headliners, there’s a lineup of lesser-known functions that deserve a spot in your toolkit. These hidd...",
      "meta_keywords": null,
      "og_description": "R is packed with powerhouse tools—think dplyr for data wrangling, ggplot2 for stunning visuals, or tidyr for tidying up messes. But beyond the headliners, there’s a lineup of lesser-known functions that deserve a spot in your toolkit. These hidd...",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Underrated Gems in R: Must-Know Functions You’re Probably Missing Out On | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 12.8,
      "sitemap_lastmod": null,
      "twitter_description": "R is packed with powerhouse tools—think dplyr for data wrangling, ggplot2 for stunning visuals, or tidyr for tidying up messes. But beyond the headliners, there’s a lineup of lesser-known functions that deserve a spot in your toolkit. These hidd...",
      "twitter_title": "Underrated Gems in R: Must-Know Functions You’re Probably Missing Out On | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/03/underrated-gems-in-r-must-know-functions-youre-probably-missing-out-on/",
      "word_count": 2562
    }
  }
}