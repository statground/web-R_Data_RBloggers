{
  "uuid": "6133eca8-70fb-42bf-b3aa-99d44801c595",
  "created_at": "2025-11-17 20:38:41",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2024/01/i-in-data-table/",
    "crawled_at": "2025-11-17T09:24:43.876964",
    "external_links": [
      {
        "href": "https://johnmackintosh.net/blog/2024-01-03-dot-I/",
        "text": "Data By John"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://johnmackintosh.net/blog/2020-07-17-simd-revisited/",
        "text": "SIMD2020 dataset"
      },
      {
        "href": "https://github.com/johnmackintosh/DT_dot_I",
        "text": "github if you‚Äôre interested"
      },
      {
        "href": "https://stackoverflow.com/questions/73506180/select-rows-based-on-conditions-in-r",
        "text": "relating to selecting rows based on conditions"
      },
      {
        "href": "https://johnmackintosh.net/blog/2024-01-03-dot-I/",
        "text": "Data By John"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": ".I in data.table | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/john-mackintosh/",
        "text": "John MacKintosh"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-381259 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">.I in data.table</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 2, 2024</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/john-mackintosh/\">John MacKintosh</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://johnmackintosh.net/blog/2024-01-03-dot-I/\"> Data By John</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>In this post I‚Äôm using a small extract from the <a href=\"https://johnmackintosh.net/blog/2020-07-17-simd-revisited/\" rel=\"nofollow\" target=\"_blank\">SIMD2020 dataset</a> to figure out what the special operator <code>.I</code> does.</p>\n<p>Files and code are on <a href=\"https://github.com/johnmackintosh/DT_dot_I\" rel=\"nofollow\" target=\"_blank\">github if you‚Äôre interested</a></p>\n<pre># files and code : https://github.com/johnmackintosh/DT_dot_I\nlibrary(data.table)\nDT &lt;- fread(\"highdata.csv\")\nlookup &lt;- fread(\"https://raw.githubusercontent.com/johnmackintosh/ph_lookups/main/dz_intzone_cp_dz_names.csv\")\n</pre>\n<p>To join these together, I could set a key on <code>Data_Zone</code> and <code>DataZone</code> respectively.\nHowever, that would reorder the data, so, for now, I will do the join ‚Äúby hand‚Äù:</p>\n<pre>DT &lt;- lookup[DT, on = .(DataZone = Data_Zone)]\n</pre>\n<p>I‚Äôll maintain the existing order by keying on the overall SIMD rank</p>\n<pre>setkey(DT, SIMD2020v2_Rank)\n</pre>\n<p>I also update some column names</p>\n<pre>setnames(DT, \n         old = c(\"SIMD2020v2_Income_Domain_Rank\",\n                 \"SIMD2020_Employment_Domain_Rank\",  \n                 \"SIMD2020_Health_Domain_Rank\",\n                 \"SIMD2020_Education_Domain_Rank\", \n                 \"SIMD2020_Access_Domain_Rank\", \n                 \"SIMD2020_Crime_Domain_Rank\",    \n                 \"SIMD2020_Housing_Domain_Rank\",\n                 \"CP_Name\"),\n\n         new = c(\"Income\", \"Employment\", \n                 \"Health\",   \"Education\",\n                 \"Access\",  \"Crime\", \n                 \"Housing\", \"areaname\"))\n</pre>\n<p>Which row has the highest income ranking?</p>\n<pre>DT[,.I[Income == max(Income)]]\n# [1] 437\n</pre>\n<p>The same for the Health ranking, but returning a data.table or vector respectively</p>\n<pre># returns data.table\nDT[,.I[Health == max(Health)],.SD] \n\n#      V1\n#   &lt;int&gt;\n# 1:   424\n\n# returns single element vector\nDT[,.I[Health == max(Health)],.SD]$V1\n# [1] 424\n</pre>\n<p>Return the maximum health ranking by area</p>\n<pre>DT[,.I[Health == max(Health)], areaname]\n\n\r\n                         areaname    V1\n                           &lt;char&gt; &lt;int&gt;\n 1:                     Inverness   417\n 2:                Bute and Cowal   414\n 3:                     Caithness   358\n 4:                     East Ross   364\n 5:        Helensburgh and Lomond   424\n 6:          Nairn and Nairnshire   388\n 7:      Oban, Lorn and the Isles   363\n 8: Mid-Argyll, Kintyre and Islay   295\n 9:                      Lochaber   252\n10:                      Mid Ross   389\n11:                    Sutherland   220\n12:  Skye, Lochalsh and West Ross   271\n13:       Badenoch and Strathspey   333\n\n</pre>\n<p>Remember - these are row indices, not the actual values</p>\n<p>Extract multiple indices</p>\n<pre>DT[,\n   .(min_health = .I[Health == min(Health)], \n     max_health = .I[Health == max(Health)]),\n   areaname]\n\r\n                        areaname min_health max_health\n                           &lt;char&gt;      &lt;int&gt;      &lt;int&gt;\n 1:                     Inverness          1        417\n 2:                Bute and Cowal          3        414\n 3:                     Caithness          4        358\n 4:                     East Ross          5        364\n 5:        Helensburgh and Lomond          7        424\n 6:          Nairn and Nairnshire         12        388\n 7:      Oban, Lorn and the Isles         14        363\n 8: Mid-Argyll, Kintyre and Islay         21        295\n 9:                      Lochaber         36        252\n10:                      Mid Ross         37        389\n11:                    Sutherland         82        220\n12:  Skye, Lochalsh and West Ross         93        271\n13:       Badenoch and Strathspey        276        333\n\n</pre>\n<p>What happens if we do something in i, then .I?\nSpecifically, filter for the Inverness area, then find the min and max Health rankings</p>\n<pre>DT[ areaname == \"Inverness\",  .(min_health = .I[Health == min(Health)], # still 1\n                                max_health = .I[Health == max(Health)])] # now 94\n\n</pre>\n<p>We return a new index for the maximum value which is now row 94, having previously been row 417</p>\n<p>If I set the key on <code>DataZone</code>, then the indices change</p>\n<pre>setkey(DT, DataZone)\n\nDT[,.I[Income == max(Income)]] # now 108, was 437\n\n\nDT[,.I[Health == max(Health)],.SD]  # now 95, was 424\n\n</pre>\n<p>We can use <code>.I</code>  to answer the question here <a href=\"https://stackoverflow.com/questions/73506180/select-rows-based-on-conditions-in-r\" rel=\"nofollow\" target=\"_blank\">relating to selecting rows based on conditions</a></p>\n<p>We can do it all in data.table üôÇ</p>\n<pre># recreate the example data\n\nlibrary(data.table)\nid &lt;- c(rep(102,9),rep(103,5),rep(104,4))\nstatus &lt;- rep(c('single','relationship','relationship','single','single','single'),3)\nstatus &lt;- factor(status, levels = c(\"single\" ,\"relationship\"), ordered = TRUE)\n# setting as factor for display reasons\nage &lt;- c(17:19,22,23,26,28,32,33,21:25,21:24)\nDT &lt;- data.table(id, status, age)\n\n# this is the desired output\nnewdata &lt;- DT[c(1,2,7,8,13,14,18),]\n\n</pre>\n<p>Create a new data.table by finding the indices based on the conditions (single and highest age, relationship and lowest age) and use <code>rleid</code> to only pick out where the status changes, for each <code>id</code>.</p>\n<p>I also create a rownumber variable.</p>\n<pre>DT2 &lt;- DT[DT[,.I[status == \"single\" &amp; age == max(age) |  \n                   status == \"relationship\" &amp; age == min(age)], \n             .(rleid(status),id)]$V1\n          ][,rn := rleid(status),id\n            ][]\n\n</pre>\n<p>You will see what appears to be a random <code>$V1</code> at the end of this line:</p>\n<pre>DT[DT[,.I[status == \"single\" &amp; age == max(age) |  \n                   status == \"relationship\" &amp; age == min(age)], \n             .(rleid(status),id)]$V1\n          ]\n</pre>\n<p>If I take that out, I get the following error:</p>\n<p><code>Error: When i is a data.table (or character vector), the columns to join by must be specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, and, marked as sorted, see ?setkey), or by sharing column names between x and i (i.e., a natural join). Keyed joins might have further speed benefits on very large data due to x being sorted in RAM. </code></p>\n<p>This confirms that what we‚Äôre doing here is a self join of DT to itself based on the row indices returned by the conditions we specify.</p>\n<p>When the <code>$V1</code> is returned, we get the following results:</p>\n<pre>     id       status   age\n   &lt;num&gt;        &lt;ord&gt; &lt;num&gt;\n1:   102       single    17\n2:   102 relationship    18\n3:   102       single    28\n4:   102 relationship    32\n5:   103       single    24\n6:   103 relationship    25\n7:   104 relationship    21\n8:   104       single    24\n\n</pre>\n<p>This gives us far fewer rows than our original  dataset, but still more than our desired results.</p>\n<p>The row indexed by <code>DT2[,.I[(rn == 1 &amp; status == \"relationship\")]]</code>, returns the row index <code>7</code>. \nThis is the one we need to remove, because we don‚Äôt want to include results where the first status is ‚Äúrelationship‚Äù.</p>\n<p>This is an anti join, joining DT2 to itself, minus the row indexed above.<br/>\nI also update the rownumber for each id, so that each status increments appropriately.</p>\n<pre>DT2 &lt;- DT2[!DT2[,.I[(rn == 1 &amp; status == \"relationship\")]]\n           ][,rn := seq(.N), .(id, status)][]\n</pre>\n<p>This returns the following:</p>\n<pre>     id       status   age    rn\n   &lt;num&gt;        &lt;ord&gt; &lt;num&gt; &lt;int&gt;\n1:   102       single    17     1\n2:   102 relationship    18     1\n3:   102       single    28     2\n4:   102 relationship    32     2\n5:   103       single    24     1\n6:   103 relationship    25     1\n7:   104       single    24     1\n\n</pre>\n<p>Which matches the desired data perfectly</p>\n<pre>all.equal(DT2[,1:3], newdata)\n# [1] TRUE\n</pre>\n<p>Finally, use <code>dcast</code> to pivot_wider, as per OP‚Äôs request</p>\n<pre>dcast(DT2,  \n      id ~   rn + status, \n      value.var = \"age\")\n\nKey: &lt;id&gt;\n      id 1_single 1_relationship 2_single 2_relationship\n   &lt;num&gt;    &lt;num&gt;          &lt;num&gt;    &lt;num&gt;          &lt;num&gt;\n1:   102       17             18       28             32\n2:   103       24             25       NA             NA\n3:   104       24             NA       NA             NA\n</pre>\n<p>Key takeaway:  <code>.I</code> returns indices, and can be used in circumstances where you might otherwise use <code>which</code> to identify rows meeting certain conditions. \nYou can use it to join a data.table to itself, or anti_join to itself, to return your desired results.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://johnmackintosh.net/blog/2024-01-03-dot-I/\"> Data By John</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": ".I in data.table\nPosted on\nJanuary 2, 2024\nby\nJohn MacKintosh\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nData By John\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn this post I‚Äôm using a small extract from the\nSIMD2020 dataset\nto figure out what the special operator\n.I\ndoes.\nFiles and code are on\ngithub if you‚Äôre interested\n# files and code : https://github.com/johnmackintosh/DT_dot_I\nlibrary(data.table)\nDT <- fread(\"highdata.csv\")\nlookup <- fread(\"https://raw.githubusercontent.com/johnmackintosh/ph_lookups/main/dz_intzone_cp_dz_names.csv\")\nTo join these together, I could set a key on\nData_Zone\nand\nDataZone\nrespectively.\nHowever, that would reorder the data, so, for now, I will do the join ‚Äúby hand‚Äù:\nDT <- lookup[DT, on = .(DataZone = Data_Zone)]\nI‚Äôll maintain the existing order by keying on the overall SIMD rank\nsetkey(DT, SIMD2020v2_Rank)\nI also update some column names\nsetnames(DT, \n         old = c(\"SIMD2020v2_Income_Domain_Rank\",\n                 \"SIMD2020_Employment_Domain_Rank\",  \n                 \"SIMD2020_Health_Domain_Rank\",\n                 \"SIMD2020_Education_Domain_Rank\", \n                 \"SIMD2020_Access_Domain_Rank\", \n                 \"SIMD2020_Crime_Domain_Rank\",    \n                 \"SIMD2020_Housing_Domain_Rank\",\n                 \"CP_Name\"),\n\n         new = c(\"Income\", \"Employment\", \n                 \"Health\",   \"Education\",\n                 \"Access\",  \"Crime\", \n                 \"Housing\", \"areaname\"))\nWhich row has the highest income ranking?\nDT[,.I[Income == max(Income)]]\n# [1] 437\nThe same for the Health ranking, but returning a data.table or vector respectively\n# returns data.table\nDT[,.I[Health == max(Health)],.SD] \n\n#      V1\n#   <int>\n# 1:   424\n\n# returns single element vector\nDT[,.I[Health == max(Health)],.SD]$V1\n# [1] 424\nReturn the maximum health ranking by area\nDT[,.I[Health == max(Health)], areaname]\n\n                         areaname    V1\n                           <char> <int>\n 1:                     Inverness   417\n 2:                Bute and Cowal   414\n 3:                     Caithness   358\n 4:                     East Ross   364\n 5:        Helensburgh and Lomond   424\n 6:          Nairn and Nairnshire   388\n 7:      Oban, Lorn and the Isles   363\n 8: Mid-Argyll, Kintyre and Islay   295\n 9:                      Lochaber   252\n10:                      Mid Ross   389\n11:                    Sutherland   220\n12:  Skye, Lochalsh and West Ross   271\n13:       Badenoch and Strathspey   333\nRemember - these are row indices, not the actual values\nExtract multiple indices\nDT[,\n   .(min_health = .I[Health == min(Health)], \n     max_health = .I[Health == max(Health)]),\n   areaname]\n\n                        areaname min_health max_health\n                           <char>      <int>      <int>\n 1:                     Inverness          1        417\n 2:                Bute and Cowal          3        414\n 3:                     Caithness          4        358\n 4:                     East Ross          5        364\n 5:        Helensburgh and Lomond          7        424\n 6:          Nairn and Nairnshire         12        388\n 7:      Oban, Lorn and the Isles         14        363\n 8: Mid-Argyll, Kintyre and Islay         21        295\n 9:                      Lochaber         36        252\n10:                      Mid Ross         37        389\n11:                    Sutherland         82        220\n12:  Skye, Lochalsh and West Ross         93        271\n13:       Badenoch and Strathspey        276        333\nWhat happens if we do something in i, then .I?\nSpecifically, filter for the Inverness area, then find the min and max Health rankings\nDT[ areaname == \"Inverness\",  .(min_health = .I[Health == min(Health)], # still 1\n                                max_health = .I[Health == max(Health)])] # now 94\nWe return a new index for the maximum value which is now row 94, having previously been row 417\nIf I set the key on\nDataZone\n, then the indices change\nsetkey(DT, DataZone)\n\nDT[,.I[Income == max(Income)]] # now 108, was 437\n\nDT[,.I[Health == max(Health)],.SD]  # now 95, was 424\nWe can use\n.I\nto answer the question here\nrelating to selecting rows based on conditions\nWe can do it all in data.table üôÇ\n# recreate the example data\n\nlibrary(data.table)\nid <- c(rep(102,9),rep(103,5),rep(104,4))\nstatus <- rep(c('single','relationship','relationship','single','single','single'),3)\nstatus <- factor(status, levels = c(\"single\" ,\"relationship\"), ordered = TRUE)\n# setting as factor for display reasons\nage <- c(17:19,22,23,26,28,32,33,21:25,21:24)\nDT <- data.table(id, status, age)\n\n# this is the desired output\nnewdata <- DT[c(1,2,7,8,13,14,18),]\nCreate a new data.table by finding the indices based on the conditions (single and highest age, relationship and lowest age) and use\nrleid\nto only pick out where the status changes, for each\nid\n.\nI also create a rownumber variable.\nDT2 <- DT[DT[,.I[status == \"single\" & age == max(age) |  \n                   status == \"relationship\" & age == min(age)], \n             .(rleid(status),id)]$V1\n          ][,rn := rleid(status),id\n            ][]\nYou will see what appears to be a random\n$V1\nat the end of this line:\nDT[DT[,.I[status == \"single\" & age == max(age) |  \n                   status == \"relationship\" & age == min(age)], \n             .(rleid(status),id)]$V1\n          ]\nIf I take that out, I get the following error:\nError: When i is a data.table (or character vector), the columns to join by must be specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, and, marked as sorted, see ?setkey), or by sharing column names between x and i (i.e., a natural join). Keyed joins might have further speed benefits on very large data due to x being sorted in RAM.\nThis confirms that what we‚Äôre doing here is a self join of DT to itself based on the row indices returned by the conditions we specify.\nWhen the\n$V1\nis returned, we get the following results:\nid       status   age\n   <num>        <ord> <num>\n1:   102       single    17\n2:   102 relationship    18\n3:   102       single    28\n4:   102 relationship    32\n5:   103       single    24\n6:   103 relationship    25\n7:   104 relationship    21\n8:   104       single    24\nThis gives us far fewer rows than our original  dataset, but still more than our desired results.\nThe row indexed by\nDT2[,.I[(rn == 1 & status == \"relationship\")]]\n, returns the row index\n7\n. \nThis is the one we need to remove, because we don‚Äôt want to include results where the first status is ‚Äúrelationship‚Äù.\nThis is an anti join, joining DT2 to itself, minus the row indexed above.\nI also update the rownumber for each id, so that each status increments appropriately.\nDT2 <- DT2[!DT2[,.I[(rn == 1 & status == \"relationship\")]]\n           ][,rn := seq(.N), .(id, status)][]\nThis returns the following:\nid       status   age    rn\n   <num>        <ord> <num> <int>\n1:   102       single    17     1\n2:   102 relationship    18     1\n3:   102       single    28     2\n4:   102 relationship    32     2\n5:   103       single    24     1\n6:   103 relationship    25     1\n7:   104       single    24     1\nWhich matches the desired data perfectly\nall.equal(DT2[,1:3], newdata)\n# [1] TRUE\nFinally, use\ndcast\nto pivot_wider, as per OP‚Äôs request\ndcast(DT2,  \n      id ~   rn + status, \n      value.var = \"age\")\n\nKey: <id>\n      id 1_single 1_relationship 2_single 2_relationship\n   <num>    <num>          <num>    <num>          <num>\n1:   102       17             18       28             32\n2:   103       24             25       NA             NA\n3:   104       24             NA       NA             NA\nKey takeaway:\n.I\nreturns indices, and can be used in circumstances where you might otherwise use\nwhich\nto identify rows meeting certain conditions. \nYou can use it to join a data.table to itself, or anti_join to itself, to return your desired results.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nData By John\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "A quick note to understand what .I does in data.table",
    "meta_keywords": null,
    "og_description": "A quick note to understand what .I does in data.table",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": ".I in data.table | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 6,
    "sitemap_lastmod": "2024-01-03T12:05:35+00:00",
    "twitter_description": "A quick note to understand what .I does in data.table",
    "twitter_title": ".I in data.table | R-bloggers",
    "url": "https://www.r-bloggers.com/2024/01/i-in-data-table/",
    "word_count": 1205
  }
}