{
  "uuid": "0c7a7559-dff6-412f-9af7-9809a92f9390",
  "created_at": "2025-11-17 20:39:02",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/12/a-r-graphic-in-a-yesod-app/",
    "crawled_at": "2025-11-17T09:42:39.119445",
    "external_links": [
      {
        "href": "https://laustep.github.io/stlahblog/posts/yesod_ggplot.html",
        "text": "Saturn Elephant"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://github.com/stla/yesod_ggplot",
        "text": "this Github repository"
      },
      {
        "href": "https://www.yesodweb.com/book/shakespearean-templates",
        "text": "Hamlet"
      },
      {
        "href": "https://laustep.github.io/stlahblog/posts/yesod_ggplot.html",
        "text": "Saturn Elephant"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "A R graphic in a Yesod app | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/laustep.github.io/stlahblog/posts/figures/yesod-ggplot.gif?w=578&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/stephane-laurent/",
        "text": "Stéphane Laurent"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-380462 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">A R graphic in a Yesod app</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">December 1, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/stephane-laurent/\">Stéphane Laurent</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://laustep.github.io/stlahblog/posts/yesod_ggplot.html\"> Saturn Elephant</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><div class=\"container-fluid\">\n<div class=\"main col-sm-12\">\n<div class=\"content\">\n<p>\n        Yesod is a web framework for Haskell. In this post I show how to do a\n        Yesod application allowing to upload some data from a CSV or a XLSX file\n        and to display a R graphic representing two selected columns of the\n        data.\n      </p>\n<p>\n<img data-lazy-src=\"https://i0.wp.com/laustep.github.io/stlahblog/posts/figures/yesod-ggplot.gif?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i0.wp.com/laustep.github.io/stlahblog/posts/figures/yesod-ggplot.gif?w=578&amp;ssl=1\"/></noscript>\n</p>\n<p>\n        Below is the directory content of the application, available in\n        <a href=\"https://github.com/stla/yesod_ggplot\" rel=\"nofollow\" target=\"_blank\">this Github repository</a>.\n      </p>\n<pre>|   .dir-locals.el\n|   client_session_key.aes\n|   package.yaml\n|   README.md\n|   routes.yesodroutes\n|   stack.yaml\n|   \n+---app\n|       Main.hs\n|       \n+---src\n|       Application.hs\n|       Foundation.hs\n|       GGplot.hs\n|       Home.hs\n|       \n\\---static\n    +---bootstrap-5.3.2\n    |   +---css\n    |   |       bootstrap.min.css\n    |   |       bootstrap.min.css.map\n    |   |       \n    |   \\---js\n    |           bootstrap.bundle.min.js\n    |           bootstrap.bundle.min.js.map\n    |           \n    +---DataTables-1.13.8\n    |   |   datatables.min.css\n    |   |   datatables.min.js\n    |   |   \n    |   \\---images\n    |           sort_asc.png\n    |           sort_asc_disabled.png\n    |           sort_both.png\n    |           sort_desc.png\n    |           sort_desc_disabled.png\n    |           \n    +---images\n    |       haskell.png\n    |       \n    +---jQuery\n    |       jquery-3.7.1.min.js\n    |       \n    +---PapaParse\n    |       papaparse.min.js\n    |       \n    +---R\n    |       ggplotXY.R\n    |       \n    \\---SheetJS\n            xlsx.core.min.js\n            xlsx.core.min.map</pre>\n<p>\n        I’m using <strong>bootstrap</strong> for the style,\n        <strong>DataTables</strong> to display a nice table of the data,\n        <strong>PapaParse</strong> to parse the uploaded CSV file to a JSON\n        object, and <strong>SheetJS</strong> to convert the uploaded XLSX file\n        to CSV data, which can then be parsed to a JSON object with\n        <strong>PapaParse</strong>.\n      </p>\n<p>\n<a href=\"https://www.yesodweb.com/book/shakespearean-templates\" rel=\"nofollow\" target=\"_blank\">Hamlet</a>\n        is a HTML templating language developed for Yesod applications. Below is\n        the Hamlet code of the application. I use a Bootstrap modal to display\n        errors if there are.\n      </p>\n<div class=\"sourceCode\" id=\"cb2\">\n<pre>&lt;body&gt;\n  $# BOOTSTRAP MODAL -----------------------------------------------------------\n  &lt;div #myModal .modal .fade aria-hidden aria-labelledby=myModalLabel tabindex=-1&gt;\n    &lt;div .modal-dialog .modal-dialog-centered&gt;\n      &lt;div .modal-content&gt;\n        &lt;div .modal-header&gt;\n            &lt;h1 .modal-title .fs-5&gt;\n        &lt;div .modal-body&gt;\n            &lt;span #message&gt;\n        &lt;div .modal-footer&gt;\n            &lt;button type=button .btn .btn-secondary data-bs-dismiss=modal&gt;Close\n  $# HASKELL LOGO --------------------------------------------------------------\n  &lt;img src=./static/images/haskell.png style=float:right;margin:5px;width:50px;&gt;\n  $# ---------------------------------------------------------------------------\n  &lt;div .container-fluid&gt;\n    $# TABS --------------------------------------------------------\n    &lt;ul .nav .nav-tabs role=tablist&gt;\n      &lt;li .nav-item role=presentation&gt;\n        &lt;button #data-tab .nav-link .active data-bs-toggle=tab data-bs-target=#data-tab-pane type=button role=tab aria-controls=data-tab-pane aria-selected=true&gt;Data\n      &lt;li .nav-item role=presentation&gt;\n        &lt;button #plot-tab .nav-link data-bs-toggle=tab data-bs-target=#plot-tab-pane type=button role=tab aria-controls=plot-tab-pane aria-selected=false&gt;Plot\n    $# TABS CONTENTS -----------------------------------------------------------\n    &lt;div #tabContent .tab-content&gt;\n      $# DATA TAB --------------------------------------------------------------\n      &lt;div #data-tab-pane .tab-pane .fade .show .active role=tabpanel aria-labelledby=data-tab tabindex=0&gt;\n        &lt;div .row&gt;\n          $# SIDEBAR -----------------------------------------------------------\n          &lt;div .col-4&gt;\n            &lt;div .card .text-bg-dark tabindex=-1 aria-labelledby=sidebarDataTitle&gt;\n              &lt;div .card-body&gt;\n                &lt;h5 #sidebarDataTitle .card-title&gt;Upload data\n                &lt;h6 .card-text&gt;Upload a CSV file or a XLSX file.\n                &lt;p .card-text style=font-style:italic;&gt;If you upload a XLSX file, the data from the first sheet will be extracted.\n                &lt;input #file type=file .form-control .btn .btn-info&gt;\n          $# TABLE -------------------------------------------------------------\n          &lt;div .col-8&gt;\n            &lt;table #table .table-striped .table-bordered .table-hover&gt;\n              &lt;thead&gt;\n                &lt;tr role=row&gt;\n              &lt;tbody&gt;\n      $# PLOT TAB --------------------------------------------------------------\n      &lt;div #plot-tab-pane .tab-pane .fade role=tabpanel aria-labelledby=plot-tab tabindex=0&gt;\n        &lt;div .row&gt;\n          $# SIDEBAR -----------------------------------------------------------\n          &lt;div .col-4&gt;\n            &lt;div .sidebar .card .text-bg-dark tabindex=-1 aria-labelledby=sidebarPlotTitle&gt;\n              &lt;div .card-body&gt;\n                &lt;div .sidebar-header&gt;\n                  &lt;h5 #sidebarPlotTitle .card-title&gt;Plot\n                &lt;div .sidebar-body&gt;\n                  &lt;fieldset #selectXY style=display:none;&gt;\n                    &lt;label for=selX&gt;Select the &lt;em&gt;x&lt;/em&gt; column\n                    &lt;select .form-control #selX style=overflow-y:auto;&gt;\n                    &lt;br&gt;\n                    &lt;label for=selY&gt;Select the &lt;em&gt;y&lt;/em&gt; column\n                    &lt;select .form-control #selY style=overflow-y:auto;&gt;\n            $# SPINNER ---------------------------------------------------------\n            &lt;div #spinner .spinner-border .m-5 role=status style=display:none&gt;\n                &lt;span .visually-hidden&gt;Loading...\n          $# PLOT --------------------------------------------------------------\n          &lt;div .col-8&gt;\n            &lt;img #plot width=100% height=400px&gt;</pre>\n</div>\n<p>\n        The interface has two tabs: one to upload and display the data, and the\n        other one to select two columns and display the graphic.\n      </p>\n<p>\n        The JavaScript function below will be called when the user uploads a\n        file. The file can be either a CSV file or a XLSX file. If this is a\n        XLSX file, then its content will be converted to CSV data before calling\n        this function. This function firstly converts the CSV data to a JSON\n        object, then it fills the table with the data and the <code>x</code> and\n        <code>y</code> dropdown lists with the column names, and then it defines\n        the behavior of the application.\n      </p>\n<div class=\"sourceCode\" id=\"cb3\">\n<pre>function papaParse(csv) {\n  Papa.parse(csv, {\n    header: true,\n    skipEmptyLines: true,\n    dynamicTyping: true,\n    complete: function(results) {\n      if(results.errors.length != 0) {\n        alert(\"Something is wrong with this CSV file.\");\n        console.log(\"Errors:\", results.errors);\n        throw new Error(\"Something is wrong with this CSV file.\");\n      }\n      let dataframe = results.data;\n      let colNames = results.meta.fields;\n      // Fill the table --------------------------------------------------------\n      let headers = \"\";\n      for(let colname of colNames) {\n        headers += \"&lt;th&gt;\" + colname + \"&lt;/th&gt;\";\n      }\n      $(\"#table thead tr\").append(headers);\n      let columns = [];\n      for(let colname of colNames) {\n        columns.push({ data: colname });\n      }\n      $(\"#table\").DataTable({\n        data: results.data,\n        columns: columns\n      });\n      // the dataframe is an array of objects like:\n      //   [{A: a1, B: b1, ...}, {A: a2, B: b2, ...}, ...]\n      // we transform it to this object:\n      //   {A: [a1, a2, ...], B: [b1, b2, ...], ...}\n      let dfx = {}; // for x, we convert every entry to a string\n      let dfy = {}; // for y, we don't convert anything\n      for(let colname of colNames) {\n        let columnx = [];\n        let columny = [];\n        for(let j = 0; j &lt; dataframe.length; j++) {\n          let entry = dataframe[j][colname];\n          columnx.push(entry.toString());\n          columny.push(entry);\n        }\n        dfx[colname] = columnx;\n        dfy[colname] = columny;\n      }\n      // Fill the x &amp; y dropdowns ----------------------------------------------\n      let $selsXY = $(\"#selX, #selY\");\n      let ncolumns = colNames.length;\n      let size = ncolumns &lt; 5 ? ncolumns : 5;\n      $selsXY.attr(\"size\", size);\n      $(colNames).each(function(idx, item) {\n        if(item != \"\") {\n          $selsXY.append($(\"&lt;option&gt;\").attr(\"value\", idx).text(item));\n        }\n      });\n      // Set x to the first column and y to the second one ---------------------\n      let selX = document.querySelector(\"#selX\");\n      let selY = document.querySelector(\"#selY\");\n      selX.value = \"0\";\n      selY.value = \"1\";\n      $(\"#selectXY\").show();\n      // Initial plot ----------------------------------------------------------\n      let myModalEl = document.getElementById(\"myModal\");\n      let myModal = new bootstrap.Modal(myModalEl);\n      let messageEl = myModalEl.querySelector(\"#message\");\n      let titleEl = myModalEl.querySelector(\".modal-title\");\n      let $selX = $(\"#selX\");\n      let $selY = $(\"#selY\");\n      plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      // Plot on change x or y -------------------------------------------------\n      $selsXY.on(\"change\", function() {\n        plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      });\n      // Plot on resize --------------------------------------------------------\n      $(window).on(\"resize\", function() {\n        plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      });\n    }\n  });\n}</pre>\n</div>\n<p>Here is the JavaScript code handling the file upload:</p>\n<div class=\"sourceCode\" id=\"cb4\">\n<pre>$(function() {\n  $(\"#file\").on(\"change\", function(e) {\n    let file = e.target.files[0];\n    let extension = file.name.split(\".\").pop().toLowerCase();\n    // --------------------------------------------------------------------\n    if(extension === \"xlsx\") {\n      let reader = new FileReader();\n      reader.onload = function (e) {\n        let workbook;\n        try {\n          workbook = XLSX.read(e.target.result, {\n            type: \"binary\"\n          });\n        } catch(err) {\n          alert(\"Something is wrong with this XLSX file.\");\n          throw new Error(err);\n        }\n        let sheetNames = workbook.SheetNames;\n        let sheet1 = sheetNames[0];\n        let XLSXasCSV = XLSX.utils.sheet_to_csv(workbook.Sheets[sheet1]);\n        papaParse(XLSXasCSV);\n      };\n      reader.onerror = function(err) {\n        alert(\"I can't read this XLSX file!\");\n        throw new Error(err);\n      };\n      reader.readAsArrayBuffer(file);\n    } else if(extension === \"csv\" || extension === \"tsv\") {\n      papaParse(file);\n    }\n  });\n});</pre>\n</div>\n<p>\n        Below is the <code>plot</code> function. It firstly collects the data of\n        the two selected columns and the dimensions of the plot container, and\n        then with an Ajax PUT request, it sends all these data to Haskell. The\n        Haskell function <code>putGgplotR</code> will receive these data, it\n        will send them to R and it will get the result from R. This result is\n        either a base64 string coding the graphic or an error message. We use a\n        separator <code>\"*::*::*::*::*\"</code> to put the error message at the\n        left of it and the base64 string at the right of it. If there’s no error\n        then the left part is the empty string. The Ajax request receives this\n        result. If there is an error message then it includes it in the\n        Bootstrap modal and displays this modal. If there is no error message\n        then it sends the base64 string to the <code>img</code> element of the\n        interface.\n      </p>\n<div class=\"sourceCode\" id=\"cb5\">\n<pre>function plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal) {\n  $(\"#spinner\").show();\n  let xidx = $selX.val();\n  let yidx = $selY.val();\n  let x = dfx[colNames[xidx]];\n  let y = dfy[colNames[yidx]];\n  let width = $(\"#plot\").width();\n  if(width === 0) {\n    // the plot tab is initially hidden and then width=0\n    width = 770;\n  }\n  let height = $(\"#plot\").height();\n  if(height === 0) {\n    height = 400;\n  }\n  let XYwh = JSON.stringify({ _x: x, _y: y, _width: width, _height: height });\n  let JSONstring = JSON.stringify(XYwh);\n  $.ajax({\n    contentType: \"application/json; charset=UTF-8\",\n    processData: false,\n    url: \"@{GgplotR}\",\n    type: \"PUT\",\n    data: JSONstring,\n    success: function(string) {\n      $(\"#spinner\").hide();\n      let error_base64 = string.split(\"*::*::*::*::*\");\n      let error = error_base64[0];\n      if(error === \"\") {\n        let base64 = error_base64[1];\n        $(\"#plot\").attr(\"src\", base64);\n      } else {\n        titleEl.textContent = \"An error has occured\";\n        messageEl.textContent = error;\n        myModal.show();\n      }\n    },\n    dataType: \"text\"\n  });\n}</pre>\n</div>\n<p>\n        The Haskell function <code>putGgplotR</code> that we just mentioned will\n        send the data to R with a JSON file written in the temporary folder.\n        Here is the function used to write a temporary file:\n      </p>\n<div class=\"sourceCode\" id=\"cb6\">\n<pre>writeTempFile :: String -&gt; FilePath -&gt; IO FilePath\nwriteTempFile contents fileName = do\n    tmpDir &lt;- getCanonicalTemporaryDirectory\n    dir &lt;- createTempDirectory tmpDir \"yesod\"\n    let filePath = dir ++ \"/\" ++ fileName\n    writeFile filePath contents\n    return $ replaceBackslahes filePath\n    where\n        replaceBackslahes :: String -&gt; String\n        replaceBackslahes string = subRegex (mkRegex \"\\\\\\\\\") string \"/\"</pre>\n</div>\n<p>And here is the function <code>putGgplotR</code>:</p>\n<div class=\"sourceCode\" id=\"cb7\">\n<pre>putGgplotR :: Handler String\nputGgplotR = do\n    jsonData &lt;- requireCheckJsonBody :: Handler String\n    jsonFile &lt;- liftIO $ writeTempFile jsonData \"data.json\"\n    (exitcode, stdout, stderr) &lt;- liftIO $ \n        readProcessWithExitCode \"Rscript\" [\"-e\", rCommand jsonFile] \"\"\n    let base64 = stdout\n    let err = if exitcode == ExitSuccess then \"\" else stderr\n    -- return the error message and the base64 string with a separator\n    return $ err ++ \"*::*::*::*::*\" ++ base64\n    where\n        rCommand :: FilePath -&gt; String\n        rCommand file = \n            \"jsonFile&lt;-\" ++ quote file ++ \n                \";source(\" ++ quote \"static/R/ggplotXY.R\" ++ \")\"\n            where\n                quote :: String -&gt; String\n                quote x = \"\\\"\" ++ x ++ \"\\\"\"        </pre>\n</div>\n<p>\n        Finally, here is the R file <strong><em>ggplotXY.R</em></strong> which\n        is sourced:\n      </p>\n<div class=\"sourceCode\" id=\"cb8\">\n<pre>library(ggplot2)\nlibrary(jsonlite)\nlibrary(base64enc)\n\n# extract data from the JSON file\njsonData &lt;- fromJSON(jsonFile)\nx &lt;- jsonData[[\"_x\"]]\ny &lt;- jsonData[[\"_y\"]]\nw &lt;- jsonData[[\"_width\"]]\nh &lt;- jsonData[[\"_height\"]]\n\n# if `y` is not numeric, we throw an error\nif(!is.numeric(y)) {\n  stop(\"The `y` column is not numeric.\")\n}\n\n# function to convert x to numeric if possible\nmaybeNumeric &lt;- function(x) {\n  xx &lt;- as.numeric(x)\n  if(anyNA(xx)) x else xx\n}\n\n# data\ndat &lt;- data.frame(x = maybeNumeric(x), y = y)\n\n# plot\ngg &lt;- ggplot(dat, aes(x = x, y = y)) + \n  geom_point()\n\n# save plot as PNG\npng &lt;- tempfile(fileext = \".png\")\nggsave(png, gg, width = w, height = h, units = \"px\", dpi = \"print\")\n\n# convert the PNG file to a base64 string\nbase64 &lt;- dataURI(file = png, mime = \"image/png\")\n\n# print the base64 string\ncat(base64)</pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://laustep.github.io/stlahblog/posts/yesod_ggplot.html\"> Saturn Elephant</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "A R graphic in a Yesod app\nPosted on\nDecember 1, 2023\nby\nStéphane Laurent\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nSaturn Elephant\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nYesod is a web framework for Haskell. In this post I show how to do a\n        Yesod application allowing to upload some data from a CSV or a XLSX file\n        and to display a R graphic representing two selected columns of the\n        data.\nBelow is the directory content of the application, available in\nthis Github repository\n.\n|   .dir-locals.el\n|   client_session_key.aes\n|   package.yaml\n|   README.md\n|   routes.yesodroutes\n|   stack.yaml\n|   \n+---app\n|       Main.hs\n|       \n+---src\n|       Application.hs\n|       Foundation.hs\n|       GGplot.hs\n|       Home.hs\n|       \n\\---static\n    +---bootstrap-5.3.2\n    |   +---css\n    |   |       bootstrap.min.css\n    |   |       bootstrap.min.css.map\n    |   |       \n    |   \\---js\n    |           bootstrap.bundle.min.js\n    |           bootstrap.bundle.min.js.map\n    |           \n    +---DataTables-1.13.8\n    |   |   datatables.min.css\n    |   |   datatables.min.js\n    |   |   \n    |   \\---images\n    |           sort_asc.png\n    |           sort_asc_disabled.png\n    |           sort_both.png\n    |           sort_desc.png\n    |           sort_desc_disabled.png\n    |           \n    +---images\n    |       haskell.png\n    |       \n    +---jQuery\n    |       jquery-3.7.1.min.js\n    |       \n    +---PapaParse\n    |       papaparse.min.js\n    |       \n    +---R\n    |       ggplotXY.R\n    |       \n    \\---SheetJS\n            xlsx.core.min.js\n            xlsx.core.min.map\nI’m using\nbootstrap\nfor the style,\nDataTables\nto display a nice table of the data,\nPapaParse\nto parse the uploaded CSV file to a JSON\n        object, and\nSheetJS\nto convert the uploaded XLSX file\n        to CSV data, which can then be parsed to a JSON object with\nPapaParse\n.\nHamlet\nis a HTML templating language developed for Yesod applications. Below is\n        the Hamlet code of the application. I use a Bootstrap modal to display\n        errors if there are.\n<body>\n  $# BOOTSTRAP MODAL -----------------------------------------------------------\n  <div #myModal .modal .fade aria-hidden aria-labelledby=myModalLabel tabindex=-1>\n    <div .modal-dialog .modal-dialog-centered>\n      <div .modal-content>\n        <div .modal-header>\n            <h1 .modal-title .fs-5>\n        <div .modal-body>\n            <span #message>\n        <div .modal-footer>\n            <button type=button .btn .btn-secondary data-bs-dismiss=modal>Close\n  $# HASKELL LOGO --------------------------------------------------------------\n  <img src=./static/images/haskell.png style=float:right;margin:5px;width:50px;>\n  $# ---------------------------------------------------------------------------\n  <div .container-fluid>\n    $# TABS --------------------------------------------------------\n    <ul .nav .nav-tabs role=tablist>\n      <li .nav-item role=presentation>\n        <button #data-tab .nav-link .active data-bs-toggle=tab data-bs-target=#data-tab-pane type=button role=tab aria-controls=data-tab-pane aria-selected=true>Data\n      <li .nav-item role=presentation>\n        <button #plot-tab .nav-link data-bs-toggle=tab data-bs-target=#plot-tab-pane type=button role=tab aria-controls=plot-tab-pane aria-selected=false>Plot\n    $# TABS CONTENTS -----------------------------------------------------------\n    <div #tabContent .tab-content>\n      $# DATA TAB --------------------------------------------------------------\n      <div #data-tab-pane .tab-pane .fade .show .active role=tabpanel aria-labelledby=data-tab tabindex=0>\n        <div .row>\n          $# SIDEBAR -----------------------------------------------------------\n          <div .col-4>\n            <div .card .text-bg-dark tabindex=-1 aria-labelledby=sidebarDataTitle>\n              <div .card-body>\n                <h5 #sidebarDataTitle .card-title>Upload data\n                <h6 .card-text>Upload a CSV file or a XLSX file.\n                <p .card-text style=font-style:italic;>If you upload a XLSX file, the data from the first sheet will be extracted.\n                <input #file type=file .form-control .btn .btn-info>\n          $# TABLE -------------------------------------------------------------\n          <div .col-8>\n            <table #table .table-striped .table-bordered .table-hover>\n              <thead>\n                <tr role=row>\n              <tbody>\n      $# PLOT TAB --------------------------------------------------------------\n      <div #plot-tab-pane .tab-pane .fade role=tabpanel aria-labelledby=plot-tab tabindex=0>\n        <div .row>\n          $# SIDEBAR -----------------------------------------------------------\n          <div .col-4>\n            <div .sidebar .card .text-bg-dark tabindex=-1 aria-labelledby=sidebarPlotTitle>\n              <div .card-body>\n                <div .sidebar-header>\n                  <h5 #sidebarPlotTitle .card-title>Plot\n                <div .sidebar-body>\n                  <fieldset #selectXY style=display:none;>\n                    <label for=selX>Select the <em>x</em> column\n                    <select .form-control #selX style=overflow-y:auto;>\n                    <br>\n                    <label for=selY>Select the <em>y</em> column\n                    <select .form-control #selY style=overflow-y:auto;>\n            $# SPINNER ---------------------------------------------------------\n            <div #spinner .spinner-border .m-5 role=status style=display:none>\n                <span .visually-hidden>Loading...\n          $# PLOT --------------------------------------------------------------\n          <div .col-8>\n            <img #plot width=100% height=400px>\nThe interface has two tabs: one to upload and display the data, and the\n        other one to select two columns and display the graphic.\nThe JavaScript function below will be called when the user uploads a\n        file. The file can be either a CSV file or a XLSX file. If this is a\n        XLSX file, then its content will be converted to CSV data before calling\n        this function. This function firstly converts the CSV data to a JSON\n        object, then it fills the table with the data and the\nx\nand\ny\ndropdown lists with the column names, and then it defines\n        the behavior of the application.\nfunction papaParse(csv) {\n  Papa.parse(csv, {\n    header: true,\n    skipEmptyLines: true,\n    dynamicTyping: true,\n    complete: function(results) {\n      if(results.errors.length != 0) {\n        alert(\"Something is wrong with this CSV file.\");\n        console.log(\"Errors:\", results.errors);\n        throw new Error(\"Something is wrong with this CSV file.\");\n      }\n      let dataframe = results.data;\n      let colNames = results.meta.fields;\n      // Fill the table --------------------------------------------------------\n      let headers = \"\";\n      for(let colname of colNames) {\n        headers += \"<th>\" + colname + \"</th>\";\n      }\n      $(\"#table thead tr\").append(headers);\n      let columns = [];\n      for(let colname of colNames) {\n        columns.push({ data: colname });\n      }\n      $(\"#table\").DataTable({\n        data: results.data,\n        columns: columns\n      });\n      // the dataframe is an array of objects like:\n      //   [{A: a1, B: b1, ...}, {A: a2, B: b2, ...}, ...]\n      // we transform it to this object:\n      //   {A: [a1, a2, ...], B: [b1, b2, ...], ...}\n      let dfx = {}; // for x, we convert every entry to a string\n      let dfy = {}; // for y, we don't convert anything\n      for(let colname of colNames) {\n        let columnx = [];\n        let columny = [];\n        for(let j = 0; j < dataframe.length; j++) {\n          let entry = dataframe[j][colname];\n          columnx.push(entry.toString());\n          columny.push(entry);\n        }\n        dfx[colname] = columnx;\n        dfy[colname] = columny;\n      }\n      // Fill the x & y dropdowns ----------------------------------------------\n      let $selsXY = $(\"#selX, #selY\");\n      let ncolumns = colNames.length;\n      let size = ncolumns < 5 ? ncolumns : 5;\n      $selsXY.attr(\"size\", size);\n      $(colNames).each(function(idx, item) {\n        if(item != \"\") {\n          $selsXY.append($(\"<option>\").attr(\"value\", idx).text(item));\n        }\n      });\n      // Set x to the first column and y to the second one ---------------------\n      let selX = document.querySelector(\"#selX\");\n      let selY = document.querySelector(\"#selY\");\n      selX.value = \"0\";\n      selY.value = \"1\";\n      $(\"#selectXY\").show();\n      // Initial plot ----------------------------------------------------------\n      let myModalEl = document.getElementById(\"myModal\");\n      let myModal = new bootstrap.Modal(myModalEl);\n      let messageEl = myModalEl.querySelector(\"#message\");\n      let titleEl = myModalEl.querySelector(\".modal-title\");\n      let $selX = $(\"#selX\");\n      let $selY = $(\"#selY\");\n      plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      // Plot on change x or y -------------------------------------------------\n      $selsXY.on(\"change\", function() {\n        plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      });\n      // Plot on resize --------------------------------------------------------\n      $(window).on(\"resize\", function() {\n        plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal);\n      });\n    }\n  });\n}\nHere is the JavaScript code handling the file upload:\n$(function() {\n  $(\"#file\").on(\"change\", function(e) {\n    let file = e.target.files[0];\n    let extension = file.name.split(\".\").pop().toLowerCase();\n    // --------------------------------------------------------------------\n    if(extension === \"xlsx\") {\n      let reader = new FileReader();\n      reader.onload = function (e) {\n        let workbook;\n        try {\n          workbook = XLSX.read(e.target.result, {\n            type: \"binary\"\n          });\n        } catch(err) {\n          alert(\"Something is wrong with this XLSX file.\");\n          throw new Error(err);\n        }\n        let sheetNames = workbook.SheetNames;\n        let sheet1 = sheetNames[0];\n        let XLSXasCSV = XLSX.utils.sheet_to_csv(workbook.Sheets[sheet1]);\n        papaParse(XLSXasCSV);\n      };\n      reader.onerror = function(err) {\n        alert(\"I can't read this XLSX file!\");\n        throw new Error(err);\n      };\n      reader.readAsArrayBuffer(file);\n    } else if(extension === \"csv\" || extension === \"tsv\") {\n      papaParse(file);\n    }\n  });\n});\nBelow is the\nplot\nfunction. It firstly collects the data of\n        the two selected columns and the dimensions of the plot container, and\n        then with an Ajax PUT request, it sends all these data to Haskell. The\n        Haskell function\nputGgplotR\nwill receive these data, it\n        will send them to R and it will get the result from R. This result is\n        either a base64 string coding the graphic or an error message. We use a\n        separator\n\"*::*::*::*::*\"\nto put the error message at the\n        left of it and the base64 string at the right of it. If there’s no error\n        then the left part is the empty string. The Ajax request receives this\n        result. If there is an error message then it includes it in the\n        Bootstrap modal and displays this modal. If there is no error message\n        then it sends the base64 string to the\nimg\nelement of the\n        interface.\nfunction plot($selX, $selY, dfx, dfy, colNames, titleEl, messageEl, myModal) {\n  $(\"#spinner\").show();\n  let xidx = $selX.val();\n  let yidx = $selY.val();\n  let x = dfx[colNames[xidx]];\n  let y = dfy[colNames[yidx]];\n  let width = $(\"#plot\").width();\n  if(width === 0) {\n    // the plot tab is initially hidden and then width=0\n    width = 770;\n  }\n  let height = $(\"#plot\").height();\n  if(height === 0) {\n    height = 400;\n  }\n  let XYwh = JSON.stringify({ _x: x, _y: y, _width: width, _height: height });\n  let JSONstring = JSON.stringify(XYwh);\n  $.ajax({\n    contentType: \"application/json; charset=UTF-8\",\n    processData: false,\n    url: \"@{GgplotR}\",\n    type: \"PUT\",\n    data: JSONstring,\n    success: function(string) {\n      $(\"#spinner\").hide();\n      let error_base64 = string.split(\"*::*::*::*::*\");\n      let error = error_base64[0];\n      if(error === \"\") {\n        let base64 = error_base64[1];\n        $(\"#plot\").attr(\"src\", base64);\n      } else {\n        titleEl.textContent = \"An error has occured\";\n        messageEl.textContent = error;\n        myModal.show();\n      }\n    },\n    dataType: \"text\"\n  });\n}\nThe Haskell function\nputGgplotR\nthat we just mentioned will\n        send the data to R with a JSON file written in the temporary folder.\n        Here is the function used to write a temporary file:\nwriteTempFile :: String -> FilePath -> IO FilePath\nwriteTempFile contents fileName = do\n    tmpDir <- getCanonicalTemporaryDirectory\n    dir <- createTempDirectory tmpDir \"yesod\"\n    let filePath = dir ++ \"/\" ++ fileName\n    writeFile filePath contents\n    return $ replaceBackslahes filePath\n    where\n        replaceBackslahes :: String -> String\n        replaceBackslahes string = subRegex (mkRegex \"\\\\\\\\\") string \"/\"\nAnd here is the function\nputGgplotR\n:\nputGgplotR :: Handler String\nputGgplotR = do\n    jsonData <- requireCheckJsonBody :: Handler String\n    jsonFile <- liftIO $ writeTempFile jsonData \"data.json\"\n    (exitcode, stdout, stderr) <- liftIO $ \n        readProcessWithExitCode \"Rscript\" [\"-e\", rCommand jsonFile] \"\"\n    let base64 = stdout\n    let err = if exitcode == ExitSuccess then \"\" else stderr\n    -- return the error message and the base64 string with a separator\n    return $ err ++ \"*::*::*::*::*\" ++ base64\n    where\n        rCommand :: FilePath -> String\n        rCommand file = \n            \"jsonFile<-\" ++ quote file ++ \n                \";source(\" ++ quote \"static/R/ggplotXY.R\" ++ \")\"\n            where\n                quote :: String -> String\n                quote x = \"\\\"\" ++ x ++ \"\\\"\"\nFinally, here is the R file\nggplotXY.R\nwhich\n        is sourced:\nlibrary(ggplot2)\nlibrary(jsonlite)\nlibrary(base64enc)\n\n# extract data from the JSON file\njsonData <- fromJSON(jsonFile)\nx <- jsonData[[\"_x\"]]\ny <- jsonData[[\"_y\"]]\nw <- jsonData[[\"_width\"]]\nh <- jsonData[[\"_height\"]]\n\n# if `y` is not numeric, we throw an error\nif(!is.numeric(y)) {\n  stop(\"The `y` column is not numeric.\")\n}\n\n# function to convert x to numeric if possible\nmaybeNumeric <- function(x) {\n  xx <- as.numeric(x)\n  if(anyNA(xx)) x else xx\n}\n\n# data\ndat <- data.frame(x = maybeNumeric(x), y = y)\n\n# plot\ngg <- ggplot(dat, aes(x = x, y = y)) + \n  geom_point()\n\n# save plot as PNG\npng <- tempfile(fileext = \".png\")\nggsave(png, gg, width = w, height = h, units = \"px\", dpi = \"print\")\n\n# convert the PNG file to a base64 string\nbase64 <- dataURI(file = png, mime = \"image/png\")\n\n# print the base64 string\ncat(base64)\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nSaturn Elephant\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Yesod is a web framework for Haskell. In this post I show how to do a Yesod application allowing to upload some data from a CSV or a XLSX file and to display a R graphic representing two selected columns of the ...",
    "meta_keywords": null,
    "og_description": "Yesod is a web framework for Haskell. In this post I show how to do a Yesod application allowing to upload some data from a CSV or a XLSX file and to display a R graphic representing two selected columns of the ...",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "A R graphic in a Yesod app | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 9.1,
    "sitemap_lastmod": "2023-12-02T00:00:00+00:00",
    "twitter_description": "Yesod is a web framework for Haskell. In this post I show how to do a Yesod application allowing to upload some data from a CSV or a XLSX file and to display a R graphic representing two selected columns of the ...",
    "twitter_title": "A R graphic in a Yesod app | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/12/a-r-graphic-in-a-yesod-app/",
    "word_count": 1825
  }
}