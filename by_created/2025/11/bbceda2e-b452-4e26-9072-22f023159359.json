{
  "uuid": "bbceda2e-b452-4e26-9072-22f023159359",
  "created_at": "2025-11-22 19:59:24",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/01/keys-to-scalable-code-owning-the-interfaces-you-use-2/",
    "crawled_at": "2025-11-22T10:55:19.244551",
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/own-interfaces-you-use",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://jakubsobolewski.com/blog/own-interfaces-you-use",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Keys To Scalable Code: Owning The Interfaces You Use | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-393511 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Keys To Scalable Code: Owning The Interfaces You Use</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 22, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/own-interfaces-you-use\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>As the codebase grows, it’s important to own the interfaces you use, especially for code that’s more likely to change in the future.</p>\n<p>When we develop code, we make choices about libraries we use that help us build the functionality we need. Sometimes those choices are more conscious, and sometimes we just use what we always do. It might be a no-brainer that we use <code>dplyr</code> to wrangle data. We might not expect to ever have to rewrite <code>dplyr</code> to <code>data.table</code>.</p>\n<p>But there are some parts of the codebase that are more likely to change, and not even because of our own decisions.</p>\n<h2 id=\"shiny-components-are-parts-of-the-codebase-that-we-might-want-to-change-in-the-future\">Shiny components are parts of the codebase that we might want to change in the future.</h2>\n<p>You’re building a Shiny app.</p>\n<p>You decide to use <code>shiny::selectInput</code> to create dropdowns, because you always use them, and they never failed you.</p>\n<p>But then, you decide to refactor the interface.</p>\n<p>You no longer like the default label being in the top left corner of the input, you want it to be in one line with the select. The function doesn’t support such modification. Neither it’s feasible with CSS.</p>\n<p>So you need to change the markup.</p>\n<pre>shiny::div(\n  class = \"d-flex flex-row gap-2 align-items-center\",\n  shiny::tags$label(\"Select a variable\"),\n  shiny::selectInput(\n    inputId = \"variable\",\n    label = NULL,\n    choices = c(\"a\", \"b\", \"c\"),\n    selected = \"a\"\n  )\n)</pre>\n<p>This might be fine as long as you have at most a few dropdowns.</p>\n<p>But what if you have plenty of them, all needing the same change? To carry out change we’d need to produce a huge diff. And it’s just to reposition the label.</p>\n<p>What if we want to make another change like that in the future?</p>\n<p>All of the work will have to be repeated.</p>\n<h2 id=\"the-solution-is-to-own-the-interfaces-our-code-uses\">The solution is to own the interfaces our code uses.</h2>\n<p>We can aviod changing code in a lot of places if we create a function producing this component.</p>\n<p>Then we can change the code in one place, propagating the change to all the places where its used. Just wrap the code you suspect might change in the future in a function. You can also provide your own defaults, so you don’t have to repeat them every time you use the component.</p>\n<p>So if we used such a <code>select</code> component in our codebase, instead of <code>shiny::selectInput</code>:</p>\n<pre>select &lt;- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::selectInput(\n    inputId = id,\n    label = label,\n    choices = choices,\n    selected = selected,\n    ...\n  )\n}</pre>\n<p>Then we can modify our code in one place:</p>\n<pre>select &lt;- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::div(\n    class = \"d-flex flex-row gap-2 align-items-center\",\n    shiny::tags$label(label),\n    shiny::selectInput(\n      inputId = id,\n      label = NULL,\n      choices = choices,\n      selected = selected,\n      ...\n    )\n  )\n}</pre>\n<p>And all the places where we used the <code>select</code> function will be updated.</p>\n<hr/>\n<p>We’re <strong>abstracting</strong> the select component and <strong>hiding information</strong> about the implementation.</p>\n<hr/>\n<h2 id=\"i-implement-it-even-if-i-dont-know-if-itll-come-in-handy-better-be-safe-than-sorry\">I implement it even if I don’t know if it’ll come in handy, better be safe than sorry.</h2>\n<p>If we do it for a select, we should also do this with other components.</p>\n<pre>select &lt;- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::div(\n    class = \"d-flex flex-row gap-2 align-items-center\",\n    shiny::tags$label(label),\n    shiny::selectInput(\n      inputId = id,\n      label = NULL,\n      choices = choices,\n      selected = selected,\n      ...\n    )\n  )\n}\n\ncheckbox &lt;- function(id, label, value) {\n\n}\n\nradio &lt;- function(id, label = NULL, choices = c(), selected = NULL) {\n\n}\n\nbutton &lt;- function(id, label, variant = \"primary\") {\n\n}\n\n# ...</pre>\n<p>Then you have the flexibility to update your components in one place and have less code to maintain. It also allows you to change the implementation of the component. Do you want to switch to <code>shinyWidgets</code>? No problem, just replace the body of the <code>select</code> function!</p>\n<p>This idea doesn’t end with Shiny components.</p>\n<h2 id=\"own-all-interfaces-that-might-change-their-implementation\">Own all interfaces that might change their implementation.</h2>\n<p>Similar idea can be applied to other interfaces used in our codebase.</p>\n<ul>\n<li>Storage, so that you can switch providers. Whether you use a flat file, a database, or a cloud storage, you can run the same <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code> operations on them. Your code doesn’t need to know from where the data comes from.</li>\n<li>Logging, so that you can switch the logging library without changing all calls to the log function.</li>\n</ul>\n<p>Allowing dependencies to spill into your code might be okay when you’re 100% sure you won’t change your mind in the future. But if you suspect you might, it’s better to own the interfaces your code calls.</p>\n<p><strong>Abstraction and information hiding</strong> is the key to scalable code, one that we can easily change in the future.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/own-interfaces-you-use\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Keys To Scalable Code: Owning The Interfaces You Use\nPosted on\nJanuary 22, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nAs the codebase grows, it’s important to own the interfaces you use, especially for code that’s more likely to change in the future.\nWhen we develop code, we make choices about libraries we use that help us build the functionality we need. Sometimes those choices are more conscious, and sometimes we just use what we always do. It might be a no-brainer that we use\ndplyr\nto wrangle data. We might not expect to ever have to rewrite\ndplyr\nto\ndata.table\n.\nBut there are some parts of the codebase that are more likely to change, and not even because of our own decisions.\nShiny components are parts of the codebase that we might want to change in the future.\nYou’re building a Shiny app.\nYou decide to use\nshiny::selectInput\nto create dropdowns, because you always use them, and they never failed you.\nBut then, you decide to refactor the interface.\nYou no longer like the default label being in the top left corner of the input, you want it to be in one line with the select. The function doesn’t support such modification. Neither it’s feasible with CSS.\nSo you need to change the markup.\nshiny::div(\n  class = \"d-flex flex-row gap-2 align-items-center\",\n  shiny::tags$label(\"Select a variable\"),\n  shiny::selectInput(\n    inputId = \"variable\",\n    label = NULL,\n    choices = c(\"a\", \"b\", \"c\"),\n    selected = \"a\"\n  )\n)\nThis might be fine as long as you have at most a few dropdowns.\nBut what if you have plenty of them, all needing the same change? To carry out change we’d need to produce a huge diff. And it’s just to reposition the label.\nWhat if we want to make another change like that in the future?\nAll of the work will have to be repeated.\nThe solution is to own the interfaces our code uses.\nWe can aviod changing code in a lot of places if we create a function producing this component.\nThen we can change the code in one place, propagating the change to all the places where its used. Just wrap the code you suspect might change in the future in a function. You can also provide your own defaults, so you don’t have to repeat them every time you use the component.\nSo if we used such a\nselect\ncomponent in our codebase, instead of\nshiny::selectInput\n:\nselect <- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::selectInput(\n    inputId = id,\n    label = label,\n    choices = choices,\n    selected = selected,\n    ...\n  )\n}\nThen we can modify our code in one place:\nselect <- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::div(\n    class = \"d-flex flex-row gap-2 align-items-center\",\n    shiny::tags$label(label),\n    shiny::selectInput(\n      inputId = id,\n      label = NULL,\n      choices = choices,\n      selected = selected,\n      ...\n    )\n  )\n}\nAnd all the places where we used the\nselect\nfunction will be updated.\nWe’re\nabstracting\nthe select component and\nhiding information\nabout the implementation.\nI implement it even if I don’t know if it’ll come in handy, better be safe than sorry.\nIf we do it for a select, we should also do this with other components.\nselect <- function(id, label = NULL, choices = c(), selected = c(), ...) {\n  shiny::div(\n    class = \"d-flex flex-row gap-2 align-items-center\",\n    shiny::tags$label(label),\n    shiny::selectInput(\n      inputId = id,\n      label = NULL,\n      choices = choices,\n      selected = selected,\n      ...\n    )\n  )\n}\n\ncheckbox <- function(id, label, value) {\n\n}\n\nradio <- function(id, label = NULL, choices = c(), selected = NULL) {\n\n}\n\nbutton <- function(id, label, variant = \"primary\") {\n\n}\n\n# ...\nThen you have the flexibility to update your components in one place and have less code to maintain. It also allows you to change the implementation of the component. Do you want to switch to\nshinyWidgets\n? No problem, just replace the body of the\nselect\nfunction!\nThis idea doesn’t end with Shiny components.\nOwn all interfaces that might change their implementation.\nSimilar idea can be applied to other interfaces used in our codebase.\nStorage, so that you can switch providers. Whether you use a flat file, a database, or a cloud storage, you can run the same\ncreate\n,\nread\n,\nupdate\n,\ndelete\noperations on them. Your code doesn’t need to know from where the data comes from.\nLogging, so that you can switch the logging library without changing all calls to the log function.\nAllowing dependencies to spill into your code might be okay when you’re 100% sure you won’t change your mind in the future. But if you suspect you might, it’s better to own the interfaces your code calls.\nAbstraction and information hiding\nis the key to scalable code, one that we can easily change in the future.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Learn how to build scalable and maintainable code by abstraction and information hiding, improving flexibility and ease of future changes.",
    "meta_keywords": null,
    "og_description": "Learn how to build scalable and maintainable code by abstraction and information hiding, improving flexibility and ease of future changes.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "Keys To Scalable Code: Owning The Interfaces You Use | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 4.6,
    "sitemap_lastmod": null,
    "twitter_description": "Learn how to build scalable and maintainable code by abstraction and information hiding, improving flexibility and ease of future changes.",
    "twitter_title": "Keys To Scalable Code: Owning The Interfaces You Use | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/01/keys-to-scalable-code-owning-the-interfaces-you-use-2/",
    "word_count": 915
  }
}