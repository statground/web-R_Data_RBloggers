{
  "uuid": "f9085343-e7bc-4896-8002-dbf1ab15315b",
  "created_at": "2025-11-17 20:39:33",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/10/reproducible-data-science-with-nix-part-7-building-a-quarto-book-using-nix-on-github-actions/",
    "crawled_at": "2025-11-17T10:07:17.128019",
    "external_links": [
      {
        "href": "https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://www.brodrigues.co/blog/2023-06-29-book_quarto/",
        "text": "here"
      },
      {
        "href": "https://www.brodrigues.co/about/books/",
        "text": "building reproducible analytical pipelines with\nR"
      },
      {
        "href": "https://github.com/b-rodrigues/kdp_quarto",
        "text": "template on Github"
      },
      {
        "href": "https://github.com/b-rodrigues/quarto_book_nix",
        "text": "here"
      },
      {
        "href": "https://github.com/quarto-dev/quarto-actions/blob/main/publish/action.yml",
        "text": "here"
      },
      {
        "href": "https://github.com/b-rodrigues/quarto-nix-actions/blob/f48f5a7813eb4978a2f557ff45bcc854526fb80b/publish/action.yml#L58",
        "text": "Nix environment defined for the\nproject"
      },
      {
        "href": "https://b-rodrigues.github.io/quarto_book_nix/",
        "text": "here"
      },
      {
        "href": "https://github.com/NixOS/nixpkgs",
        "text": "https://github.com/NixOS/nixpkgs"
      },
      {
        "href": "https://search.nixos.org/packages",
        "text": "here"
      },
      {
        "href": "https://github.com/philipp-baumann",
        "text": "Philipp\nBaumann"
      },
      {
        "href": "https://www.brodrigues.co/blog/2023-10-05-repro_overview/",
        "text": "previous\nblog post"
      },
      {
        "href": "https://fosstodon.org/@brodriguesco",
        "text": "Mastodon"
      },
      {
        "href": "https://www.twitter.com/brodriguesco",
        "text": "twitter"
      },
      {
        "href": "https://www.buymeacoffee.com/brodriguesco",
        "text": "buy me an espresso"
      },
      {
        "href": "https://www.paypal.me/brodriguesco",
        "text": "paypal.me"
      },
      {
        "href": "https://www.brodrigues.co/about/books/",
        "text": "ebooks"
      },
      {
        "href": "https://www.youtube.com/c/BrunoRodrigues1988/",
        "text": "youtube"
      },
      {
        "href": "https://www.buymeacoffee.com/brodriguesco",
        "text": "Buy me an Espresso"
      },
      {
        "href": "https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Reproducible data science with Nix, part 7 — Building a Quarto book using Nix on Github Actions | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.brodrigues.co/img/nix_users_press_both_buttons.png?w=50%25&ssl=1"
      },
      {
        "alt": "Buy me an Espresso",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Buy me an Espresso",
        "base64": null,
        "src": "https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/econometrics-and-free-software/",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-379293 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Reproducible data science with Nix, part 7 — Building a Quarto book using Nix on Github Actions</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">October 19, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/econometrics-and-free-software/\">Econometrics and Free Software</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/\"> Econometrics and Free Software</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><div style=\"text-align:center;\">\n<p><img data-lazy-src=\"https://i0.wp.com/www.brodrigues.co/img/nix_users_press_both_buttons.png?w=50%25&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.brodrigues.co/img/nix_users_press_both_buttons.png?w=50%25&amp;ssl=1\"/></noscript></p>\n</div>\n<p>Back in June I self-published a book on Amazon’s Kindle Direct Publishing\nservice and wrote a blog post detailling how you could achieve that using\nQuarto, which you can read\n<a href=\"https://www.brodrigues.co/blog/2023-06-29-book_quarto/\" rel=\"nofollow\" target=\"_blank\">here</a>. The book is\nabout <a href=\"https://www.brodrigues.co/about/books/\" rel=\"nofollow\" target=\"_blank\">building reproducible analytical pipelines with\nR</a>. For the purposes of this post I made\na <a href=\"https://github.com/b-rodrigues/kdp_quarto\" rel=\"nofollow\" target=\"_blank\">template on Github</a> that you could\nfork and use as a starting point to write your own book. The book also gets\nbuilt using Github Actions each time you push new changes: a website gets built,\nan E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built.\nThat template used dedicated actions to install the required version of R,\nQuarto, and R packages (using <code>{renv}</code>).</p>\n<p>Let’s take a look at the workflow file:</p>\n<pre>on:\n  push:\n    branches: main\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v3\n\n      - name: Setup pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: '4.3.1'\n\n      - name: Setup renv\n        uses: r-lib/actions/setup-renv@v2\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        with:\n          # To install LaTeX to build PDF book \n          tinytex: true \n          # uncomment below and fill to pin a version\n          #version: 1.3.353\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions</pre>\n<p>As you can see, there are a lot of different moving pieces to get this to work.\nSince then I discovered Nix (if you’ve not been following my adventures, there’s\n6 other parts to this series as of today), and now I wrote another template that\nuses Nix to handle the book’s dependencies instead of dedicated actions and\n<code>{renv}</code>. You can find the repository\n<a href=\"https://github.com/b-rodrigues/quarto_book_nix\" rel=\"nofollow\" target=\"_blank\">here</a>.</p>\n<p>Here is what the workflow file looks like:</p>\n<pre>name: Build book using Nix\n\non:\n  push:\n    branches:\n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Code\n      uses: actions/checkout@v3\n\n    - name: Install Nix\n      uses: DeterminateSystems/nix-installer-action@main\n      with:\n        logger: pretty\n        log-directives: nix_installer=trace\n        backtrace: full\n\n    - name: Nix cache\n      uses: DeterminateSystems/magic-nix-cache-action@main\n\n    - name: Build development environment\n      run: |\n        nix-build\n\n    - name: Publish to GitHub Pages (and render)\n      uses: b-rodrigues/quarto-nix-actions/publish@main\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} </pre>\n<p>The first thing you should notice is that this file is much shorter.</p>\n<p>The first step, <code>Checkout Code</code> makes the code available to the rest of the\nsteps. I then install Nix on this runner using the Determinate Systems\n<code>nix-installer-action</code> and then I use another action from Determinate Systems,\nthe <code>magic-nix-cache-action</code>. This action caches all the packages so that they\ndon’t need to get re-built each time a change gets pushed, speeding up the\nprocess by a lot. The development environment gets then built using <code>nix-build</code>.</p>\n<p>Finally, an action I defined runs, <code>quarto-nix-actions/publish</code>. This is a fork\nof the <code>quarto-actions/publish</code> action which you can find\n<a href=\"https://github.com/quarto-dev/quarto-actions/blob/main/publish/action.yml\" rel=\"nofollow\" target=\"_blank\">here</a>.\nMy fork simply makes sure that the <code>quarto render</code> and <code>quarto publish</code> commands\nrun in the <a href=\"https://github.com/b-rodrigues/quarto-nix-actions/blob/f48f5a7813eb4978a2f557ff45bcc854526fb80b/publish/action.yml#L58\" rel=\"nofollow\" target=\"_blank\">Nix environment defined for the\nproject</a>.</p>\n<p>You can see the book website\n<a href=\"https://b-rodrigues.github.io/quarto_book_nix/\" rel=\"nofollow\" target=\"_blank\">here</a>; read it, it’s explains\neverything in much more details than this blog post! But if you’re busy, read\ncontinue reading this blog post instead.</p>\n<p>The obvious next question is why bother with this second, Nix-centric, approach?</p>\n<p>There are at least three reasons. The first is that it is possible to define\nso-called <code>default.nix</code> files that the Nix package manager then uses to build a\nfully reproducible development environment. This environment will contain all\nthe packages that you require, and will not interfere with any other packages\ninstalled on your system. This essentially means that you can have\nproject-specific <code>default.nix</code> files, each specifying the requirements for\nspecific projects. This file can then be used as-is on any other platform to\nre-create your environment. The second reason is that when installing a package\nthat requires system-level dependencies, <code>{rJava}</code> for example, all the\nlower-level dependencies get automatically installed as well. Forget about\nreading error messages of <code>install.packages()</code> to find which system development\nlibrary you need to install first. The third reason is that you can pin a\nspecific revision of <code>nixpkgs</code> to ensure reproducibility.</p>\n<p>The <code>nixpkgs</code> mono-repository is “just” a Github repository which you can find\nhere: <a href=\"https://github.com/NixOS/nixpkgs\" rel=\"nofollow\" target=\"_blank\">https://github.com/NixOS/nixpkgs</a>. This\nrepository contains Nix expressions to build and install more than 80’000\npackages and you can search for installable Nix packages\n<a href=\"https://search.nixos.org/packages\" rel=\"nofollow\" target=\"_blank\">here</a>.</p>\n<p>Because <code>nixpkgs</code> is a “just” Github repository, it is possible to use a\nspecific commit hash to install the packages as they were at a specific point in\ntime. For example, if you use this commit, <code>7c9cc5a6e</code>, you’ll get the very\nlatest packages as of the 19th of October 2023, but if you used this one\ninstead: <code>976fa3369</code>, you’ll get packages from the 19th of August 2023.</p>\n<p>This ability to deal with both underlying system-level dependencies and pin\npackage versions at a specific commit is extremely useful on Git(Dev)Ops\nplatforms like Github Actions. Debugging installation failures of packages can\nbe quite frustrating, especially on Github Actions, and especially if you’re not\nalready familiar with how Linux distributions work. Having a tool that handles\nall of that for you is amazing. The difficult part is writing these\n<code>default.nix</code> files that the Nix package manager requires to actually build\nthese development environments. But don’t worry, with my co-author <a href=\"https://github.com/philipp-baumann\" rel=\"nofollow\" target=\"_blank\">Philipp\nBaumann</a>, we developed an R package called\n<code>{rix}</code> which generates these <code>default.nix</code> files for you.</p>\n<p><code>{rix}</code> is an R package that makes it very easy to generate very complex\n<code>default.nix</code> files. These files can in turn be used by the Nix package manager\nto build project-specific environments. The book’s Github repository contains a\nfile called <code>define_env.R</code> with the following content:</p>\n<pre>library(rix)\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"quarto\"),\n    system_pkgs = \"quarto\",\n    tex_pkgs = c(\n      \"amsmath\",\n      \"framed\",\n      \"fvextra\",\n      \"environ\",\n      \"fontawesome5\",\n      \"orcidlink\",\n      \"pdfcol\",\n      \"tcolorbox\",\n      \"tikzfill\"\n    ),\n    ide = \"other\",\n    shell_hook = \"\",\n    project_path = \".\",\n    overwrite = TRUE,\n    print = TRUE)</pre>\n<p><code>{rix}</code> ships the <code>rix()</code> function which takes several arguments. These\narguments allow you to specify an R version, a list of R packages, a list of\nsystem packages, TeXLive packages and other options that allow you to specify\nyour requirements. Running this code generates this <code>default.nix</code> file:</p>\n<pre># This file was generated by the {rix} R package v0.4.1 on 2023-10-19\n# with following call:\n# &gt;rix(r_ver = \"976fa3369d722e76f37c77493d99829540d43845\",\n#  &gt; r_pkgs = c(\"quarto\"),\n#  &gt; system_pkgs = \"quarto\",\n#  &gt; tex_pkgs = c(\"amsmath\",\n#  &gt; \"framed\",\n#  &gt; \"fvextra\",\n#  &gt; \"environ\",\n#  &gt; \"fontawesome5\",\n#  &gt; \"orcidlink\",\n#  &gt; \"pdfcol\",\n#  &gt; \"tcolorbox\",\n#  &gt; \"tikzfill\"),\n#  &gt; ide = \"other\",\n#  &gt; project_path = \".\",\n#  &gt; overwrite = TRUE,\n#  &gt; print = TRUE,\n#  &gt; shell_hook = \"\")\n# It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes\n# which will install R version 4.3.1\n# Report any issues to https://github.com/b-rodrigues/rix\nlet\n pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n rpkgs = builtins.attrValues {\n  inherit (pkgs.rPackages) quarto;\n};\n  tex = (pkgs.texlive.combine {\n  inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;\n});\n system_packages = builtins.attrValues {\n  inherit (pkgs) R glibcLocalesUtf8 quarto;\n};\n  in\n  pkgs.mkShell {\n    LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then  \"${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive\" else \"\";\n    LANG = \"en_US.UTF-8\";\n    LC_ALL = \"en_US.UTF-8\";\n    LC_TIME = \"en_US.UTF-8\";\n    LC_MONETARY = \"en_US.UTF-8\";\n    LC_PAPER = \"en_US.UTF-8\";\n    LC_MEASUREMENT = \"en_US.UTF-8\";\n\n    buildInputs = [  rpkgs tex system_packages  ];\n  }</pre>\n<p>This file defines the environment that is needed to build your book: be it\nlocally on your machine, or on a GitOps platform like Github Actions. All that\nmatters is that you have the Nix package manager installed (thankfully, it’s\navailable for Windows –through WSL2–, Linux and macOS).</p>\n<p>Being able to work locally on a specific environment, defined through code, and\nuse that environment on the cloud as well, is great. It doesn’t matter that the\ncode runs on Ubuntu on the Github Actions runner, and if that operating system\nis not the one you use as well. Thanks to Nix, your code will run on exactly the\nsame environment. Because of that, you can use <code>ubuntu-latest</code> as your runner,\nbecause exactly the same packages will always get installed. This is not the\ncase with my first template that uses dedicated actions and <code>{renv}</code>: there, the\nrunner uses <code>ubuntu-22.04</code>, a fixed version of the Ubuntu operating system. The\nrisk here, is that once these runners get decommissioned (Ubuntu 22.04 is a\n<em>long-term support</em> release of Ubuntu, so it’ll stop getting updated sometime in\n2027), my code won’t be able to run anymore. This is because there’s no\nguarantee that the required version of R, Quarto, and all the other packages I\nneed will be installable on that new release of Ubuntu. So for example, suppose\nI have the package <code>{foo}</code> at version 1.0 that requires the system-level\ndevelopment library <code>bar-dev</code> at version 0.4 to be installed on Ubuntu. This is\nnot an issue now, as Ubuntu 22.04 ships version 0.4 of <code>bar-dev</code>. But it is very\nunlikely that the future version of Ubuntu from 2027 will ship that version, and\nthere’s no guarantee my package will successfully build and work as expected\nwith a more recent version of <code>bar-dev</code>. With Nix, this is not an issue; because\nI pin a specific commit of <code>nixpkgs</code>, not only will <code>{foo}</code> at version 1.0 get\ninstalled, its dependency <code>bar-dev</code> at version 0.4 will get installed by Nix as\nwell, and get used to build <code>{foo}</code>. It doesn’t matter that my underlying\noperating system ships a more recent version of <code>bar-dev</code>. I really insist on\nthis point, because this is not something that you can easily deal with, even\nwith Docker. This is because when you use Docker, you need to be able to rebuild\nthe image as many times as you need (the alternative is to store, forever, the\nbuilt image), and just like for Github Actions runners, the underlying Ubuntu\nimage will be decommissioned and stop working one day.</p>\n<p>In other words, if you need long-term reproducibility, you should really\nconsider using Nix, and even if you don’t need long-term reproducibility, you\nshould really consider using Nix. This is because Nix makes things much easier.\nBut there is one point where Nix is at a huge disadvantage when compared to the\nalternatives: the entry cost is quite high, as I’ve discussed in my <a href=\"https://www.brodrigues.co/blog/2023-10-05-repro_overview/\" rel=\"nofollow\" target=\"_blank\">previous\nblog post</a>. But I’m\nhoping that through my blog posts, this entry cost is getting lowered for R\nusers!</p>\n<p>\nHope you enjoyed! If you found this blog post useful, you might want to follow\nme on <a href=\"https://fosstodon.org/@brodriguesco\" rel=\"nofollow\" target=\"_blank\">Mastodon</a> or <a href=\"https://www.twitter.com/brodriguesco\" rel=\"nofollow\" target=\"_blank\">twitter</a> for blog post updates and\n<a href=\"https://www.buymeacoffee.com/brodriguesco\" rel=\"nofollow\" target=\"_blank\">buy me an espresso</a> or <a href=\"https://www.paypal.me/brodriguesco\" rel=\"nofollow\" target=\"_blank\">paypal.me</a>, or buy my <a href=\"https://www.brodrigues.co/about/books/\" rel=\"nofollow\" target=\"_blank\">ebooks</a>.\nYou can also watch my videos on <a href=\"https://www.youtube.com/c/BrunoRodrigues1988/\" rel=\"nofollow\" target=\"_blank\">youtube</a>.\nSo much content for you to consoom!\n</p>\n\n<p>\n<a class=\"bmc-button\" href=\"https://www.buymeacoffee.com/brodriguesco\" rel=\"nofollow\" target=\"_blank\"><img alt=\"Buy me an Espresso\" data-lazy-src=\"https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Buy me an Espresso\" src=\"https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg\"/></noscript><span style=\"margin-left:5px\">Buy me an Espresso</span></a>\n</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/\"> Econometrics and Free Software</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "Reproducible data science with Nix, part 7 — Building a Quarto book using Nix on Github Actions\nPosted on\nOctober 19, 2023\nby\nEconometrics and Free Software\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nEconometrics and Free Software\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nBack in June I self-published a book on Amazon’s Kindle Direct Publishing\nservice and wrote a blog post detailling how you could achieve that using\nQuarto, which you can read\nhere\n. The book is\nabout\nbuilding reproducible analytical pipelines with\nR\n. For the purposes of this post I made\na\ntemplate on Github\nthat you could\nfork and use as a starting point to write your own book. The book also gets\nbuilt using Github Actions each time you push new changes: a website gets built,\nan E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built.\nThat template used dedicated actions to install the required version of R,\nQuarto, and R packages (using\n{renv}\n).\nLet’s take a look at the workflow file:\non:\n  push:\n    branches: main\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v3\n\n      - name: Setup pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: '4.3.1'\n\n      - name: Setup renv\n        uses: r-lib/actions/setup-renv@v2\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        with:\n          # To install LaTeX to build PDF book \n          tinytex: true \n          # uncomment below and fill to pin a version\n          #version: 1.3.353\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions\nAs you can see, there are a lot of different moving pieces to get this to work.\nSince then I discovered Nix (if you’ve not been following my adventures, there’s\n6 other parts to this series as of today), and now I wrote another template that\nuses Nix to handle the book’s dependencies instead of dedicated actions and\n{renv}\n. You can find the repository\nhere\n.\nHere is what the workflow file looks like:\nname: Build book using Nix\n\non:\n  push:\n    branches:\n      - main\n      - master\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout Code\n      uses: actions/checkout@v3\n\n    - name: Install Nix\n      uses: DeterminateSystems/nix-installer-action@main\n      with:\n        logger: pretty\n        log-directives: nix_installer=trace\n        backtrace: full\n\n    - name: Nix cache\n      uses: DeterminateSystems/magic-nix-cache-action@main\n\n    - name: Build development environment\n      run: |\n        nix-build\n\n    - name: Publish to GitHub Pages (and render)\n      uses: b-rodrigues/quarto-nix-actions/publish@main\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nThe first thing you should notice is that this file is much shorter.\nThe first step,\nCheckout Code\nmakes the code available to the rest of the\nsteps. I then install Nix on this runner using the Determinate Systems\nnix-installer-action\nand then I use another action from Determinate Systems,\nthe\nmagic-nix-cache-action\n. This action caches all the packages so that they\ndon’t need to get re-built each time a change gets pushed, speeding up the\nprocess by a lot. The development environment gets then built using\nnix-build\n.\nFinally, an action I defined runs,\nquarto-nix-actions/publish\n. This is a fork\nof the\nquarto-actions/publish\naction which you can find\nhere\n.\nMy fork simply makes sure that the\nquarto render\nand\nquarto publish\ncommands\nrun in the\nNix environment defined for the\nproject\n.\nYou can see the book website\nhere\n; read it, it’s explains\neverything in much more details than this blog post! But if you’re busy, read\ncontinue reading this blog post instead.\nThe obvious next question is why bother with this second, Nix-centric, approach?\nThere are at least three reasons. The first is that it is possible to define\nso-called\ndefault.nix\nfiles that the Nix package manager then uses to build a\nfully reproducible development environment. This environment will contain all\nthe packages that you require, and will not interfere with any other packages\ninstalled on your system. This essentially means that you can have\nproject-specific\ndefault.nix\nfiles, each specifying the requirements for\nspecific projects. This file can then be used as-is on any other platform to\nre-create your environment. The second reason is that when installing a package\nthat requires system-level dependencies,\n{rJava}\nfor example, all the\nlower-level dependencies get automatically installed as well. Forget about\nreading error messages of\ninstall.packages()\nto find which system development\nlibrary you need to install first. The third reason is that you can pin a\nspecific revision of\nnixpkgs\nto ensure reproducibility.\nThe\nnixpkgs\nmono-repository is “just” a Github repository which you can find\nhere:\nhttps://github.com/NixOS/nixpkgs\n. This\nrepository contains Nix expressions to build and install more than 80’000\npackages and you can search for installable Nix packages\nhere\n.\nBecause\nnixpkgs\nis a “just” Github repository, it is possible to use a\nspecific commit hash to install the packages as they were at a specific point in\ntime. For example, if you use this commit,\n7c9cc5a6e\n, you’ll get the very\nlatest packages as of the 19th of October 2023, but if you used this one\ninstead:\n976fa3369\n, you’ll get packages from the 19th of August 2023.\nThis ability to deal with both underlying system-level dependencies and pin\npackage versions at a specific commit is extremely useful on Git(Dev)Ops\nplatforms like Github Actions. Debugging installation failures of packages can\nbe quite frustrating, especially on Github Actions, and especially if you’re not\nalready familiar with how Linux distributions work. Having a tool that handles\nall of that for you is amazing. The difficult part is writing these\ndefault.nix\nfiles that the Nix package manager requires to actually build\nthese development environments. But don’t worry, with my co-author\nPhilipp\nBaumann\n, we developed an R package called\n{rix}\nwhich generates these\ndefault.nix\nfiles for you.\n{rix}\nis an R package that makes it very easy to generate very complex\ndefault.nix\nfiles. These files can in turn be used by the Nix package manager\nto build project-specific environments. The book’s Github repository contains a\nfile called\ndefine_env.R\nwith the following content:\nlibrary(rix)\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"quarto\"),\n    system_pkgs = \"quarto\",\n    tex_pkgs = c(\n      \"amsmath\",\n      \"framed\",\n      \"fvextra\",\n      \"environ\",\n      \"fontawesome5\",\n      \"orcidlink\",\n      \"pdfcol\",\n      \"tcolorbox\",\n      \"tikzfill\"\n    ),\n    ide = \"other\",\n    shell_hook = \"\",\n    project_path = \".\",\n    overwrite = TRUE,\n    print = TRUE)\n{rix}\nships the\nrix()\nfunction which takes several arguments. These\narguments allow you to specify an R version, a list of R packages, a list of\nsystem packages, TeXLive packages and other options that allow you to specify\nyour requirements. Running this code generates this\ndefault.nix\nfile:\n# This file was generated by the {rix} R package v0.4.1 on 2023-10-19\n# with following call:\n# >rix(r_ver = \"976fa3369d722e76f37c77493d99829540d43845\",\n#  > r_pkgs = c(\"quarto\"),\n#  > system_pkgs = \"quarto\",\n#  > tex_pkgs = c(\"amsmath\",\n#  > \"framed\",\n#  > \"fvextra\",\n#  > \"environ\",\n#  > \"fontawesome5\",\n#  > \"orcidlink\",\n#  > \"pdfcol\",\n#  > \"tcolorbox\",\n#  > \"tikzfill\"),\n#  > ide = \"other\",\n#  > project_path = \".\",\n#  > overwrite = TRUE,\n#  > print = TRUE,\n#  > shell_hook = \"\")\n# It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes\n# which will install R version 4.3.1\n# Report any issues to https://github.com/b-rodrigues/rix\nlet\n pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n rpkgs = builtins.attrValues {\n  inherit (pkgs.rPackages) quarto;\n};\n  tex = (pkgs.texlive.combine {\n  inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;\n});\n system_packages = builtins.attrValues {\n  inherit (pkgs) R glibcLocalesUtf8 quarto;\n};\n  in\n  pkgs.mkShell {\n    LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then  \"${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive\" else \"\";\n    LANG = \"en_US.UTF-8\";\n    LC_ALL = \"en_US.UTF-8\";\n    LC_TIME = \"en_US.UTF-8\";\n    LC_MONETARY = \"en_US.UTF-8\";\n    LC_PAPER = \"en_US.UTF-8\";\n    LC_MEASUREMENT = \"en_US.UTF-8\";\n\n    buildInputs = [  rpkgs tex system_packages  ];\n  }\nThis file defines the environment that is needed to build your book: be it\nlocally on your machine, or on a GitOps platform like Github Actions. All that\nmatters is that you have the Nix package manager installed (thankfully, it’s\navailable for Windows –through WSL2–, Linux and macOS).\nBeing able to work locally on a specific environment, defined through code, and\nuse that environment on the cloud as well, is great. It doesn’t matter that the\ncode runs on Ubuntu on the Github Actions runner, and if that operating system\nis not the one you use as well. Thanks to Nix, your code will run on exactly the\nsame environment. Because of that, you can use\nubuntu-latest\nas your runner,\nbecause exactly the same packages will always get installed. This is not the\ncase with my first template that uses dedicated actions and\n{renv}\n: there, the\nrunner uses\nubuntu-22.04\n, a fixed version of the Ubuntu operating system. The\nrisk here, is that once these runners get decommissioned (Ubuntu 22.04 is a\nlong-term support\nrelease of Ubuntu, so it’ll stop getting updated sometime in\n2027), my code won’t be able to run anymore. This is because there’s no\nguarantee that the required version of R, Quarto, and all the other packages I\nneed will be installable on that new release of Ubuntu. So for example, suppose\nI have the package\n{foo}\nat version 1.0 that requires the system-level\ndevelopment library\nbar-dev\nat version 0.4 to be installed on Ubuntu. This is\nnot an issue now, as Ubuntu 22.04 ships version 0.4 of\nbar-dev\n. But it is very\nunlikely that the future version of Ubuntu from 2027 will ship that version, and\nthere’s no guarantee my package will successfully build and work as expected\nwith a more recent version of\nbar-dev\n. With Nix, this is not an issue; because\nI pin a specific commit of\nnixpkgs\n, not only will\n{foo}\nat version 1.0 get\ninstalled, its dependency\nbar-dev\nat version 0.4 will get installed by Nix as\nwell, and get used to build\n{foo}\n. It doesn’t matter that my underlying\noperating system ships a more recent version of\nbar-dev\n. I really insist on\nthis point, because this is not something that you can easily deal with, even\nwith Docker. This is because when you use Docker, you need to be able to rebuild\nthe image as many times as you need (the alternative is to store, forever, the\nbuilt image), and just like for Github Actions runners, the underlying Ubuntu\nimage will be decommissioned and stop working one day.\nIn other words, if you need long-term reproducibility, you should really\nconsider using Nix, and even if you don’t need long-term reproducibility, you\nshould really consider using Nix. This is because Nix makes things much easier.\nBut there is one point where Nix is at a huge disadvantage when compared to the\nalternatives: the entry cost is quite high, as I’ve discussed in my\nprevious\nblog post\n. But I’m\nhoping that through my blog posts, this entry cost is getting lowered for R\nusers!\nHope you enjoyed! If you found this blog post useful, you might want to follow\nme on\nMastodon\nor\ntwitter\nfor blog post updates and\nbuy me an espresso\nor\npaypal.me\n, or buy my\nebooks\n.\nYou can also watch my videos on\nyoutube\n.\nSo much content for you to consoom!\nBuy me an Espresso\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nEconometrics and Free Software\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Back in June I self-published a book on Amazon’s Kindle Direct Publishing service and wrote a blog post detailling how you could achieve that using Quarto, which you can read here. The book is about building reproducible analytical pipelines with R. For the purposes of this post I made a template on Github that you could fork and use as a starting point to write your own book. The book also gets built using Github Actions each time you push new changes: a website gets built, an E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built. That template used dedicated actions to install the required version of R, Quarto, and R packages (using {renv}). Let’s take a look at the workflow file: on: push: branches: main name: Render and Publish jobs: build-deploy: runs-on: ubuntu-22.04 steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup pandoc uses: r-lib/actions/setup-pandoc@v2 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: '4.3.1' - name: Setup renv uses: r-lib/actions/setup-renv@v2 - name: Set up Quarto uses: quarto-dev/quarto-actions/setup@v2 with: # To install LaTeX to build PDF book tinytex: true # uncomment below and fill to pin a version #version: 1.3.353 - name: Publish to GitHub Pages (and render) uses: quarto-dev/quarto-actions/publish@v2 with: target: gh-pages env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions As you can see, there are a lot of different moving pieces to get this to work. Since then I discovered Nix (if you’ve not been following my adventures, there’s 6 other parts to this series as of today), and now I wrote another template that uses Nix to handle the book’s dependencies instead of dedicated actions and {renv}. You can find the repository here. Here is what the workflow file looks like: name: Build book using Nix on: push: branches: - main - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Code uses: actions/checkout@v3 - name: Install Nix uses: DeterminateSystems/nix-installer-action@main with: logger: pretty log-directives: nix_installer=trace backtrace: full - name: Nix cache uses: DeterminateSystems/magic-nix-cache-action@main - name: Build development environment run: | nix-build - name: Publish to GitHub Pages (and render) uses: b-rodrigues/quarto-nix-actions/publish@main env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} The first thing you should notice is that this file is much shorter. The first step, Checkout Code makes the code available to the rest of the steps. I then install Nix on this runner using the Determinate Systems nix-installer-action and then I use another action from Determinate Systems, the magic-nix-cache-action. This action caches all the packages so that they don’t need to get re-built each time a change gets pushed, speeding up the process by a lot. The development environment gets then built using nix-build. Finally, an action I defined runs, quarto-nix-actions/publish. This is a fork of the quarto-actions/publish action which you can find here. My fork simply makes sure that the quarto render and quarto publish commands run in the Nix environment defined for the project. You can see the book website here; read it, it’s explains everything in much more details than this blog post! But if you’re busy, read continue reading this blog post instead. The obvious next question is why bother with this second, Nix-centric, approach? There are at least three reasons. The first is that it is possible to define so-called default.nix files that the Nix package manager then uses to build a fully reproducible development environment. This environment will contain all the packages that you require, and will not interfere with any other packages installed on your system. This essentially means that you can have project-specific default.nix files, each specifying the requirements for specific projects. This file can then be used as-is on any other platform to re-create your environment. The second reason is that when installing a package that requires system-level dependencies, {rJava} for example, all the lower-level dependencies get automatically installed as well. Forget about reading error messages of install.packages() to find which system development library you need to install first. The third reason is that you can pin a specific revision of nixpkgs to ensure reproducibility. The nixpkgs mono-repository is “just” a Github repository which you can find here: https://github.com/NixOS/nixpkgs. This repository contains Nix expressions to build and install more than 80’000 packages and you can search for installable Nix packages here. Because nixpkgs is a “just” Github repository, it is possible to use a specific commit hash to install the packages as they were at a specific point in time. For example, if you use this commit, 7c9cc5a6e, you’ll get the very latest packages as of the 19th of October 2023, but if you used this one instead: 976fa3369, you’ll get packages from the 19th of August 2023. This ability to deal with both underlying system-level dependencies and pin package versions at a specific commit is extremely useful on Git(Dev)Ops platforms like Github Actions. Debugging installation failures of packages can be quite frustrating, especially on Github Actions, and especially if you’re not already familiar with how Linux distributions work. Having a tool that handles all of that for you is amazing. The difficult part is writing these default.nix files that the Nix package manager requires to actually build these development environments. But don’t worry, with my co-author Philipp Baumann, we developed an R package called {rix} which generates these default.nix files for you. {rix} is an R package that makes it very easy to generate very complex default.nix files. These files can in turn be used by the Nix package manager to build project-specific environments. The book’s Github repository contains a file called define_env.R with the following content: library(rix) rix(r_ver = \"4.3.1\", r_pkgs = c(\"quarto\"), system_pkgs = \"quarto\", tex_pkgs = c( \"amsmath\", \"framed\", \"fvextra\", \"environ\", \"fontawesome5\", \"orcidlink\", \"pdfcol\", \"tcolorbox\", \"tikzfill\" ), ide = \"other\", shell_hook = \"\", project_path = \".\", overwrite = TRUE, print = TRUE) {rix} ships the rix() function which takes several arguments. These arguments allow you to specify an R version, a list of R packages, a list of system packages, TeXLive packages and other options that allow you to specify your requirements. Running this code generates this default.nix file: # This file was generated by the {rix} R package v0.4.1 on 2023-10-19 # with following call: # >rix(r_ver = \"976fa3369d722e76f37c77493d99829540d43845\", # > r_pkgs = c(\"quarto\"), # > system_pkgs = \"quarto\", # > tex_pkgs = c(\"amsmath\", # > \"framed\", # > \"fvextra\", # > \"environ\", # > \"fontawesome5\", # > \"orcidlink\", # > \"pdfcol\", # > \"tcolorbox\", # > \"tikzfill\"), # > ide = \"other\", # > project_path = \".\", # > overwrite = TRUE, # > print = TRUE, # > shell_hook = \"\") # It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes # which will install R version 4.3.1 # Report any issues to https://github.com/b-rodrigues/rix let pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {}; rpkgs = builtins.attrValues { inherit (pkgs.rPackages) quarto; }; tex = (pkgs.texlive.combine { inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill; }); system_packages = builtins.attrValues { inherit (pkgs) R glibcLocalesUtf8 quarto; }; in pkgs.mkShell { LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then \"${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive\" else \"\"; LANG = \"en_US.UTF-8\"; LC_ALL = \"en_US.UTF-8\"; LC_TIME = \"en_US.UTF-8\"; LC_MONETARY = \"en_US.UTF-8\"; LC_PAPER = \"en_US.UTF-8\"; LC_MEASUREMENT = \"en_US.UTF-8\"; buildInputs = [ rpkgs tex system_packages ]; } This file defines the environment that is needed to build your book: be it locally on your machine, or on a GitOps platform like Github Actions. All that matters is that you have the Nix package manager installed (thankfully, it’s available for Windows –through WSL2–, Linux and macOS). Being able to work locally on a specific environment, defined through code, and use that environment on the cloud as well, is great. It doesn’t matter that the code runs on Ubuntu on the Github Actions runner, and if that operating system is not the one you use as well. Thanks to Nix, your code will run on exactly the same environment. Because of that, you can use ubuntu-latest as your runner, because exactly the same packages will always get installed. This is not the case with my first template that uses dedicated actions and {renv}: there, the runner uses ubuntu-22.04, a fixed version of the Ubuntu operating system. The risk here, is that once these runners get decommissioned (Ubuntu 22.04 is a long-term support release of Ubuntu, so it’ll stop getting updated sometime in 2027), my code won’t be able to run anymore. This is because there’s no guarantee that the required version of R, Quarto, and all the other packages I need will be installable on that new release of Ubuntu. So for example, suppose I have the package {foo} at version 1.0 that requires the system-level development library bar-dev at version 0.4 to be installed on Ubuntu. This is not an issue now, as Ubuntu 22.04 ships version 0.4 of bar-dev. But it is very unlikely that the future version of Ubuntu from 2027 will ship that version, and there’s no guarantee my package will successfully build and work as expected with a more recent version of bar-dev. With Nix, this is not an issue; because I pin a specific commit of nixpkgs, not only will {foo} at version 1.0 get installed, its dependency bar-dev at version 0.4 will get installed by Nix as well, and get used to build {foo}. It doesn’t matter that my underlying operating system ships a more recent version of bar-dev. I really insist on this point, because this is not something that you can easily deal with, even with Docker. This is because when you use Docker, you need to be able to rebuild the image as many times as you need (the alternative is to store, forever, the built image), and just like for Github Actions runners, the underlying Ubuntu image will be decommissioned and stop working one day. In other words, if you need long-term reproducibility, you should really consider using Nix, and even if you don’t need long-term reproducibility, you should really consider using Nix. This is because Nix makes things much easier. But there is one point where Nix is at a huge disadvantage when compared to the alternatives: the entry cost is quite high, as I’ve discussed in my previous blog post. But I’m hoping that through my blog posts, this entry cost is getting lowered for R users! Hope you enjoyed! If you found this blog post useful, you might want to follow me on Mastodon or twitter for blog post updates and buy me an espresso or paypal.me, or buy my ebooks. You can also watch my videos on youtube. So much content for you to consoom! Buy me an Espresso",
    "meta_keywords": null,
    "og_description": "Back in June I self-published a book on Amazon’s Kindle Direct Publishing service and wrote a blog post detailling how you could achieve that using Quarto, which you can read here. The book is about building reproducible analytical pipelines with R. For the purposes of this post I made a template on Github that you could fork and use as a starting point to write your own book. The book also gets built using Github Actions each time you push new changes: a website gets built, an E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built. That template used dedicated actions to install the required version of R, Quarto, and R packages (using {renv}). Let’s take a look at the workflow file: on: push: branches: main name: Render and Publish jobs: build-deploy: runs-on: ubuntu-22.04 steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup pandoc uses: r-lib/actions/setup-pandoc@v2 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: '4.3.1' - name: Setup renv uses: r-lib/actions/setup-renv@v2 - name: Set up Quarto uses: quarto-dev/quarto-actions/setup@v2 with: # To install LaTeX to build PDF book tinytex: true # uncomment below and fill to pin a version #version: 1.3.353 - name: Publish to GitHub Pages (and render) uses: quarto-dev/quarto-actions/publish@v2 with: target: gh-pages env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions As you can see, there are a lot of different moving pieces to get this to work. Since then I discovered Nix (if you’ve not been following my adventures, there’s 6 other parts to this series as of today), and now I wrote another template that uses Nix to handle the book’s dependencies instead of dedicated actions and {renv}. You can find the repository here. Here is what the workflow file looks like: name: Build book using Nix on: push: branches: - main - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Code uses: actions/checkout@v3 - name: Install Nix uses: DeterminateSystems/nix-installer-action@main with: logger: pretty log-directives: nix_installer=trace backtrace: full - name: Nix cache uses: DeterminateSystems/magic-nix-cache-action@main - name: Build development environment run: | nix-build - name: Publish to GitHub Pages (and render) uses: b-rodrigues/quarto-nix-actions/publish@main env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} The first thing you should notice is that this file is much shorter. The first step, Checkout Code makes the code available to the rest of the steps. I then install Nix on this runner using the Determinate Systems nix-installer-action and then I use another action from Determinate Systems, the magic-nix-cache-action. This action caches all the packages so that they don’t need to get re-built each time a change gets pushed, speeding up the process by a lot. The development environment gets then built using nix-build. Finally, an action I defined runs, quarto-nix-actions/publish. This is a fork of the quarto-actions/publish action which you can find here. My fork simply makes sure that the quarto render and quarto publish commands run in the Nix environment defined for the project. You can see the book website here; read it, it’s explains everything in much more details than this blog post! But if you’re busy, read continue reading this blog post instead. The obvious next question is why bother with this second, Nix-centric, approach? There are at least three reasons. The first is that it is possible to define so-called default.nix files that the Nix package manager then uses to build a fully reproducible development environment. This environment will contain all the packages that you require, and will not interfere with any other packages installed on your system. This essentially means that you can have project-specific default.nix files, each specifying the requirements for specific projects. This file can then be used as-is on any other platform to re-create your environment. The second reason is that when installing a package that requires system-level dependencies, {rJava} for example, all the lower-level dependencies get automatically installed as well. Forget about reading error messages of install.packages() to find which system development library you need to install first. The third reason is that you can pin a specific revision of nixpkgs to ensure reproducibility. The nixpkgs mono-repository is “just” a Github repository which you can find here: https://github.com/NixOS/nixpkgs. This repository contains Nix expressions to build and install more than 80’000 packages and you can search for installable Nix packages here. Because nixpkgs is a “just” Github repository, it is possible to use a specific commit hash to install the packages as they were at a specific point in time. For example, if you use this commit, 7c9cc5a6e, you’ll get the very latest packages as of the 19th of October 2023, but if you used this one instead: 976fa3369, you’ll get packages from the 19th of August 2023. This ability to deal with both underlying system-level dependencies and pin package versions at a specific commit is extremely useful on Git(Dev)Ops platforms like Github Actions. Debugging installation failures of packages can be quite frustrating, especially on Github Actions, and especially if you’re not already familiar with how Linux distributions work. Having a tool that handles all of that for you is amazing. The difficult part is writing these default.nix files that the Nix package manager requires to actually build these development environments. But don’t worry, with my co-author Philipp Baumann, we developed an R package called {rix} which generates these default.nix files for you. {rix} is an R package that makes it very easy to generate very complex default.nix files. These files can in turn be used by the Nix package manager to build project-specific environments. The book’s Github repository contains a file called define_env.R with the following content: library(rix) rix(r_ver = \"4.3.1\", r_pkgs = c(\"quarto\"), system_pkgs = \"quarto\", tex_pkgs = c( \"amsmath\", \"framed\", \"fvextra\", \"environ\", \"fontawesome5\", \"orcidlink\", \"pdfcol\", \"tcolorbox\", \"tikzfill\" ), ide = \"other\", shell_hook = \"\", project_path = \".\", overwrite = TRUE, print = TRUE) {rix} ships the rix() function which takes several arguments. These arguments allow you to specify an R version, a list of R packages, a list of system packages, TeXLive packages and other options that allow you to specify your requirements. Running this code generates this default.nix file: # This file was generated by the {rix} R package v0.4.1 on 2023-10-19 # with following call: # >rix(r_ver = \"976fa3369d722e76f37c77493d99829540d43845\", # > r_pkgs = c(\"quarto\"), # > system_pkgs = \"quarto\", # > tex_pkgs = c(\"amsmath\", # > \"framed\", # > \"fvextra\", # > \"environ\", # > \"fontawesome5\", # > \"orcidlink\", # > \"pdfcol\", # > \"tcolorbox\", # > \"tikzfill\"), # > ide = \"other\", # > project_path = \".\", # > overwrite = TRUE, # > print = TRUE, # > shell_hook = \"\") # It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes # which will install R version 4.3.1 # Report any issues to https://github.com/b-rodrigues/rix let pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {}; rpkgs = builtins.attrValues { inherit (pkgs.rPackages) quarto; }; tex = (pkgs.texlive.combine { inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill; }); system_packages = builtins.attrValues { inherit (pkgs) R glibcLocalesUtf8 quarto; }; in pkgs.mkShell { LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then \"${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive\" else \"\"; LANG = \"en_US.UTF-8\"; LC_ALL = \"en_US.UTF-8\"; LC_TIME = \"en_US.UTF-8\"; LC_MONETARY = \"en_US.UTF-8\"; LC_PAPER = \"en_US.UTF-8\"; LC_MEASUREMENT = \"en_US.UTF-8\"; buildInputs = [ rpkgs tex system_packages ]; } This file defines the environment that is needed to build your book: be it locally on your machine, or on a GitOps platform like Github Actions. All that matters is that you have the Nix package manager installed (thankfully, it’s available for Windows –through WSL2–, Linux and macOS). Being able to work locally on a specific environment, defined through code, and use that environment on the cloud as well, is great. It doesn’t matter that the code runs on Ubuntu on the Github Actions runner, and if that operating system is not the one you use as well. Thanks to Nix, your code will run on exactly the same environment. Because of that, you can use ubuntu-latest as your runner, because exactly the same packages will always get installed. This is not the case with my first template that uses dedicated actions and {renv}: there, the runner uses ubuntu-22.04, a fixed version of the Ubuntu operating system. The risk here, is that once these runners get decommissioned (Ubuntu 22.04 is a long-term support release of Ubuntu, so it’ll stop getting updated sometime in 2027), my code won’t be able to run anymore. This is because there’s no guarantee that the required version of R, Quarto, and all the other packages I need will be installable on that new release of Ubuntu. So for example, suppose I have the package {foo} at version 1.0 that requires the system-level development library bar-dev at version 0.4 to be installed on Ubuntu. This is not an issue now, as Ubuntu 22.04 ships version 0.4 of bar-dev. But it is very unlikely that the future version of Ubuntu from 2027 will ship that version, and there’s no guarantee my package will successfully build and work as expected with a more recent version of bar-dev. With Nix, this is not an issue; because I pin a specific commit of nixpkgs, not only will {foo} at version 1.0 get installed, its dependency bar-dev at version 0.4 will get installed by Nix as well, and get used to build {foo}. It doesn’t matter that my underlying operating system ships a more recent version of bar-dev. I really insist on this point, because this is not something that you can easily deal with, even with Docker. This is because when you use Docker, you need to be able to rebuild the image as many times as you need (the alternative is to store, forever, the built image), and just like for Github Actions runners, the underlying Ubuntu image will be decommissioned and stop working one day. In other words, if you need long-term reproducibility, you should really consider using Nix, and even if you don’t need long-term reproducibility, you should really consider using Nix. This is because Nix makes things much easier. But there is one point where Nix is at a huge disadvantage when compared to the alternatives: the entry cost is quite high, as I’ve discussed in my previous blog post. But I’m hoping that through my blog posts, this entry cost is getting lowered for R users! Hope you enjoyed! If you found this blog post useful, you might want to follow me on Mastodon or twitter for blog post updates and buy me an espresso or paypal.me, or buy my ebooks. You can also watch my videos on youtube. So much content for you to consoom! Buy me an Espresso",
    "og_image": "https://www.brodrigues.co/img/nix_users_press_both_buttons.png",
    "og_title": "Reproducible data science with Nix, part 7 — Building a Quarto book using Nix on Github Actions | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 10.1,
    "sitemap_lastmod": "2023-10-20T00:00:00+00:00",
    "twitter_description": "Back in June I self-published a book on Amazon’s Kindle Direct Publishing service and wrote a blog post detailling how you could achieve that using Quarto, which you can read here. The book is about building reproducible analytical pipelines with R. For the purposes of this post I made a template on Github that you could fork and use as a starting point to write your own book. The book also gets built using Github Actions each time you push new changes: a website gets built, an E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built. That template used dedicated actions to install the required version of R, Quarto, and R packages (using {renv}). Let’s take a look at the workflow file: on: push: branches: main name: Render and Publish jobs: build-deploy: runs-on: ubuntu-22.04 steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup pandoc uses: r-lib/actions/setup-pandoc@v2 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: '4.3.1' - name: Setup renv uses: r-lib/actions/setup-renv@v2 - name: Set up Quarto uses: quarto-dev/quarto-actions/setup@v2 with: # To install LaTeX to build PDF book tinytex: true # uncomment below and fill to pin a version #version: 1.3.353 - name: Publish to GitHub Pages (and render) uses: quarto-dev/quarto-actions/publish@v2 with: target: gh-pages env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions As you can see, there are a lot of different moving pieces to get this to work. Since then I discovered Nix (if you’ve not been following my adventures, there’s 6 other parts to this series as of today), and now I wrote another template that uses Nix to handle the book’s dependencies instead of dedicated actions and {renv}. You can find the repository here. Here is what the workflow file looks like: name: Build book using Nix on: push: branches: - main - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Code uses: actions/checkout@v3 - name: Install Nix uses: DeterminateSystems/nix-installer-action@main with: logger: pretty log-directives: nix_installer=trace backtrace: full - name: Nix cache uses: DeterminateSystems/magic-nix-cache-action@main - name: Build development environment run: | nix-build - name: Publish to GitHub Pages (and render) uses: b-rodrigues/quarto-nix-actions/publish@main env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} The first thing you should notice is that this file is much shorter. The first step, Checkout Code makes the code available to the rest of the steps. I then install Nix on this runner using the Determinate Systems nix-installer-action and then I use another action from Determinate Systems, the magic-nix-cache-action. This action caches all the packages so that they don’t need to get re-built each time a change gets pushed, speeding up the process by a lot. The development environment gets then built using nix-build. Finally, an action I defined runs, quarto-nix-actions/publish. This is a fork of the quarto-actions/publish action which you can find here. My fork simply makes sure that the quarto render and quarto publish commands run in the Nix environment defined for the project. You can see the book website here; read it, it’s explains everything in much more details than this blog post! But if you’re busy, read continue reading this blog post instead. The obvious next question is why bother with this second, Nix-centric, approach? There are at least three reasons. The first is that it is possible to define so-called default.nix files that the Nix package manager then uses to build a fully reproducible development environment. This environment will contain all the packages that you require, and will not interfere with any other packages installed on your system. This essentially means that you can have project-specific default.nix files, each specifying the requirements for specific projects. This file can then be used as-is on any other platform to re-create your environment. The second reason is that when installing a package that requires system-level dependencies, {rJava} for example, all the lower-level dependencies get automatically installed as well. Forget about reading error messages of install.packages() to find which system development library you need to install first. The third reason is that you can pin a specific revision of nixpkgs to ensure reproducibility. The nixpkgs mono-repository is “just” a Github repository which you can find here: https://github.com/NixOS/nixpkgs. This repository contains Nix expressions to build and install more than 80’000 packages and you can search for installable Nix packages here. Because nixpkgs is a “just” Github repository, it is possible to use a specific commit hash to install the packages as they were at a specific point in time. For example, if you use this commit, 7c9cc5a6e, you’ll get the very latest packages as of the 19th of October 2023, but if you used this one instead: 976fa3369, you’ll get packages from the 19th of August 2023. This ability to deal with both underlying system-level dependencies and pin package versions at a specific commit is extremely useful on Git(Dev)Ops platforms like Github Actions. Debugging installation failures of packages can be quite frustrating, especially on Github Actions, and especially if you’re not already familiar with how Linux distributions work. Having a tool that handles all of that for you is amazing. The difficult part is writing these default.nix files that the Nix package manager requires to actually build these development environments. But don’t worry, with my co-author Philipp Baumann, we developed an R package called {rix} which generates these default.nix files for you. {rix} is an R package that makes it very easy to generate very complex default.nix files. These files can in turn be used by the Nix package manager to build project-specific environments. The book’s Github repository contains a file called define_env.R with the following content: library(rix) rix(r_ver = \"4.3.1\", r_pkgs = c(\"quarto\"), system_pkgs = \"quarto\", tex_pkgs = c( \"amsmath\", \"framed\", \"fvextra\", \"environ\", \"fontawesome5\", \"orcidlink\", \"pdfcol\", \"tcolorbox\", \"tikzfill\" ), ide = \"other\", shell_hook = \"\", project_path = \".\", overwrite = TRUE, print = TRUE) {rix} ships the rix() function which takes several arguments. These arguments allow you to specify an R version, a list of R packages, a list of system packages, TeXLive packages and other options that allow you to specify your requirements. Running this code generates this default.nix file: # This file was generated by the {rix} R package v0.4.1 on 2023-10-19 # with following call: # >rix(r_ver = \"976fa3369d722e76f37c77493d99829540d43845\", # > r_pkgs = c(\"quarto\"), # > system_pkgs = \"quarto\", # > tex_pkgs = c(\"amsmath\", # > \"framed\", # > \"fvextra\", # > \"environ\", # > \"fontawesome5\", # > \"orcidlink\", # > \"pdfcol\", # > \"tcolorbox\", # > \"tikzfill\"), # > ide = \"other\", # > project_path = \".\", # > overwrite = TRUE, # > print = TRUE, # > shell_hook = \"\") # It uses nixpkgs' revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes # which will install R version 4.3.1 # Report any issues to https://github.com/b-rodrigues/rix let pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {}; rpkgs = builtins.attrValues { inherit (pkgs.rPackages) quarto; }; tex = (pkgs.texlive.combine { inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill; }); system_packages = builtins.attrValues { inherit (pkgs) R glibcLocalesUtf8 quarto; }; in pkgs.mkShell { LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then \"${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive\" else \"\"; LANG = \"en_US.UTF-8\"; LC_ALL = \"en_US.UTF-8\"; LC_TIME = \"en_US.UTF-8\"; LC_MONETARY = \"en_US.UTF-8\"; LC_PAPER = \"en_US.UTF-8\"; LC_MEASUREMENT = \"en_US.UTF-8\"; buildInputs = [ rpkgs tex system_packages ]; } This file defines the environment that is needed to build your book: be it locally on your machine, or on a GitOps platform like Github Actions. All that matters is that you have the Nix package manager installed (thankfully, it’s available for Windows –through WSL2–, Linux and macOS). Being able to work locally on a specific environment, defined through code, and use that environment on the cloud as well, is great. It doesn’t matter that the code runs on Ubuntu on the Github Actions runner, and if that operating system is not the one you use as well. Thanks to Nix, your code will run on exactly the same environment. Because of that, you can use ubuntu-latest as your runner, because exactly the same packages will always get installed. This is not the case with my first template that uses dedicated actions and {renv}: there, the runner uses ubuntu-22.04, a fixed version of the Ubuntu operating system. The risk here, is that once these runners get decommissioned (Ubuntu 22.04 is a long-term support release of Ubuntu, so it’ll stop getting updated sometime in 2027), my code won’t be able to run anymore. This is because there’s no guarantee that the required version of R, Quarto, and all the other packages I need will be installable on that new release of Ubuntu. So for example, suppose I have the package {foo} at version 1.0 that requires the system-level development library bar-dev at version 0.4 to be installed on Ubuntu. This is not an issue now, as Ubuntu 22.04 ships version 0.4 of bar-dev. But it is very unlikely that the future version of Ubuntu from 2027 will ship that version, and there’s no guarantee my package will successfully build and work as expected with a more recent version of bar-dev. With Nix, this is not an issue; because I pin a specific commit of nixpkgs, not only will {foo} at version 1.0 get installed, its dependency bar-dev at version 0.4 will get installed by Nix as well, and get used to build {foo}. It doesn’t matter that my underlying operating system ships a more recent version of bar-dev. I really insist on this point, because this is not something that you can easily deal with, even with Docker. This is because when you use Docker, you need to be able to rebuild the image as many times as you need (the alternative is to store, forever, the built image), and just like for Github Actions runners, the underlying Ubuntu image will be decommissioned and stop working one day. In other words, if you need long-term reproducibility, you should really consider using Nix, and even if you don’t need long-term reproducibility, you should really consider using Nix. This is because Nix makes things much easier. But there is one point where Nix is at a huge disadvantage when compared to the alternatives: the entry cost is quite high, as I’ve discussed in my previous blog post. But I’m hoping that through my blog posts, this entry cost is getting lowered for R users! Hope you enjoyed! If you found this blog post useful, you might want to follow me on Mastodon or twitter for blog post updates and buy me an espresso or paypal.me, or buy my ebooks. You can also watch my videos on youtube. So much content for you to consoom! Buy me an Espresso",
    "twitter_title": "Reproducible data science with Nix, part 7 — Building a Quarto book using Nix on Github Actions | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/10/reproducible-data-science-with-nix-part-7-building-a-quarto-book-using-nix-on-github-actions/",
    "word_count": 2017
  }
}