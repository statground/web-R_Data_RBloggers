{
  "uuid": "a4259092-98b0-4abc-bfb9-0f22d91933d6",
  "created_at": "2025-11-17 20:38:39",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2024/01/r-solution-for-excel-puzzles-7/",
    "crawled_at": "2025-11-17T09:22:11.047028",
    "external_links": [
      {
        "href": "https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd",
        "text": "Numbers around us - Medium"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://www.linkedin.com/in/excelbi/",
        "text": "ExcelBI"
      },
      {
        "href": "https://github.com/kgryczan/excelbi_puzzles",
        "text": "Github"
      },
      {
        "href": "https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd",
        "text": "R Solution for Excel Puzzles"
      },
      {
        "href": "https://medium.com/number-around-us",
        "text": "Numbers around us"
      },
      {
        "href": "https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd",
        "text": "Numbers around us - Medium"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "R Solution for Excel Puzzles | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*AdgwcPx6IewqT10WW7-dHQ.jpeg?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*BqYtwp7dQMsxoCvGDgZz1A.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*pY4FWaZWt2-sw-4SaiRYjQ.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*zwqZMsrRt6lwK2IT0SaG8g.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*QGlqOlJfC0gXjruEXQ4IJQ.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*wItf5fH8uxUo7N5GERwpbA.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": "data:application/octet-stream;base64,R0lGODlhAQABAO+/vQAA77+977+977+9AAAAIe+/vQQBAAAAACwAAAAAAQABAAACAkQBADs=",
        "src": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e8ce0037d4cd"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/numbers-around-us/",
        "text": "Numbers around us"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-381377 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">R Solution for Excel Puzzles</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 8, 2024</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/numbers-around-us/\">Numbers around us</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd\"> Numbers around us - Medium</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>Puzzles no. 359–363</p><figure><img alt=\"\" data-lazy-src=\"https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*AdgwcPx6IewqT10WW7-dHQ.jpeg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*AdgwcPx6IewqT10WW7-dHQ.jpeg?w=578&amp;ssl=1\"/></noscript></figure><h3>Puzzles</h3><p>Author: <a href=\"https://www.linkedin.com/in/excelbi/\" rel=\"nofollow\" target=\"_blank\">ExcelBI</a></p><p>All files (xlsx with puzzle and R with solution) for each and every puzzle are available on my <a href=\"https://github.com/kgryczan/excelbi_puzzles\" rel=\"nofollow\" target=\"_blank\">Github</a>. Enjoy.</p><h3>Puzzle #359</h3><figure><img alt=\"\" data-lazy-src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*BqYtwp7dQMsxoCvGDgZz1A.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*BqYtwp7dQMsxoCvGDgZz1A.png?w=578&amp;ssl=1\"/></noscript></figure><p>Just like in this dragon sometimes numbers are a sum of many consecutive elements. And todays task is to discover which sequence of numbers are valid to given number.</p><h4>Load libraries and data</h4><pre>library(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"B1:B10\") %&gt;%\n  mutate(`Answer Expected` = str_remove_all(as.character(`Answer Expected`), \"\\\\s\"))</pre><p>I did this additiona action, because probably unintentionally there are some double spaces, so I removed all spaces and adjusted my further code to it as well.</p><h4>Transformation</h4><pre>find_consecutive_sums &lt;- function(target) {\n  results &lt;- tibble()\n  for (start_num in 1:(target/2 + 1)) {\n    sum &lt;- start_num\n    next_num &lt;- start_num\n    while (sum &lt; target) {\n      next_num &lt;- next_num + 1\n      sum &lt;- sum + next_num\n      if (sum == target) {\n        results &lt;- bind_rows(results, tibble(start = start_num, end = next_num))\n      }\n    }\n  }\n  if (nrow(results) == 0) {\n    return(tibble(Numbers = target, seq = NA_character_))\n    # this take care of numbers that doesn't met condition\n  } else {\n    sqs &lt;- results %&gt;%\n      mutate(\n        Numbers = target,\n        seq = map2_chr(start, end, ~paste(.x:.y, collapse = \"+\"))\n      ) %&gt;%\n      select(Numbers, seq)\n    return(sqs)\n  }\n}\n\nresult = map(input$Numbers, find_consecutive_sums) %&gt;%\n  bind_rows() %&gt;%\n  group_by(Numbers) %&gt;%\n  slice(1)  \n  # If you omit last line you'll get all sequences for each number. There are some :)\n  # Final solutions are the longest sequences, so we only keep the first one.</pre><h4>Validation</h4><pre>identical(result$seq, test$`Answer Expected`)\n# [1] TRUE</pre><h3>Puzzle #360</h3><figure><img alt=\"\" data-lazy-src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*pY4FWaZWt2-sw-4SaiRYjQ.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*pY4FWaZWt2-sw-4SaiRYjQ.png?w=578&amp;ssl=1\"/></noscript></figure><p>From Tuesday to Friday we have puzzles focused on text transformation and sometimes we use regular expressions to go through. First of those was about extracting letters from given string and then put them back in the same places but with exactly reversed order. For example: f@x -&gt; x@f.</p><h4>Load data and libraries</h4><pre>library(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"A1:A13\")\ntest  = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"B1:B13\")</pre><h4>Transformation</h4><pre>reverse_alpha = function(word) {\n  chars = strsplit(word, \"\")[[1]]\n  pos = which(chars %in% c(letters, LETTERS))\n  alphas = chars[pos]\n  rev_alphas = rev(alphas)\n  chars[pos] = rev_alphas\n  processed = paste(chars, collapse = \"\")\n  return(processed)\n}\n\noutput = input %&gt;%\n  mutate(`Answer Expected` = map_chr(Strings, reverse_alpha))</pre><h4>Validation</h4><pre>identical(output$`Answer Expected`, test$`Answer Expected`)\n# [1] TRUE</pre><h3>Puzzle #361</h3><figure><img alt=\"\" data-lazy-src=\"https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*zwqZMsrRt6lwK2IT0SaG8g.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/cdn-images-1.medium.com/max/1024/1*zwqZMsrRt6lwK2IT0SaG8g.png?w=578&amp;ssl=1\"/></noscript></figure><p>Here are strings again. Now we have some pretty long strings containing letters, digits, special characters, punctuations and white spaces. And like this miner in picture above we need to find gold nuggets which in this case are longest sequence of letters and digits distinctively. If there are more then one sequence for the max length, they have to be both shown concatenated.</p><h4>Load libraries and data</h4><pre>library(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"A1:A10\")\ntest  = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"B1:C10\")</pre><h4>Transformation</h4><pre>extract_longest_typeseq = function(string, pattern) {\n  seqs = data.frame(string = string) %&gt;% \n    mutate(seq = str_extract_all(string, pattern)) %&gt;% \n    unnest_longer(seq) %&gt;%\n    mutate(str_len = str_length(seq)) %&gt;%\n    filter(str_len == max(str_len, na.rm = TRUE)) %&gt;%\n    pull(seq) %&gt;%\n    paste0(collapse = \", \") \n  \n  if (is.na(seqs) | seqs == \"\") {\n    return(NA)\n  } else {\n    return(seqs)\n  }\n  \n}\n\nresult = input %&gt;%\n  mutate(Alphabets = map_chr(String, ~extract_longest_typeseq(.x, \"[A-Za-z]+\")),\n         Numbers = map_chr(String, ~extract_longest_typeseq(.x, \"[0-9]+\")))</pre><h4>Validation</h4><pre>identical(result$Alphabets, test$Alphabets)\n#&gt; [1] TRUE\nidentical(result$Numbers, test$Numbers)\n#&gt; [1] TRUE</pre><h3>Puzzle #362</h3><figure><img alt=\"\" data-lazy-src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*QGlqOlJfC0gXjruEXQ4IJQ.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*QGlqOlJfC0gXjruEXQ4IJQ.png?w=578&amp;ssl=1\"/></noscript></figure><p>Next two puzzles are basing on exactly the same dataset but with different outcome. In #362 letters that are next to digits (no matter if in front or behind) in string have to capitalize itself. Like some bodybuilder flexing himself in front of beautiful girl. So lets buff some letters.</p><h4>Load libraries and data</h4><pre>library(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"B1:B10\")</pre><h4>Transformation</h4><pre>convert = function(sentence) {\n  pos_foll = str_locate_all(sentence, pattern = \"[a-z](?=[0-9])\") %&gt;% unlist()\n  # pattern is regular expression for letter followed by digit\n  pos_pre  = str_locate_all(sentence, pattern = \"(?&lt;=[0-9])[a-z]\") %&gt;% unlist()\n  # pattern is regular expression for letter preceded by digit\n  pos = c(pos_foll, pos_pre) %&gt;% unique()\n  \n  chars = str_split(sentence, pattern = \"\")[[1]]\n  chars[pos] = str_to_upper(chars[pos])\n  sentence = paste(chars, collapse = \"\")\n  \n  return(sentence)\n}\n\nresult = input %&gt;% \n  mutate(`Answer Expected` = map_chr(Sentences, convert)) </pre><h4>Validation</h4><pre>identical(result$`Answer Expected`, test$`Answer Expected`)\n# [1] TRUE</pre><h3>Puzzle #363</h3><figure><img alt=\"\" data-lazy-src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*wItf5fH8uxUo7N5GERwpbA.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/cdn-images-1.medium.com/max/1024/1*wItf5fH8uxUo7N5GERwpbA.png?w=578&amp;ssl=1\"/></noscript></figure><p>As I said this riddle has the same data set, but different task. Now we have to find all “words” ending with number. Be careful we are working on numbers, not digits this time. And we have to increase those numbers by one. Tricky, but not so hard.</p><h4>Load libraries and data</h4><pre>library(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/363 Increment last number by 1.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/363 Increment last number by 1.xlsx\", range = \"B1:B10\")</pre><h4>Transformation</h4><pre>add_one = function(x) {\n  original_length &lt;- nchar(x) \n  incremented_number &lt;- as.numeric(x) + 1\n  str_pad(incremented_number, original_length, pad = \"0\")\n}\n\nprocess_word = function(word) {\n  if (str_detect(word, \"\\\\d+$\")) {  \n    parts = str_match(word, \"(.*?)(\\\\d+)$\")  \n    return(paste0(parts[2], add_one(parts[3])))  \n  } else {\n    return(word)  \n  }\n}\n\nprocess_text = function(text) {\n  words = unlist(str_split(text, \" \"))  \n  processed_words = map_chr(words, process_word)  \n  text_concat = str_c(processed_words, collapse = \" \")\n  return(text_concat)  \n}\n\nresult = input %&gt;%\n  mutate(`Answer Expected` = map_chr(Sentences, process_text))</pre><h4>Validation</h4><pre>identical(result$`Answer Expected`, test$`Answer Expected`)\n#&gt; [1] TRUE</pre><p>Feel free to comment, share and contact me with advices, questions and your ideas how to improve anything.</p><img alt=\"\" data-lazy-src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e8ce0037d4cd\" height=\"1\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"1\"/><noscript><img alt=\"\" height=\"1\" loading=\"lazy\" src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e8ce0037d4cd\" width=\"1\"/></noscript><hr/><p><a href=\"https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd\" rel=\"nofollow\" target=\"_blank\">R Solution for Excel Puzzles</a> was originally published in <a href=\"https://medium.com/number-around-us\" rel=\"nofollow\" target=\"_blank\">Numbers around us</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://medium.com/number-around-us/r-solution-for-excel-puzzles-e8ce0037d4cd\"> Numbers around us - Medium</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "R Solution for Excel Puzzles\nPosted on\nJanuary 8, 2024\nby\nNumbers around us\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nNumbers around us - Medium\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nPuzzles no. 359–363\nPuzzles\nAuthor:\nExcelBI\nAll files (xlsx with puzzle and R with solution) for each and every puzzle are available on my\nGithub\n. Enjoy.\nPuzzle #359\nJust like in this dragon sometimes numbers are a sum of many consecutive elements. And todays task is to discover which sequence of numbers are valid to given number.\nLoad libraries and data\nlibrary(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"B1:B10\") %>%\n  mutate(`Answer Expected` = str_remove_all(as.character(`Answer Expected`), \"\\\\s\"))\nI did this additiona action, because probably unintentionally there are some double spaces, so I removed all spaces and adjusted my further code to it as well.\nTransformation\nfind_consecutive_sums <- function(target) {\n  results <- tibble()\n  for (start_num in 1:(target/2 + 1)) {\n    sum <- start_num\n    next_num <- start_num\n    while (sum < target) {\n      next_num <- next_num + 1\n      sum <- sum + next_num\n      if (sum == target) {\n        results <- bind_rows(results, tibble(start = start_num, end = next_num))\n      }\n    }\n  }\n  if (nrow(results) == 0) {\n    return(tibble(Numbers = target, seq = NA_character_))\n    # this take care of numbers that doesn't met condition\n  } else {\n    sqs <- results %>%\n      mutate(\n        Numbers = target,\n        seq = map2_chr(start, end, ~paste(.x:.y, collapse = \"+\"))\n      ) %>%\n      select(Numbers, seq)\n    return(sqs)\n  }\n}\n\nresult = map(input$Numbers, find_consecutive_sums) %>%\n  bind_rows() %>%\n  group_by(Numbers) %>%\n  slice(1)  \n  # If you omit last line you'll get all sequences for each number. There are some :)\n  # Final solutions are the longest sequences, so we only keep the first one.\nValidation\nidentical(result$seq, test$`Answer Expected`)\n# [1] TRUE\nPuzzle #360\nFrom Tuesday to Friday we have puzzles focused on text transformation and sometimes we use regular expressions to go through. First of those was about extracting letters from given string and then put them back in the same places but with exactly reversed order. For example: f@x -> x@f.\nLoad data and libraries\nlibrary(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"A1:A13\")\ntest  = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"B1:B13\")\nTransformation\nreverse_alpha = function(word) {\n  chars = strsplit(word, \"\")[[1]]\n  pos = which(chars %in% c(letters, LETTERS))\n  alphas = chars[pos]\n  rev_alphas = rev(alphas)\n  chars[pos] = rev_alphas\n  processed = paste(chars, collapse = \"\")\n  return(processed)\n}\n\noutput = input %>%\n  mutate(`Answer Expected` = map_chr(Strings, reverse_alpha))\nValidation\nidentical(output$`Answer Expected`, test$`Answer Expected`)\n# [1] TRUE\nPuzzle #361\nHere are strings again. Now we have some pretty long strings containing letters, digits, special characters, punctuations and white spaces. And like this miner in picture above we need to find gold nuggets which in this case are longest sequence of letters and digits distinctively. If there are more then one sequence for the max length, they have to be both shown concatenated.\nLoad libraries and data\nlibrary(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"A1:A10\")\ntest  = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"B1:C10\")\nTransformation\nextract_longest_typeseq = function(string, pattern) {\n  seqs = data.frame(string = string) %>% \n    mutate(seq = str_extract_all(string, pattern)) %>% \n    unnest_longer(seq) %>%\n    mutate(str_len = str_length(seq)) %>%\n    filter(str_len == max(str_len, na.rm = TRUE)) %>%\n    pull(seq) %>%\n    paste0(collapse = \", \") \n  \n  if (is.na(seqs) | seqs == \"\") {\n    return(NA)\n  } else {\n    return(seqs)\n  }\n  \n}\n\nresult = input %>%\n  mutate(Alphabets = map_chr(String, ~extract_longest_typeseq(.x, \"[A-Za-z]+\")),\n         Numbers = map_chr(String, ~extract_longest_typeseq(.x, \"[0-9]+\")))\nValidation\nidentical(result$Alphabets, test$Alphabets)\n#> [1] TRUE\nidentical(result$Numbers, test$Numbers)\n#> [1] TRUE\nPuzzle #362\nNext two puzzles are basing on exactly the same dataset but with different outcome. In #362 letters that are next to digits (no matter if in front or behind) in string have to capitalize itself. Like some bodybuilder flexing himself in front of beautiful girl. So lets buff some letters.\nLoad libraries and data\nlibrary(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"B1:B10\")\nTransformation\nconvert = function(sentence) {\n  pos_foll = str_locate_all(sentence, pattern = \"[a-z](?=[0-9])\") %>% unlist()\n  # pattern is regular expression for letter followed by digit\n  pos_pre  = str_locate_all(sentence, pattern = \"(?<=[0-9])[a-z]\") %>% unlist()\n  # pattern is regular expression for letter preceded by digit\n  pos = c(pos_foll, pos_pre) %>% unique()\n  \n  chars = str_split(sentence, pattern = \"\")[[1]]\n  chars[pos] = str_to_upper(chars[pos])\n  sentence = paste(chars, collapse = \"\")\n  \n  return(sentence)\n}\n\nresult = input %>% \n  mutate(`Answer Expected` = map_chr(Sentences, convert))\nValidation\nidentical(result$`Answer Expected`, test$`Answer Expected`)\n# [1] TRUE\nPuzzle #363\nAs I said this riddle has the same data set, but different task. Now we have to find all “words” ending with number. Be careful we are working on numbers, not digits this time. And we have to increase those numbers by one. Tricky, but not so hard.\nLoad libraries and data\nlibrary(tidyverse)\nlibrary(readxl)\n\ninput = read_excel(\"Excel/363 Increment last number by 1.xlsx\", range = \"A1:A10\")\ntest  = read_excel(\"Excel/363 Increment last number by 1.xlsx\", range = \"B1:B10\")\nTransformation\nadd_one = function(x) {\n  original_length <- nchar(x) \n  incremented_number <- as.numeric(x) + 1\n  str_pad(incremented_number, original_length, pad = \"0\")\n}\n\nprocess_word = function(word) {\n  if (str_detect(word, \"\\\\d+$\")) {  \n    parts = str_match(word, \"(.*?)(\\\\d+)$\")  \n    return(paste0(parts[2], add_one(parts[3])))  \n  } else {\n    return(word)  \n  }\n}\n\nprocess_text = function(text) {\n  words = unlist(str_split(text, \" \"))  \n  processed_words = map_chr(words, process_word)  \n  text_concat = str_c(processed_words, collapse = \" \")\n  return(text_concat)  \n}\n\nresult = input %>%\n  mutate(`Answer Expected` = map_chr(Sentences, process_text))\nValidation\nidentical(result$`Answer Expected`, test$`Answer Expected`)\n#> [1] TRUE\nFeel free to comment, share and contact me with advices, questions and your ideas how to improve anything.\nR Solution for Excel Puzzles\nwas originally published in\nNumbers around us\non Medium, where people are continuing the conversation by highlighting and responding to this story.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nNumbers around us - Medium\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Puzzles no. 359–363PuzzlesAuthor: ExcelBIAll files (xlsx with puzzle and R with solution) for each and every puzzle are available on my Github. Enjoy.Puzzle #359Just like in this dragon sometimes numbers are a sum of many consecutive elements. And todays task is to discover which sequence of numbers are valid to given number.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"B1:B10\") %>% mutate(`Answer Expected` = str_remove_all(as.character(`Answer Expected`), \"\\s\"))I did this additiona action, because probably unintentionally there are some double spaces, so I removed all spaces and adjusted my further code to it as well.Transformationfind_consecutive_sums x@f.Load data and librarieslibrary(tidyverse)library(readxl)input = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"A1:A13\")test = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"B1:B13\")Transformationreverse_alpha = function(word) { chars = strsplit(word, \"\")[[1]] pos = which(chars %in% c(letters, LETTERS)) alphas = chars[pos] rev_alphas = rev(alphas) chars[pos] = rev_alphas processed = paste(chars, collapse = \"\") return(processed)}output = input %>% mutate(`Answer Expected` = map_chr(Strings, reverse_alpha))Validationidentical(output$`Answer Expected`, test$`Answer Expected`)# [1] TRUEPuzzle #361Here are strings again. Now we have some pretty long strings containing letters, digits, special characters, punctuations and white spaces. And like this miner in picture above we need to find gold nuggets which in this case are longest sequence of letters and digits distinctively. If there are more then one sequence for the max length, they have to be both shown concatenated.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"A1:A10\")test = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"B1:C10\")Transformationextract_longest_typeseq = function(string, pattern) { seqs = data.frame(string = string) %>% mutate(seq = str_extract_all(string, pattern)) %>% unnest_longer(seq) %>% mutate(str_len = str_length(seq)) %>% filter(str_len == max(str_len, na.rm = TRUE)) %>% pull(seq) %>% paste0(collapse = \", \") if (is.na(seqs) | seqs == \"\") { return(NA) } else { return(seqs) } }result = input %>% mutate(Alphabets = map_chr(String, ~extract_longest_typeseq(.x, \"[A-Za-z]+\")), Numbers = map_chr(String, ~extract_longest_typeseq(.x, \"[0-9]+\")))Validationidentical(result$Alphabets, test$Alphabets)#> [1] TRUEidentical(result$Numbers, test$Numbers)#> [1] TRUEPuzzle #362Next two puzzles are basing on exactly the same dataset but with different outcome. In #362 letters that are next to digits (no matter if in front or behind) in string have to capitalize itself. Like some bodybuilder flexing himself in front of beautiful girl. So lets buff some letters.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"B1:B10\")Transformationconvert = function(sentence) { pos_foll = str_locate_all(sentence, pattern = \"[a-z](?=[0-9])\") %>% unlist() # pattern is regular expression for letter followed by digit pos_pre = str_locate_all(sentence, pattern = \"(?",
    "meta_keywords": null,
    "og_description": "Puzzles no. 359–363PuzzlesAuthor: ExcelBIAll files (xlsx with puzzle and R with solution) for each and every puzzle are available on my Github. Enjoy.Puzzle #359Just like in this dragon sometimes numbers are a sum of many consecutive elements. And todays task is to discover which sequence of numbers are valid to given number.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"B1:B10\") %>% mutate(`Answer Expected` = str_remove_all(as.character(`Answer Expected`), \"\\s\"))I did this additiona action, because probably unintentionally there are some double spaces, so I removed all spaces and adjusted my further code to it as well.Transformationfind_consecutive_sums x@f.Load data and librarieslibrary(tidyverse)library(readxl)input = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"A1:A13\")test = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"B1:B13\")Transformationreverse_alpha = function(word) { chars = strsplit(word, \"\")[[1]] pos = which(chars %in% c(letters, LETTERS)) alphas = chars[pos] rev_alphas = rev(alphas) chars[pos] = rev_alphas processed = paste(chars, collapse = \"\") return(processed)}output = input %>% mutate(`Answer Expected` = map_chr(Strings, reverse_alpha))Validationidentical(output$`Answer Expected`, test$`Answer Expected`)# [1] TRUEPuzzle #361Here are strings again. Now we have some pretty long strings containing letters, digits, special characters, punctuations and white spaces. And like this miner in picture above we need to find gold nuggets which in this case are longest sequence of letters and digits distinctively. If there are more then one sequence for the max length, they have to be both shown concatenated.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"A1:A10\")test = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"B1:C10\")Transformationextract_longest_typeseq = function(string, pattern) { seqs = data.frame(string = string) %>% mutate(seq = str_extract_all(string, pattern)) %>% unnest_longer(seq) %>% mutate(str_len = str_length(seq)) %>% filter(str_len == max(str_len, na.rm = TRUE)) %>% pull(seq) %>% paste0(collapse = \", \") if (is.na(seqs) | seqs == \"\") { return(NA) } else { return(seqs) } }result = input %>% mutate(Alphabets = map_chr(String, ~extract_longest_typeseq(.x, \"[A-Za-z]+\")), Numbers = map_chr(String, ~extract_longest_typeseq(.x, \"[0-9]+\")))Validationidentical(result$Alphabets, test$Alphabets)#> [1] TRUEidentical(result$Numbers, test$Numbers)#> [1] TRUEPuzzle #362Next two puzzles are basing on exactly the same dataset but with different outcome. In #362 letters that are next to digits (no matter if in front or behind) in string have to capitalize itself. Like some bodybuilder flexing himself in front of beautiful girl. So lets buff some letters.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"B1:B10\")Transformationconvert = function(sentence) { pos_foll = str_locate_all(sentence, pattern = \"[a-z](?=[0-9])\") %>% unlist() # pattern is regular expression for letter followed by digit pos_pre = str_locate_all(sentence, pattern = \"(?",
    "og_image": "https://cdn-images-1.medium.com/max/1024/1*AdgwcPx6IewqT10WW7-dHQ.jpeg",
    "og_title": "R Solution for Excel Puzzles | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 5.3,
    "sitemap_lastmod": "2024-01-08T19:47:56+00:00",
    "twitter_description": "Puzzles no. 359–363PuzzlesAuthor: ExcelBIAll files (xlsx with puzzle and R with solution) for each and every puzzle are available on my Github. Enjoy.Puzzle #359Just like in this dragon sometimes numbers are a sum of many consecutive elements. And todays task is to discover which sequence of numbers are valid to given number.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/359 Express as Sum of Consecutive Digits.xlsx\", range = \"B1:B10\") %>% mutate(`Answer Expected` = str_remove_all(as.character(`Answer Expected`), \"\\s\"))I did this additiona action, because probably unintentionally there are some double spaces, so I removed all spaces and adjusted my further code to it as well.Transformationfind_consecutive_sums x@f.Load data and librarieslibrary(tidyverse)library(readxl)input = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"A1:A13\")test = read_excel(\"Excel/360 Reverse alphabets only.xlsx\", range = \"B1:B13\")Transformationreverse_alpha = function(word) { chars = strsplit(word, \"\")[[1]] pos = which(chars %in% c(letters, LETTERS)) alphas = chars[pos] rev_alphas = rev(alphas) chars[pos] = rev_alphas processed = paste(chars, collapse = \"\") return(processed)}output = input %>% mutate(`Answer Expected` = map_chr(Strings, reverse_alpha))Validationidentical(output$`Answer Expected`, test$`Answer Expected`)# [1] TRUEPuzzle #361Here are strings again. Now we have some pretty long strings containing letters, digits, special characters, punctuations and white spaces. And like this miner in picture above we need to find gold nuggets which in this case are longest sequence of letters and digits distinctively. If there are more then one sequence for the max length, they have to be both shown concatenated.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"A1:A10\")test = read_excel(\"Excel/361 Longest Sequence of Alphabets and Numbers.xlsx\", range =\"B1:C10\")Transformationextract_longest_typeseq = function(string, pattern) { seqs = data.frame(string = string) %>% mutate(seq = str_extract_all(string, pattern)) %>% unnest_longer(seq) %>% mutate(str_len = str_length(seq)) %>% filter(str_len == max(str_len, na.rm = TRUE)) %>% pull(seq) %>% paste0(collapse = \", \") if (is.na(seqs) | seqs == \"\") { return(NA) } else { return(seqs) } }result = input %>% mutate(Alphabets = map_chr(String, ~extract_longest_typeseq(.x, \"[A-Za-z]+\")), Numbers = map_chr(String, ~extract_longest_typeseq(.x, \"[0-9]+\")))Validationidentical(result$Alphabets, test$Alphabets)#> [1] TRUEidentical(result$Numbers, test$Numbers)#> [1] TRUEPuzzle #362Next two puzzles are basing on exactly the same dataset but with different outcome. In #362 letters that are next to digits (no matter if in front or behind) in string have to capitalize itself. Like some bodybuilder flexing himself in front of beautiful girl. So lets buff some letters.Load libraries and datalibrary(tidyverse)library(readxl)input = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"A1:A10\")test = read_excel(\"Excel/362 Uppercase Conversion Around Numbers.xlsx\", range = \"B1:B10\")Transformationconvert = function(sentence) { pos_foll = str_locate_all(sentence, pattern = \"[a-z](?=[0-9])\") %>% unlist() # pattern is regular expression for letter followed by digit pos_pre = str_locate_all(sentence, pattern = \"(?",
    "twitter_title": "R Solution for Excel Puzzles | R-bloggers",
    "url": "https://www.r-bloggers.com/2024/01/r-solution-for-excel-puzzles-7/",
    "word_count": 1069
  }
}