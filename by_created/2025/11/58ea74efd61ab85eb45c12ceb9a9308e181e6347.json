{
  "id": "58ea74efd61ab85eb45c12ceb9a9308e181e6347",
  "url": "https://www.r-bloggers.com/2025/06/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
  "created_at_utc": "2025-11-22T19:58:26Z",
  "data": null,
  "raw_original": {
    "uuid": "2bfd1c0a-7901-40df-b5e2-603f122d8731",
    "created_at": "2025-11-22 19:58:26",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/06/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
      "crawled_at": "2025-11-22T10:47:52.416657",
      "external_links": [
        {
          "href": "https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
          "text": "Rtask"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://rtask.thinkr.fr/",
          "text": "Rtask"
        },
        {
          "href": "https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
          "text": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide"
        },
        {
          "href": "https://github.com/ThinkR-open/golem",
          "text": "{golem}"
        },
        {
          "href": "https://github.com/VincentGuyader/shiny2docker",
          "text": "{shiny2docker}"
        },
        {
          "href": "https://hub.docker.com/r/rocker/geospatial",
          "text": "rocker/geospatial"
        },
        {
          "href": "http://localhost/",
          "text": "http://localhost:80"
        },
        {
          "href": "https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
          "text": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide"
        },
        {
          "href": "https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
          "text": "Rtask"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/vincent-guyader/",
          "text": "Vincent GUYADER"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-392824 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">June 3, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/vincent-guyader/\">Vincent GUYADER</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/\"> Rtask</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>You can read the original post in its original format on <a href=\"https://rtask.thinkr.fr/\" rel=\"nofollow\" target=\"_blank\">Rtask</a> website by ThinkR here: <a href=\"https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/\" rel=\"nofollow\" target=\"_blank\">Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide</a></p>\n<p>    Deploying a Shiny application to different servers or sharing it with others can be challenging due to differences in R package versions and system requirements. Containerization offers a solution: by packaging your Shiny app and its environment into a Docker container, you ensure it runs consistently anywhere Docker is available. However, not every Shiny developer is familiar with writing Dockerfiles from scratch, and not everyone uses the <a href=\"https://github.com/ThinkR-open/golem\" rel=\"nofollow\" target=\"_blank\">{golem}</a> framework, which includes deployment tools natively. This is where the <a href=\"https://github.com/VincentGuyader/shiny2docker\" rel=\"nofollow\" target=\"_blank\"><strong>{shiny2docker}</strong></a> package comes in. In this post, we‚Äôll introduce {shiny2docker} ‚Äì a tool that automates Dockerfile creation for Shiny apps ‚Äì and walk through a simple example of using it to containerize a Shiny application. The tutorial is beginner-friendly, with plenty of commentary, but also informative for DevOps professionals looking to streamline Shiny deployments.</p>\n<div class=\"section level2\" id=\"why-dockerize-shiny-apps\">\n<h2>Why Dockerize Shiny Apps?</h2>\n<p><strong>Reproducibility and Consistency:</strong> One major reason to containerize your Shiny app is to capture a consistent R environment. Docker containers bundle the operating system, R installation, packages, and all dependencies your app needs. This eliminates the classic ‚Äúworks on my machine‚Äù problem ‚Äì if it works in the container, it will work on any host running Docker. By containerizing, you ensure your Shiny app has the same R package versions and system libraries wherever it‚Äôs deployed.</p>\n<p><strong>Ease of Deployment:</strong> With a Docker image of your app, deploying is straightforward. You (or your DevOps team) can run the image on any server or cloud service that supports Docker. This can simplify migrating from development to production or scaling up instances of your Shiny application. Instead of manually configuring servers with R and packages, you just ship the container.</p>\n<p><strong>Isolation and Stability:</strong> Docker provides isolation from other processes on the host system. Your Shiny app runs in its own environment without risking interference from other software. This isolation helps maintain stability and can improve security as well.</p>\n<p>In short, containerization allows Shiny developers to package <strong>everything</strong> the app needs to run ‚Äì code, packages, system libraries ‚Äì into a portable unit. Now, let‚Äôs see how {shiny2docker} simplifies this process.</p></div>\n<div class=\"section level2\" id=\"introducing-shiny2docker\">\n<h2>Introducing {shiny2docker}</h2>\n<p><strong>{shiny2docker}</strong> is an R package designed to streamline the process of containerizing Shiny applications using Docker. It automates the generation of the essential Docker files and manages R package dependencies with <strong>{renv}</strong>, making it much easier to deploy Shiny apps in reproducible. In other words, {shiny2docker} will <strong>write a Dockerfile for you</strong>, based on your Shiny app‚Äôs requirements, and even help set up continuous integration for building the Docker image if needed.</p>\n<p>Some key features of {shiny2docker} include:</p>\n<ul>\n<li>\n<p><strong>Automated Dockerfile Creation:</strong> The main function <code>shiny2docker()</code> inspects your Shiny application and generates a Dockerfile tailored to it. It leverages your app‚Äôs <code>renv.lock</code> file (if available) to pin R package versions. If you haven‚Äôt been using {renv}, don‚Äôt worry ‚Äì {shiny2docker} can create a lockfile for you on the fly (using <code>attachment::create_renv_for_prod</code> under the hood). This ensures all necessary R packages for your app are accounted for in the Docker image.</p>\n</li><li>\n<p><strong>.dockerignore Generation:</strong> To keep your Docker image lean, {shiny2docker} automatically creates a <code>.dockerignore</code> file. This file lists patterns of files/folders to exclude from the build context (such as your local data, documentation, etc.), which can significantly reduce build times and image size.</p>\n</li><li>\n<p><strong>Dependency Management with {renv}:</strong> By integrating with {renv}, the package ensures that the versions of R packages inside the container match those you developed with, achieving reproducibility and consistency across different environments. The container build process will use the lockfile to install the exact package versions your app needs.</p>\n</li><li>\n<p><strong>CI/CD Integration:</strong> For more advanced users, {shiny2docker} provides helpers to set up continuous integration pipelines. With a single function call, you can add a GitLab CI configuration or a GitHub Actions workflow to your project. For example, <code>set_gitlab_ci()</code> adds a GitLab CI YAML file configured to build and push your Docker image to the registry, and <code>set_github_action()</code> places a GitHub Actions workflow file to build and deploy your image on GitHub Container Registry. This is a boon for DevOps engineers looking to automate Shiny app deployment in a CI/CD pipeline.</p></li></ul>\n<p>In summary, {shiny2docker} handles the heavy lifting of containerization: it writes Dockerfiles, manages R package versions, and even helps automate builds. Now let‚Äôs get our hands dirty with a practical example.</p></div>\n<div class=\"section level2\" id=\"getting-started-installation-and-setup\">\n<h2>Getting Started: Installation and Setup</h2>\n<p>Before we begin, make sure you have a recent version of <strong>R</strong> installed and that <strong>Docker</strong> is installed and running on your system (you dont need docker on your system to create a Dockerfile, but if you want to build/run your app using docker you need docker). You don‚Äôt need deep Docker knowledge to follow along, but you should have Docker up and running (for example, Docker Desktop on Windows/Mac or the Docker Engine on Linux).</p>\n<p>Next, install the <strong>{shiny2docker}</strong> package from CRAN (it‚Äôs a recent package, first released in 2025):</p>\n<pre>install.packages(\"shiny2docker\")</pre>\n<p>This will also install any required dependencies. Once installed, load the package:</p>\n<pre>library(shiny2docker)</pre>\n<p>Also, ensure you have <strong>{shiny}</strong> installed (for developing the app) and <strong>{renv}</strong> to manage dependencies. </p>\n<p>Finally, you should of course have a Shiny application that you want to containerize. For this tutorial, we‚Äôll create a simple example app from scratch.</p></div>\n<div class=\"section level2\" id=\"example-containerizing-a-shiny-app-step-by-step\">\n<h2>Example: Containerizing a Shiny App Step-by-Step</h2>\n<p>Let‚Äôs go through the process step by step by containerizing a simple Shiny app. Our example app will be minimal ‚Äì a histogram of the famous Old Faithful geyser data ‚Äì but the process applies to any Shiny app (large or small).</p>\n<div class=\"section level3\" id=\"step-1-prepare-a-simple-shiny-application\">\n<h3>Step 1: Prepare a Simple Shiny Application</h3>\n<p>First, we need a Shiny app to containerize. We‚Äôll write a basic <code>app.R</code> that defines a UI and server. In a real project, you might have separate <code>ui.R</code> and <code>server.R</code> files or a more complex app structure, but {shiny2docker} works with any standard Shiny app directory.</p>\n<pre># app.R -- a simple Shiny app \n# (Make sure this file is in its own directory, e.g., \"myapp/app.R\")\n\nlibrary(shiny)\n\n# Define UI for the application\nui &lt;- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Slider for the number of bins in the histogram\n      sliderInput(\"bins\", \"Number of bins:\",\n                  min = 1, max = 50, value = 30)\n    ),\n    mainPanel(\n      # Output: Histogram plot\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\n# Define server logic for the histogram\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    # Draw the histogram using the 'waiting' column of the faithful dataset\n    x &lt;- faithful$waiting  \n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x, breaks = bins,\n         col = \"#75AADB\", border = \"white\",\n         xlab = \"Waiting time to next eruption (mins)\",\n         main = \"Histogram of Old Faithful waiting times\")\n  })\n}\n\n# Combine the UI and server into an app and run it\nshinyApp(ui = ui, server = server)</pre>\n<p>A quick explanation of the above code: It‚Äôs the classic Shiny example where the user can adjust the number of bins for a histogram. We use <code>faithful$waiting</code> (the Old Faithful geyser dataset built into R) as the data. The app has a slider input for the number of bins and displays a histogram that updates as the slider changes. If you save this code as <code>app.R</code> and run <code>shiny::runApp(\"app.R\")</code>, you should see the app running locally.</p>\n<p>Now that we have our Shiny app ready in a directory (say, we saved <code>app.R</code> in a folder called <code>myapp/</code>), we‚Äôre ready to containerize it with {shiny2docker}.</p></div>\n<div class=\"section level3\" id=\"step-2-generate-a-dockerfile-with-shiny2docker\">\n<h3>Step 2: Generate a Dockerfile with {shiny2docker}</h3>\n<p>The {shiny2docker} package will inspect our application and produce a Dockerfile (and a corresponding <code>.dockerignore</code>). Make sure your working directory is set to the folder containing the Shiny app (for example, set it to the <code>myapp</code> directory we created).</p>\n<p>In an R session, run the following:</p>\n<pre># In the R console, with working directory set to the Shiny app folder (e.g., \"myapp\")\nlibrary(shiny2docker)\n\n# Generate a Dockerfile for the Shiny app in the current directory\nshiny2docker(path = \".\")</pre>\n<p>After running <code>shiny2docker(path = \".\")</code>, you should see some messages in R indicating that a Dockerfile is being created. By default, this will create two files in your app directory:</p>\n<ul>\n<li><strong>Dockerfile</strong> ‚Äì a text file with instructions to build an image for your Shiny app.\n</li><li><strong>.dockerignore</strong> ‚Äì a text file specifying files to exclude from the Docker build context (common entries might include <code>.Rproj.user</code>, <code>renv/library/</code>, etc., which {shiny2docker} populates automatically).</li></ul>\n<p>Let‚Äôs break down what {shiny2docker} does for us when generating the Dockerfile:</p>\n<ul>\n<li>\n<p>It checks for an existing <code>renv.lock</code> in the directory. If it finds one (meaning you already used {renv} to lock dependencies), it will use that. If not, <strong>{shiny2docker} will create a lockfile for you</strong> by analyzing your app‚Äôs <code>library()</code> calls to figure out which packages (and versions) are needed. In our simple app, the main package dependency is <strong>shiny</strong> itself (plus any default R packages like datasets). The lockfile ensures the container installs the same version of <strong>shiny</strong> (and any other packages) that you used locally.</p>\n</li><li>\n<p>It writes a Dockerfile that typically uses a base Docker image suitable for Shiny. In many cases, this will be the <a href=\"https://hub.docker.com/r/rocker/geospatial\" rel=\"nofollow\" target=\"_blank\"><strong>rocker/geospatial</strong></a> image, which comes with R,Shiny and lot of stuff pre-installed. Using a pre-made base image saves us from manually setting up R and Shiny in the Dockerfile. The Dockerfile will <code>FROM</code> a specific version of rocker/geospatial (for example, <code>rocker/geospatial:4.2.2</code> if you‚Äôre using R 4.2.2).</p>\n</li><li>\n<p>The Dockerfile will then include instructions to install system libraries and R packages. Thanks to the lockfile, {shiny2docker} knows exactly which R packages (and versions) to install in the container. Typically, the Dockerfile will do something like:</p>\n<ul>\n<li>Install <strong>renv</strong> in the container (so it can use it to restore packages).\n</li><li>Copy the <code>renv.lock</code> file (and possibly your R project files) into the container.\n</li><li>Run <code>renv::restore()</code> to install all the required R packages at the locked versions.\n</li><li>Copy your Shiny app files into the container (e.g., the <code>app.R</code> or <code>ui.R</code>/<code>server.R</code> and any other app resources).\n</li><li>Set appropriate file permissions and environment variables for the Shiny app (if needed).</li></ul>\n</li><li>\n<p>Finally, the Dockerfile will specify a command to launch the Shiny app when the container runs. Usually, this is done by calling <code>shiny::runApp()</code> or by using the Shiny server default command. For example, it might use an entrypoint that runs something like:</p>\n<pre>R -e \"shiny::runApp('/srv/shiny-server', port=3838, host='0.0.0.0')\"</pre>\n<p>To peek at the generated Dockerfile, open it in a text editor. It should look somewhat like this (your exact file may differ in minor details):</p>\n<pre>FROM rocker/geospatial:4.4.2\nRUN apt-get update -y &amp;&amp; apt-get install -y  make zlib1g-dev git &amp;&amp; rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock renv.lock\nRUN --mount=type=cache,id=renv-cache,target=/root/.cache/R/renv R -e 'renv::restore()'\nWORKDIR /srv/shiny-server/\nCOPY . /srv/shiny-server/\nEXPOSE 3838\nCMD R -e 'shiny::runApp(\"/srv/shiny-server\",host=\"0.0.0.0\",port=3838)'\n</pre>\n<p>The above is an <strong>illustrative example</strong> of what the Dockerfile might contain. The key points are that it uses the <code>rocker/geospatial</code> base image (matching your R version), copies the lockfile and app, installs packages via <code>renv::restore()</code>, and sets the container to run a Shiny Server that serves the app. Notice that port 3838 is exposed ‚Äì this is the default port where Shiny Server serves apps. </p>\n<p>At this stage, without writing any Docker instructions ourselves, we have a Dockerfile ready to go. Now let‚Äôs use it to build a Docker image.</p></li></ul></div>\n<div class=\"section level3\" id=\"step-3-build-the-docker-image\">\n<h3>Step 3: Build the Docker Image</h3>\n<p>With the Dockerfile in place, the next step is to build the Docker image for your Shiny app. This step is done in the terminal (not in R). Open a terminal (or use RStudio‚Äôs Terminal tab) and navigate to the directory containing the Dockerfile (our <code>myapp</code> folder). Then run:</p>\n<pre># Make sure you are in the directory with the Dockerfile\n# Replace 'myshinyapp' with the name you want for your Docker image.\ndocker build -t myshinyapp .</pre>\n<p>Let‚Äôs break down this command:</p>\n<ul>\n<li><code>docker build</code> is the command to build a Docker image.\n</li><li><code>-t myshinyapp</code> tags the image with the name ‚Äúmyshinyapp‚Äù (you can choose any name; this will be the reference you use to run the container).\n</li><li><code>.</code> (dot) at the end tells Docker to use the current directory as the build context, looking for the Dockerfile there.</li></ul>\n<p>Docker will then step through the instructions in the Dockerfile. The first time you run this, it may download the base image (rocker/geospatial), which can be a few hundred MB. Then it will install R packages as needed. This process can take a while, especially if your app has many packages, but for our simple app (which just needs base R and shiny) it should be fairly quick.</p>\n<p>Keep an eye on the output in the terminal. You should see Docker downloading layers, installing packages, etc., and hopefully finishing with a message indicating it built the image and tagged it as ‚Äúmyshinyapp:latest‚Äù. If something goes wrong (e.g., a package failing to install), the error logs will appear. In our case, it should build successfully.</p>\n<p><strong>Tip:</strong> If you change your app or add packages and want to rebuild, you might need to run <code>docker build</code> again. Docker cache will help speed up rebuilds (unchanged steps are cached), but if you add new R packages, the <code>renv::restore()</code> step will install the new ones on rebuild.</p></div>\n<div class=\"section level3\" id=\"step-4-run-the-shiny-app-in-a-docker-container\">\n<h3>Step 4: Run the Shiny App in a Docker Container</h3>\n<p>Now that the image is built, you‚Äôre ready to run your Shiny app in a container. Running the container will start a Shiny Server that hosts your app. Use the following <code>docker run</code> command:</p>\n<pre>docker run -d -p 80:3838 --name myshinyapp_container myshinyapp</pre>\n<p>Here‚Äôs what each part means:</p>\n<ul>\n<li><code>docker run</code> is the command to start a new container from an image.\n</li><li><code>-d</code> runs the container in ‚Äúdetached‚Äù mode (in the background). You can omit <code>-d</code> if you want to run it in the foreground to see logs, but then you‚Äôll need a separate terminal.\n</li><li><code>-p 80:3838</code> maps port 3838 inside the container to port 80 on your local machine. This is crucial: the Shiny app is served on container port 3838, and this option exposes it so you can access it via <code>http://localhost:80</code> in your web browser.\n</li><li><code>--name myshinyapp_container</code> gives the container a friendly name (optional but useful for managing containers). We chose ‚Äúmyshinyapp_container‚Äù here.\n</li><li><code>myshinyapp</code> at the end is the name of the image to run (the one we built and tagged in Step 3).</li></ul>\n<p>After running this, Docker will start the container. You can check that it‚Äôs running by executing <code>docker ps</code> (which should list the running container). Now open your web browser and go to <strong><a class=\"uri\" href=\"http://localhost/\" rel=\"nofollow\" target=\"_blank\">http://localhost:80</a></strong>. You should see your Shiny histogram app running, just as it did locally! üéâ Adjust the slider and the histogram will update, but now note that it‚Äôs running inside a Docker container.</p>\n<p>If you don‚Äôt see anything or get an error, a few things to check: ‚Äì Ensure Docker is actually running and that the container is up (<code>docker ps</code> should show it). ‚Äì If you‚Äôre on a remote server, make sure to visit the correct host or have the port forwarded. The above assumes local development. ‚Äì Check container logs with <code>docker logs myshinyapp_container</code> to see if the Shiny app or server printed any error messages during startup.</p>\n<p>At this point, you‚Äôve successfully containerized a Shiny app using {shiny2docker}. The app is running in an isolated environment with all its dependencies managed by renv and installed in the container.</p>\n<p>When you‚Äôre done, you can stop the container with <code>docker stop myshinyapp_container</code> and remove it with <code>docker rm myshinyapp_container</code>. The Docker image ‚Äúmyshinyapp‚Äù will remain on your system (viewable with <code>docker images</code>), and you can re-run it anytime or push it to a container registry if you want to deploy it elsewhere.</p></div>\n</div>\n<div class=\"section level2\" id=\"tips-for-a-smooth-containerization-process\">\n<h2>Tips for a Smooth Containerization Process</h2>\n<p>Containerizing apps is much easier with {shiny2docker}, but here are some additional tips and best practices to consider:</p>\n<ul>\n<li>\n<p><strong>Keep Your App Directory Clean:</strong> Since {shiny2docker} will package everything in your app folder (except what‚Äôs excluded by <code>.dockerignore</code>), make sure you don‚Äôt have large unused files in there. Use the generated <code>.dockerignore</code> to exclude things like local datasets, caches, or R project settings that aren‚Äôt needed in the container.</p>\n</li><li>\n<p><strong>Use {renv} for Dependency Management:</strong> Even though {shiny2docker} can create a lockfile for you, it‚Äôs a good practice to use {renv} in your Shiny project from the start. Using {renv} while developing (call <code>renv::init()</code> and regularly <code>renv::snapshot()</code>) means you‚Äôre explicitly tracking package versions. This not only helps {shiny2docker} but also documents your environment for anyone collaborating on your project.</p>\n</li><li>\n<p><strong>Test Locally Before CI/CD:</strong> If you plan to integrate with CI/CD (using the provided <code>set_gitlab_ci()</code> or <code>set_github_action()</code> functions), test building and running your Docker image locally first (as we did above). This helps catch any issues early. Once it works locally, you can confidently add the CI configuration and let your CI pipeline build the image on each</p>\n</li><li>\n<p><strong>Security Considerations:</strong> When your Shiny app is running in Docker, treat the container as you would a server. Exposing port 3838 is fine for development, but in production you might put a proxy in front or use authentication if needed. Also, avoid including any sensitive credentials in the image. If your app needs API keys or passwords, use environment variables or external configuration rather than hard-coding them in the app or Dockerfile.</p>\n</li><li>\n<p><strong>Learn Docker Basics:</strong> While {shiny2docker} abstracts away Dockerfile details, having a basic understanding of Docker is beneficial. Knowing how to build, run, stop containers, and how Docker layers work will help you troubleshoot and optimize your containerized apps. The Dockerfile generated is a great learning resource ‚Äì read through it to see how R packages are installed and how the app is launched. Over time, you might customize it (using the returned <code>dockerfiler</code> object from <code>shiny2docker()</code> if needed).</p></li></ul>\n</div>\n<div class=\"section level2\" id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>Containerizing a Shiny application might seem intimidating at first, especially if you‚Äôre not familiar with Docker. The {shiny2docker} package bridges the gap between Shiny developers and DevOps, providing an easy way to create Docker images for Shiny apps without writing Dockerfiles manually. In our example, we saw how a simple Shiny app can be containerized in just a few steps: generate a Dockerfile, build the image, and run a container. The result is a portable app that runs the same everywhere, which is incredibly useful for deployment and sharing.</p>\n<p>Both Shiny developers and DevOps engineers can appreciate this workflow: developers don‚Äôt need to become Docker experts to deploy their apps, and DevOps professionals get a reproducible environment defined by code. With containerization, scaling and managing Shiny apps in production (using tools like Kubernetes, ShinyProxy, or cloud services) becomes much more manageable, since each app is encapsulated in its own image.</p>\n<p>We encourage you to try {shiny2docker} on one of your own Shiny projects. You‚Äôll save time and avoid the pitfalls of environment configuration. For further reading, check out the <strong>{shiny2docker}</strong> documentation and vignette for more advanced usage, including how to customize the Dockerfile or integrate CI/CD pipelines. Happy containerizing!</p></div>\n<p>This post is better presented on its original ThinkR website here: <a href=\"https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/\" rel=\"nofollow\" target=\"_blank\">Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide</a></p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://rtask.thinkr.fr/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/\"> Rtask</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide\nPosted on\nJune 3, 2025\nby\nVincent GUYADER\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nRtask\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nYou can read the original post in its original format on\nRtask\nwebsite by ThinkR here:\nContainerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide\nDeploying a Shiny application to different servers or sharing it with others can be challenging due to differences in R package versions and system requirements. Containerization offers a solution: by packaging your Shiny app and its environment into a Docker container, you ensure it runs consistently anywhere Docker is available. However, not every Shiny developer is familiar with writing Dockerfiles from scratch, and not everyone uses the\n{golem}\nframework, which includes deployment tools natively. This is where the\n{shiny2docker}\npackage comes in. In this post, we‚Äôll introduce {shiny2docker} ‚Äì a tool that automates Dockerfile creation for Shiny apps ‚Äì and walk through a simple example of using it to containerize a Shiny application. The tutorial is beginner-friendly, with plenty of commentary, but also informative for DevOps professionals looking to streamline Shiny deployments.\nWhy Dockerize Shiny Apps?\nReproducibility and Consistency:\nOne major reason to containerize your Shiny app is to capture a consistent R environment. Docker containers bundle the operating system, R installation, packages, and all dependencies your app needs. This eliminates the classic ‚Äúworks on my machine‚Äù problem ‚Äì if it works in the container, it will work on any host running Docker. By containerizing, you ensure your Shiny app has the same R package versions and system libraries wherever it‚Äôs deployed.\nEase of Deployment:\nWith a Docker image of your app, deploying is straightforward. You (or your DevOps team) can run the image on any server or cloud service that supports Docker. This can simplify migrating from development to production or scaling up instances of your Shiny application. Instead of manually configuring servers with R and packages, you just ship the container.\nIsolation and Stability:\nDocker provides isolation from other processes on the host system. Your Shiny app runs in its own environment without risking interference from other software. This isolation helps maintain stability and can improve security as well.\nIn short, containerization allows Shiny developers to package\neverything\nthe app needs to run ‚Äì code, packages, system libraries ‚Äì into a portable unit. Now, let‚Äôs see how {shiny2docker} simplifies this process.\nIntroducing {shiny2docker}\n{shiny2docker}\nis an R package designed to streamline the process of containerizing Shiny applications using Docker. It automates the generation of the essential Docker files and manages R package dependencies with\n{renv}\n, making it much easier to deploy Shiny apps in reproducible. In other words, {shiny2docker} will\nwrite a Dockerfile for you\n, based on your Shiny app‚Äôs requirements, and even help set up continuous integration for building the Docker image if needed.\nSome key features of {shiny2docker} include:\nAutomated Dockerfile Creation:\nThe main function\nshiny2docker()\ninspects your Shiny application and generates a Dockerfile tailored to it. It leverages your app‚Äôs\nrenv.lock\nfile (if available) to pin R package versions. If you haven‚Äôt been using {renv}, don‚Äôt worry ‚Äì {shiny2docker} can create a lockfile for you on the fly (using\nattachment::create_renv_for_prod\nunder the hood). This ensures all necessary R packages for your app are accounted for in the Docker image.\n.dockerignore Generation:\nTo keep your Docker image lean, {shiny2docker} automatically creates a\n.dockerignore\nfile. This file lists patterns of files/folders to exclude from the build context (such as your local data, documentation, etc.), which can significantly reduce build times and image size.\nDependency Management with {renv}:\nBy integrating with {renv}, the package ensures that the versions of R packages inside the container match those you developed with, achieving reproducibility and consistency across different environments. The container build process will use the lockfile to install the exact package versions your app needs.\nCI/CD Integration:\nFor more advanced users, {shiny2docker} provides helpers to set up continuous integration pipelines. With a single function call, you can add a GitLab CI configuration or a GitHub Actions workflow to your project. For example,\nset_gitlab_ci()\nadds a GitLab CI YAML file configured to build and push your Docker image to the registry, and\nset_github_action()\nplaces a GitHub Actions workflow file to build and deploy your image on GitHub Container Registry. This is a boon for DevOps engineers looking to automate Shiny app deployment in a CI/CD pipeline.\nIn summary, {shiny2docker} handles the heavy lifting of containerization: it writes Dockerfiles, manages R package versions, and even helps automate builds. Now let‚Äôs get our hands dirty with a practical example.\nGetting Started: Installation and Setup\nBefore we begin, make sure you have a recent version of\nR\ninstalled and that\nDocker\nis installed and running on your system (you dont need docker on your system to create a Dockerfile, but if you want to build/run your app using docker you need docker). You don‚Äôt need deep Docker knowledge to follow along, but you should have Docker up and running (for example, Docker Desktop on Windows/Mac or the Docker Engine on Linux).\nNext, install the\n{shiny2docker}\npackage from CRAN (it‚Äôs a recent package, first released in 2025):\ninstall.packages(\"shiny2docker\")\nThis will also install any required dependencies. Once installed, load the package:\nlibrary(shiny2docker)\nAlso, ensure you have\n{shiny}\ninstalled (for developing the app) and\n{renv}\nto manage dependencies.\nFinally, you should of course have a Shiny application that you want to containerize. For this tutorial, we‚Äôll create a simple example app from scratch.\nExample: Containerizing a Shiny App Step-by-Step\nLet‚Äôs go through the process step by step by containerizing a simple Shiny app. Our example app will be minimal ‚Äì a histogram of the famous Old Faithful geyser data ‚Äì but the process applies to any Shiny app (large or small).\nStep 1: Prepare a Simple Shiny Application\nFirst, we need a Shiny app to containerize. We‚Äôll write a basic\napp.R\nthat defines a UI and server. In a real project, you might have separate\nui.R\nand\nserver.R\nfiles or a more complex app structure, but {shiny2docker} works with any standard Shiny app directory.\n# app.R -- a simple Shiny app \n# (Make sure this file is in its own directory, e.g., \"myapp/app.R\")\n\nlibrary(shiny)\n\n# Define UI for the application\nui <- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Input: Slider for the number of bins in the histogram\n      sliderInput(\"bins\", \"Number of bins:\",\n                  min = 1, max = 50, value = 30)\n    ),\n    mainPanel(\n      # Output: Histogram plot\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\n# Define server logic for the histogram\nserver <- function(input, output) {\n  output$distPlot <- renderPlot({\n    # Draw the histogram using the 'waiting' column of the faithful dataset\n    x <- faithful$waiting  \n    bins <- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x, breaks = bins,\n         col = \"#75AADB\", border = \"white\",\n         xlab = \"Waiting time to next eruption (mins)\",\n         main = \"Histogram of Old Faithful waiting times\")\n  })\n}\n\n# Combine the UI and server into an app and run it\nshinyApp(ui = ui, server = server)\nA quick explanation of the above code: It‚Äôs the classic Shiny example where the user can adjust the number of bins for a histogram. We use\nfaithful$waiting\n(the Old Faithful geyser dataset built into R) as the data. The app has a slider input for the number of bins and displays a histogram that updates as the slider changes. If you save this code as\napp.R\nand run\nshiny::runApp(\"app.R\")\n, you should see the app running locally.\nNow that we have our Shiny app ready in a directory (say, we saved\napp.R\nin a folder called\nmyapp/\n), we‚Äôre ready to containerize it with {shiny2docker}.\nStep 2: Generate a Dockerfile with {shiny2docker}\nThe {shiny2docker} package will inspect our application and produce a Dockerfile (and a corresponding\n.dockerignore\n). Make sure your working directory is set to the folder containing the Shiny app (for example, set it to the\nmyapp\ndirectory we created).\nIn an R session, run the following:\n# In the R console, with working directory set to the Shiny app folder (e.g., \"myapp\")\nlibrary(shiny2docker)\n\n# Generate a Dockerfile for the Shiny app in the current directory\nshiny2docker(path = \".\")\nAfter running\nshiny2docker(path = \".\")\n, you should see some messages in R indicating that a Dockerfile is being created. By default, this will create two files in your app directory:\nDockerfile\n‚Äì a text file with instructions to build an image for your Shiny app.\n.dockerignore\n‚Äì a text file specifying files to exclude from the Docker build context (common entries might include\n.Rproj.user\n,\nrenv/library/\n, etc., which {shiny2docker} populates automatically).\nLet‚Äôs break down what {shiny2docker} does for us when generating the Dockerfile:\nIt checks for an existing\nrenv.lock\nin the directory. If it finds one (meaning you already used {renv} to lock dependencies), it will use that. If not,\n{shiny2docker} will create a lockfile for you\nby analyzing your app‚Äôs\nlibrary()\ncalls to figure out which packages (and versions) are needed. In our simple app, the main package dependency is\nshiny\nitself (plus any default R packages like datasets). The lockfile ensures the container installs the same version of\nshiny\n(and any other packages) that you used locally.\nIt writes a Dockerfile that typically uses a base Docker image suitable for Shiny. In many cases, this will be the\nrocker/geospatial\nimage, which comes with R,Shiny and lot of stuff pre-installed. Using a pre-made base image saves us from manually setting up R and Shiny in the Dockerfile. The Dockerfile will\nFROM\na specific version of rocker/geospatial (for example,\nrocker/geospatial:4.2.2\nif you‚Äôre using R 4.2.2).\nThe Dockerfile will then include instructions to install system libraries and R packages. Thanks to the lockfile, {shiny2docker} knows exactly which R packages (and versions) to install in the container. Typically, the Dockerfile will do something like:\nInstall\nrenv\nin the container (so it can use it to restore packages).\nCopy the\nrenv.lock\nfile (and possibly your R project files) into the container.\nRun\nrenv::restore()\nto install all the required R packages at the locked versions.\nCopy your Shiny app files into the container (e.g., the\napp.R\nor\nui.R\n/\nserver.R\nand any other app resources).\nSet appropriate file permissions and environment variables for the Shiny app (if needed).\nFinally, the Dockerfile will specify a command to launch the Shiny app when the container runs. Usually, this is done by calling\nshiny::runApp()\nor by using the Shiny server default command. For example, it might use an entrypoint that runs something like:\nR -e \"shiny::runApp('/srv/shiny-server', port=3838, host='0.0.0.0')\"\nTo peek at the generated Dockerfile, open it in a text editor. It should look somewhat like this (your exact file may differ in minor details):\nFROM rocker/geospatial:4.4.2\nRUN apt-get update -y && apt-get install -y  make zlib1g-dev git && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock renv.lock\nRUN --mount=type=cache,id=renv-cache,target=/root/.cache/R/renv R -e 'renv::restore()'\nWORKDIR /srv/shiny-server/\nCOPY . /srv/shiny-server/\nEXPOSE 3838\nCMD R -e 'shiny::runApp(\"/srv/shiny-server\",host=\"0.0.0.0\",port=3838)'\nThe above is an\nillustrative example\nof what the Dockerfile might contain. The key points are that it uses the\nrocker/geospatial\nbase image (matching your R version), copies the lockfile and app, installs packages via\nrenv::restore()\n, and sets the container to run a Shiny Server that serves the app. Notice that port 3838 is exposed ‚Äì this is the default port where Shiny Server serves apps.\nAt this stage, without writing any Docker instructions ourselves, we have a Dockerfile ready to go. Now let‚Äôs use it to build a Docker image.\nStep 3: Build the Docker Image\nWith the Dockerfile in place, the next step is to build the Docker image for your Shiny app. This step is done in the terminal (not in R). Open a terminal (or use RStudio‚Äôs Terminal tab) and navigate to the directory containing the Dockerfile (our\nmyapp\nfolder). Then run:\n# Make sure you are in the directory with the Dockerfile\n# Replace 'myshinyapp' with the name you want for your Docker image.\ndocker build -t myshinyapp .\nLet‚Äôs break down this command:\ndocker build\nis the command to build a Docker image.\n-t myshinyapp\ntags the image with the name ‚Äúmyshinyapp‚Äù (you can choose any name; this will be the reference you use to run the container).\n.\n(dot) at the end tells Docker to use the current directory as the build context, looking for the Dockerfile there.\nDocker will then step through the instructions in the Dockerfile. The first time you run this, it may download the base image (rocker/geospatial), which can be a few hundred MB. Then it will install R packages as needed. This process can take a while, especially if your app has many packages, but for our simple app (which just needs base R and shiny) it should be fairly quick.\nKeep an eye on the output in the terminal. You should see Docker downloading layers, installing packages, etc., and hopefully finishing with a message indicating it built the image and tagged it as ‚Äúmyshinyapp:latest‚Äù. If something goes wrong (e.g., a package failing to install), the error logs will appear. In our case, it should build successfully.\nTip:\nIf you change your app or add packages and want to rebuild, you might need to run\ndocker build\nagain. Docker cache will help speed up rebuilds (unchanged steps are cached), but if you add new R packages, the\nrenv::restore()\nstep will install the new ones on rebuild.\nStep 4: Run the Shiny App in a Docker Container\nNow that the image is built, you‚Äôre ready to run your Shiny app in a container. Running the container will start a Shiny Server that hosts your app. Use the following\ndocker run\ncommand:\ndocker run -d -p 80:3838 --name myshinyapp_container myshinyapp\nHere‚Äôs what each part means:\ndocker run\nis the command to start a new container from an image.\n-d\nruns the container in ‚Äúdetached‚Äù mode (in the background). You can omit\n-d\nif you want to run it in the foreground to see logs, but then you‚Äôll need a separate terminal.\n-p 80:3838\nmaps port 3838 inside the container to port 80 on your local machine. This is crucial: the Shiny app is served on container port 3838, and this option exposes it so you can access it via\nhttp://localhost:80\nin your web browser.\n--name myshinyapp_container\ngives the container a friendly name (optional but useful for managing containers). We chose ‚Äúmyshinyapp_container‚Äù here.\nmyshinyapp\nat the end is the name of the image to run (the one we built and tagged in Step 3).\nAfter running this, Docker will start the container. You can check that it‚Äôs running by executing\ndocker ps\n(which should list the running container). Now open your web browser and go to\nhttp://localhost:80\n. You should see your Shiny histogram app running, just as it did locally! üéâ Adjust the slider and the histogram will update, but now note that it‚Äôs running inside a Docker container.\nIf you don‚Äôt see anything or get an error, a few things to check: ‚Äì Ensure Docker is actually running and that the container is up (\ndocker ps\nshould show it). ‚Äì If you‚Äôre on a remote server, make sure to visit the correct host or have the port forwarded. The above assumes local development. ‚Äì Check container logs with\ndocker logs myshinyapp_container\nto see if the Shiny app or server printed any error messages during startup.\nAt this point, you‚Äôve successfully containerized a Shiny app using {shiny2docker}. The app is running in an isolated environment with all its dependencies managed by renv and installed in the container.\nWhen you‚Äôre done, you can stop the container with\ndocker stop myshinyapp_container\nand remove it with\ndocker rm myshinyapp_container\n. The Docker image ‚Äúmyshinyapp‚Äù will remain on your system (viewable with\ndocker images\n), and you can re-run it anytime or push it to a container registry if you want to deploy it elsewhere.\nTips for a Smooth Containerization Process\nContainerizing apps is much easier with {shiny2docker}, but here are some additional tips and best practices to consider:\nKeep Your App Directory Clean:\nSince {shiny2docker} will package everything in your app folder (except what‚Äôs excluded by\n.dockerignore\n), make sure you don‚Äôt have large unused files in there. Use the generated\n.dockerignore\nto exclude things like local datasets, caches, or R project settings that aren‚Äôt needed in the container.\nUse {renv} for Dependency Management:\nEven though {shiny2docker} can create a lockfile for you, it‚Äôs a good practice to use {renv} in your Shiny project from the start. Using {renv} while developing (call\nrenv::init()\nand regularly\nrenv::snapshot()\n) means you‚Äôre explicitly tracking package versions. This not only helps {shiny2docker} but also documents your environment for anyone collaborating on your project.\nTest Locally Before CI/CD:\nIf you plan to integrate with CI/CD (using the provided\nset_gitlab_ci()\nor\nset_github_action()\nfunctions), test building and running your Docker image locally first (as we did above). This helps catch any issues early. Once it works locally, you can confidently add the CI configuration and let your CI pipeline build the image on each\nSecurity Considerations:\nWhen your Shiny app is running in Docker, treat the container as you would a server. Exposing port 3838 is fine for development, but in production you might put a proxy in front or use authentication if needed. Also, avoid including any sensitive credentials in the image. If your app needs API keys or passwords, use environment variables or external configuration rather than hard-coding them in the app or Dockerfile.\nLearn Docker Basics:\nWhile {shiny2docker} abstracts away Dockerfile details, having a basic understanding of Docker is beneficial. Knowing how to build, run, stop containers, and how Docker layers work will help you troubleshoot and optimize your containerized apps. The Dockerfile generated is a great learning resource ‚Äì read through it to see how R packages are installed and how the app is launched. Over time, you might customize it (using the returned\ndockerfiler\nobject from\nshiny2docker()\nif needed).\nConclusion\nContainerizing a Shiny application might seem intimidating at first, especially if you‚Äôre not familiar with Docker. The {shiny2docker} package bridges the gap between Shiny developers and DevOps, providing an easy way to create Docker images for Shiny apps without writing Dockerfiles manually. In our example, we saw how a simple Shiny app can be containerized in just a few steps: generate a Dockerfile, build the image, and run a container. The result is a portable app that runs the same everywhere, which is incredibly useful for deployment and sharing.\nBoth Shiny developers and DevOps engineers can appreciate this workflow: developers don‚Äôt need to become Docker experts to deploy their apps, and DevOps professionals get a reproducible environment defined by code. With containerization, scaling and managing Shiny apps in production (using tools like Kubernetes, ShinyProxy, or cloud services) becomes much more manageable, since each app is encapsulated in its own image.\nWe encourage you to try {shiny2docker} on one of your own Shiny projects. You‚Äôll save time and avoid the pitfalls of environment configuration. For further reading, check out the\n{shiny2docker}\ndocumentation and vignette for more advanced usage, including how to customize the Dockerfile or integrate CI/CD pipelines. Happy containerizing!\nThis post is better presented on its original ThinkR website here:\nContainerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nRtask\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "You can read the original post in its original format on Rtask website by ThinkR here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide Deploying a Shiny application to different servers or sharing it with others can be challenging due to differences in R package versions and system requirements. Containerization offers a solution: by packaging your Shiny app and its environment into a Docker container, you ensure it runs consistently anywhere Docker is available. However, not every Shiny developer is familiar with writing Dockerfiles This post is better presented on its original ThinkR website here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide",
      "meta_keywords": null,
      "og_description": "You can read the original post in its original format on Rtask website by ThinkR here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide Deploying a Shiny application to different servers or sharing it with others can be challenging due to differences in R package versions and system requirements. Containerization offers a solution: by packaging your Shiny app and its environment into a Docker container, you ensure it runs consistently anywhere Docker is available. However, not every Shiny developer is familiar with writing Dockerfiles This post is better presented on its original ThinkR website here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 17.3,
      "sitemap_lastmod": null,
      "twitter_description": "You can read the original post in its original format on Rtask website by ThinkR here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide Deploying a Shiny application to different servers or sharing it with others can be challenging due to differences in R package versions and system requirements. Containerization offers a solution: by packaging your Shiny app and its environment into a Docker container, you ensure it runs consistently anywhere Docker is available. However, not every Shiny developer is familiar with writing Dockerfiles This post is better presented on its original ThinkR website here: Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide",
      "twitter_title": "Containerizing Shiny Apps with {shiny2docker}: A Step-by-Step Guide | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/06/containerizing-shiny-apps-with-shiny2docker-a-step-by-step-guide/",
      "word_count": 3467
    }
  }
}