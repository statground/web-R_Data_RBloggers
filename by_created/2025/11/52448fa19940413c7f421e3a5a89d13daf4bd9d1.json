{
  "id": "52448fa19940413c7f421e3a5a89d13daf4bd9d1",
  "url": "https://www.r-bloggers.com/2008/11/calculating-an-n50-from-velvet-output/",
  "created_at_utc": "2025-11-17T20:41:25Z",
  "data": null,
  "raw_original": {
    "uuid": "266a6362-bdc4-43b7-976a-be1917fec409",
    "created_at": "2025-11-17 20:41:25",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2008/11/calculating-an-n50-from-velvet-output/",
      "crawled_at": "2025-11-17T10:48:42.464410",
      "external_links": [
        {
          "href": "https://jermdemo.blogspot.com/2008/11/calculating-n50-from-velvet-output.html",
          "text": "Jermdemo Raised to the Law"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "http://www.ebi.ac.uk/~zerbino/velvet/",
          "text": "Velvet"
        },
        {
          "href": "https://jermdemo.blogspot.com/2008/11/calculating-n50-from-velvet-output.html",
          "text": "Jermdemo Raised to the Law"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Calculating an N50 from Velvet output | R-bloggers",
      "images": [],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/jeremy-leipzig/",
          "text": "Jeremy Leipzig"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-14627 post type-post status-publish format-standard hentry\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Calculating an N50 from Velvet output</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 25, 2008</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jeremy-leipzig/\">Jeremy Leipzig</a></span>  in Uncategorized | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<p class=\"syndicated-attribution\"><!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://jermdemo.blogspot.com/2008/11/calculating-n50-from-velvet-output.html\"> Jermdemo Raised to the Law</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div></p>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.0-->In sequencing circles the N50 length is a useful heuristic for judging the quality of an assembly. Here is my definition of N50 length, which you may or may not find intuitive:<br/><blockquote></blockquote><blockquote>N50 length is the length of the shortest contig such that the sum of contigs of equal length or longer is at least 50% of the total length of all contigs</blockquote>For example’s sake imagine an assembler has created contigs of the following length (in descending order):<br/><blockquote>91 77 70 69 62 56 45 29 16  4</blockquote>The sum of these is 519bp, so the sum of all contigs equal to or greater than N50 must be equal to or greater than 519/2 or 259.5<br/>We can see by brute force that<br/>91+77=168<br/>91+77+70=238<br/>91+77+70+69=307 (that’ll do)<br/>so the N50 for this assembly is 69bp<br/><br/>Another way to look at this: <blockquote>at least half the nucleotides in this assembly belong to contigs of size 69bp or longer.</blockquote><br/><h3>N50 vs N50 length</h3>Technically N50, as opposed to <span style=\"font-style:italic;\">N50 length</span>, refers to the ordinal of that last contig that pushes it over the brink – in this example 4 (since 69bp is the 4th largest contig). Unfortunately, a higher N50 implies the opposite of a longer N50 length. Some papers refer to N50 length as L50, while most have simply followed the lazy convention of dropping “length” off of “N50 length”. I think it is important to include units with your N50 to minimize confusion.<br/><br/><h3>Contig N50 vs Scaffold N50</h3>Another distinction is often made between contig N50 and scaffold N50. Contigs are “contiguous segments”, while scaffolds (aka supercontigs) consist of contigs separated by gaps. Scaffolds are constructed using paired-end information at the read level and, in major sequencing projects, paired BAC ends. Because the scaffolds sequences are filled with varying quantities of empty N’s, the scaffold N50 should not solely be used as a comparative score of assembly quality.<br/><br/>Velvet, when used with sane expCov settings, is very conservative with regard to scaffolding – so much that the contigs.fa N50 can be virtually considered a contig N50, as opposed to a scaffold N50. More aggressive programs, such as SOAPdenovo, produce separate contig and scaffold files.<br/><br/><h3>Velvet N50 from stats.txt</h3><a href=\"http://www.ebi.ac.uk/~zerbino/velvet/\" rel=\"nofollow\" target=\"_blank\">Velvet</a> is a popular assembler for short sequences that uses DeBruijn graphs and Eulerian graph theory instead of a repetitive align-consensus-align approach. Although it returns an N50 in the course of assembling, I wanted to derive it from the contigs themselves. These contigs are summarized in a table called stats.txt<br/><br/>Using R and its cumulative summation function we can easily compute N50.<br/><br/><span style=\"font-style: italic;\">Strategy: Order the contigs by decreasing size and find the first value for which the cumulative summation is at least half the total sum.</span><br/><br/>Thanks to Barry Rowlingson for providing this solution<br/><br/><pre>\nmyStatsTable&lt;-read.table(\"stats.txt\",header=TRUE)\ncontigs&lt;-rev(sort(myStatsTable$lgth+myKmerValue-1))\nn50&lt;-contigs[cumsum(contigs) &gt;= sum(contigs)/2][1]\n</pre><br/><br/><h3>Beware the kmer</h3>Note: The length in the stats.txt file is given as length=lgth+kmer-1, where kmer is the kmer value chosen for that assembly. The N50 length given in the Log file also appears to be in kmers. <span style=\"font-weight:bold;\">You cannot convert an N50 in kmers to bp by adding kmer-1. The math doesn’t work like that – you need to convert each contig to bp before recalculating N50.</span><br/><br/>Finally, you can calculate N50 from sequences in the contigs.fa, but this file only contains contigs longer than 2-kmers by default. The contigs.fa bp-N50 will sometimes approximate the kmer-N50 in the Log file, but that is not a rule to depend on.\r\n\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.0-->\n<p class=\"syndicated-attribution\"><div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jermdemo.blogspot.com/2008/11/calculating-n50-from-velvet-output.html\"> Jermdemo Raised to the Law</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div></p> </div>\n</article>",
      "main_text": "Calculating an N50 from Velvet output\nPosted on\nNovember 25, 2008\nby\nJeremy Leipzig\nin Uncategorized | 0 Comments\n[This article was first published on\nJermdemo Raised to the Law\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn sequencing circles the N50 length is a useful heuristic for judging the quality of an assembly. Here is my definition of N50 length, which you may or may not find intuitive:\nN50 length is the length of the shortest contig such that the sum of contigs of equal length or longer is at least 50% of the total length of all contigs\nFor example’s sake imagine an assembler has created contigs of the following length (in descending order):\n91 77 70 69 62 56 45 29 16  4\nThe sum of these is 519bp, so the sum of all contigs equal to or greater than N50 must be equal to or greater than 519/2 or 259.5\nWe can see by brute force that\n91+77=168\n91+77+70=238\n91+77+70+69=307 (that’ll do)\nso the N50 for this assembly is 69bp\nAnother way to look at this:\nat least half the nucleotides in this assembly belong to contigs of size 69bp or longer.\nN50 vs N50 length\nTechnically N50, as opposed to\nN50 length\n, refers to the ordinal of that last contig that pushes it over the brink – in this example 4 (since 69bp is the 4th largest contig). Unfortunately, a higher N50 implies the opposite of a longer N50 length. Some papers refer to N50 length as L50, while most have simply followed the lazy convention of dropping “length” off of “N50 length”. I think it is important to include units with your N50 to minimize confusion.\nContig N50 vs Scaffold N50\nAnother distinction is often made between contig N50 and scaffold N50. Contigs are “contiguous segments”, while scaffolds (aka supercontigs) consist of contigs separated by gaps. Scaffolds are constructed using paired-end information at the read level and, in major sequencing projects, paired BAC ends. Because the scaffolds sequences are filled with varying quantities of empty N’s, the scaffold N50 should not solely be used as a comparative score of assembly quality.\nVelvet, when used with sane expCov settings, is very conservative with regard to scaffolding – so much that the contigs.fa N50 can be virtually considered a contig N50, as opposed to a scaffold N50. More aggressive programs, such as SOAPdenovo, produce separate contig and scaffold files.\nVelvet N50 from stats.txt\nVelvet\nis a popular assembler for short sequences that uses DeBruijn graphs and Eulerian graph theory instead of a repetitive align-consensus-align approach. Although it returns an N50 in the course of assembling, I wanted to derive it from the contigs themselves. These contigs are summarized in a table called stats.txt\nUsing R and its cumulative summation function we can easily compute N50.\nStrategy: Order the contigs by decreasing size and find the first value for which the cumulative summation is at least half the total sum.\nThanks to Barry Rowlingson for providing this solution\nmyStatsTable<-read.table(\"stats.txt\",header=TRUE)\ncontigs<-rev(sort(myStatsTable$lgth+myKmerValue-1))\nn50<-contigs[cumsum(contigs) >= sum(contigs)/2][1]\nBeware the kmer\nNote: The length in the stats.txt file is given as length=lgth+kmer-1, where kmer is the kmer value chosen for that assembly. The N50 length given in the Log file also appears to be in kmers.\nYou cannot convert an N50 in kmers to bp by adding kmer-1. The math doesn’t work like that – you need to convert each contig to bp before recalculating N50.\nFinally, you can calculate N50 from sequences in the contigs.fa, but this file only contains contigs longer than 2-kmers by default. The contigs.fa bp-N50 will sometimes approximate the kmer-N50 in the Log file, but that is not a rule to depend on.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nJermdemo Raised to the Law\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "In sequencing circles the N50 length is a useful heuristic for judging the quality of an assembly. Here is my definition of N50 length, which you may or may not find intuitive: N50 length is the length of the shortest contig such that the sum of contigs of equal length or longer is at least 50% of the total length of all contigsFor example's sake imagine an assembler has created contigs of the following length (in descending order):91 77 70 69 62 56 45 29 16 4The sum of these is 519bp, so the sum of all contigs equal to or greater than N50 must be equal to or greater than 519/2 or 259.5We can see by brute force that91+77=16891+77+70=23891+77+70+69=307 (that'll do)so the N50 for this assembly is 69bpAnother way to look at this: at least half the nucleotides in this assembly belong to contigs of size 69bp or longer. N50 vs N50 lengthTechnically N50, as opposed to N50 length, refers to the ordinal of that last contig that pushes it over the brink - in this example 4 (since 69bp is the 4th largest contig). Unfortunately, a higher N50 implies the opposite of a longer N50 length. Some papers refer to N50 length as L50, while most have simply followed the lazy convention of dropping \"length\" off of \"N50 length\". I think it is important to include units with your N50 to minimize confusion.Contig N50 vs Scaffold N50Another distinction is often made between contig N50 and scaffold N50. Contigs are \"contiguous segments\", while scaffolds (aka supercontigs) consist of contigs separated by gaps. Scaffolds are constructed using paired-end information at the read level and, in major sequencing projects, paired BAC ends. Because the scaffolds sequences are filled with varying quantities of empty N's, the scaffold N50 should not solely be used as a comparative score of assembly quality.Velvet, when used with sane expCov settings, is very conservative with regard to scaffolding - so much that the contigs.fa N50 can be virtually considered a contig N50, as opposed to a scaffold N50. More aggressive programs, such as SOAPdenovo, produce separate contig and scaffold files.Velvet N50 from stats.txt Velvet is a popular assembler for short sequences that uses DeBruijn graphs and Eulerian graph theory instead of a repetitive align-consensus-align approach. Although it returns an N50 in the course of assembling, I wanted to derive it from the contigs themselves. These contigs are summarized in a table called stats.txtUsing R and its cumulative summation function we can easily compute N50.Strategy: Order the contigs by decreasing size and find the first value for which the cumulative summation is at least half the total sum.Thanks to Barry Rowlingson for providing this solutionmyStatsTablecontigsn50= sum(contigs)/2][1] Beware the kmerNote: The length in the stats.txt file is given as length=lgth+kmer-1, where kmer is the kmer value chosen for that assembly. The N50 length given in the Log file also appears to be in kmers. You cannot convert an N50 in kmers to bp by adding kmer-1. The math doesn't work like that - you need to convert each contig to bp before recalculating N50.Finally, you can calculate N50 from sequences in the contigs.fa, but this file only contains contigs longer than 2-kmers by default. The contigs.fa bp-N50 will sometimes approximate the kmer-N50 in the Log file, but that is not a rule to depend on.",
      "meta_keywords": null,
      "og_description": "In sequencing circles the N50 length is a useful heuristic for judging the quality of an assembly. Here is my definition of N50 length, which you may or may not find intuitive: N50 length is the length of the shortest contig such that the sum of contigs of equal length or longer is at least 50% of the total length of all contigsFor example's sake imagine an assembler has created contigs of the following length (in descending order):91 77 70 69 62 56 45 29 16 4The sum of these is 519bp, so the sum of all contigs equal to or greater than N50 must be equal to or greater than 519/2 or 259.5We can see by brute force that91+77=16891+77+70=23891+77+70+69=307 (that'll do)so the N50 for this assembly is 69bpAnother way to look at this: at least half the nucleotides in this assembly belong to contigs of size 69bp or longer. N50 vs N50 lengthTechnically N50, as opposed to N50 length, refers to the ordinal of that last contig that pushes it over the brink - in this example 4 (since 69bp is the 4th largest contig). Unfortunately, a higher N50 implies the opposite of a longer N50 length. Some papers refer to N50 length as L50, while most have simply followed the lazy convention of dropping \"length\" off of \"N50 length\". I think it is important to include units with your N50 to minimize confusion.Contig N50 vs Scaffold N50Another distinction is often made between contig N50 and scaffold N50. Contigs are \"contiguous segments\", while scaffolds (aka supercontigs) consist of contigs separated by gaps. Scaffolds are constructed using paired-end information at the read level and, in major sequencing projects, paired BAC ends. Because the scaffolds sequences are filled with varying quantities of empty N's, the scaffold N50 should not solely be used as a comparative score of assembly quality.Velvet, when used with sane expCov settings, is very conservative with regard to scaffolding - so much that the contigs.fa N50 can be virtually considered a contig N50, as opposed to a scaffold N50. More aggressive programs, such as SOAPdenovo, produce separate contig and scaffold files.Velvet N50 from stats.txt Velvet is a popular assembler for short sequences that uses DeBruijn graphs and Eulerian graph theory instead of a repetitive align-consensus-align approach. Although it returns an N50 in the course of assembling, I wanted to derive it from the contigs themselves. These contigs are summarized in a table called stats.txtUsing R and its cumulative summation function we can easily compute N50.Strategy: Order the contigs by decreasing size and find the first value for which the cumulative summation is at least half the total sum.Thanks to Barry Rowlingson for providing this solutionmyStatsTablecontigsn50= sum(contigs)/2][1] Beware the kmerNote: The length in the stats.txt file is given as length=lgth+kmer-1, where kmer is the kmer value chosen for that assembly. The N50 length given in the Log file also appears to be in kmers. You cannot convert an N50 in kmers to bp by adding kmer-1. The math doesn't work like that - you need to convert each contig to bp before recalculating N50.Finally, you can calculate N50 from sequences in the contigs.fa, but this file only contains contigs longer than 2-kmers by default. The contigs.fa bp-N50 will sometimes approximate the kmer-N50 in the Log file, but that is not a rule to depend on.",
      "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
      "og_title": "Calculating an N50 from Velvet output | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 3.8,
      "sitemap_lastmod": "2010-04-17T19:03:09+00:00",
      "twitter_description": "In sequencing circles the N50 length is a useful heuristic for judging the quality of an assembly. Here is my definition of N50 length, which you may or may not find intuitive: N50 length is the length of the shortest contig such that the sum of contigs of equal length or longer is at least 50% of the total length of all contigsFor example's sake imagine an assembler has created contigs of the following length (in descending order):91 77 70 69 62 56 45 29 16 4The sum of these is 519bp, so the sum of all contigs equal to or greater than N50 must be equal to or greater than 519/2 or 259.5We can see by brute force that91+77=16891+77+70=23891+77+70+69=307 (that'll do)so the N50 for this assembly is 69bpAnother way to look at this: at least half the nucleotides in this assembly belong to contigs of size 69bp or longer. N50 vs N50 lengthTechnically N50, as opposed to N50 length, refers to the ordinal of that last contig that pushes it over the brink - in this example 4 (since 69bp is the 4th largest contig). Unfortunately, a higher N50 implies the opposite of a longer N50 length. Some papers refer to N50 length as L50, while most have simply followed the lazy convention of dropping \"length\" off of \"N50 length\". I think it is important to include units with your N50 to minimize confusion.Contig N50 vs Scaffold N50Another distinction is often made between contig N50 and scaffold N50. Contigs are \"contiguous segments\", while scaffolds (aka supercontigs) consist of contigs separated by gaps. Scaffolds are constructed using paired-end information at the read level and, in major sequencing projects, paired BAC ends. Because the scaffolds sequences are filled with varying quantities of empty N's, the scaffold N50 should not solely be used as a comparative score of assembly quality.Velvet, when used with sane expCov settings, is very conservative with regard to scaffolding - so much that the contigs.fa N50 can be virtually considered a contig N50, as opposed to a scaffold N50. More aggressive programs, such as SOAPdenovo, produce separate contig and scaffold files.Velvet N50 from stats.txt Velvet is a popular assembler for short sequences that uses DeBruijn graphs and Eulerian graph theory instead of a repetitive align-consensus-align approach. Although it returns an N50 in the course of assembling, I wanted to derive it from the contigs themselves. These contigs are summarized in a table called stats.txtUsing R and its cumulative summation function we can easily compute N50.Strategy: Order the contigs by decreasing size and find the first value for which the cumulative summation is at least half the total sum.Thanks to Barry Rowlingson for providing this solutionmyStatsTablecontigsn50= sum(contigs)/2][1] Beware the kmerNote: The length in the stats.txt file is given as length=lgth+kmer-1, where kmer is the kmer value chosen for that assembly. The N50 length given in the Log file also appears to be in kmers. You cannot convert an N50 in kmers to bp by adding kmer-1. The math doesn't work like that - you need to convert each contig to bp before recalculating N50.Finally, you can calculate N50 from sequences in the contigs.fa, but this file only contains contigs longer than 2-kmers by default. The contigs.fa bp-N50 will sometimes approximate the kmer-N50 in the Log file, but that is not a rule to depend on.",
      "twitter_title": "Calculating an N50 from Velvet output | R-bloggers",
      "url": "https://www.r-bloggers.com/2008/11/calculating-an-n50-from-velvet-output/",
      "word_count": 769
    }
  }
}