{
  "uuid": "21ca2b6d-eb53-42cf-8ceb-4cb591ccad51",
  "created_at": "2025-11-17 20:39:08",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/11/introduction-to-data-manipulation-in-r-with-dplyr/",
    "crawled_at": "2025-11-17T09:48:34.838020",
    "external_links": [
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/",
        "text": "R on Stats and R"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#introduction",
        "text": "Introduction"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#data",
        "text": "Data"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#dplyr-package",
        "text": "{dplyr} package"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#filter-observations",
        "text": "Filter observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#the-pipe-operator",
        "text": "The pipe operator"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#extract-observations",
        "text": "Extract observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#based-on-their-positions",
        "text": "Based on their positions"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#based-on-their-values",
        "text": "Based on their values"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#sample-observations",
        "text": "Sample observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#sort-observations",
        "text": "Sort observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#select-variables",
        "text": "Select variables"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#rename-variables",
        "text": "Rename variables"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#create-or-modify-variables",
        "text": "Create or modify variables"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#summarize-observations",
        "text": "Summarize observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#identify-distinct-values",
        "text": "Identify distinct values"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#connected-operations",
        "text": "Connected operations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#group-by",
        "text": "Group by"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#number-of-observations",
        "text": "Number of observations"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#number-of-distinct-values",
        "text": "Number of distinct values"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#first-last-or-nth-value",
        "text": "First, last or nth value"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#if-else",
        "text": "If else"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#case-when",
        "text": "Case when"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#conclusion-and-other-resources",
        "text": "Conclusion and other resources"
      },
      {
        "href": "https://statsandr.com/blog/data-manipulation-in-r/",
        "text": "manipulate data in R"
      },
      {
        "href": "https://dplyr.tidyverse.org/",
        "text": "dplyr.tidyverse.org"
      },
      {
        "href": "https://datanalyze.be/trainings/",
        "text": "training"
      },
      {
        "href": "https://statsandr.com/blog/graphics-in-r-with-ggplot2/",
        "text": "how to use{ggplot2}"
      },
      {
        "href": "https://statsandr.com/blog/variable-types-and-examples/#quantitative",
        "text": "quantitative"
      },
      {
        "href": "https://statsandr.com/blog/variable-types-and-examples/#qualitative",
        "text": "qualitative"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#fn1",
        "text": "1"
      },
      {
        "href": "https://statsandr.com/blog/data-types-in-r/#factor",
        "text": "factor"
      },
      {
        "href": "https://statsandr.com/blog/descriptive-statistics-in-r/",
        "text": "descriptive statistics"
      },
      {
        "href": "https://dplyr.tidyverse.org/",
        "text": "dplyr.tidyverse.org"
      },
      {
        "href": "https://r4ds.hadley.nz/data-transform.html",
        "text": "Chapter “Data transformation”"
      },
      {
        "href": "https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf",
        "text": "Cheatsheet"
      },
      {
        "href": "https://dplyr.tidyverse.org/articles/dplyr.html",
        "text": "Vignette"
      },
      {
        "href": "https://cran.r-project.org/web/packages/dplyr/vignettes/base.html",
        "text": "vignette"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#fnref1",
        "text": "↩︎"
      },
      {
        "href": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/",
        "text": "R on Stats and R"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Introduction to data manipulation in R with {dplyr} | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/introduction-to-data-manipulation-in-r-with-dplyr.jpeg?w=578&ssl=1"
      },
      {
        "alt": "Rules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Rules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.",
        "base64": null,
        "src": "https://i1.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/tidy-data.png?w=578&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/r-on-stats-and-r/",
        "text": "R on Stats and R"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-380332 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Introduction to data manipulation in R with {dplyr}</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 26, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-on-stats-and-r/\">R on Stats and R</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/\"> R on Stats and R</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div id=\"TOC\">\n<ul>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#introduction\" id=\"toc-introduction\" rel=\"nofollow\" target=\"_blank\">Introduction</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#data\" id=\"toc-data\" rel=\"nofollow\" target=\"_blank\">Data</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#dplyr-package\" id=\"toc-dplyr-package\" rel=\"nofollow\" target=\"_blank\">{dplyr} package</a>\n<ul>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#filter-observations\" id=\"toc-filter-observations\" rel=\"nofollow\" target=\"_blank\">Filter observations</a>\n<ul>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#the-pipe-operator\" id=\"toc-the-pipe-operator\" rel=\"nofollow\" target=\"_blank\">The pipe operator</a></li>\n</ul></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#extract-observations\" id=\"toc-extract-observations\" rel=\"nofollow\" target=\"_blank\">Extract observations</a>\n<ul>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#based-on-their-positions\" id=\"toc-based-on-their-positions\" rel=\"nofollow\" target=\"_blank\">Based on their positions</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#based-on-their-values\" id=\"toc-based-on-their-values\" rel=\"nofollow\" target=\"_blank\">Based on their values</a></li>\n</ul></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#sample-observations\" id=\"toc-sample-observations\" rel=\"nofollow\" target=\"_blank\">Sample observations</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#sort-observations\" id=\"toc-sort-observations\" rel=\"nofollow\" target=\"_blank\">Sort observations</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#select-variables\" id=\"toc-select-variables\" rel=\"nofollow\" target=\"_blank\">Select variables</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#rename-variables\" id=\"toc-rename-variables\" rel=\"nofollow\" target=\"_blank\">Rename variables</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#create-or-modify-variables\" id=\"toc-create-or-modify-variables\" rel=\"nofollow\" target=\"_blank\">Create or modify variables</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#summarize-observations\" id=\"toc-summarize-observations\" rel=\"nofollow\" target=\"_blank\">Summarize observations</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#identify-distinct-values\" id=\"toc-identify-distinct-values\" rel=\"nofollow\" target=\"_blank\">Identify distinct values</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#connected-operations\" id=\"toc-connected-operations\" rel=\"nofollow\" target=\"_blank\">Connected operations</a>\n<ul>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#group-by\" id=\"toc-group-by\" rel=\"nofollow\" target=\"_blank\">Group by</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#number-of-observations\" id=\"toc-number-of-observations\" rel=\"nofollow\" target=\"_blank\">Number of observations</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#number-of-distinct-values\" id=\"toc-number-of-distinct-values\" rel=\"nofollow\" target=\"_blank\">Number of distinct values</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#first-last-or-nth-value\" id=\"toc-first-last-or-nth-value\" rel=\"nofollow\" target=\"_blank\">First, last or nth value</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#if-else\" id=\"toc-if-else\" rel=\"nofollow\" target=\"_blank\">If else</a></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#case-when\" id=\"toc-case-when\" rel=\"nofollow\" target=\"_blank\">Case when</a></li>\n</ul></li>\n</ul></li>\n<li><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#conclusion-and-other-resources\" id=\"toc-conclusion-and-other-resources\" rel=\"nofollow\" target=\"_blank\">Conclusion and other resources</a></li>\n</ul>\n</div>\n<p><img data-lazy-src=\"https://i2.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/introduction-to-data-manipulation-in-r-with-dplyr.jpeg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width:100.0%\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/introduction-to-data-manipulation-in-r-with-dplyr.jpeg?w=578&amp;ssl=1\" style=\"width:100.0%\"/></noscript></p>\n<div class=\"section level1\" id=\"introduction\">\n<h1>Introduction</h1>\n<p>In a previous post, we showed how to <a href=\"https://statsandr.com/blog/data-manipulation-in-r/\" rel=\"nofollow\" target=\"_blank\">manipulate data in R</a>. In particular, we illustrated how to create and manipulate vectors, factors, lists and data frames. This served as an introduction to R and was aimed at beginners. Moreover, as long as it was possible, all manipulations were made in base R, that is, without having to load any package.</p>\n<p>In this post, we would like to show again how to manipulate data in R, but this time using the <code>{dplyr}</code> package.</p>\n<p>The <code>{dplyr}</code> package, developed by Hadley Wickham and colleagues at posit, provides a complete set of functions that help you solve the most common data manipulation challenges such as:</p>\n<ul>\n<li>filtering observations based on their values</li>\n<li>extracting observations based on their values or positions</li>\n<li>sampling observations based on a specific number or fraction of rows</li>\n<li>sorting observations based on one or several variables</li>\n<li>selecting variables based on their names or positions</li>\n<li>renaming variables</li>\n<li>adding new variables based on existing ones</li>\n<li>summarizing observations or variables to a single descriptive measure</li>\n<li>performing any operation by group</li>\n<li>categorizing observations into two or more groups</li>\n<li>etc.</li>\n</ul>\n<p>More information about the package can be found at <a href=\"https://dplyr.tidyverse.org/\" rel=\"nofollow\" target=\"_blank\">dplyr.tidyverse.org</a>.</p>\n<p>In this post, we will present the most common functions for data manipulation and data management using the <code>{dplyr}</code> package (illustrated on a data frame). This is however not an exhaustive list! It is likely that you will need other functions that the ones presented here. For the interested readers, see the end of this post for further resources.</p>\n<p>A question I am often asked is whether it is best to first learn data manipulation with base R and <em>then</em> with <code>{dplyr}</code>, or directly learn <code>{dplyr}</code>.</p>\n<p>Everyone may not agrees, but here is what I tend to answer. The interest in terms of efficiency and clarity/readability of the code that <code>{dplyr}</code> brings is obvious. So even when I give a <a href=\"https://datanalyze.be/trainings/\" rel=\"nofollow\" target=\"_blank\">training</a> targeted to statisticians, I present the <code>{dplyr}</code> package. However, I still do believe that learning data manipulation with base R is important for two reasons:</p>\n<ol style=\"list-style-type: decimal\">\n<li>Everyone will, at some point, be confronted with code written in base R (either from collaboration with other R users, or from code found in textbooks or online).</li>\n<li>Through the feedback I receive from my students, I notice that <code>{dplyr}</code> is relatively easy to learn when you are familiar with base R (which is quite rewarding for those who struggled at the beginning).</li>\n</ol>\n<p>For these reasons, I tend to teach data manipulation with base R first and then slowly switch to <code>{dplyr}</code> (up to the point that for some advanced training courses, I hardly use base R at all by the end of the course). As a side note, this is the approach I follow for data visualization in R as well: I teach first how to plot data with base R, then I gradually teach them <a href=\"https://statsandr.com/blog/graphics-in-r-with-ggplot2/\" rel=\"nofollow\" target=\"_blank\">how to use <code>{ggplot2}</code></a>.</p>\n<p>With this approach, some students may have the impression that they wasted their time learning base R. At least, some may have this impression during the training. However, as soon as the training is done and they have to learn R by themselves or work on real projects, they are grateful of having learned both.</p>\n<p>I am curious to hear from other teachers regarding their approach, so feel free to share your opinion.</p>\n</div>\n<div class=\"section level1\" id=\"data\">\n<h1>Data</h1>\n<p>To present the different functions, we will use the data frame <code>penguins</code>, available within the <code>{palmerpenguins}</code> package:</p>\n<pre># install.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)</pre>\n<p>Before going further, we rename the data frame as <code>dat</code>:</p>\n<pre>dat &lt;- penguins</pre>\n<p>I like to call data frames I am working on with a generic name such as <code>dat</code> for two reasons:</p>\n<ol style=\"list-style-type: decimal\">\n<li>Every time I need to write the name of the data frame, it is usually shorter to write <code>dat</code> than to write the name of the data frame (which is in this case <code>penguins</code>).</li>\n<li>If I need to do similar analyses or plots on different data frames, the code I wrote in the past can be reused with only a few modifications. With this very simple trick, most of the time I only have to edit the names of the variables, but the name of the data frame does not need to be changed (which saves me a lot of time).</li>\n</ol>\n<p>The data frame contains data for 344 penguins and 8 variables describing the species, the island, some measurements of the size of the bill, flipper and body mass, the sex and the study year. More information about the data frame can be found by running <code>?penguins</code> (after loading the <code>{palmerpenguins}</code> package).</p>\n<p>For this post, we will focus only on the variables <code>species</code>, <code>body_mass_g</code>, <code>sex</code> and <code>year</code>.</p>\n<p>Before proceeding with the different data manipulation techniques, let’s first inspect the data by displaying its structure, the first 6 rows and a summary of it:</p>\n<pre>str(dat) # structure of the data\r\n## tibble [344 × 4] (S3: tbl_df/tbl/data.frame)\n##  $ species    : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ body_mass_g: int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n##  $ sex        : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n##  $ year       : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\r\nhead(dat) # display first 6 rows\r\n## # A tibble: 6 × 4\n##   species body_mass_g sex     year\n##   &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Adelie         3750 male    2007\n## 2 Adelie         3800 female  2007\n## 3 Adelie         3250 female  2007\n## 4 Adelie           NA &lt;NA&gt;    2007\n## 5 Adelie         3450 female  2007\n## 6 Adelie         3650 male    2007\r\nsummary(dat) # summary\r\n##       species     body_mass_g       sex           year     \n##  Adelie   :152   Min.   :2700   female:165   Min.   :2007  \n##  Chinstrap: 68   1st Qu.:3550   male  :168   1st Qu.:2007  \n##  Gentoo   :124   Median :4050   NA's  : 11   Median :2008  \n##                  Mean   :4202                Mean   :2008  \n##                  3rd Qu.:4750                3rd Qu.:2009  \n##                  Max.   :6300                Max.   :2009  \n##                  NA's   :2</pre>\n</div>\n<div class=\"section level1\" id=\"dplyr-package\">\n<h1>{dplyr} package</h1>\n<p>Without further ado, let’s illustrate the different functions for data manipulation available in the <code>{dplyr}</code> package in the following sections.</p>\n<p>As for any package, we first need to install and load it before using it:</p>\n<pre># install.packages(\"dplyr\")\nlibrary(dplyr)</pre>\n<p>Note that all functions presented below requires tidy data, which means that:</p>\n<ul>\n<li>each variable is in its own column,</li>\n<li>each observation, or case, is in its own row, and</li>\n<li>each value is in its own cell.</li>\n</ul>\n<div class=\"float\">\n<img alt=\"Rules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.\" data-lazy-src=\"https://i1.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/tidy-data.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width:100.0%\"/><noscript><img alt=\"Rules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/tidy-data.png?w=578&amp;ssl=1\" style=\"width:100.0%\"/></noscript>\n<div class=\"figcaption\">Rules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.</div>\n</div>\n<p><br/></p>\n<div class=\"section level2\" id=\"filter-observations\">\n<h2>Filter observations</h2>\n<p>Filtering observations based on their values can be done with the <code>filter()</code> function. This function works on both <a href=\"https://statsandr.com/blog/variable-types-and-examples/#quantitative\" rel=\"nofollow\" target=\"_blank\">quantitative</a> and <a href=\"https://statsandr.com/blog/variable-types-and-examples/#qualitative\" rel=\"nofollow\" target=\"_blank\">qualitative</a> variables:</p>\n<pre># filter observations based on a quantitative variable\nfilter(dat, body_mass_g &gt; 4000)\r\n## # A tibble: 172 × 4\n##    species body_mass_g sex    year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n##  1 Adelie         4675 male   2007\n##  2 Adelie         4250 &lt;NA&gt;   2007\n##  3 Adelie         4400 male   2007\n##  4 Adelie         4500 male   2007\n##  5 Adelie         4200 male   2007\n##  6 Adelie         4150 male   2007\n##  7 Adelie         4650 male   2007\n##  8 Adelie         4400 male   2007\n##  9 Adelie         4600 male   2007\n## 10 Adelie         4150 male   2007\n## # ℹ 162 more rows\r\n# filter observations based on a qualitative variable\nfilter(dat, sex == \"female\")\r\n## # A tibble: 165 × 4\n##    species body_mass_g sex     year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Adelie         3800 female  2007\n##  2 Adelie         3250 female  2007\n##  3 Adelie         3450 female  2007\n##  4 Adelie         3625 female  2007\n##  5 Adelie         3200 female  2007\n##  6 Adelie         3700 female  2007\n##  7 Adelie         3450 female  2007\n##  8 Adelie         3325 female  2007\n##  9 Adelie         3400 female  2007\n## 10 Adelie         3800 female  2007\n## # ℹ 155 more rows</pre>\n<p>You can combine several conditions with <code>&amp;</code> (if the conditions must be cumulative) or <code>|</code> (if the conditions are alternatives), for instance:</p>\n<pre># filter observations based on 2 cumulative conditions\nfilter(dat, body_mass_g &gt; 4000 &amp; sex == \"female\")\r\n## # A tibble: 58 × 4\n##    species body_mass_g sex     year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Gentoo         4500 female  2007\n##  2 Gentoo         4450 female  2007\n##  3 Gentoo         4550 female  2007\n##  4 Gentoo         4800 female  2007\n##  5 Gentoo         4400 female  2007\n##  6 Gentoo         4650 female  2007\n##  7 Gentoo         4650 female  2007\n##  8 Gentoo         4200 female  2007\n##  9 Gentoo         4150 female  2007\n## 10 Gentoo         4800 female  2007\n## # ℹ 48 more rows</pre>\n<p>Notice that variable names do <em>not</em> have to be written inside single nor double quotation marks (<code>''</code> or <code>\"\"</code>). This is the case for all functions presented below.</p>\n<div class=\"section level3\" id=\"the-pipe-operator\">\n<h3>The pipe operator</h3>\n<p>As you can see from the code above, the <code>filter()</code> functions requires the name of the data frame as first argument, then the condition (with the usual logical operators <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>%in%</code>, etc.) as second argument.</p>\n<p>Specifying the name of the data frame as first argument is required for all functions presented in this list. However, there is a workaround to specifying the data frame’s name inside the functions: the pipe operator (<code>|&gt;</code> or <code>%&gt;%</code>).<a class=\"footnote-ref\" href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#fn1\" id=\"fnref1\" rel=\"nofollow\" target=\"_blank\"><sup>1</sup></a></p>\n<p>The pipe operator allows to perform a sequence of several operations, that is, chain a sequence of calculations together. It is particularly useful when you are performing several operations on a data frame, and you do not want to save the output at each intermediate step. We will see below how to use the pipe operator with several operations, but for now I would like to introduce it with only one operation at a time.</p>\n<p>As you can see with the <code>filter()</code> function, the pipe operator is not compulsory. However, I recommend it so much (even to beginners) for its easy of use, convenience, code readability and popularity that from now on functions available in <code>{dplyr}</code> will be presented together with the pipe operator.</p>\n<p>So with the pipe operator, the code above becomes:</p>\n<pre># filter observations based on a quantitative variable\ndat |&gt;\n  filter(body_mass_g &gt; 4000)\r\n## # A tibble: 172 × 4\n##    species body_mass_g sex    year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n##  1 Adelie         4675 male   2007\n##  2 Adelie         4250 &lt;NA&gt;   2007\n##  3 Adelie         4400 male   2007\n##  4 Adelie         4500 male   2007\n##  5 Adelie         4200 male   2007\n##  6 Adelie         4150 male   2007\n##  7 Adelie         4650 male   2007\n##  8 Adelie         4400 male   2007\n##  9 Adelie         4600 male   2007\n## 10 Adelie         4150 male   2007\n## # ℹ 162 more rows\r\n# filter observations based on a qualitative variable\ndat |&gt;\n  filter(sex == \"female\")\r\n## # A tibble: 165 × 4\n##    species body_mass_g sex     year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Adelie         3800 female  2007\n##  2 Adelie         3250 female  2007\n##  3 Adelie         3450 female  2007\n##  4 Adelie         3625 female  2007\n##  5 Adelie         3200 female  2007\n##  6 Adelie         3700 female  2007\n##  7 Adelie         3450 female  2007\n##  8 Adelie         3325 female  2007\n##  9 Adelie         3400 female  2007\n## 10 Adelie         3800 female  2007\n## # ℹ 155 more rows\r\n# filter observations based on 2 cumulative conditions\ndat |&gt;\n  filter(body_mass_g &gt; 4000 &amp; sex == \"female\")\r\n## # A tibble: 58 × 4\n##    species body_mass_g sex     year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Gentoo         4500 female  2007\n##  2 Gentoo         4450 female  2007\n##  3 Gentoo         4550 female  2007\n##  4 Gentoo         4800 female  2007\n##  5 Gentoo         4400 female  2007\n##  6 Gentoo         4650 female  2007\n##  7 Gentoo         4650 female  2007\n##  8 Gentoo         4200 female  2007\n##  9 Gentoo         4150 female  2007\n## 10 Gentoo         4800 female  2007\n## # ℹ 48 more rows</pre>\n<p>The pipe operator simply takes the results of one operation into the next operation below it, making the code extremely easy to write and read.</p>\n<p>This way, instead of specifying the data frame’s name as first argument in the <code>filter()</code> function (or any other function within the <code>{dplyr}</code> package), we simply specify the data frame’s name and then the desired function, combined together thanks to the pipe operator.</p>\n</div>\n</div>\n<div class=\"section level2\" id=\"extract-observations\">\n<h2>Extract observations</h2>\n<p>It is possible to extract observations based on:</p>\n<ul>\n<li>their positions, or</li>\n<li>their values.</li>\n</ul>\n<div class=\"section level3\" id=\"based-on-their-positions\">\n<h3>Based on their positions</h3>\n<p>Extracting observations based on their positions can be done with the <code>slice()</code> function:</p>\n<pre># extract rows 2, 5 and 37\ndat |&gt;\n  slice(c(2, 5, 37))\r\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Adelie         3800 female  2007\n## 2 Adelie         3450 female  2007\n## 3 Adelie         3950 male    2007</pre>\n<p>Moreover, extracting the first or last rows can be done with <code>slice_head()</code> and <code>slice_tail()</code>:</p>\n<pre># extract first 3 rows\ndat |&gt;\n  slice_head(n = 3)\r\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Adelie         3750 male    2007\n## 2 Adelie         3800 female  2007\n## 3 Adelie         3250 female  2007\r\n# extract last 3 rows\ndat |&gt;\n  slice_tail(n = 3)\r\n## # A tibble: 3 × 4\n##   species   body_mass_g sex     year\n##   &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Chinstrap        3775 male    2009\n## 2 Chinstrap        4100 male    2009\n## 3 Chinstrap        3775 female  2009</pre>\n</div>\n<div class=\"section level3\" id=\"based-on-their-values\">\n<h3>Based on their values</h3>\n<p>To extract observations based on values of a variable, use:</p>\n<ul>\n<li><code>slice_min()</code> to select rows with the <strong>lowest</strong> values (with a defined proportion), and</li>\n<li><code>slice_max()</code> to select rows with the <strong>highest</strong> values (with a defined proportion).</li>\n</ul>\n<pre># extract observations with 25% lowest body mass\ndat |&gt;\n  slice_min(body_mass_g, prop = 0.25)\r\n## # A tibble: 89 × 4\n##    species   body_mass_g sex     year\n##    &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           2975 &lt;NA&gt;    2007\n## 10 Adelie           3000 female  2007\n## # ℹ 79 more rows\r\n# extract observations with 25% highest body mass\ndat |&gt;\n  slice_max(body_mass_g, prop = 0.25)\r\n## # A tibble: 90 × 4\n##    species body_mass_g sex    year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n##  1 Gentoo         6300 male   2007\n##  2 Gentoo         6050 male   2007\n##  3 Gentoo         6000 male   2008\n##  4 Gentoo         6000 male   2009\n##  5 Gentoo         5950 male   2008\n##  6 Gentoo         5950 male   2009\n##  7 Gentoo         5850 male   2007\n##  8 Gentoo         5850 male   2007\n##  9 Gentoo         5850 male   2009\n## 10 Gentoo         5800 male   2008\n## # ℹ 80 more rows</pre>\n</div>\n</div>\n<div class=\"section level2\" id=\"sample-observations\">\n<h2>Sample observations</h2>\n<p>Sampling observations can be done in two ways:</p>\n<ol style=\"list-style-type: decimal\">\n<li>Random sample of a <strong>number</strong> of rows with <code>sample_n()</code></li>\n<li>Random sample of a <strong>fraction</strong> of rows with <code>sample_frac()</code></li>\n</ol>\n<pre># random sample of 3 rows\ndat |&gt;\n  sample_n(size = 3)\r\n## # A tibble: 3 × 4\n##   species   body_mass_g sex     year\n##   &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Adelie           3450 female  2007\n## 2 Chinstrap        3675 female  2009\n## 3 Gentoo           4500 female  2007\r\n# random sample of half of the rows\ndat |&gt;\n  sample_frac(size = 1 / 2)\r\n## # A tibble: 172 × 4\n##    species   body_mass_g sex     year\n##    &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Adelie           4150 male    2008\n##  2 Gentoo           5800 male    2008\n##  3 Adelie           3650 male    2009\n##  4 Adelie           3500 male    2009\n##  5 Adelie           3450 female  2007\n##  6 Adelie           4300 male    2009\n##  7 Chinstrap        3400 female  2008\n##  8 Adelie           3950 male    2007\n##  9 Chinstrap        3325 female  2009\n## 10 Adelie           3950 male    2008\n## # ℹ 162 more rows</pre>\n<p>Note that, as with the <code>sample()</code> function within base R, <code>size</code> can be greater than the size of the data frame. In this case, some rows will be duplicated, and you will need to specify the argument <code>replace = TRUE</code>.</p>\n<p>Alternatively, it is possible to obtain a random sample of a number of rows or fraction or rows with <code>slice_sample()</code>. For this, use:</p>\n<ul>\n<li>the argument <code>n</code> to select a number of rows, or</li>\n<li>the argument <code>prop</code> to select a fraction of rows.</li>\n</ul>\n<pre># random sample of 3 rows\ndat |&gt;\n  slice_sample(n = 3)\r\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n## 1 Adelie         3200 female  2007\n## 2 Adelie         3800 female  2007\n## 3 Gentoo         4800 female  2007\r\n# random sample of half of the rows\ndat |&gt;\n  slice_sample(prop = 1 / 2)\r\n## # A tibble: 172 × 4\n##    species body_mass_g sex     year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Adelie         3900 male    2009\n##  2 Adelie         3275 female  2009\n##  3 Gentoo         5050 male    2008\n##  4 Gentoo         4700 female  2009\n##  5 Gentoo         4600 female  2008\n##  6 Gentoo         4875 &lt;NA&gt;    2009\n##  7 Adelie         3700 &lt;NA&gt;    2007\n##  8 Gentoo         3950 female  2008\n##  9 Gentoo         4550 female  2007\n## 10 Adelie         3500 female  2008\n## # ℹ 162 more rows</pre>\n</div>\n<div class=\"section level2\" id=\"sort-observations\">\n<h2>Sort observations</h2>\n<p>Sorting observations can be done with the <code>arrange()</code> function:</p>\n<pre># sort observations based on body mass (ascending order)\ndat |&gt;\n  arrange(body_mass_g)\r\n## # A tibble: 344 × 4\n##    species   body_mass_g sex     year\n##    &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           2975 &lt;NA&gt;    2007\n## 10 Adelie           3000 female  2007\n## # ℹ 334 more rows</pre>\n<p>By default, <code>arrange()</code> uses the <strong>ascending</strong> order. To sort in <strong>descending</strong> order, use <code>desc()</code> inside <code>arrange()</code>:</p>\n<pre># sort observations based on body mass (descending order)\ndat |&gt;\n  arrange(desc(body_mass_g))\r\n## # A tibble: 344 × 4\n##    species body_mass_g sex    year\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n##  1 Gentoo         6300 male   2007\n##  2 Gentoo         6050 male   2007\n##  3 Gentoo         6000 male   2008\n##  4 Gentoo         6000 male   2009\n##  5 Gentoo         5950 male   2008\n##  6 Gentoo         5950 male   2009\n##  7 Gentoo         5850 male   2007\n##  8 Gentoo         5850 male   2007\n##  9 Gentoo         5850 male   2009\n## 10 Gentoo         5800 male   2008\n## # ℹ 334 more rows</pre>\n<p>As with <code>filter()</code>, <code>arrange()</code> can be used for several variables and works both on quantitative and qualitative variables:</p>\n<pre># sort observations based on two variables\ndat |&gt;\n  arrange(sex, body_mass_g)\r\n## # A tibble: 344 × 4\n##    species   body_mass_g sex     year\n##    &lt;fct&gt;           &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           3000 female  2007\n## 10 Adelie           3000 female  2009\n## # ℹ 334 more rows</pre>\n<p>The code above sorts the observations first based on the sex (in alphabetical order) and then based on the body mass (in ascending order, so from lowest to highest).</p>\n<p>Note that if the qualitative variable is defined as an ordered <a href=\"https://statsandr.com/blog/data-types-in-r/#factor\" rel=\"nofollow\" target=\"_blank\">factor</a>, the sorting is based on level order, not alphabetical order!</p>\n</div>\n<div class=\"section level2\" id=\"select-variables\">\n<h2>Select variables</h2>\n<p>Selecting variables can be done with the <code>select()</code> function, based on:</p>\n<ul>\n<li>the position of the variable(s), or</li>\n<li>the name(s) of the variable(s).</li>\n</ul>\n<pre># select variables by their positions\ndat |&gt;\n  select(c(2, 4))\r\n## # A tibble: 344 × 2\n##    body_mass_g  year\n##          &lt;int&gt; &lt;int&gt;\n##  1        3750  2007\n##  2        3800  2007\n##  3        3250  2007\n##  4          NA  2007\n##  5        3450  2007\n##  6        3650  2007\n##  7        3625  2007\n##  8        4675  2007\n##  9        3475  2007\n## 10        4250  2007\n## # ℹ 334 more rows\r\n# select variables by their names\ndat |&gt;\n  select(body_mass_g, year)\r\n## # A tibble: 344 × 2\n##    body_mass_g  year\n##          &lt;int&gt; &lt;int&gt;\n##  1        3750  2007\n##  2        3800  2007\n##  3        3250  2007\n##  4          NA  2007\n##  5        3450  2007\n##  6        3650  2007\n##  7        3625  2007\n##  8        4675  2007\n##  9        3475  2007\n## 10        4250  2007\n## # ℹ 334 more rows</pre>\n<p>Note that it is also possible to remove variables. For this, use the <code>-</code> sign in front of their positions or names:</p>\n<pre># remove variables by their positions\ndat |&gt;\n  select(-c(2, 4))\r\n## # A tibble: 344 × 2\n##    species sex   \n##    &lt;fct&gt;   &lt;fct&gt; \n##  1 Adelie  male  \n##  2 Adelie  female\n##  3 Adelie  female\n##  4 Adelie  &lt;NA&gt;  \n##  5 Adelie  female\n##  6 Adelie  male  \n##  7 Adelie  female\n##  8 Adelie  male  \n##  9 Adelie  &lt;NA&gt;  \n## 10 Adelie  &lt;NA&gt;  \n## # ℹ 334 more rows\r\n# remove variables by their names\ndat |&gt;\n  select(-c(body_mass_g, year))\r\n## # A tibble: 344 × 2\n##    species sex   \n##    &lt;fct&gt;   &lt;fct&gt; \n##  1 Adelie  male  \n##  2 Adelie  female\n##  3 Adelie  female\n##  4 Adelie  &lt;NA&gt;  \n##  5 Adelie  female\n##  6 Adelie  male  \n##  7 Adelie  female\n##  8 Adelie  male  \n##  9 Adelie  &lt;NA&gt;  \n## 10 Adelie  &lt;NA&gt;  \n## # ℹ 334 more rows</pre>\n<p>It is also possible to select variables with a sequence of names:</p>\n<pre># select all variables from species to sex\ndat |&gt;\n  select(species:sex)\r\n## # A tibble: 344 × 3\n##    species body_mass_g sex   \n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; \n##  1 Adelie         3750 male  \n##  2 Adelie         3800 female\n##  3 Adelie         3250 female\n##  4 Adelie           NA &lt;NA&gt;  \n##  5 Adelie         3450 female\n##  6 Adelie         3650 male  \n##  7 Adelie         3625 female\n##  8 Adelie         4675 male  \n##  9 Adelie         3475 &lt;NA&gt;  \n## 10 Adelie         4250 &lt;NA&gt;  \n## # ℹ 334 more rows</pre>\n<p>Last but not least, <code>select()</code> can also be used as an easy way to rearrange columns in the desired order:</p>\n<pre># put sex as first column, then all the others\ndat |&gt;\n  select(sex, species:year)\r\n## # A tibble: 344 × 4\n##    sex    species body_mass_g  year\n##    &lt;fct&gt;  &lt;fct&gt;         &lt;int&gt; &lt;int&gt;\n##  1 male   Adelie         3750  2007\n##  2 female Adelie         3800  2007\n##  3 female Adelie         3250  2007\n##  4 &lt;NA&gt;   Adelie           NA  2007\n##  5 female Adelie         3450  2007\n##  6 male   Adelie         3650  2007\n##  7 female Adelie         3625  2007\n##  8 male   Adelie         4675  2007\n##  9 &lt;NA&gt;   Adelie         3475  2007\n## 10 &lt;NA&gt;   Adelie         4250  2007\n## # ℹ 334 more rows</pre>\n</div>\n<div class=\"section level2\" id=\"rename-variables\">\n<h2>Rename variables</h2>\n<p>To rename variables, use the <code>rename()</code> function:</p>\n<pre># rename variables\ndat |&gt;\n  rename(\n    body_mass = body_mass_g, # rename body_mass_g into body_mass\n    study_year = year # rename year into study_year\n  )\r\n## # A tibble: 344 × 4\n##    species body_mass sex    study_year\n##    &lt;fct&gt;       &lt;int&gt; &lt;fct&gt;       &lt;int&gt;\n##  1 Adelie       3750 male         2007\n##  2 Adelie       3800 female       2007\n##  3 Adelie       3250 female       2007\n##  4 Adelie         NA &lt;NA&gt;         2007\n##  5 Adelie       3450 female       2007\n##  6 Adelie       3650 male         2007\n##  7 Adelie       3625 female       2007\n##  8 Adelie       4675 male         2007\n##  9 Adelie       3475 &lt;NA&gt;         2007\n## 10 Adelie       4250 &lt;NA&gt;         2007\n## # ℹ 334 more rows</pre>\n<p>This might not be intuitive (at least it was not for me at the time of learning this package), so bear in mind that you always need to write first the new name and then the old name (separated with the <code>=</code> sign).</p>\n</div>\n<div class=\"section level2\" id=\"create-or-modify-variables\">\n<h2>Create or modify variables</h2>\n<p>You can create or modify certain variables of the data frame with <code>mutate()</code>, based on:</p>\n<ul>\n<li>another variable, or</li>\n<li>a vector of your choice.</li>\n</ul>\n<pre># create a new variable based on an existing one\ndat |&gt;\n  mutate(\n    body_mass_kg = body_mass_g / 1000\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_kg\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt;        &lt;dbl&gt;\n##  1 Adelie         3750 male    2007         3.75\n##  2 Adelie         3800 female  2007         3.8 \n##  3 Adelie         3250 female  2007         3.25\n##  4 Adelie           NA &lt;NA&gt;    2007        NA   \n##  5 Adelie         3450 female  2007         3.45\n##  6 Adelie         3650 male    2007         3.65\n##  7 Adelie         3625 female  2007         3.62\n##  8 Adelie         4675 male    2007         4.68\n##  9 Adelie         3475 &lt;NA&gt;    2007         3.48\n## 10 Adelie         4250 &lt;NA&gt;    2007         4.25\n## # ℹ 334 more rows\r\n# create a new variable from a vector of your choice\ndat |&gt;\n  mutate(\n    ID = 1:nrow(dat)\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year    ID\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt;\n##  1 Adelie         3750 male    2007     1\n##  2 Adelie         3800 female  2007     2\n##  3 Adelie         3250 female  2007     3\n##  4 Adelie           NA &lt;NA&gt;    2007     4\n##  5 Adelie         3450 female  2007     5\n##  6 Adelie         3650 male    2007     6\n##  7 Adelie         3625 female  2007     7\n##  8 Adelie         4675 male    2007     8\n##  9 Adelie         3475 &lt;NA&gt;    2007     9\n## 10 Adelie         4250 &lt;NA&gt;    2007    10\n## # ℹ 334 more rows</pre>\n<p>Note that if you create a variable with a name which already exists in the data frame, the old variable will be erased and replaced by the new one.</p>\n<p>Like <code>rename()</code>, <code>mutate()</code> requires the argument to be written as <code>name = expression</code>, where <code>name</code> is name of the column created or modified and <code>expression</code> is the formula for calculating the values.</p>\n</div>\n<div class=\"section level2\" id=\"summarize-observations\">\n<h2>Summarize observations</h2>\n<p>Often, you will want to summarize the data with some <a href=\"https://statsandr.com/blog/descriptive-statistics-in-r/\" rel=\"nofollow\" target=\"_blank\">descriptive statistics</a>. This can be done with the <code>summarize()</code> function, in addition to most functions used for descriptive statistics (<code>mean()</code>, <code>median()</code>, <code>min()</code>, <code>max()</code>, <code>sd()</code>, <code>var()</code>, etc.):</p>\n<pre># compute mean and sd of body mass\ndat |&gt;\n  summarize(\n    body_mass_mean = mean(body_mass_g, na.rm = TRUE),\n    body_mass_sd = sd(body_mass_g, na.rm = TRUE)\n  )\r\n## # A tibble: 1 × 2\n##   body_mass_mean body_mass_sd\n##            &lt;dbl&gt;        &lt;dbl&gt;\n## 1          4202.         802.</pre>\n<p>Note that:</p>\n<ul>\n<li>The <code>na.rm = TRUE</code> argument is used to omit missing values in the computation of the summary statistics.</li>\n<li><code>summarize()</code> and <code>summarise()</code> give the exact same results.</li>\n</ul>\n</div>\n<div class=\"section level2\" id=\"identify-distinct-values\">\n<h2>Identify distinct values</h2>\n<p>Identifying distinct values of a variable can be done with <code>distinct()</code>:</p>\n<pre># find the distinct species\ndat |&gt;\n  distinct(species)\r\n## # A tibble: 3 × 1\n##   species  \n##   &lt;fct&gt;    \n## 1 Adelie   \n## 2 Gentoo   \n## 3 Chinstrap</pre>\n<p>Identifying distinct values is mostly done on qualitative or quantitative discrete variables, but it can be done on any type of variable and with several variables at the same time. If more than one variables is specified, it returns all the combinations of values of the variables.</p>\n<p>For instance, with species and study year:</p>\n<pre># combination of distinct species and year\ndat |&gt;\n  distinct(species, year)\r\n## # A tibble: 9 × 2\n##   species    year\n##   &lt;fct&gt;     &lt;int&gt;\n## 1 Adelie     2007\n## 2 Adelie     2008\n## 3 Adelie     2009\n## 4 Gentoo     2007\n## 5 Gentoo     2008\n## 6 Gentoo     2009\n## 7 Chinstrap  2007\n## 8 Chinstrap  2008\n## 9 Chinstrap  2009</pre>\n</div>\n<div class=\"section level2\" id=\"connected-operations\">\n<h2>Connected operations</h2>\n<p>Another advantage of using the <code>{dplyr}</code> package is that several operations can be connected all at once, with great readability of the code. This can easily be done with the pipe operator (<code>|&gt;</code> or <code>%&gt;%</code>) introduced earlier.</p>\n<p>Until now, we have always seen the same structure: we call a data frame, and then we apply an operation on that data frame. From now on, we will see how to combine more operations into one single chain of operations.</p>\n<div class=\"section level3\" id=\"group-by\">\n<h3>Group by</h3>\n<p><code>group_by()</code> allows to modify the way the basic functions are performed. Instead of covering all the rows of the data frame, the operations will cover each of the groups of rows defined by the grouping command. In this way, aggregation operations, using <code>summarize()</code>, will produce statistics for each group rather than for all observations.</p>\n<p>For example, we might be interested in computing some descriptive statistics of a quantitative variable, for each level of a qualitative variable (so by group).</p>\n<p>In our case, suppose we would like to compute the mean and standard deviation of the body mass, but this time separately for each species:</p>\n<pre># compute mean and sd of body mass by species\ndat |&gt;\n  group_by(species) |&gt; # group by species\n  summarize(\n    mean = mean(body_mass_g, na.rm = TRUE), # compute mean\n    sd = sd(body_mass_g, na.rm = TRUE) # compute sd\n  )\r\n## # A tibble: 3 × 3\n##   species    mean    sd\n##   &lt;fct&gt;     &lt;dbl&gt; &lt;dbl&gt;\n## 1 Adelie    3701.  459.\n## 2 Chinstrap 3733.  384.\n## 3 Gentoo    5076.  504.</pre>\n<p>Applied to the example above, here is how the pipe operator works:</p>\n<ol style=\"list-style-type: decimal\">\n<li>The first operation (<code>group_by()</code>) groups observations by species.</li>\n<li>Then the output of the first operation is used as the input for the second operation (<code>summarize()</code>): mean and standard deviation are computed on body mass.</li>\n</ol>\n<p>As a result, we have the mean and standard deviation of body mass by group. As you can imagine, all previous operations can be connected to match your needs.</p>\n<p>Also note that <code>group_by()</code> can be used for several grouping variables at the same time:</p>\n<pre># compute mean and sd of body mass by species and sex\ndat |&gt;\n  group_by(species, sex) |&gt; # group by species and sex\n  summarize(\n    mean = mean(body_mass_g, na.rm = TRUE), # compute mean\n    sd = sd(body_mass_g, na.rm = TRUE) # compute sd\n  )\r\n## # A tibble: 8 × 4\n## # Groups:   species [3]\n##   species   sex     mean    sd\n##   &lt;fct&gt;     &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;\n## 1 Adelie    female 3369.  269.\n## 2 Adelie    male   4043.  347.\n## 3 Adelie    &lt;NA&gt;   3540   477.\n## 4 Chinstrap female 3527.  285.\n## 5 Chinstrap male   3939.  362.\n## 6 Gentoo    female 4680.  282.\n## 7 Gentoo    male   5485.  313.\n## 8 Gentoo    &lt;NA&gt;   4588.  338.</pre>\n<p>(Note that, as for all connected operations, the name of the data frame needs to be specified only in the first operation.)</p>\n</div>\n<div class=\"section level3\" id=\"number-of-observations\">\n<h3>Number of observations</h3>\n<p>Some operations can only be performed inside other operations.</p>\n<p>This is the case with the number of observations <code>n()</code>, which can only be used inside <code>summarize()</code>:</p>\n<pre># number of observations\ndat |&gt;\n  summarize(n_obs = n())\r\n## # A tibble: 1 × 1\n##   n_obs\n##   &lt;int&gt;\n## 1   344</pre>\n<p>To refer with the previous connected operation <code>group_by()</code>, we can compute the number of observations by group using the two operations <code>n()</code> and <code>group_by()</code> separated by the pipe operator:</p>\n<pre># number of observations by species\ndat |&gt;\n  group_by(species) |&gt;\n  summarize(n_obs = n())\r\n## # A tibble: 3 × 2\n##   species   n_obs\n##   &lt;fct&gt;     &lt;int&gt;\n## 1 Adelie      152\n## 2 Chinstrap    68\n## 3 Gentoo      124</pre>\n<p>Note that <code>n()</code> accepts no parameters and is therefore always written with empty parentheses.</p>\n<p>Moreover, note also that the <code>count()</code> function is equivalent to <code>summarize(n = n())</code>:</p>\n<pre># number of observations\ndat |&gt;\n  count()\r\n## # A tibble: 1 × 1\n##       n\n##   &lt;int&gt;\n## 1   344\r\n# number of observations by species\ndat |&gt;\n  count(species)\r\n## # A tibble: 3 × 2\n##   species       n\n##   &lt;fct&gt;     &lt;int&gt;\n## 1 Adelie      152\n## 2 Chinstrap    68\n## 3 Gentoo      124</pre>\n</div>\n<div class=\"section level3\" id=\"number-of-distinct-values\">\n<h3>Number of distinct values</h3>\n<p><code>n_distinct()</code>, which can also be used only inside <code>summarize()</code>, computes the number of different values/levels of a variable or combination of variables:</p>\n<pre># number of distinct species\ndat |&gt;\n  summarize(n_species = n_distinct(species))\r\n## # A tibble: 1 × 1\n##   n_species\n##       &lt;int&gt;\n## 1         3\r\n# number of distinct species and year of study\ndat |&gt;\n  summarize(n_species_year = n_distinct(species, year))\r\n## # A tibble: 1 × 1\n##   n_species_year\n##            &lt;int&gt;\n## 1              9</pre>\n<p>Note that you do not have to specify a name for the output. In that case, the name of the operation will be used. For example:</p>\n<pre># number of distinct species\ndat |&gt;\n  summarize(n_distinct(species))\r\n## # A tibble: 1 × 1\n##   `n_distinct(species)`\n##                   &lt;int&gt;\n## 1                     3</pre>\n</div>\n<div class=\"section level3\" id=\"first-last-or-nth-value\">\n<h3>First, last or nth value</h3>\n<p>Also only available inside <code>summarize()</code>, the first, last or nth value can be found with the following commands:</p>\n<pre># first value of the variable sex\ndat |&gt;\n  summarize(first(sex))\r\n## # A tibble: 1 × 1\n##   `first(sex)`\n##   &lt;fct&gt;       \n## 1 male\r\n# last value of the variable sex\ndat |&gt;\n  summarize(last(sex))\r\n## # A tibble: 1 × 1\n##   `last(sex)`\n##   &lt;fct&gt;      \n## 1 female\r\n# 37th value of the variable sex\ndat |&gt;\n  summarize(nth(sex, n = 37))\r\n## # A tibble: 1 × 1\n##   `nth(sex, n = 37)`\n##   &lt;fct&gt;             \n## 1 male</pre>\n<p>Several interesting arguments exist within this function to deal with missing values. For the interested reader, see more information in the documentation of the function (run <code>?nth()</code>).</p>\n</div>\n<div class=\"section level3\" id=\"if-else\">\n<h3>If else</h3>\n<p>A very common data transformation is the well known “if else” technique. This technique is usually used to create, from an existing variable, another variable which can take <strong>two levels</strong>.</p>\n<p>Suppose that we want to create a new variable called <code>body_mass_cat</code>, which takes the value “High” when <code>body_mass_g</code> is equal or greater than a certain threshold, “Low” otherwise. This transformation can be performed with the combination of <code>mutate()</code> and <code>if_else()</code>:</p>\n<pre># if else\ndat |&gt;\n  mutate(\n    body_mass_cat = if_else(body_mass_g &gt;= 4000, # condition\n      \"High\", # output if condition is true\n      \"Low\" # output if condition is false\n    )\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;chr&gt;        \n##  1 Adelie         3750 male    2007 Low          \n##  2 Adelie         3800 female  2007 Low          \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA &lt;NA&gt;    2007 &lt;NA&gt;         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Low          \n##  7 Adelie         3625 female  2007 Low          \n##  8 Adelie         4675 male    2007 High         \n##  9 Adelie         3475 &lt;NA&gt;    2007 Low          \n## 10 Adelie         4250 &lt;NA&gt;    2007 High         \n## # ℹ 334 more rows</pre>\n<p>The <code>if_else()</code> function works with 3 arguments:</p>\n<ol style=\"list-style-type: decimal\">\n<li>The condition (in our case: <code>body_mass_g &gt;= 4000</code>)</li>\n<li>The output value when the condition is true (<code>High</code> in our case).</li>\n<li>The output value when the conditions is false (<code>Low</code> in our case).</li>\n</ol>\n<p>As you can see from the table above, when body mass is missing, <code>if_else()</code> also returns a missing value, which is often a good thing to prevent observations being classified erroneously.</p>\n</div>\n<div class=\"section level3\" id=\"case-when\">\n<h3>Case when</h3>\n<p>If you want to categorize a variable into <strong>more than two levels</strong>, an if else is not the most appropriate tool. In these cases, a “case when” is more appropriate.</p>\n<p>For your information, when I learned R, I used to write nested if else functions, that is, a secondary if else inside a primary if else. Most of the time it worked (with very often a waste of time trying to debug my code), but it is very easy to make a mistake. And even if you managed to make it work, the code is not easy to read at all!</p>\n<p>So I highly recommend using this case when technique instead of several if else functions nested within each other.</p>\n<p>Suppose we want to classify body mass into 3 categories: low, medium and high. For this illustration, we arbitrarily decide that body mass is low when it is strictly lower than 3500, high when it is strictly higher than 4750 and medium otherwise.</p>\n<p>With nested if else functions, here is the code we would need to write:</p>\n<pre># nested if else\ndat |&gt;\n  mutate(\n    body_mass_cat = if_else(body_mass_g &lt; 3500, # first condition\n      \"Low\", # output if first condition is true\n      if_else(body_mass_g &gt; 4750, # second condition when first condition is false\n        \"High\", # output when second condition is true\n        \"Medium\" # output when second condition is false\n      )\n    )\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;chr&gt;        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA &lt;NA&gt;    2007 &lt;NA&gt;         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 &lt;NA&gt;    2007 Low          \n## 10 Adelie         4250 &lt;NA&gt;    2007 Medium       \n## # ℹ 334 more rows</pre>\n<p>This code works as follows:</p>\n<ol style=\"list-style-type: decimal\">\n<li>It evaluates the first condition <code>body_mass_g &lt; 3500</code>.</li>\n<li>If it is true, <code>body_mass_cat</code> is <code>Low</code>. On the contrary, if it is false, it evaluates the second condition <code>body_mass_g &gt; 4750</code>.</li>\n<li>If this second condition is true, <code>body_mass_cat</code> is <code>High</code>, otherwise it is <code>Medium</code>.</li>\n</ol>\n<p>As you can see from the results above, it works. However, you will concede that it is easy to make coding mistakes, and that the code is not easy to write nor to read.</p>\n<p>To improve this workflow, we now use the case when technique:</p>\n<pre># case when, without a default option\ndat |&gt;\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g &lt; 3500 ~ \"Low\",\n      body_mass_g &gt;= 3500 &amp; body_mass_g &lt;= 4750 ~ \"Medium\",\n      body_mass_g &gt; 4750 ~ \"High\"\n    )\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;chr&gt;        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA &lt;NA&gt;    2007 &lt;NA&gt;         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 &lt;NA&gt;    2007 Low          \n## 10 Adelie         4250 &lt;NA&gt;    2007 Medium       \n## # ℹ 334 more rows</pre>\n<p>This workflow is much simpler to code and read!</p>\n<p>If there are no missing values in the variable(s) used for the condition(s), it can even be simplified to:</p>\n<pre># case when, with a default option\ndat |&gt;\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g &lt; 3500 ~ \"Low\",\n      body_mass_g &gt; 4750 ~ \"High\",\n      .default = \"Medium\" # default output\n    )\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;chr&gt;        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA &lt;NA&gt;    2007 Medium       \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 &lt;NA&gt;    2007 Low          \n## 10 Adelie         4250 &lt;NA&gt;    2007 Medium       \n## # ℹ 334 more rows</pre>\n<p>As you can see, a default output can be specified with <code>.default</code> for observations that do not match any of the conditions.</p>\n<p>However, be careful if there are missing values! Indeed, if there is at least one missing value (as in our case), the code above is not correct because observations with missing <code>body_mass_g</code> will be misclassified as <code>Medium</code>.</p>\n<p>Therefore, if you really want to specify a default output, I recommend using the code below which keeps missing values as <code>NA</code>:</p>\n<pre># case when, with a default option and missing values\ndat |&gt;\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g &lt; 3500 ~ \"Low\",\n      body_mass_g &gt; 4750 ~ \"High\",\n      is.na(body_mass_g) ~ NA, # keep missing values as NA\n      .default = \"Medium\" # default output\n    )\n  )\r\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    &lt;fct&gt;         &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;chr&gt;        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA &lt;NA&gt;    2007 &lt;NA&gt;         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 &lt;NA&gt;    2007 Low          \n## 10 Adelie         4250 &lt;NA&gt;    2007 Medium       \n## # ℹ 334 more rows</pre>\n<p>I personally prefer to write all categories and not write a default option for improved code readability and robustness of my code, but it is more a personal opinion.</p>\n<p>In all cases, no matter if you used an if else or a case when, it is a good practice to check the variable you just created to make sure that you obtain the intended results.</p>\n</div>\n</div>\n</div>\n<div class=\"section level1\" id=\"conclusion-and-other-resources\">\n<h1>Conclusion and other resources</h1>\n<p>Thanks for reading.</p>\n<p>This article introduced and illustrated the most common data manipulation and data management tools in R, using the <code>{dplyr}</code> package. We also introduced the pipe operator, well known to users of modern R packages.</p>\n<p>The <code>{dplyr}</code> package offers many more functions for data manipulation (in particular to merge data frames with the family of <code>join()</code> functions). If you would like to learn more about this package, I recommend starting with the following resources:</p>\n<ul>\n<li><a href=\"https://dplyr.tidyverse.org/\" rel=\"nofollow\" target=\"_blank\">dplyr.tidyverse.org</a></li>\n<li><a href=\"https://r4ds.hadley.nz/data-transform.html\" rel=\"nofollow\" target=\"_blank\">Chapter “Data transformation”</a> in the book “R for Data Science”</li>\n<li><a href=\"https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf\" rel=\"nofollow\" target=\"_blank\">Cheatsheet</a></li>\n<li><a href=\"https://dplyr.tidyverse.org/articles/dplyr.html\" rel=\"nofollow\" target=\"_blank\">Vignette</a></li>\n<li>For those who are used to base R, a <a href=\"https://cran.r-project.org/web/packages/dplyr/vignettes/base.html\" rel=\"nofollow\" target=\"_blank\">vignette</a> comparing <code>{dplyr}</code> functions to their base R equivalents</li>\n</ul>\n<p>As always, if you have a question or a suggestion related to the topic covered in this article, please add it as a comment so other readers can benefit from the discussion.</p>\n</div>\n<div class=\"footnotes footnotes-end-of-document\">\n<hr>\n<ol>\n<li id=\"fn1\"><p>The keyboard shortcut for the pipe operator is <code>ctrl + shift + m</code> (Windows) or <code>cmd + shift + m</code> (Mac). It will print <code>%&gt;%</code>, unless you specified to use the native pipe operator <code>|&gt;</code> in the settings of RStudio.<a class=\"footnote-back\" href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#fnref1\" rel=\"nofollow\" target=\"_blank\">↩︎</a></p></li>\n</ol>\n</hr></div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/\"> R on Stats and R</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div> </div>\n</article>",
    "main_text": "Introduction to data manipulation in R with {dplyr}\nPosted on\nNovember 26, 2023\nby\nR on Stats and R\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR on Stats and R\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIntroduction\nData\n{dplyr} package\nFilter observations\nThe pipe operator\nExtract observations\nBased on their positions\nBased on their values\nSample observations\nSort observations\nSelect variables\nRename variables\nCreate or modify variables\nSummarize observations\nIdentify distinct values\nConnected operations\nGroup by\nNumber of observations\nNumber of distinct values\nFirst, last or nth value\nIf else\nCase when\nConclusion and other resources\nIntroduction\nIn a previous post, we showed how to\nmanipulate data in R\n. In particular, we illustrated how to create and manipulate vectors, factors, lists and data frames. This served as an introduction to R and was aimed at beginners. Moreover, as long as it was possible, all manipulations were made in base R, that is, without having to load any package.\nIn this post, we would like to show again how to manipulate data in R, but this time using the\n{dplyr}\npackage.\nThe\n{dplyr}\npackage, developed by Hadley Wickham and colleagues at posit, provides a complete set of functions that help you solve the most common data manipulation challenges such as:\nfiltering observations based on their values\nextracting observations based on their values or positions\nsampling observations based on a specific number or fraction of rows\nsorting observations based on one or several variables\nselecting variables based on their names or positions\nrenaming variables\nadding new variables based on existing ones\nsummarizing observations or variables to a single descriptive measure\nperforming any operation by group\ncategorizing observations into two or more groups\netc.\nMore information about the package can be found at\ndplyr.tidyverse.org\n.\nIn this post, we will present the most common functions for data manipulation and data management using the\n{dplyr}\npackage (illustrated on a data frame). This is however not an exhaustive list! It is likely that you will need other functions that the ones presented here. For the interested readers, see the end of this post for further resources.\nA question I am often asked is whether it is best to first learn data manipulation with base R and\nthen\nwith\n{dplyr}\n, or directly learn\n{dplyr}\n.\nEveryone may not agrees, but here is what I tend to answer. The interest in terms of efficiency and clarity/readability of the code that\n{dplyr}\nbrings is obvious. So even when I give a\ntraining\ntargeted to statisticians, I present the\n{dplyr}\npackage. However, I still do believe that learning data manipulation with base R is important for two reasons:\nEveryone will, at some point, be confronted with code written in base R (either from collaboration with other R users, or from code found in textbooks or online).\nThrough the feedback I receive from my students, I notice that\n{dplyr}\nis relatively easy to learn when you are familiar with base R (which is quite rewarding for those who struggled at the beginning).\nFor these reasons, I tend to teach data manipulation with base R first and then slowly switch to\n{dplyr}\n(up to the point that for some advanced training courses, I hardly use base R at all by the end of the course). As a side note, this is the approach I follow for data visualization in R as well: I teach first how to plot data with base R, then I gradually teach them\nhow to use\n{ggplot2}\n.\nWith this approach, some students may have the impression that they wasted their time learning base R. At least, some may have this impression during the training. However, as soon as the training is done and they have to learn R by themselves or work on real projects, they are grateful of having learned both.\nI am curious to hear from other teachers regarding their approach, so feel free to share your opinion.\nData\nTo present the different functions, we will use the data frame\npenguins\n, available within the\n{palmerpenguins}\npackage:\n# install.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\nBefore going further, we rename the data frame as\ndat\n:\ndat <- penguins\nI like to call data frames I am working on with a generic name such as\ndat\nfor two reasons:\nEvery time I need to write the name of the data frame, it is usually shorter to write\ndat\nthan to write the name of the data frame (which is in this case\npenguins\n).\nIf I need to do similar analyses or plots on different data frames, the code I wrote in the past can be reused with only a few modifications. With this very simple trick, most of the time I only have to edit the names of the variables, but the name of the data frame does not need to be changed (which saves me a lot of time).\nThe data frame contains data for 344 penguins and 8 variables describing the species, the island, some measurements of the size of the bill, flipper and body mass, the sex and the study year. More information about the data frame can be found by running\n?penguins\n(after loading the\n{palmerpenguins}\npackage).\nFor this post, we will focus only on the variables\nspecies\n,\nbody_mass_g\n,\nsex\nand\nyear\n.\nBefore proceeding with the different data manipulation techniques, let’s first inspect the data by displaying its structure, the first 6 rows and a summary of it:\nstr(dat) # structure of the data\n## tibble [344 × 4] (S3: tbl_df/tbl/data.frame)\n##  $ species    : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ body_mass_g: int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n##  $ sex        : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n##  $ year       : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\nhead(dat) # display first 6 rows\n## # A tibble: 6 × 4\n##   species body_mass_g sex     year\n##   <fct>         <int> <fct>  <int>\n## 1 Adelie         3750 male    2007\n## 2 Adelie         3800 female  2007\n## 3 Adelie         3250 female  2007\n## 4 Adelie           NA <NA>    2007\n## 5 Adelie         3450 female  2007\n## 6 Adelie         3650 male    2007\nsummary(dat) # summary\n##       species     body_mass_g       sex           year     \n##  Adelie   :152   Min.   :2700   female:165   Min.   :2007  \n##  Chinstrap: 68   1st Qu.:3550   male  :168   1st Qu.:2007  \n##  Gentoo   :124   Median :4050   NA's  : 11   Median :2008  \n##                  Mean   :4202                Mean   :2008  \n##                  3rd Qu.:4750                3rd Qu.:2009  \n##                  Max.   :6300                Max.   :2009  \n##                  NA's   :2\n{dplyr} package\nWithout further ado, let’s illustrate the different functions for data manipulation available in the\n{dplyr}\npackage in the following sections.\nAs for any package, we first need to install and load it before using it:\n# install.packages(\"dplyr\")\nlibrary(dplyr)\nNote that all functions presented below requires tidy data, which means that:\neach variable is in its own column,\neach observation, or case, is in its own row, and\neach value is in its own cell.\nRules of a tidy data frame: variables are columns, observations are rows, and values are cells. Source: R for Data Science (2e) by H. Wickham, M. Çetinkaya-Rundel and G. Grolemund.\nFilter observations\nFiltering observations based on their values can be done with the\nfilter()\nfunction. This function works on both\nquantitative\nand\nqualitative\nvariables:\n# filter observations based on a quantitative variable\nfilter(dat, body_mass_g > 4000)\n## # A tibble: 172 × 4\n##    species body_mass_g sex    year\n##    <fct>         <int> <fct> <int>\n##  1 Adelie         4675 male   2007\n##  2 Adelie         4250 <NA>   2007\n##  3 Adelie         4400 male   2007\n##  4 Adelie         4500 male   2007\n##  5 Adelie         4200 male   2007\n##  6 Adelie         4150 male   2007\n##  7 Adelie         4650 male   2007\n##  8 Adelie         4400 male   2007\n##  9 Adelie         4600 male   2007\n## 10 Adelie         4150 male   2007\n## # ℹ 162 more rows\n# filter observations based on a qualitative variable\nfilter(dat, sex == \"female\")\n## # A tibble: 165 × 4\n##    species body_mass_g sex     year\n##    <fct>         <int> <fct>  <int>\n##  1 Adelie         3800 female  2007\n##  2 Adelie         3250 female  2007\n##  3 Adelie         3450 female  2007\n##  4 Adelie         3625 female  2007\n##  5 Adelie         3200 female  2007\n##  6 Adelie         3700 female  2007\n##  7 Adelie         3450 female  2007\n##  8 Adelie         3325 female  2007\n##  9 Adelie         3400 female  2007\n## 10 Adelie         3800 female  2007\n## # ℹ 155 more rows\nYou can combine several conditions with\n&\n(if the conditions must be cumulative) or\n|\n(if the conditions are alternatives), for instance:\n# filter observations based on 2 cumulative conditions\nfilter(dat, body_mass_g > 4000 & sex == \"female\")\n## # A tibble: 58 × 4\n##    species body_mass_g sex     year\n##    <fct>         <int> <fct>  <int>\n##  1 Gentoo         4500 female  2007\n##  2 Gentoo         4450 female  2007\n##  3 Gentoo         4550 female  2007\n##  4 Gentoo         4800 female  2007\n##  5 Gentoo         4400 female  2007\n##  6 Gentoo         4650 female  2007\n##  7 Gentoo         4650 female  2007\n##  8 Gentoo         4200 female  2007\n##  9 Gentoo         4150 female  2007\n## 10 Gentoo         4800 female  2007\n## # ℹ 48 more rows\nNotice that variable names do\nnot\nhave to be written inside single nor double quotation marks (\n''\nor\n\"\"\n). This is the case for all functions presented below.\nThe pipe operator\nAs you can see from the code above, the\nfilter()\nfunctions requires the name of the data frame as first argument, then the condition (with the usual logical operators\n>\n,\n<\n,\n>=\n,\n<=\n,\n==\n,\n!=\n,\n%in%\n, etc.) as second argument.\nSpecifying the name of the data frame as first argument is required for all functions presented in this list. However, there is a workaround to specifying the data frame’s name inside the functions: the pipe operator (\n|>\nor\n%>%\n).\n1\nThe pipe operator allows to perform a sequence of several operations, that is, chain a sequence of calculations together. It is particularly useful when you are performing several operations on a data frame, and you do not want to save the output at each intermediate step. We will see below how to use the pipe operator with several operations, but for now I would like to introduce it with only one operation at a time.\nAs you can see with the\nfilter()\nfunction, the pipe operator is not compulsory. However, I recommend it so much (even to beginners) for its easy of use, convenience, code readability and popularity that from now on functions available in\n{dplyr}\nwill be presented together with the pipe operator.\nSo with the pipe operator, the code above becomes:\n# filter observations based on a quantitative variable\ndat |>\n  filter(body_mass_g > 4000)\n## # A tibble: 172 × 4\n##    species body_mass_g sex    year\n##    <fct>         <int> <fct> <int>\n##  1 Adelie         4675 male   2007\n##  2 Adelie         4250 <NA>   2007\n##  3 Adelie         4400 male   2007\n##  4 Adelie         4500 male   2007\n##  5 Adelie         4200 male   2007\n##  6 Adelie         4150 male   2007\n##  7 Adelie         4650 male   2007\n##  8 Adelie         4400 male   2007\n##  9 Adelie         4600 male   2007\n## 10 Adelie         4150 male   2007\n## # ℹ 162 more rows\n# filter observations based on a qualitative variable\ndat |>\n  filter(sex == \"female\")\n## # A tibble: 165 × 4\n##    species body_mass_g sex     year\n##    <fct>         <int> <fct>  <int>\n##  1 Adelie         3800 female  2007\n##  2 Adelie         3250 female  2007\n##  3 Adelie         3450 female  2007\n##  4 Adelie         3625 female  2007\n##  5 Adelie         3200 female  2007\n##  6 Adelie         3700 female  2007\n##  7 Adelie         3450 female  2007\n##  8 Adelie         3325 female  2007\n##  9 Adelie         3400 female  2007\n## 10 Adelie         3800 female  2007\n## # ℹ 155 more rows\n# filter observations based on 2 cumulative conditions\ndat |>\n  filter(body_mass_g > 4000 & sex == \"female\")\n## # A tibble: 58 × 4\n##    species body_mass_g sex     year\n##    <fct>         <int> <fct>  <int>\n##  1 Gentoo         4500 female  2007\n##  2 Gentoo         4450 female  2007\n##  3 Gentoo         4550 female  2007\n##  4 Gentoo         4800 female  2007\n##  5 Gentoo         4400 female  2007\n##  6 Gentoo         4650 female  2007\n##  7 Gentoo         4650 female  2007\n##  8 Gentoo         4200 female  2007\n##  9 Gentoo         4150 female  2007\n## 10 Gentoo         4800 female  2007\n## # ℹ 48 more rows\nThe pipe operator simply takes the results of one operation into the next operation below it, making the code extremely easy to write and read.\nThis way, instead of specifying the data frame’s name as first argument in the\nfilter()\nfunction (or any other function within the\n{dplyr}\npackage), we simply specify the data frame’s name and then the desired function, combined together thanks to the pipe operator.\nExtract observations\nIt is possible to extract observations based on:\ntheir positions, or\ntheir values.\nBased on their positions\nExtracting observations based on their positions can be done with the\nslice()\nfunction:\n# extract rows 2, 5 and 37\ndat |>\n  slice(c(2, 5, 37))\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   <fct>         <int> <fct>  <int>\n## 1 Adelie         3800 female  2007\n## 2 Adelie         3450 female  2007\n## 3 Adelie         3950 male    2007\nMoreover, extracting the first or last rows can be done with\nslice_head()\nand\nslice_tail()\n:\n# extract first 3 rows\ndat |>\n  slice_head(n = 3)\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   <fct>         <int> <fct>  <int>\n## 1 Adelie         3750 male    2007\n## 2 Adelie         3800 female  2007\n## 3 Adelie         3250 female  2007\n# extract last 3 rows\ndat |>\n  slice_tail(n = 3)\n## # A tibble: 3 × 4\n##   species   body_mass_g sex     year\n##   <fct>           <int> <fct>  <int>\n## 1 Chinstrap        3775 male    2009\n## 2 Chinstrap        4100 male    2009\n## 3 Chinstrap        3775 female  2009\nBased on their values\nTo extract observations based on values of a variable, use:\nslice_min()\nto select rows with the\nlowest\nvalues (with a defined proportion), and\nslice_max()\nto select rows with the\nhighest\nvalues (with a defined proportion).\n# extract observations with 25% lowest body mass\ndat |>\n  slice_min(body_mass_g, prop = 0.25)\n## # A tibble: 89 × 4\n##    species   body_mass_g sex     year\n##    <fct>           <int> <fct>  <int>\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           2975 <NA>    2007\n## 10 Adelie           3000 female  2007\n## # ℹ 79 more rows\n# extract observations with 25% highest body mass\ndat |>\n  slice_max(body_mass_g, prop = 0.25)\n## # A tibble: 90 × 4\n##    species body_mass_g sex    year\n##    <fct>         <int> <fct> <int>\n##  1 Gentoo         6300 male   2007\n##  2 Gentoo         6050 male   2007\n##  3 Gentoo         6000 male   2008\n##  4 Gentoo         6000 male   2009\n##  5 Gentoo         5950 male   2008\n##  6 Gentoo         5950 male   2009\n##  7 Gentoo         5850 male   2007\n##  8 Gentoo         5850 male   2007\n##  9 Gentoo         5850 male   2009\n## 10 Gentoo         5800 male   2008\n## # ℹ 80 more rows\nSample observations\nSampling observations can be done in two ways:\nRandom sample of a\nnumber\nof rows with\nsample_n()\nRandom sample of a\nfraction\nof rows with\nsample_frac()\n# random sample of 3 rows\ndat |>\n  sample_n(size = 3)\n## # A tibble: 3 × 4\n##   species   body_mass_g sex     year\n##   <fct>           <int> <fct>  <int>\n## 1 Adelie           3450 female  2007\n## 2 Chinstrap        3675 female  2009\n## 3 Gentoo           4500 female  2007\n# random sample of half of the rows\ndat |>\n  sample_frac(size = 1 / 2)\n## # A tibble: 172 × 4\n##    species   body_mass_g sex     year\n##    <fct>           <int> <fct>  <int>\n##  1 Adelie           4150 male    2008\n##  2 Gentoo           5800 male    2008\n##  3 Adelie           3650 male    2009\n##  4 Adelie           3500 male    2009\n##  5 Adelie           3450 female  2007\n##  6 Adelie           4300 male    2009\n##  7 Chinstrap        3400 female  2008\n##  8 Adelie           3950 male    2007\n##  9 Chinstrap        3325 female  2009\n## 10 Adelie           3950 male    2008\n## # ℹ 162 more rows\nNote that, as with the\nsample()\nfunction within base R,\nsize\ncan be greater than the size of the data frame. In this case, some rows will be duplicated, and you will need to specify the argument\nreplace = TRUE\n.\nAlternatively, it is possible to obtain a random sample of a number of rows or fraction or rows with\nslice_sample()\n. For this, use:\nthe argument\nn\nto select a number of rows, or\nthe argument\nprop\nto select a fraction of rows.\n# random sample of 3 rows\ndat |>\n  slice_sample(n = 3)\n## # A tibble: 3 × 4\n##   species body_mass_g sex     year\n##   <fct>         <int> <fct>  <int>\n## 1 Adelie         3200 female  2007\n## 2 Adelie         3800 female  2007\n## 3 Gentoo         4800 female  2007\n# random sample of half of the rows\ndat |>\n  slice_sample(prop = 1 / 2)\n## # A tibble: 172 × 4\n##    species body_mass_g sex     year\n##    <fct>         <int> <fct>  <int>\n##  1 Adelie         3900 male    2009\n##  2 Adelie         3275 female  2009\n##  3 Gentoo         5050 male    2008\n##  4 Gentoo         4700 female  2009\n##  5 Gentoo         4600 female  2008\n##  6 Gentoo         4875 <NA>    2009\n##  7 Adelie         3700 <NA>    2007\n##  8 Gentoo         3950 female  2008\n##  9 Gentoo         4550 female  2007\n## 10 Adelie         3500 female  2008\n## # ℹ 162 more rows\nSort observations\nSorting observations can be done with the\narrange()\nfunction:\n# sort observations based on body mass (ascending order)\ndat |>\n  arrange(body_mass_g)\n## # A tibble: 344 × 4\n##    species   body_mass_g sex     year\n##    <fct>           <int> <fct>  <int>\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           2975 <NA>    2007\n## 10 Adelie           3000 female  2007\n## # ℹ 334 more rows\nBy default,\narrange()\nuses the\nascending\norder. To sort in\ndescending\norder, use\ndesc()\ninside\narrange()\n:\n# sort observations based on body mass (descending order)\ndat |>\n  arrange(desc(body_mass_g))\n## # A tibble: 344 × 4\n##    species body_mass_g sex    year\n##    <fct>         <int> <fct> <int>\n##  1 Gentoo         6300 male   2007\n##  2 Gentoo         6050 male   2007\n##  3 Gentoo         6000 male   2008\n##  4 Gentoo         6000 male   2009\n##  5 Gentoo         5950 male   2008\n##  6 Gentoo         5950 male   2009\n##  7 Gentoo         5850 male   2007\n##  8 Gentoo         5850 male   2007\n##  9 Gentoo         5850 male   2009\n## 10 Gentoo         5800 male   2008\n## # ℹ 334 more rows\nAs with\nfilter()\n,\narrange()\ncan be used for several variables and works both on quantitative and qualitative variables:\n# sort observations based on two variables\ndat |>\n  arrange(sex, body_mass_g)\n## # A tibble: 344 × 4\n##    species   body_mass_g sex     year\n##    <fct>           <int> <fct>  <int>\n##  1 Chinstrap        2700 female  2008\n##  2 Adelie           2850 female  2008\n##  3 Adelie           2850 female  2008\n##  4 Adelie           2900 female  2008\n##  5 Adelie           2900 female  2008\n##  6 Adelie           2900 female  2009\n##  7 Chinstrap        2900 female  2007\n##  8 Adelie           2925 female  2009\n##  9 Adelie           3000 female  2007\n## 10 Adelie           3000 female  2009\n## # ℹ 334 more rows\nThe code above sorts the observations first based on the sex (in alphabetical order) and then based on the body mass (in ascending order, so from lowest to highest).\nNote that if the qualitative variable is defined as an ordered\nfactor\n, the sorting is based on level order, not alphabetical order!\nSelect variables\nSelecting variables can be done with the\nselect()\nfunction, based on:\nthe position of the variable(s), or\nthe name(s) of the variable(s).\n# select variables by their positions\ndat |>\n  select(c(2, 4))\n## # A tibble: 344 × 2\n##    body_mass_g  year\n##          <int> <int>\n##  1        3750  2007\n##  2        3800  2007\n##  3        3250  2007\n##  4          NA  2007\n##  5        3450  2007\n##  6        3650  2007\n##  7        3625  2007\n##  8        4675  2007\n##  9        3475  2007\n## 10        4250  2007\n## # ℹ 334 more rows\n# select variables by their names\ndat |>\n  select(body_mass_g, year)\n## # A tibble: 344 × 2\n##    body_mass_g  year\n##          <int> <int>\n##  1        3750  2007\n##  2        3800  2007\n##  3        3250  2007\n##  4          NA  2007\n##  5        3450  2007\n##  6        3650  2007\n##  7        3625  2007\n##  8        4675  2007\n##  9        3475  2007\n## 10        4250  2007\n## # ℹ 334 more rows\nNote that it is also possible to remove variables. For this, use the\n-\nsign in front of their positions or names:\n# remove variables by their positions\ndat |>\n  select(-c(2, 4))\n## # A tibble: 344 × 2\n##    species sex   \n##    <fct>   <fct> \n##  1 Adelie  male  \n##  2 Adelie  female\n##  3 Adelie  female\n##  4 Adelie  <NA>  \n##  5 Adelie  female\n##  6 Adelie  male  \n##  7 Adelie  female\n##  8 Adelie  male  \n##  9 Adelie  <NA>  \n## 10 Adelie  <NA>  \n## # ℹ 334 more rows\n# remove variables by their names\ndat |>\n  select(-c(body_mass_g, year))\n## # A tibble: 344 × 2\n##    species sex   \n##    <fct>   <fct> \n##  1 Adelie  male  \n##  2 Adelie  female\n##  3 Adelie  female\n##  4 Adelie  <NA>  \n##  5 Adelie  female\n##  6 Adelie  male  \n##  7 Adelie  female\n##  8 Adelie  male  \n##  9 Adelie  <NA>  \n## 10 Adelie  <NA>  \n## # ℹ 334 more rows\nIt is also possible to select variables with a sequence of names:\n# select all variables from species to sex\ndat |>\n  select(species:sex)\n## # A tibble: 344 × 3\n##    species body_mass_g sex   \n##    <fct>         <int> <fct> \n##  1 Adelie         3750 male  \n##  2 Adelie         3800 female\n##  3 Adelie         3250 female\n##  4 Adelie           NA <NA>  \n##  5 Adelie         3450 female\n##  6 Adelie         3650 male  \n##  7 Adelie         3625 female\n##  8 Adelie         4675 male  \n##  9 Adelie         3475 <NA>  \n## 10 Adelie         4250 <NA>  \n## # ℹ 334 more rows\nLast but not least,\nselect()\ncan also be used as an easy way to rearrange columns in the desired order:\n# put sex as first column, then all the others\ndat |>\n  select(sex, species:year)\n## # A tibble: 344 × 4\n##    sex    species body_mass_g  year\n##    <fct>  <fct>         <int> <int>\n##  1 male   Adelie         3750  2007\n##  2 female Adelie         3800  2007\n##  3 female Adelie         3250  2007\n##  4 <NA>   Adelie           NA  2007\n##  5 female Adelie         3450  2007\n##  6 male   Adelie         3650  2007\n##  7 female Adelie         3625  2007\n##  8 male   Adelie         4675  2007\n##  9 <NA>   Adelie         3475  2007\n## 10 <NA>   Adelie         4250  2007\n## # ℹ 334 more rows\nRename variables\nTo rename variables, use the\nrename()\nfunction:\n# rename variables\ndat |>\n  rename(\n    body_mass = body_mass_g, # rename body_mass_g into body_mass\n    study_year = year # rename year into study_year\n  )\n## # A tibble: 344 × 4\n##    species body_mass sex    study_year\n##    <fct>       <int> <fct>       <int>\n##  1 Adelie       3750 male         2007\n##  2 Adelie       3800 female       2007\n##  3 Adelie       3250 female       2007\n##  4 Adelie         NA <NA>         2007\n##  5 Adelie       3450 female       2007\n##  6 Adelie       3650 male         2007\n##  7 Adelie       3625 female       2007\n##  8 Adelie       4675 male         2007\n##  9 Adelie       3475 <NA>         2007\n## 10 Adelie       4250 <NA>         2007\n## # ℹ 334 more rows\nThis might not be intuitive (at least it was not for me at the time of learning this package), so bear in mind that you always need to write first the new name and then the old name (separated with the\n=\nsign).\nCreate or modify variables\nYou can create or modify certain variables of the data frame with\nmutate()\n, based on:\nanother variable, or\na vector of your choice.\n# create a new variable based on an existing one\ndat |>\n  mutate(\n    body_mass_kg = body_mass_g / 1000\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_kg\n##    <fct>         <int> <fct>  <int>        <dbl>\n##  1 Adelie         3750 male    2007         3.75\n##  2 Adelie         3800 female  2007         3.8 \n##  3 Adelie         3250 female  2007         3.25\n##  4 Adelie           NA <NA>    2007        NA   \n##  5 Adelie         3450 female  2007         3.45\n##  6 Adelie         3650 male    2007         3.65\n##  7 Adelie         3625 female  2007         3.62\n##  8 Adelie         4675 male    2007         4.68\n##  9 Adelie         3475 <NA>    2007         3.48\n## 10 Adelie         4250 <NA>    2007         4.25\n## # ℹ 334 more rows\n# create a new variable from a vector of your choice\ndat |>\n  mutate(\n    ID = 1:nrow(dat)\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year    ID\n##    <fct>         <int> <fct>  <int> <int>\n##  1 Adelie         3750 male    2007     1\n##  2 Adelie         3800 female  2007     2\n##  3 Adelie         3250 female  2007     3\n##  4 Adelie           NA <NA>    2007     4\n##  5 Adelie         3450 female  2007     5\n##  6 Adelie         3650 male    2007     6\n##  7 Adelie         3625 female  2007     7\n##  8 Adelie         4675 male    2007     8\n##  9 Adelie         3475 <NA>    2007     9\n## 10 Adelie         4250 <NA>    2007    10\n## # ℹ 334 more rows\nNote that if you create a variable with a name which already exists in the data frame, the old variable will be erased and replaced by the new one.\nLike\nrename()\n,\nmutate()\nrequires the argument to be written as\nname = expression\n, where\nname\nis name of the column created or modified and\nexpression\nis the formula for calculating the values.\nSummarize observations\nOften, you will want to summarize the data with some\ndescriptive statistics\n. This can be done with the\nsummarize()\nfunction, in addition to most functions used for descriptive statistics (\nmean()\n,\nmedian()\n,\nmin()\n,\nmax()\n,\nsd()\n,\nvar()\n, etc.):\n# compute mean and sd of body mass\ndat |>\n  summarize(\n    body_mass_mean = mean(body_mass_g, na.rm = TRUE),\n    body_mass_sd = sd(body_mass_g, na.rm = TRUE)\n  )\n## # A tibble: 1 × 2\n##   body_mass_mean body_mass_sd\n##            <dbl>        <dbl>\n## 1          4202.         802.\nNote that:\nThe\nna.rm = TRUE\nargument is used to omit missing values in the computation of the summary statistics.\nsummarize()\nand\nsummarise()\ngive the exact same results.\nIdentify distinct values\nIdentifying distinct values of a variable can be done with\ndistinct()\n:\n# find the distinct species\ndat |>\n  distinct(species)\n## # A tibble: 3 × 1\n##   species  \n##   <fct>    \n## 1 Adelie   \n## 2 Gentoo   \n## 3 Chinstrap\nIdentifying distinct values is mostly done on qualitative or quantitative discrete variables, but it can be done on any type of variable and with several variables at the same time. If more than one variables is specified, it returns all the combinations of values of the variables.\nFor instance, with species and study year:\n# combination of distinct species and year\ndat |>\n  distinct(species, year)\n## # A tibble: 9 × 2\n##   species    year\n##   <fct>     <int>\n## 1 Adelie     2007\n## 2 Adelie     2008\n## 3 Adelie     2009\n## 4 Gentoo     2007\n## 5 Gentoo     2008\n## 6 Gentoo     2009\n## 7 Chinstrap  2007\n## 8 Chinstrap  2008\n## 9 Chinstrap  2009\nConnected operations\nAnother advantage of using the\n{dplyr}\npackage is that several operations can be connected all at once, with great readability of the code. This can easily be done with the pipe operator (\n|>\nor\n%>%\n) introduced earlier.\nUntil now, we have always seen the same structure: we call a data frame, and then we apply an operation on that data frame. From now on, we will see how to combine more operations into one single chain of operations.\nGroup by\ngroup_by()\nallows to modify the way the basic functions are performed. Instead of covering all the rows of the data frame, the operations will cover each of the groups of rows defined by the grouping command. In this way, aggregation operations, using\nsummarize()\n, will produce statistics for each group rather than for all observations.\nFor example, we might be interested in computing some descriptive statistics of a quantitative variable, for each level of a qualitative variable (so by group).\nIn our case, suppose we would like to compute the mean and standard deviation of the body mass, but this time separately for each species:\n# compute mean and sd of body mass by species\ndat |>\n  group_by(species) |> # group by species\n  summarize(\n    mean = mean(body_mass_g, na.rm = TRUE), # compute mean\n    sd = sd(body_mass_g, na.rm = TRUE) # compute sd\n  )\n## # A tibble: 3 × 3\n##   species    mean    sd\n##   <fct>     <dbl> <dbl>\n## 1 Adelie    3701.  459.\n## 2 Chinstrap 3733.  384.\n## 3 Gentoo    5076.  504.\nApplied to the example above, here is how the pipe operator works:\nThe first operation (\ngroup_by()\n) groups observations by species.\nThen the output of the first operation is used as the input for the second operation (\nsummarize()\n): mean and standard deviation are computed on body mass.\nAs a result, we have the mean and standard deviation of body mass by group. As you can imagine, all previous operations can be connected to match your needs.\nAlso note that\ngroup_by()\ncan be used for several grouping variables at the same time:\n# compute mean and sd of body mass by species and sex\ndat |>\n  group_by(species, sex) |> # group by species and sex\n  summarize(\n    mean = mean(body_mass_g, na.rm = TRUE), # compute mean\n    sd = sd(body_mass_g, na.rm = TRUE) # compute sd\n  )\n## # A tibble: 8 × 4\n## # Groups:   species [3]\n##   species   sex     mean    sd\n##   <fct>     <fct>  <dbl> <dbl>\n## 1 Adelie    female 3369.  269.\n## 2 Adelie    male   4043.  347.\n## 3 Adelie    <NA>   3540   477.\n## 4 Chinstrap female 3527.  285.\n## 5 Chinstrap male   3939.  362.\n## 6 Gentoo    female 4680.  282.\n## 7 Gentoo    male   5485.  313.\n## 8 Gentoo    <NA>   4588.  338.\n(Note that, as for all connected operations, the name of the data frame needs to be specified only in the first operation.)\nNumber of observations\nSome operations can only be performed inside other operations.\nThis is the case with the number of observations\nn()\n, which can only be used inside\nsummarize()\n:\n# number of observations\ndat |>\n  summarize(n_obs = n())\n## # A tibble: 1 × 1\n##   n_obs\n##   <int>\n## 1   344\nTo refer with the previous connected operation\ngroup_by()\n, we can compute the number of observations by group using the two operations\nn()\nand\ngroup_by()\nseparated by the pipe operator:\n# number of observations by species\ndat |>\n  group_by(species) |>\n  summarize(n_obs = n())\n## # A tibble: 3 × 2\n##   species   n_obs\n##   <fct>     <int>\n## 1 Adelie      152\n## 2 Chinstrap    68\n## 3 Gentoo      124\nNote that\nn()\naccepts no parameters and is therefore always written with empty parentheses.\nMoreover, note also that the\ncount()\nfunction is equivalent to\nsummarize(n = n())\n:\n# number of observations\ndat |>\n  count()\n## # A tibble: 1 × 1\n##       n\n##   <int>\n## 1   344\n# number of observations by species\ndat |>\n  count(species)\n## # A tibble: 3 × 2\n##   species       n\n##   <fct>     <int>\n## 1 Adelie      152\n## 2 Chinstrap    68\n## 3 Gentoo      124\nNumber of distinct values\nn_distinct()\n, which can also be used only inside\nsummarize()\n, computes the number of different values/levels of a variable or combination of variables:\n# number of distinct species\ndat |>\n  summarize(n_species = n_distinct(species))\n## # A tibble: 1 × 1\n##   n_species\n##       <int>\n## 1         3\n# number of distinct species and year of study\ndat |>\n  summarize(n_species_year = n_distinct(species, year))\n## # A tibble: 1 × 1\n##   n_species_year\n##            <int>\n## 1              9\nNote that you do not have to specify a name for the output. In that case, the name of the operation will be used. For example:\n# number of distinct species\ndat |>\n  summarize(n_distinct(species))\n## # A tibble: 1 × 1\n##   `n_distinct(species)`\n##                   <int>\n## 1                     3\nFirst, last or nth value\nAlso only available inside\nsummarize()\n, the first, last or nth value can be found with the following commands:\n# first value of the variable sex\ndat |>\n  summarize(first(sex))\n## # A tibble: 1 × 1\n##   `first(sex)`\n##   <fct>       \n## 1 male\n# last value of the variable sex\ndat |>\n  summarize(last(sex))\n## # A tibble: 1 × 1\n##   `last(sex)`\n##   <fct>      \n## 1 female\n# 37th value of the variable sex\ndat |>\n  summarize(nth(sex, n = 37))\n## # A tibble: 1 × 1\n##   `nth(sex, n = 37)`\n##   <fct>             \n## 1 male\nSeveral interesting arguments exist within this function to deal with missing values. For the interested reader, see more information in the documentation of the function (run\n?nth()\n).\nIf else\nA very common data transformation is the well known “if else” technique. This technique is usually used to create, from an existing variable, another variable which can take\ntwo levels\n.\nSuppose that we want to create a new variable called\nbody_mass_cat\n, which takes the value “High” when\nbody_mass_g\nis equal or greater than a certain threshold, “Low” otherwise. This transformation can be performed with the combination of\nmutate()\nand\nif_else()\n:\n# if else\ndat |>\n  mutate(\n    body_mass_cat = if_else(body_mass_g >= 4000, # condition\n      \"High\", # output if condition is true\n      \"Low\" # output if condition is false\n    )\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    <fct>         <int> <fct>  <int> <chr>        \n##  1 Adelie         3750 male    2007 Low          \n##  2 Adelie         3800 female  2007 Low          \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA <NA>    2007 <NA>         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Low          \n##  7 Adelie         3625 female  2007 Low          \n##  8 Adelie         4675 male    2007 High         \n##  9 Adelie         3475 <NA>    2007 Low          \n## 10 Adelie         4250 <NA>    2007 High         \n## # ℹ 334 more rows\nThe\nif_else()\nfunction works with 3 arguments:\nThe condition (in our case:\nbody_mass_g >= 4000\n)\nThe output value when the condition is true (\nHigh\nin our case).\nThe output value when the conditions is false (\nLow\nin our case).\nAs you can see from the table above, when body mass is missing,\nif_else()\nalso returns a missing value, which is often a good thing to prevent observations being classified erroneously.\nCase when\nIf you want to categorize a variable into\nmore than two levels\n, an if else is not the most appropriate tool. In these cases, a “case when” is more appropriate.\nFor your information, when I learned R, I used to write nested if else functions, that is, a secondary if else inside a primary if else. Most of the time it worked (with very often a waste of time trying to debug my code), but it is very easy to make a mistake. And even if you managed to make it work, the code is not easy to read at all!\nSo I highly recommend using this case when technique instead of several if else functions nested within each other.\nSuppose we want to classify body mass into 3 categories: low, medium and high. For this illustration, we arbitrarily decide that body mass is low when it is strictly lower than 3500, high when it is strictly higher than 4750 and medium otherwise.\nWith nested if else functions, here is the code we would need to write:\n# nested if else\ndat |>\n  mutate(\n    body_mass_cat = if_else(body_mass_g < 3500, # first condition\n      \"Low\", # output if first condition is true\n      if_else(body_mass_g > 4750, # second condition when first condition is false\n        \"High\", # output when second condition is true\n        \"Medium\" # output when second condition is false\n      )\n    )\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    <fct>         <int> <fct>  <int> <chr>        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA <NA>    2007 <NA>         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 <NA>    2007 Low          \n## 10 Adelie         4250 <NA>    2007 Medium       \n## # ℹ 334 more rows\nThis code works as follows:\nIt evaluates the first condition\nbody_mass_g < 3500\n.\nIf it is true,\nbody_mass_cat\nis\nLow\n. On the contrary, if it is false, it evaluates the second condition\nbody_mass_g > 4750\n.\nIf this second condition is true,\nbody_mass_cat\nis\nHigh\n, otherwise it is\nMedium\n.\nAs you can see from the results above, it works. However, you will concede that it is easy to make coding mistakes, and that the code is not easy to write nor to read.\nTo improve this workflow, we now use the case when technique:\n# case when, without a default option\ndat |>\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g < 3500 ~ \"Low\",\n      body_mass_g >= 3500 & body_mass_g <= 4750 ~ \"Medium\",\n      body_mass_g > 4750 ~ \"High\"\n    )\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    <fct>         <int> <fct>  <int> <chr>        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA <NA>    2007 <NA>         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 <NA>    2007 Low          \n## 10 Adelie         4250 <NA>    2007 Medium       \n## # ℹ 334 more rows\nThis workflow is much simpler to code and read!\nIf there are no missing values in the variable(s) used for the condition(s), it can even be simplified to:\n# case when, with a default option\ndat |>\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g < 3500 ~ \"Low\",\n      body_mass_g > 4750 ~ \"High\",\n      .default = \"Medium\" # default output\n    )\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    <fct>         <int> <fct>  <int> <chr>        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA <NA>    2007 Medium       \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 <NA>    2007 Low          \n## 10 Adelie         4250 <NA>    2007 Medium       \n## # ℹ 334 more rows\nAs you can see, a default output can be specified with\n.default\nfor observations that do not match any of the conditions.\nHowever, be careful if there are missing values! Indeed, if there is at least one missing value (as in our case), the code above is not correct because observations with missing\nbody_mass_g\nwill be misclassified as\nMedium\n.\nTherefore, if you really want to specify a default output, I recommend using the code below which keeps missing values as\nNA\n:\n# case when, with a default option and missing values\ndat |>\n  mutate(\n    body_mass_cat = case_when(\n      body_mass_g < 3500 ~ \"Low\",\n      body_mass_g > 4750 ~ \"High\",\n      is.na(body_mass_g) ~ NA, # keep missing values as NA\n      .default = \"Medium\" # default output\n    )\n  )\n## # A tibble: 344 × 5\n##    species body_mass_g sex     year body_mass_cat\n##    <fct>         <int> <fct>  <int> <chr>        \n##  1 Adelie         3750 male    2007 Medium       \n##  2 Adelie         3800 female  2007 Medium       \n##  3 Adelie         3250 female  2007 Low          \n##  4 Adelie           NA <NA>    2007 <NA>         \n##  5 Adelie         3450 female  2007 Low          \n##  6 Adelie         3650 male    2007 Medium       \n##  7 Adelie         3625 female  2007 Medium       \n##  8 Adelie         4675 male    2007 Medium       \n##  9 Adelie         3475 <NA>    2007 Low          \n## 10 Adelie         4250 <NA>    2007 Medium       \n## # ℹ 334 more rows\nI personally prefer to write all categories and not write a default option for improved code readability and robustness of my code, but it is more a personal opinion.\nIn all cases, no matter if you used an if else or a case when, it is a good practice to check the variable you just created to make sure that you obtain the intended results.\nConclusion and other resources\nThanks for reading.\nThis article introduced and illustrated the most common data manipulation and data management tools in R, using the\n{dplyr}\npackage. We also introduced the pipe operator, well known to users of modern R packages.\nThe\n{dplyr}\npackage offers many more functions for data manipulation (in particular to merge data frames with the family of\njoin()\nfunctions). If you would like to learn more about this package, I recommend starting with the following resources:\ndplyr.tidyverse.org\nChapter “Data transformation”\nin the book “R for Data Science”\nCheatsheet\nVignette\nFor those who are used to base R, a\nvignette\ncomparing\n{dplyr}\nfunctions to their base R equivalents\nAs always, if you have a question or a suggestion related to the topic covered in this article, please add it as a comment so other readers can benefit from the discussion.\nThe keyboard shortcut for the pipe operator is\nctrl + shift + m\n(Windows) or\ncmd + shift + m\n(Mac). It will print\n%>%\n, unless you specified to use the native pipe operator\n|>\nin the settings of RStudio.\n↩︎\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR on Stats and R\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Introduction Data {dplyr} package Filter observations The pipe operator Extract observations Based on their positions Based on their values Sample observations Sort observations Select variables Rename variables Create or modify variables Summ...",
    "meta_keywords": null,
    "og_description": "Introduction Data {dplyr} package Filter observations The pipe operator Extract observations Based on their positions Based on their values Sample observations Sort observations Select variables Rename variables Create or modify variables Summ...",
    "og_image": "https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/images/introduction-to-data-manipulation-in-r-with-dplyr.jpeg",
    "og_title": "Introduction to data manipulation in R with {dplyr} | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 31.7,
    "sitemap_lastmod": "2023-11-27T00:00:00+00:00",
    "twitter_description": "Introduction Data {dplyr} package Filter observations The pipe operator Extract observations Based on their positions Based on their values Sample observations Sort observations Select variables Rename variables Create or modify variables Summ...",
    "twitter_title": "Introduction to data manipulation in R with {dplyr} | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/11/introduction-to-data-manipulation-in-r-with-dplyr/",
    "word_count": 6331
  }
}