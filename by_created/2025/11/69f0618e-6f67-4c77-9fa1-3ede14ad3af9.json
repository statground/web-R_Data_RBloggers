{
  "uuid": "69f0618e-6f67-4c77-9fa1-3ede14ad3af9",
  "created_at": "2025-11-17 20:38:36",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2024/01/a-simple-workflow-for-async-shiny-with-callr/",
    "crawled_at": "2025-11-17T09:18:44.577469",
    "external_links": [
      {
        "href": "https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/",
        "text": "R | Discindo"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://hypebright.nl/index.php/2023/09/05/mastering-async-programming-shiny/",
        "text": "writing"
      },
      {
        "href": "https://www.futureverse.org/",
        "text": "Futureverse documentation"
      },
      {
        "href": "https://github.com/shikokuchuo/mirai/",
        "text": "mirai"
      },
      {
        "href": "https://github.com/wlandau/crew",
        "text": "crew"
      },
      {
        "href": "https://discindo.org/post/asynchronous-execution-in-shiny/",
        "text": "previous\nexperience"
      },
      {
        "href": "https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/",
        "text": "R | Discindo"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "A simple workflow for async {shiny} with {callr} | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/r-discindo/",
        "text": "R | Discindo"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-381471 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">A simple workflow for async {shiny} with {callr}</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 11, 2024</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-discindo/\">R | Discindo</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/\"> R | Discindo</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>In the <code>R/Shiny</code> community we are fortunate to have several approaches for async programming.\nIt is an active field of development with a variety of\noptions depending on the needs of the application. For examples and deeper overviews of\nthe state of async programming in <code>R</code>, head over to Veerle van Leemput’s\n<a href=\"https://hypebright.nl/index.php/2023/09/05/mastering-async-programming-shiny/\" rel=\"nofollow\" target=\"_blank\">writing</a>,\nthe <a href=\"https://www.futureverse.org/\" rel=\"nofollow\" target=\"_blank\">Futureverse documentation</a> or the\n<a href=\"https://github.com/shikokuchuo/mirai/\" rel=\"nofollow\" target=\"_blank\">mirai</a> / <a href=\"https://github.com/wlandau/crew\" rel=\"nofollow\" target=\"_blank\">crew</a> repos.</p>\n<p>In this post, I am going to focus on an approach to simplify making multiple\nasync calls in <code>shiny</code> applications. Really, it boils down to developing a module\nthat wraps the initialization and polling of a <code>callr::r_bg</code> process into a single\nfunction, and makes it easier write a larger async-capable <code>shiny</code> app while\nkeeping the code a bit shorter, and more compact.</p>\n<h2 id=\"the-problem\">The problem</h2>\n<p>I am working on refactoring a relatively large <code>shiny</code> application where many of the\ncomputations are time-consuming. Ideally, I would like to convert the major bottlenecks\ninto async routines. Typically, is is done by setting up <code>future/promise</code> constructs or\nsending a job to a subprocess, keeping the main <code>shiny</code> process free, and then\npolling the subprocess ‘manually’ to fetch the result (<code>callr</code>/<code>mirai</code>/<code>crew</code>).</p>\n<p>After reviewing the available options, and trying a few things, I decided\nto go with <code>callr</code> for async, although the <code>mirai</code>, and <code>crew</code> where close seconds.\nThis choice was mostly because of <code>callr</code>’s simplicity and because I have <a href=\"https://discindo.org/post/asynchronous-execution-in-shiny/\" rel=\"nofollow\" target=\"_blank\">previous\nexperience</a> with it.</p>\n<p>The <code>callr</code> workflow can be sumarised in the following steps:</p>\n<ul>\n<li>send a call to the subprocess (possibly within a reactive and dependent on events within <code>shiny</code>)</li>\n<li>monitor the status of the background process to know when to fetch the results</li>\n<li>the polling observer has to have a switch, so we don’t waste resources on polling\nwhile there is nothing running.</li>\n</ul>\n<p>In all, its probably some 15-20 lines of code, depending on the complexity of\nthe function call we are sending to the subprocess. It looks something like this:</p>\n<pre># The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six &lt;- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\n# the r_bg call\nargs &lt;- list(head_six = head_six, x = my_data, sleep = 5)\nbg_process &lt;- callr::r_bg(\nfunc = function(head_six, x, sleep) {\nhead_six(x, sleep)\n},\nargs = args,\nsupervise = TRUE\n)\n# turn on polling after the task has been sent to the subprocess\npoll_switch &lt;- shiny::reactiveVal(TRUE)\n# reactive to store the result returned by the subprocess\nresult_rct &lt;- shiny::reactiveVal(NULL)\n# monitor the background process\nshiny::observe({\nshiny::req(isTRUE(poll_switch()))\nshiny::invalidateLater(300)\nmessage(\"checking\")\nalive &lt;- bg_job()$is_alive()\nif (isFALSE(alive)) {\nres_rct(bg_job()$get_result())\nmessage(\"done\")\npoll_rct(FALSE)\n}\n})\n# do stuff with `result_rct()`\n</pre><p>Having to write this in 20 different places where async might be needed in\nan application is definitelly a chore, not to mention error-prone as one needs\nto keep track of the names of the process objects, polling switches, and result\nreactives. Then of course, some async bits would need to respond to events, like\nbutton clicks or other reactives in the <code>shiny</code> session, while others would need\nto run without explicit triggers, adding to the complexity and maintanence of the\ncodebase.</p>\n<h2 id=\"the-solution\">The solution</h2>\n<p>I wanted to simplify the above process and make it quicker to write the async\ncode. I wanted a function or a module server that would take a function by name\nand its arguments and then run the function in a background process, poll the\nprocess and return the result when ready. Additionally, I wanted this module\nto be flexible enough such that one can trigger the execution from the outside\n(e.g., from the parent module) or to run without external triggers.</p>\n<p>In the end, I came up with a solution with 3 components: the function that does the\nlong computation, an <em>async</em> version of this function, and a module server that\nwill do the <code>shiny</code> things. Bellow are the 3 parts starting with the trivial <code>head_six</code>\nfunction (same as above):</p>\n<pre># The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six &lt;- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\n</pre><p>The async version of the function is a wrapper that is prepared manually for the\nfunction we need to run async. It is abstracting the <code>callr::r_bg</code> call, and\ncan live in a separate script (together with the function it wraps) instead\nof the <code>shiny</code> server. There probably are ways to generate this function with\ncode, and I might try that soon, but for now creating this wrapper does not\nbother me much. Having an async function that you can test and debug interactivelly\nmight actually be preferred.</p>\n<pre># Async version of `head_six`\n# calls `r_bg` and returns the process object\nhead_six_async &lt;- function(x, sleep) {\nargs &lt;- list(head_six = head_six, x = x, sleep = sleep)\nbg_process &lt;- callr::r_bg(\nfunc = function(head_six, x, sleep) {\nhead_six(x, sleep)\n},\nargs = args,\nsupervise = TRUE\n)\nreturn(bg_process)\n}\n</pre><p>The third part is the function (module server) that calls the async version of\nthe function doing the time-consumig task. The module also has reactives\nto switch polling on/off, and an observer to monitor and fetch the result. It\nreturns a list with two elements, a reactive with the result of the async\njob, and a function that updates the polling reactive (<code>poll_rct</code>) that allows\none to initiate the task from the outside. For example if we had a button in\nanother module that should trigger the computation <em>inside</em> this async module.</p>\n<pre>mod_async_srv &lt;- function(id, fun_async, fun_args, wait_for_event = FALSE) {\nmoduleServer( id, function(input, output, session){\nres_rct &lt;- shiny::reactiveVal(NULL)\npoll_rct &lt;- shiny::reactiveVal(TRUE)\nif (isTRUE(wait_for_event)) {\npoll_rct(FALSE)\n}\nbg_job &lt;- reactive({\nreq(isTRUE(poll_rct()))\ndo.call(fun_async, fun_args)\n}) |&gt; bindEvent(poll_rct())\nobserve({\nreq(isTRUE(poll_rct()))\ninvalidateLater(250)\nmessage(sprintf(\"checking: %s\", id))\nalive &lt;- bg_job()$is_alive()\nif (isFALSE(alive)) {\nres_rct(bg_job()$get_result())\nmessage(sprintf(\"done: %s\", id))\npoll_rct(FALSE)\n}\n})\nreturn(list(\nstart_job = function() poll_rct(TRUE),\nget_result = reactive(res_rct())\n))\n})\n}\n</pre><p>Note that this <em>is not</em> a typical <code>shiny</code> module, in that it does not have\n(and does not strictly need) a UI part. So we don’t have to worry\nabout the namespace (<code>ns &lt;- session$ns</code>) inside it. We simply want to observe\nand return. One could add a UI component to, perhaps, notify the user about the\nprogress (checking, checking, … done) of the async job.</p>\n<p>With this module, refactoring to async becomes more streamlined. For example,\nwe could have a scenario like this.</p>\n<pre>server &lt;- function(input, output, session) {\n# async job triggered on event (input$go_async_job1)\nasync_job1 &lt;- mod_async_srv(\nid = \"job1_srv\",\nfun_async = \"job1_async\",\nfun_args = list(x = x, z = z),\nwait_for_event = TRUE\n)\nobserveEvent(input$go_async_job1, {\nasync_job1$start_job()\n})\noutput$x &lt;- renderPlot({\nplot_fun(async_job1$get_result())\n})\n# async job that runs without external intervention\nasync_job2 &lt;- mod_async_srv(\nid = \"job2_srv\",\nfun_async = \"job2_async\",\nfun_args = list(a = a, b = b),\nwait_for_event = FALSE\n)\noutput$y &lt;- renderPlot({\ntable_fun(async_job2$get_result())\n})\n}\n</pre><p>Note that the two instances of <code>mod_async_srv</code> use different async functions\nwith different sets of arguments, and are triggered in different ways. Providing\nsome flexibility, while keeping the server code minimal.</p>\n<p>Nothing special here, no magic, just some wrappers to make life a bit easier when\nwriting large <code>shiny</code> applications with async capabilities.</p>\n<h2 id=\"demo\">Demo</h2>\n<p>To test out this approach you can download the following <code>gist</code>. In it, I have\ntwo <code>callr</code> background async jobs, to show the <code>head</code> of <code>iris</code> and <code>mtcars</code>,\nwith different sleep time. The <code>iris</code> job waits for user click, while the\n<code>mtcars</code> job runs on its own when the app starts. Neither async job blocks\nthe main <code>shiny</code> process, as they are both in the background, so the slider and\nhistogram work throughout.</p>\n\n<h2 id=\"summary\">Summary</h2>\n<p>In this post I went over an approach to organize <code>callr</code> background async jobs using a module, in order to make the async code faster to write, less error prone and overall cleaner.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://discindo.org/post/an-opiniated-workflow-for-async-shiny-with-callr/\"> R | Discindo</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "A simple workflow for async {shiny} with {callr}\nPosted on\nJanuary 11, 2024\nby\nR | Discindo\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR | Discindo\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn the\nR/Shiny\ncommunity we are fortunate to have several approaches for async programming.\nIt is an active field of development with a variety of\noptions depending on the needs of the application. For examples and deeper overviews of\nthe state of async programming in\nR\n, head over to Veerle van Leemput’s\nwriting\n,\nthe\nFutureverse documentation\nor the\nmirai\n/\ncrew\nrepos.\nIn this post, I am going to focus on an approach to simplify making multiple\nasync calls in\nshiny\napplications. Really, it boils down to developing a module\nthat wraps the initialization and polling of a\ncallr::r_bg\nprocess into a single\nfunction, and makes it easier write a larger async-capable\nshiny\napp while\nkeeping the code a bit shorter, and more compact.\nThe problem\nI am working on refactoring a relatively large\nshiny\napplication where many of the\ncomputations are time-consuming. Ideally, I would like to convert the major bottlenecks\ninto async routines. Typically, is is done by setting up\nfuture/promise\nconstructs or\nsending a job to a subprocess, keeping the main\nshiny\nprocess free, and then\npolling the subprocess ‘manually’ to fetch the result (\ncallr\n/\nmirai\n/\ncrew\n).\nAfter reviewing the available options, and trying a few things, I decided\nto go with\ncallr\nfor async, although the\nmirai\n, and\ncrew\nwhere close seconds.\nThis choice was mostly because of\ncallr\n’s simplicity and because I have\nprevious\nexperience\nwith it.\nThe\ncallr\nworkflow can be sumarised in the following steps:\nsend a call to the subprocess (possibly within a reactive and dependent on events within\nshiny\n)\nmonitor the status of the background process to know when to fetch the results\nthe polling observer has to have a switch, so we don’t waste resources on polling\nwhile there is nothing running.\nIn all, its probably some 15-20 lines of code, depending on the complexity of\nthe function call we are sending to the subprocess. It looks something like this:\n# The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six <- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\n# the r_bg call\nargs <- list(head_six = head_six, x = my_data, sleep = 5)\nbg_process <- callr::r_bg(\nfunc = function(head_six, x, sleep) {\nhead_six(x, sleep)\n},\nargs = args,\nsupervise = TRUE\n)\n# turn on polling after the task has been sent to the subprocess\npoll_switch <- shiny::reactiveVal(TRUE)\n# reactive to store the result returned by the subprocess\nresult_rct <- shiny::reactiveVal(NULL)\n# monitor the background process\nshiny::observe({\nshiny::req(isTRUE(poll_switch()))\nshiny::invalidateLater(300)\nmessage(\"checking\")\nalive <- bg_job()$is_alive()\nif (isFALSE(alive)) {\nres_rct(bg_job()$get_result())\nmessage(\"done\")\npoll_rct(FALSE)\n}\n})\n# do stuff with `result_rct()`\nHaving to write this in 20 different places where async might be needed in\nan application is definitelly a chore, not to mention error-prone as one needs\nto keep track of the names of the process objects, polling switches, and result\nreactives. Then of course, some async bits would need to respond to events, like\nbutton clicks or other reactives in the\nshiny\nsession, while others would need\nto run without explicit triggers, adding to the complexity and maintanence of the\ncodebase.\nThe solution\nI wanted to simplify the above process and make it quicker to write the async\ncode. I wanted a function or a module server that would take a function by name\nand its arguments and then run the function in a background process, poll the\nprocess and return the result when ready. Additionally, I wanted this module\nto be flexible enough such that one can trigger the execution from the outside\n(e.g., from the parent module) or to run without external triggers.\nIn the end, I came up with a solution with 3 components: the function that does the\nlong computation, an\nasync\nversion of this function, and a module server that\nwill do the\nshiny\nthings. Bellow are the 3 parts starting with the trivial\nhead_six\nfunction (same as above):\n# The function we want to run async\n# (sleep is added to mimic long computation)\nhead_six <- function(x, sleep) {\nSys.sleep(sleep)\nhead(x)\n}\nThe async version of the function is a wrapper that is prepared manually for the\nfunction we need to run async. It is abstracting the\ncallr::r_bg\ncall, and\ncan live in a separate script (together with the function it wraps) instead\nof the\nshiny\nserver. There probably are ways to generate this function with\ncode, and I might try that soon, but for now creating this wrapper does not\nbother me much. Having an async function that you can test and debug interactivelly\nmight actually be preferred.\n# Async version of `head_six`\n# calls `r_bg` and returns the process object\nhead_six_async <- function(x, sleep) {\nargs <- list(head_six = head_six, x = x, sleep = sleep)\nbg_process <- callr::r_bg(\nfunc = function(head_six, x, sleep) {\nhead_six(x, sleep)\n},\nargs = args,\nsupervise = TRUE\n)\nreturn(bg_process)\n}\nThe third part is the function (module server) that calls the async version of\nthe function doing the time-consumig task. The module also has reactives\nto switch polling on/off, and an observer to monitor and fetch the result. It\nreturns a list with two elements, a reactive with the result of the async\njob, and a function that updates the polling reactive (\npoll_rct\n) that allows\none to initiate the task from the outside. For example if we had a button in\nanother module that should trigger the computation\ninside\nthis async module.\nmod_async_srv <- function(id, fun_async, fun_args, wait_for_event = FALSE) {\nmoduleServer( id, function(input, output, session){\nres_rct <- shiny::reactiveVal(NULL)\npoll_rct <- shiny::reactiveVal(TRUE)\nif (isTRUE(wait_for_event)) {\npoll_rct(FALSE)\n}\nbg_job <- reactive({\nreq(isTRUE(poll_rct()))\ndo.call(fun_async, fun_args)\n}) |> bindEvent(poll_rct())\nobserve({\nreq(isTRUE(poll_rct()))\ninvalidateLater(250)\nmessage(sprintf(\"checking: %s\", id))\nalive <- bg_job()$is_alive()\nif (isFALSE(alive)) {\nres_rct(bg_job()$get_result())\nmessage(sprintf(\"done: %s\", id))\npoll_rct(FALSE)\n}\n})\nreturn(list(\nstart_job = function() poll_rct(TRUE),\nget_result = reactive(res_rct())\n))\n})\n}\nNote that this\nis not\na typical\nshiny\nmodule, in that it does not have\n(and does not strictly need) a UI part. So we don’t have to worry\nabout the namespace (\nns <- session$ns\n) inside it. We simply want to observe\nand return. One could add a UI component to, perhaps, notify the user about the\nprogress (checking, checking, … done) of the async job.\nWith this module, refactoring to async becomes more streamlined. For example,\nwe could have a scenario like this.\nserver <- function(input, output, session) {\n# async job triggered on event (input$go_async_job1)\nasync_job1 <- mod_async_srv(\nid = \"job1_srv\",\nfun_async = \"job1_async\",\nfun_args = list(x = x, z = z),\nwait_for_event = TRUE\n)\nobserveEvent(input$go_async_job1, {\nasync_job1$start_job()\n})\noutput$x <- renderPlot({\nplot_fun(async_job1$get_result())\n})\n# async job that runs without external intervention\nasync_job2 <- mod_async_srv(\nid = \"job2_srv\",\nfun_async = \"job2_async\",\nfun_args = list(a = a, b = b),\nwait_for_event = FALSE\n)\noutput$y <- renderPlot({\ntable_fun(async_job2$get_result())\n})\n}\nNote that the two instances of\nmod_async_srv\nuse different async functions\nwith different sets of arguments, and are triggered in different ways. Providing\nsome flexibility, while keeping the server code minimal.\nNothing special here, no magic, just some wrappers to make life a bit easier when\nwriting large\nshiny\napplications with async capabilities.\nDemo\nTo test out this approach you can download the following\ngist\n. In it, I have\ntwo\ncallr\nbackground async jobs, to show the\nhead\nof\niris\nand\nmtcars\n,\nwith different sleep time. The\niris\njob waits for user click, while the\nmtcars\njob runs on its own when the app starts. Neither async job blocks\nthe main\nshiny\nprocess, as they are both in the background, so the slider and\nhistogram work throughout.\nSummary\nIn this post I went over an approach to organize\ncallr\nbackground async jobs using a module, in order to make the async code faster to write, less error prone and overall cleaner.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR | Discindo\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "In the R/Shiny community we are fortunate to have several approaches for async programming. It is an active field of development with a variety of options depending on the needs of the application. For examples and deeper overviews of the state of asyn...",
    "meta_keywords": null,
    "og_description": "In the R/Shiny community we are fortunate to have several approaches for async programming. It is an active field of development with a variety of options depending on the needs of the application. For examples and deeper overviews of the state of asyn...",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "A simple workflow for async {shiny} with {callr} | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 7.1,
    "sitemap_lastmod": "2024-01-12T00:00:00+00:00",
    "twitter_description": "In the R/Shiny community we are fortunate to have several approaches for async programming. It is an active field of development with a variety of options depending on the needs of the application. For examples and deeper overviews of the state of asyn...",
    "twitter_title": "A simple workflow for async {shiny} with {callr} | R-bloggers",
    "url": "https://www.r-bloggers.com/2024/01/a-simple-workflow-for-async-shiny-with-callr/",
    "word_count": 1424
  }
}