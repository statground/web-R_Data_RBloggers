{
  "uuid": "d731e33f-d074-4ef8-a462-9347bc11cbe2",
  "created_at": "2025-11-22 19:58:43",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/04/spatial-machine-learning-with-r-caret-tidymodels-and-mlr3/",
    "crawled_at": "2025-11-22T10:49:40.714589",
    "external_links": [
      {
        "href": "https://geocompx.org/post/2025/sml-bp1/",
        "text": "geocompx"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://creativecommons.org/licenses/by/4.0/",
        "text": "CC BY 4.0"
      },
      {
        "href": "https://geocompx.org/post/2025/sml-bp1/",
        "text": "https://geocompx.org/post/2025/sml-bp1/"
      },
      {
        "href": "https://geocompx.org/post/2025/sml-bp1/",
        "text": "geocompx"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Spatial machine learning with R: caret, tidymodels, and mlr3 | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/mermaid-figure-1.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-6-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-7-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-15-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-16-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-17-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-18-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-19-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-20-1.png?w=450&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakub-nowosad/",
        "text": "Jakub Nowosad"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-392166 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Spatial machine learning with R: caret, tidymodels, and mlr3</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">April 29, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakub-nowosad/\">Jakub Nowosad</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://geocompx.org/post/2025/sml-bp1/\"> geocompx</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div class=\"callout callout-style-simple callout-note\">\n<div class=\"callout-body d-flex\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-body-container\">\n<p>This is the first part of a blog post series on spatial machine learning with R.</p>\n</div>\n</div>\n</div>\n<p>The R language has a variety of packages for machine learning, and many of them can be used for machine learning tasks in a spatial context (<em>spatial machine learning</em>). Spatial machine learning is generally different from traditional machine learning, as variables located closer to each other are often more similar than those located further apart. Thus, we need to consider that when building machine learning models.</p>\n<p>In this blog post, we compare three of the most popular machine learning frameworks in R: <strong>caret</strong>, <strong>tidymodels</strong>, and <strong>mlr3</strong>. We use a simple example to demonstrate how to use these frameworks for a spatial machine learning task and how their workflows differ. The goal here is to provide a general sense of how the spatial machine learning workflow looks like, and how different frameworks can be used to achieve the same goal.</p>\n<center>\n<div class=\"cell\" data-layout-align=\"default\">\n<div class=\"cell-output-display\">\n<div>\n<p></p><figure class=\"figure\"><p></p>\n<div>\n<p><img class=\"figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/mermaid-figure-1.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"width:8in;height:6.5in\"/><noscript><img class=\"figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/mermaid-figure-1.png?w=578&amp;ssl=1\" style=\"width:8in;height:6.5in\"/></noscript></p>\n</div>\n<p></p><figcaption> A possible workflow of the spatial machine learning task.</figcaption> </figure><p></p>\n</div>\n</div>\n</div>\n</center>\n<section class=\"level1\" id=\"inputs\">\n<h1>Inputs</h1>\n<p>Our task is to predict the temperature in Spain using a set of covariates. We have two datasets for that purpose: the first one, <code>temperature_train</code>, contains the temperature measurements from 195 locations in Spain, and the second one, <code>predictor_stack</code>, contains the covariates we will use to predict the temperature. These covariates include variables such as population density (<code>popdens</code>), distance to the coast (<code>coast</code>), and elevation (<code>elev</code>), among others.</p>\n<div class=\"cell\">\n<pre>library(terra)\nlibrary(sf)\ntrain_points &lt;- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\npredictor_stack &lt;- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")</pre>\n</div>\n<p>We use a subset of fourteen of the available covariates to predict the temperature. But before doing that, to prepare our data for modeling, we need to extract the covariate values at the locations of our training points.</p>\n<div class=\"cell\">\n<pre>predictor_names &lt;- names(predictor_stack)[1:14]\ntemperature_train &lt;- terra::extract(predictor_stack[[predictor_names]],\n    train_points,\n    bind = TRUE\n) |&gt;\n    sf::st_as_sf()</pre>\n</div>\n<p>Now, our <code>temperature_train</code> dataset contains the temperature measurements and the covariate values at each location and is ready for modeling.</p>\n</section>\n<section class=\"level1\" id=\"loading-packages\">\n<h1>Loading packages</h1>\n<p>Using each of the frameworks requires loading the respective packages.</p>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-1-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-1-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-1-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-1-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-1-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-1-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-1-1-tab\" class=\"tab-pane active\" id=\"tabset-1-1\">\n<div class=\"cell\">\n<pre>library(caret)              # for modeling\nlibrary(blockCV)            # for spatial cross-validation\nlibrary(CAST)               # for area of applicability</pre>\n</div>\n</div>\n<div aria-labelledby=\"tabset-1-2-tab\" class=\"tab-pane\" id=\"tabset-1-2\">\n<div class=\"cell\">\n<pre>library(tidymodels)         # metapackage for modeling\nlibrary(spatialsample)      # for spatial cross-validation\nlibrary(waywiser)           # for area of applicability\nlibrary(vip)                # for variable importance (used in AOA)</pre>\n</div>\n</div>\n<div aria-labelledby=\"tabset-1-3-tab\" class=\"tab-pane\" id=\"tabset-1-3\">\n<div class=\"cell\">\n<pre>library(mlr3verse)          # metapackage for mlr3 modeling\nlibrary(mlr3spatiotempcv)   # for spatial cross-validation\nlibrary(CAST)               # for area of applicability\nlgr::get_logger(\"mlr3\")$set_threshold(\"warn\")</pre>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"model-specification\">\n<h1>Model specification</h1>\n<p>Each of the frameworks has its own way of setting up the modeling workflow. This may include defining the model, the resampling method, and the hyperparameter values<sup>1</sup>. In this example, we use random forest models as implemented in the <strong>ranger</strong> package with the following hyperparameters:</p>\n<ul>\n<li><code>mtry</code>: the number of variables randomly sampled as candidates at each split of 8</li>\n<li><code>splitrule</code>: the splitting rule of <code>\"extratrees\"</code></li>\n<li><code>min.node.size</code>: the minimum size of terminal nodes of 5</li>\n</ul>\n<p>We also use a spatial cross-validation method with 5 folds. It means that the data is divided into many spatial blocks, and each block is assigned to a fold. The model is trained on a set of blocks belonging to the training set and evaluated on the remaining blocks. Note that each framework has its own way of defining the resampling method, and thus, the implementation and the folds may differ slightly.</p>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-2-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-2-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-2-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-2-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-2-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-2-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-2-1-tab\" class=\"tab-pane active\" id=\"tabset-2-1\">\n<p>For <strong>caret</strong>, we define the hyperparameter grid using the <code>expand.grid()</code> function, and the resampling method using the <code>trainControl()</code> function. In this case, to use spatial cross-validation, we use the <code>blockCV</code> package to create the folds, and then pass them to the <code>trainControl()</code> function.</p>\n<div class=\"cell\">\n<pre>set.seed(22)\n# hyperparameters\ntn_grid = expand.grid(\n    mtry = 8,\n    splitrule = \"extratrees\",\n    min.node.size = 5\n)\n\n# resampling\nspatial_blocks &lt;- blockCV::cv_spatial(\n    temperature_train,\n    k = 5,\n    hexagon = FALSE,\n    progress = FALSE\n)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>\n  train test\n1   155   40\n2   160   35\n3   155   40\n4   154   41\n5   156   39</pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-6-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-6-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n<pre>train_ids &lt;- lapply(spatial_blocks$folds_list, function(x) x[[1]])\ntest_ids &lt;- lapply(spatial_blocks$folds_list, function(x) x[[2]])\n\ntr_control &lt;- caret::trainControl(\n    method = \"cv\",\n    index = train_ids,\n    indexOut = test_ids,\n    savePredictions = TRUE\n)</pre>\n</div>\n</div>\n<div aria-labelledby=\"tabset-2-2-tab\" class=\"tab-pane\" id=\"tabset-2-2\">\n<p>In <strong>tidymodels</strong>, the steps are to:</p>\n<ol type=\"1\">\n<li>Specify the modeling formula using the <code>recipe()</code> function.</li>\n<li>Define the model using a function from the <strong>parsnip</strong> package, including the hyperparameters.</li>\n<li>Create a workflow using the <code>workflow()</code> function, which combines the recipe and the model.</li>\n<li>Define the resampling method using the <code>spatial_block_cv()</code> function from the <strong>spatialsample</strong> package.</li>\n</ol>\n<div class=\"cell\">\n<pre>set.seed(22)\nform &lt;- as.formula(paste0(\"temp ~ \", paste(predictor_names, collapse = \" + \")))\nrecipe &lt;- recipes::recipe(form, data = temperature_train)\n\nrf_model &lt;- parsnip::rand_forest(\n    trees = 100,\n    mtry = 8,\n    min_n = 5, \n    mode = \"regression\"\n) |&gt;\n    set_engine(\"ranger\", splitrule = \"extratrees\", importance = \"impurity\")\n\nworkflow &lt;- workflows::workflow() |&gt;\n    workflows::add_recipe(recipe) |&gt;\n    workflows::add_model(rf_model)\n\nblock_folds &lt;- spatialsample::spatial_block_cv(temperature_train, v = 5)\nspatialsample::autoplot(block_folds)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-7-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-7-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-2-3-tab\" class=\"tab-pane\" id=\"tabset-2-3\">\n<p>The basic <strong>mlr3</strong> steps are connected to its terminology:</p>\n<ol type=\"1\">\n<li><strong>Task</strong>: define the task using the <code>as_task_regr_st()</code> function, which specifies the target variable and the data.</li>\n<li><strong>Learner</strong>: define the model using the <code>lrn()</code> function, which specifies the model type and the hyperparameters.</li>\n<li><strong>Resampling</strong>: define the resampling method using the <code>rsmp()</code> function, which specifies the type of resampling and the number of folds. Here, we use the <code>spcv_block</code> resampling method.</li>\n</ol>\n<div class=\"cell\">\n<pre>set.seed(22)\ntask &lt;- mlr3spatiotempcv::as_task_regr_st(temperature_train, target = \"temp\")\nlearner &lt;- mlr3::lrn(\"regr.ranger\",\n    num.trees = 100,\n    importance = \"impurity\",\n    mtry = 8,\n    min.node.size = 5,\n    splitrule = \"extratrees\"\n)\nresampling &lt;- mlr3::rsmp(\"spcv_block\", folds = 5,\n                         cols = 10, rows = 10)</pre>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"modeling\">\n<h1>Modeling</h1>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-3-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-3-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-3-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-3-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-3-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-3-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-3-1-tab\" class=\"tab-pane active\" id=\"tabset-3-1\">\n<p>The main function of the <strong>caret</strong> package is <code>train()</code>, which takes the formula, the data, the model type, the tuning grid, the training control (including the resampling method), and some other arguments (e.g., the number of trees). The <code>train()</code> function will automatically perform the resampling and hyperparameter tuning (if applicable). The final model is stored in the <code>finalModel</code> object.</p>\n<div class=\"cell\">\n<pre>model_caret &lt;- caret::train(\n    temp ~ .,\n    data = st_drop_geometry(temperature_train),\n    method = \"ranger\",\n    tuneGrid = tn_grid,\n    trControl = tr_control,\n    num.trees = 100,\n    importance = \"impurity\"\n)\nmodel_caret_final &lt;- model_caret$finalModel</pre>\n</div>\n</div>\n<div aria-labelledby=\"tabset-3-2-tab\" class=\"tab-pane\" id=\"tabset-3-2\">\n<p>In <strong>tidymodels</strong>, the <code>fit_resamples()</code> function takes the previously defined workflow and the resampling folds. Here, we also use the <code>control</code> argument to save the predictions and the workflow, which can be useful for later analysis. The <code>fit_best()</code> function is used to fit the best model based on the resampling results.</p>\n<div class=\"cell\">\n<pre>rf_spatial &lt;- tune::fit_resamples(\n    workflow,\n    resamples = block_folds,\n    control = tune::control_resamples(save_pred = TRUE, save_workflow = TRUE)\n)\nmodel_tidymodels &lt;- fit_best(rf_spatial)</pre>\n</div>\n</div>\n<div aria-labelledby=\"tabset-3-3-tab\" class=\"tab-pane\" id=\"tabset-3-3\">\n<p>The <strong>mlr3</strong> workflow applies the <code>resample()</code> function to the task, the learner, and the resampling method. Then, to get the final model, we use the <code>train()</code> function on previously defined task and learner.</p>\n<div class=\"cell\">\n<pre>model_mlr3 &lt;- mlr3::resample(\n    task = task,\n    learner = learner,\n    resampling = resampling\n)\nlearner$train(task)</pre>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"evaluation\">\n<h1>Evaluation</h1>\n<p>After the models are trained, we want to evaluate their performance. Here, we use two of the most common metrics for regression tasks: the root mean square error (RMSE) and the coefficient of determination (R<sup>2</sup>).</p>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-4-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-4-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-4-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-4-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-4-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-4-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-4-1-tab\" class=\"tab-pane active\" id=\"tabset-4-1\">\n<p>RMSE and R<sup>2</sup> are calculated by default in <strong>caret</strong>. The performance metrics are then stored in the <code>results</code> object of the model.</p>\n<div class=\"cell\">\n<pre>model_caret$results</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>  mtry  splitrule min.node.size     RMSE  Rsquared       MAE    RMSESD\n1    8 extratrees             5 1.119936 0.8406388 0.9008884 0.2269326\n  RsquaredSD     MAESD\n1 0.06159361 0.1399976</pre>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-4-2-tab\" class=\"tab-pane\" id=\"tabset-4-2\">\n<p>RMSE and R<sup>2</sup> are calculated by default in <strong>tidymodels</strong>. The performance metrics are extracted from the resampling results using the <code>collect_metrics()</code> function.</p>\n<div class=\"cell\">\n<pre>tune::collect_metrics(rf_spatial)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre># A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard   1.10      5  0.0903 Preprocessor1_Model1\n2 rsq     standard   0.858     5  0.0424 Preprocessor1_Model1</pre>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-4-3-tab\" class=\"tab-pane\" id=\"tabset-4-3\">\n<p>We need to specify the measures we want to calculate using the <code>msr()</code> function. Then, the <code>aggregate()</code> method is used to calculate the selected performance metrics.</p>\n<div class=\"cell\">\n<pre>my_measures &lt;- c(mlr3::msr(\"regr.rmse\"), mlr3::msr(\"regr.rsq\"))\nmodel_mlr3$aggregate(measures = my_measures)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>regr.rmse       rsq \n1.1391701 0.8209292 </pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"prediction\">\n<h1>Prediction</h1>\n<p>Our goal is to predict the temperature in Spain using the covariates from the <code>predictor_stack</code> dataset. Thus, we want to obtain a map of the predicted temperature values for the entire country. The <code>predict()</code> function of the <strong>terra</strong> package makes model predictions on the new raster data.</p>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-5-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-5-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-5-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-5-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-5-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-5-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-5-1-tab\" class=\"tab-pane active\" id=\"tabset-5-1\">\n<div class=\"cell\">\n<pre>pred_caret &lt;- terra::predict(predictor_stack, model_caret, na.rm = TRUE)\nplot(pred_caret)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-15-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-15-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-5-2-tab\" class=\"tab-pane\" id=\"tabset-5-2\">\n<div class=\"cell\">\n<pre>pred_tidymodels &lt;- terra::predict(predictor_stack, model_tidymodels, na.rm = TRUE)\nplot(pred_tidymodels)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-16-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-16-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-5-3-tab\" class=\"tab-pane\" id=\"tabset-5-3\">\n<div class=\"cell\">\n<pre>pred_mlr3 &lt;- terra::predict(predictor_stack, learner, na.rm = TRUE)\nplot(pred_mlr3)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-17-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-17-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"area-of-applicability\">\n<h1>Area of applicability</h1>\n<p>The area of applicability (AoA) is a method to assess the what is the area of the input space that is similar to the training data. It is a useful tool to evaluate the model performance and to identify the areas where the model can be applied. Areas outside the AoA are considered to be outside the model’s applicability domain, and thus, the predictions in these areas should be interpreted with caution or not used at all.</p>\n<div class=\"tabset-margin-container\"></div><div class=\"panel-tabset\" data-group=\"language\">\n<ul class=\"nav nav-tabs\"><li class=\"nav-item\"><a aria-controls=\"tabset-6-1\" aria-selected=\"true\" class=\"nav-link active\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-6-1-tab\">caret</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-6-2\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-6-2-tab\">tidymodels</a></li><li class=\"nav-item\"><a aria-controls=\"tabset-6-3\" aria-selected=\"false\" class=\"nav-link\" data-bs-=\"\" data-bs-toggle=\"tab\" id=\"tabset-6-3-tab\">mlr3</a></li></ul>\n<div class=\"tab-content\" data-group=\"language\">\n<div aria-labelledby=\"tabset-6-1-tab\" class=\"tab-pane active\" id=\"tabset-6-1\">\n<p>The AoA method’s original implementation is in the <strong>CAST</strong> package – a package that extends the <strong>caret</strong> package. The AoA is calculated using the <code>aoa()</code> function, which takes the new data (the covariates) and the model as input.</p>\n<div class=\"cell\">\n<pre>AOA_caret &lt;- CAST::aoa(\n    newdata = predictor_stack,\n    model = model_caret,\n    verbose = FALSE\n)\nplot(AOA_caret$AOA)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-18-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-18-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-6-2-tab\" class=\"tab-pane\" id=\"tabset-6-2\">\n<p>The <strong>waywiser</strong> package implements the AoA method for <strong>tidymodels</strong><sup>2</sup>. The <code>ww_area_of_applicability()</code> function takes the training data and variable importance as input. Then, to obtain the AoA, we use the <code>predict()</code> function from the <strong>terra</strong> package.<sup>3</sup></p>\n<div class=\"cell\">\n<pre>model_aoa &lt;- waywiser::ww_area_of_applicability(\n    st_drop_geometry(temperature_train[, predictor_names]),\n    importance = vip::vi_model(model_tidymodels)\n)\nAOA_tidymodels &lt;- terra::predict(predictor_stack, model_aoa)\nplot(AOA_tidymodels$aoa)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-19-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-19-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<div aria-labelledby=\"tabset-6-3-tab\" class=\"tab-pane\" id=\"tabset-6-3\">\n<p>The <strong>CAST</strong> package can calculate the AoA for <strong>mlr3</strong> models. However, then we need to specify various arguments, such as a raster with covariates, the training data, the variables to be used, the weights of the variables, and the cross-validation folds.</p>\n<div class=\"cell\">\n<pre>rsmp_cv &lt;- resampling$instantiate(task)\n\nAOA_mlr3 &lt;- CAST::aoa(\n    newdata = predictor_stack,\n    train = as.data.frame(task$data()),\n    variables = task$feature_names,\n    weight = data.frame(t(learner$importance())),\n    CVtest = rsmp_cv$instance[order(row_id)]$fold,\n    verbose = FALSE\n)\nplot(AOA_mlr3$AOA)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-20-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp1/index_files/figure-html/unnamed-chunk-20-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</section>\n<section class=\"level1\" id=\"conclusion\">\n<h1>Conclusion</h1>\n<p>In this blog post, we compared three of the most popular machine learning frameworks in R: <strong>caret</strong>, <strong>tidymodels</strong>, and <strong>mlr3</strong>. We demonstrated how to use these frameworks for a spatial machine learning task, including model specification, training, evaluation, prediction, and obtaining the area of applicability.</p>\n<p>There is a lot of overlap in functionality between the three frameworks. Simultaneously, the frameworks differ in their design philosophy and implementation. Some, as <strong>caret</strong>, are more focused on providing a consistent and concise interface, but it offers limited flexibility. Others, like <strong>tidymodels</strong> and <strong>mlr3</strong>, are more modular and flexible, allowing for more complex workflows and customizations, which also makes them more complex to learn and use.</p>\n<p>Many additional steps can be added to the presented workflow, such as feature engineering, variable selection, hyperparameter tuning, model interpretation, and more. In the next blog posts, we will show these three frameworks in more detail, and then also present some other packages that can be used for spatial machine learning in R.</p>\n</section>\n<div class=\"default\" id=\"quarto-appendix\"><section class=\"footnotes footnotes-end-of-document\" id=\"footnotes\"><h2 class=\"anchored quarto-appendix-heading\">Footnotes</h2>\n<ol>\n<li id=\"fn1\"><p>Or the hyperparameter tuning grid, in a more advanced scenario.↩︎</p></li>\n<li id=\"fn2\"><p>It is not a wrapper for the <strong>CAST</strong> package, but a separate implementation with some differences as you may read in the function documentation – <code>?ww_area_of_applicability</code>↩︎</p></li>\n<li id=\"fn3\"><p>Thus, this approach allow to check the AoA for each new data set, not only the training data.↩︎</p></li>\n</ol>\n</section><section class=\"quarto-appendix-contents\" id=\"quarto-reuse\"><h2 class=\"anchored quarto-appendix-heading\">Reuse</h2><div class=\"quarto-appendix-contents\"><div><a href=\"https://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\" target=\"_blank\">CC BY 4.0</a></div></div></section><section class=\"quarto-appendix-contents\" id=\"quarto-citation\"><h2 class=\"anchored quarto-appendix-heading\">Citation</h2><div><div class=\"quarto-appendix-secondary-label\">BibTeX citation:</div><pre>@online{nowosad2025,\n  author = {Nowosad, Jakub},\n  title = {Spatial Machine Learning with {R:} Caret, Tidymodels, and\n    Mlr3},\n  date = {2025-04-30},\n  url = {https://geocompx.org/post/2025/sml-bp1/},\n  langid = {en}\n}\n</pre><div class=\"quarto-appendix-secondary-label\">For attribution, please cite this work as:</div><div class=\"csl-entry quarto-appendix-citeas\" id=\"ref-nowosad2025\">\nNowosad, Jakub. 2025. <span>“Spatial Machine Learning with R: Caret,\nTidymodels, and Mlr3.”</span> April 30, 2025. <a href=\"https://geocompx.org/post/2025/sml-bp1/\" rel=\"nofollow\" target=\"_blank\">https://geocompx.org/post/2025/sml-bp1/</a>.\n</div></div></section></div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://geocompx.org/post/2025/sml-bp1/\"> geocompx</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Spatial machine learning with R: caret, tidymodels, and mlr3\nPosted on\nApril 29, 2025\nby\nJakub Nowosad\nin\nR bloggers\n| 0 Comments\n[This article was first published on\ngeocompx\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nThis is the first part of a blog post series on spatial machine learning with R.\nThe R language has a variety of packages for machine learning, and many of them can be used for machine learning tasks in a spatial context (\nspatial machine learning\n). Spatial machine learning is generally different from traditional machine learning, as variables located closer to each other are often more similar than those located further apart. Thus, we need to consider that when building machine learning models.\nIn this blog post, we compare three of the most popular machine learning frameworks in R:\ncaret\n,\ntidymodels\n, and\nmlr3\n. We use a simple example to demonstrate how to use these frameworks for a spatial machine learning task and how their workflows differ. The goal here is to provide a general sense of how the spatial machine learning workflow looks like, and how different frameworks can be used to achieve the same goal.\nA possible workflow of the spatial machine learning task.\nInputs\nOur task is to predict the temperature in Spain using a set of covariates. We have two datasets for that purpose: the first one,\ntemperature_train\n, contains the temperature measurements from 195 locations in Spain, and the second one,\npredictor_stack\n, contains the covariates we will use to predict the temperature. These covariates include variables such as population density (\npopdens\n), distance to the coast (\ncoast\n), and elevation (\nelev\n), among others.\nlibrary(terra)\nlibrary(sf)\ntrain_points <- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\npredictor_stack <- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")\nWe use a subset of fourteen of the available covariates to predict the temperature. But before doing that, to prepare our data for modeling, we need to extract the covariate values at the locations of our training points.\npredictor_names <- names(predictor_stack)[1:14]\ntemperature_train <- terra::extract(predictor_stack[[predictor_names]],\n    train_points,\n    bind = TRUE\n) |>\n    sf::st_as_sf()\nNow, our\ntemperature_train\ndataset contains the temperature measurements and the covariate values at each location and is ready for modeling.\nLoading packages\nUsing each of the frameworks requires loading the respective packages.\ncaret\ntidymodels\nmlr3\nlibrary(caret)              # for modeling\nlibrary(blockCV)            # for spatial cross-validation\nlibrary(CAST)               # for area of applicability\nlibrary(tidymodels)         # metapackage for modeling\nlibrary(spatialsample)      # for spatial cross-validation\nlibrary(waywiser)           # for area of applicability\nlibrary(vip)                # for variable importance (used in AOA)\nlibrary(mlr3verse)          # metapackage for mlr3 modeling\nlibrary(mlr3spatiotempcv)   # for spatial cross-validation\nlibrary(CAST)               # for area of applicability\nlgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\nModel specification\nEach of the frameworks has its own way of setting up the modeling workflow. This may include defining the model, the resampling method, and the hyperparameter values\n1\n. In this example, we use random forest models as implemented in the\nranger\npackage with the following hyperparameters:\nmtry\n: the number of variables randomly sampled as candidates at each split of 8\nsplitrule\n: the splitting rule of\n\"extratrees\"\nmin.node.size\n: the minimum size of terminal nodes of 5\nWe also use a spatial cross-validation method with 5 folds. It means that the data is divided into many spatial blocks, and each block is assigned to a fold. The model is trained on a set of blocks belonging to the training set and evaluated on the remaining blocks. Note that each framework has its own way of defining the resampling method, and thus, the implementation and the folds may differ slightly.\ncaret\ntidymodels\nmlr3\nFor\ncaret\n, we define the hyperparameter grid using the\nexpand.grid()\nfunction, and the resampling method using the\ntrainControl()\nfunction. In this case, to use spatial cross-validation, we use the\nblockCV\npackage to create the folds, and then pass them to the\ntrainControl()\nfunction.\nset.seed(22)\n# hyperparameters\ntn_grid = expand.grid(\n    mtry = 8,\n    splitrule = \"extratrees\",\n    min.node.size = 5\n)\n\n# resampling\nspatial_blocks <- blockCV::cv_spatial(\n    temperature_train,\n    k = 5,\n    hexagon = FALSE,\n    progress = FALSE\n)\ntrain test\n1   155   40\n2   160   35\n3   155   40\n4   154   41\n5   156   39\ntrain_ids <- lapply(spatial_blocks$folds_list, function(x) x[[1]])\ntest_ids <- lapply(spatial_blocks$folds_list, function(x) x[[2]])\n\ntr_control <- caret::trainControl(\n    method = \"cv\",\n    index = train_ids,\n    indexOut = test_ids,\n    savePredictions = TRUE\n)\nIn\ntidymodels\n, the steps are to:\nSpecify the modeling formula using the\nrecipe()\nfunction.\nDefine the model using a function from the\nparsnip\npackage, including the hyperparameters.\nCreate a workflow using the\nworkflow()\nfunction, which combines the recipe and the model.\nDefine the resampling method using the\nspatial_block_cv()\nfunction from the\nspatialsample\npackage.\nset.seed(22)\nform <- as.formula(paste0(\"temp ~ \", paste(predictor_names, collapse = \" + \")))\nrecipe <- recipes::recipe(form, data = temperature_train)\n\nrf_model <- parsnip::rand_forest(\n    trees = 100,\n    mtry = 8,\n    min_n = 5, \n    mode = \"regression\"\n) |>\n    set_engine(\"ranger\", splitrule = \"extratrees\", importance = \"impurity\")\n\nworkflow <- workflows::workflow() |>\n    workflows::add_recipe(recipe) |>\n    workflows::add_model(rf_model)\n\nblock_folds <- spatialsample::spatial_block_cv(temperature_train, v = 5)\nspatialsample::autoplot(block_folds)\nThe basic\nmlr3\nsteps are connected to its terminology:\nTask\n: define the task using the\nas_task_regr_st()\nfunction, which specifies the target variable and the data.\nLearner\n: define the model using the\nlrn()\nfunction, which specifies the model type and the hyperparameters.\nResampling\n: define the resampling method using the\nrsmp()\nfunction, which specifies the type of resampling and the number of folds. Here, we use the\nspcv_block\nresampling method.\nset.seed(22)\ntask <- mlr3spatiotempcv::as_task_regr_st(temperature_train, target = \"temp\")\nlearner <- mlr3::lrn(\"regr.ranger\",\n    num.trees = 100,\n    importance = \"impurity\",\n    mtry = 8,\n    min.node.size = 5,\n    splitrule = \"extratrees\"\n)\nresampling <- mlr3::rsmp(\"spcv_block\", folds = 5,\n                         cols = 10, rows = 10)\nModeling\ncaret\ntidymodels\nmlr3\nThe main function of the\ncaret\npackage is\ntrain()\n, which takes the formula, the data, the model type, the tuning grid, the training control (including the resampling method), and some other arguments (e.g., the number of trees). The\ntrain()\nfunction will automatically perform the resampling and hyperparameter tuning (if applicable). The final model is stored in the\nfinalModel\nobject.\nmodel_caret <- caret::train(\n    temp ~ .,\n    data = st_drop_geometry(temperature_train),\n    method = \"ranger\",\n    tuneGrid = tn_grid,\n    trControl = tr_control,\n    num.trees = 100,\n    importance = \"impurity\"\n)\nmodel_caret_final <- model_caret$finalModel\nIn\ntidymodels\n, the\nfit_resamples()\nfunction takes the previously defined workflow and the resampling folds. Here, we also use the\ncontrol\nargument to save the predictions and the workflow, which can be useful for later analysis. The\nfit_best()\nfunction is used to fit the best model based on the resampling results.\nrf_spatial <- tune::fit_resamples(\n    workflow,\n    resamples = block_folds,\n    control = tune::control_resamples(save_pred = TRUE, save_workflow = TRUE)\n)\nmodel_tidymodels <- fit_best(rf_spatial)\nThe\nmlr3\nworkflow applies the\nresample()\nfunction to the task, the learner, and the resampling method. Then, to get the final model, we use the\ntrain()\nfunction on previously defined task and learner.\nmodel_mlr3 <- mlr3::resample(\n    task = task,\n    learner = learner,\n    resampling = resampling\n)\nlearner$train(task)\nEvaluation\nAfter the models are trained, we want to evaluate their performance. Here, we use two of the most common metrics for regression tasks: the root mean square error (RMSE) and the coefficient of determination (R\n2\n).\ncaret\ntidymodels\nmlr3\nRMSE and R\n2\nare calculated by default in\ncaret\n. The performance metrics are then stored in the\nresults\nobject of the model.\nmodel_caret$results\nmtry  splitrule min.node.size     RMSE  Rsquared       MAE    RMSESD\n1    8 extratrees             5 1.119936 0.8406388 0.9008884 0.2269326\n  RsquaredSD     MAESD\n1 0.06159361 0.1399976\nRMSE and R\n2\nare calculated by default in\ntidymodels\n. The performance metrics are extracted from the resampling results using the\ncollect_metrics()\nfunction.\ntune::collect_metrics(rf_spatial)\n# A tibble: 2 × 6\n  .metric .estimator  mean     n std_err .config             \n  <chr>   <chr>      <dbl> <int>   <dbl> <chr>               \n1 rmse    standard   1.10      5  0.0903 Preprocessor1_Model1\n2 rsq     standard   0.858     5  0.0424 Preprocessor1_Model1\nWe need to specify the measures we want to calculate using the\nmsr()\nfunction. Then, the\naggregate()\nmethod is used to calculate the selected performance metrics.\nmy_measures <- c(mlr3::msr(\"regr.rmse\"), mlr3::msr(\"regr.rsq\"))\nmodel_mlr3$aggregate(measures = my_measures)\nregr.rmse       rsq \n1.1391701 0.8209292\nPrediction\nOur goal is to predict the temperature in Spain using the covariates from the\npredictor_stack\ndataset. Thus, we want to obtain a map of the predicted temperature values for the entire country. The\npredict()\nfunction of the\nterra\npackage makes model predictions on the new raster data.\ncaret\ntidymodels\nmlr3\npred_caret <- terra::predict(predictor_stack, model_caret, na.rm = TRUE)\nplot(pred_caret)\npred_tidymodels <- terra::predict(predictor_stack, model_tidymodels, na.rm = TRUE)\nplot(pred_tidymodels)\npred_mlr3 <- terra::predict(predictor_stack, learner, na.rm = TRUE)\nplot(pred_mlr3)\nArea of applicability\nThe area of applicability (AoA) is a method to assess the what is the area of the input space that is similar to the training data. It is a useful tool to evaluate the model performance and to identify the areas where the model can be applied. Areas outside the AoA are considered to be outside the model’s applicability domain, and thus, the predictions in these areas should be interpreted with caution or not used at all.\ncaret\ntidymodels\nmlr3\nThe AoA method’s original implementation is in the\nCAST\npackage – a package that extends the\ncaret\npackage. The AoA is calculated using the\naoa()\nfunction, which takes the new data (the covariates) and the model as input.\nAOA_caret <- CAST::aoa(\n    newdata = predictor_stack,\n    model = model_caret,\n    verbose = FALSE\n)\nplot(AOA_caret$AOA)\nThe\nwaywiser\npackage implements the AoA method for\ntidymodels\n2\n. The\nww_area_of_applicability()\nfunction takes the training data and variable importance as input. Then, to obtain the AoA, we use the\npredict()\nfunction from the\nterra\npackage.\n3\nmodel_aoa <- waywiser::ww_area_of_applicability(\n    st_drop_geometry(temperature_train[, predictor_names]),\n    importance = vip::vi_model(model_tidymodels)\n)\nAOA_tidymodels <- terra::predict(predictor_stack, model_aoa)\nplot(AOA_tidymodels$aoa)\nThe\nCAST\npackage can calculate the AoA for\nmlr3\nmodels. However, then we need to specify various arguments, such as a raster with covariates, the training data, the variables to be used, the weights of the variables, and the cross-validation folds.\nrsmp_cv <- resampling$instantiate(task)\n\nAOA_mlr3 <- CAST::aoa(\n    newdata = predictor_stack,\n    train = as.data.frame(task$data()),\n    variables = task$feature_names,\n    weight = data.frame(t(learner$importance())),\n    CVtest = rsmp_cv$instance[order(row_id)]$fold,\n    verbose = FALSE\n)\nplot(AOA_mlr3$AOA)\nConclusion\nIn this blog post, we compared three of the most popular machine learning frameworks in R:\ncaret\n,\ntidymodels\n, and\nmlr3\n. We demonstrated how to use these frameworks for a spatial machine learning task, including model specification, training, evaluation, prediction, and obtaining the area of applicability.\nThere is a lot of overlap in functionality between the three frameworks. Simultaneously, the frameworks differ in their design philosophy and implementation. Some, as\ncaret\n, are more focused on providing a consistent and concise interface, but it offers limited flexibility. Others, like\ntidymodels\nand\nmlr3\n, are more modular and flexible, allowing for more complex workflows and customizations, which also makes them more complex to learn and use.\nMany additional steps can be added to the presented workflow, such as feature engineering, variable selection, hyperparameter tuning, model interpretation, and more. In the next blog posts, we will show these three frameworks in more detail, and then also present some other packages that can be used for spatial machine learning in R.\nFootnotes\nOr the hyperparameter tuning grid, in a more advanced scenario.↩︎\nIt is not a wrapper for the\nCAST\npackage, but a separate implementation with some differences as you may read in the function documentation –\n?ww_area_of_applicability\n↩︎\nThus, this approach allow to check the AoA for each new data set, not only the training data.↩︎\nReuse\nCC BY 4.0\nCitation\nBibTeX citation:\n@online{nowosad2025,\n  author = {Nowosad, Jakub},\n  title = {Spatial Machine Learning with {R:} Caret, Tidymodels, and\n    Mlr3},\n  date = {2025-04-30},\n  url = {https://geocompx.org/post/2025/sml-bp1/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nNowosad, Jakub. 2025.\n“Spatial Machine Learning with R: Caret,\nTidymodels, and Mlr3.”\nApril 30, 2025.\nhttps://geocompx.org/post/2025/sml-bp1/\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\ngeocompx\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "This is the first part of a blog post series on spatial machine learning with R. The R language has a variety of packages for machine learning, and many of them can be used for machine learning tasks in a spatial context (spatial machine...",
    "meta_keywords": null,
    "og_description": "This is the first part of a blog post series on spatial machine learning with R. The R language has a variety of packages for machine learning, and many of them can be used for machine learning tasks in a spatial context (spatial machine...",
    "og_image": "https://geocompx.org/post/2025/sml-bp1/index_files/figure-html/mermaid-figure-1.png",
    "og_title": "Spatial machine learning with R: caret, tidymodels, and mlr3 | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 10.4,
    "sitemap_lastmod": null,
    "twitter_description": "This is the first part of a blog post series on spatial machine learning with R. The R language has a variety of packages for machine learning, and many of them can be used for machine learning tasks in a spatial context (spatial machine...",
    "twitter_title": "Spatial machine learning with R: caret, tidymodels, and mlr3 | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/04/spatial-machine-learning-with-r-caret-tidymodels-and-mlr3/",
    "word_count": 2073
  }
}