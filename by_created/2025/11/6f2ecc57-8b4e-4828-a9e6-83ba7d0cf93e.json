{
  "uuid": "6f2ecc57-8b4e-4828-a9e6-83ba7d0cf93e",
  "created_at": "2025-11-22 19:59:16",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/02/lazy-introduction-to-laziness-in-r/",
    "crawled_at": "2025-11-22T10:54:15.241576",
    "external_links": [
      {
        "href": "https://blog.r-hub.io/2025/02/13/lazy-meanings/",
        "text": "Posts on R-hub blog"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://adv-r.hadley.nz/functions.html#lazy-evaluation",
        "text": "Advanced R book by Hadley Wickham"
      },
      {
        "href": "https://future.futureverse.org/index.html",
        "text": "future package"
      },
      {
        "href": "https://future.futureverse.org/reference/future.html",
        "text": "by default"
      },
      {
        "href": "https://dbplyr.tidyverse.org/",
        "text": "dbplyr package"
      },
      {
        "href": "https://dtplyr.tidyverse.org/index.html",
        "text": "dtplyr package"
      },
      {
        "href": "https://dtplyr.tidyverse.org/reference/lazy_dt.html",
        "text": "‚Äúlazy‚Äù data.table objects"
      },
      {
        "href": "https://dplyr.tidyverse.org/reference/compute.html",
        "text": "collect()"
      },
      {
        "href": "https://duckplyr.tidyverse.org/dev/",
        "text": "the duckplyr package"
      },
      {
        "href": "https://dplyr.tidyverse.org/reference/compute.html",
        "text": "collect()"
      },
      {
        "href": "https://duckdb.org/2024/04/02/duckplyr.html#eager-vs-lazy-materialization",
        "text": "ALTREP"
      },
      {
        "href": "https://duckplyr.tidyverse.org/reference/duckdb_tibble.html",
        "text": "duckplyr::as_duckdb_tibble()"
      },
      {
        "href": "https://duckplyr.tidyverse.org/reference/read_file_duckdb.html",
        "text": "duckplyr::read_parquet_duckdb()"
      },
      {
        "href": "https://rdrr.io/r/utils/data.html",
        "text": "data()"
      },
      {
        "href": "https://r-pkgs.org/data.html#sec-data-data",
        "text": "R packages book by Hadley Wickham and Jenny Bryan"
      },
      {
        "href": "https://cloud.r-project.org/doc/manuals/r-devel/R-exts.html#Data-in-packages",
        "text": "Writing R Extensions"
      },
      {
        "href": "https://blog.r-hub.io/2025/02/13/lazy-meanings/#fn:1",
        "text": "1"
      },
      {
        "href": "https://pkgdown.r-lib.org/reference/build_site.html",
        "text": "pkgdown::build_site()"
      },
      {
        "href": "https://pkgdown.r-lib.org/reference/build_site.html#arg-lazy",
        "text": "lazyargument"
      },
      {
        "href": "https://michaelchirico.github.io/potools/reference/po_update.html?q=lazy#ref-usage",
        "text": "‚Äúlazy‚Äù for a similar meaning"
      },
      {
        "href": "https://lazytest.cynkra.com/",
        "text": "lazytest package"
      },
      {
        "href": "https://devtools.r-lib.org/reference/test.html",
        "text": "devtools::test()"
      },
      {
        "href": "https://blog.djnavarro.net/posts/2024-12-16_regex-backreferences/#quantifiers",
        "text": "quantifiers"
      },
      {
        "href": "https://cloud.r-project.org/doc/manuals/r-devel/R-exts.html#Data-in-packages",
        "text": "Writing R Extensions"
      },
      {
        "href": "https://blog.r-hub.io/2025/02/13/lazy-meanings/#fnref:1",
        "text": "‚Ü©Ô∏é"
      },
      {
        "href": "https://blog.r-hub.io/2025/02/13/lazy-meanings/",
        "text": "Posts on R-hub blog"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Lazy introduction to laziness in R | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/posts-on-r-hub-blog/",
        "text": "Posts on R-hub blog"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-390562 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Lazy introduction to laziness in R</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">February 12, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/posts-on-r-hub-blog/\">Posts on R-hub blog</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://blog.r-hub.io/2025/02/13/lazy-meanings/\"> Posts on R-hub blog</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>In the programming world, laziness can often be a good thing: it is both a human quality that can motivate automation efforts, and a programming concept that avoids wasting resources such as memory. Now, when reading code or documentation, seeing the word ‚Äúlazy‚Äù can be confusing, because of its polisemy: it carries several meanings. In this post, we will enumerate the different possible definitions of ‚Äúlazy‚Äù in R code.</p>\n<h2 id=\"lazy-as-in-lazy-evaluation\">Lazy as in lazy evaluation</h2>\n<p>You might know that R provides <strong>lazy evaluation</strong>: the arguments of a function are only evaluated if they are accessed. In short, you can pass anything as an argument value to a function without any problem as long as the function does not use that value.</p>\n<p>For instance, the code below works despite <code>evaluation</code> not existing because the definition of the <code>do_something()</code> function includes ellipsis and because the <code>lazy</code> argument is not actually used.</p>\n<div class=\"highlight\">\n<pre>do_something &lt;- function(x, na.rm = TRUE, ...) {\n  mean(x, na.rm = na.rm)\n}\n\ndo_something(1:10, lazy = evaluation)\n#&gt; [1] 5.5\n</pre>\n</div>\n<p>The contrary of lazy evaluation is <strong>eager evaluation</strong>.</p>\n<p>The <a href=\"https://adv-r.hadley.nz/functions.html#lazy-evaluation\" rel=\"nofollow\" target=\"_blank\">Advanced R book by Hadley Wickham</a> features a very clear introduction to lazy evaluation.</p>\n<p>Note that the workhorse of lazy evaluation in base R is a thing called a <strong>promise</strong> that contains an <em>expression</em> (the recipe for getting a value), an <em>environment</em> (the ingredients that are around), and a <em>value</em>. The latter is only computed when accessed, and cached once computed.</p>\n<h3 id=\"what-about-futures-promises\">What about {future}‚Äôs promises?</h3>\n<p>Maybe you have heard the word ‚Äúpromises‚Äù in R in the context of the <a href=\"https://future.futureverse.org/index.html\" rel=\"nofollow\" target=\"_blank\">future package</a> by Henrik Bengtsson. It provides an implementation in R of <strong>futures</strong>, a programming concept. Its homepage state ‚ÄúIn programming, a future is an abstraction for a value that may be available at some point in the future. The state of a future can either be unresolved or resolved.‚Äù</p>\n<p>When using the {future} package, you create a future, that is associated to a <strong>promise</strong>, which is a <strong>placeholder for a value</strong> and then the value itself (so not the same definition of ‚Äúpromise‚Äù as the ‚Äúpromises‚Äù used by base R in the context of lazy evaluation). The value can be computed asynchronously, which means in parallel. Therefore, the futures package allows R programmers to take full advantage of their local computing resources: cores, clusters, etc.</p>\n<p>To come back to laziness, <a href=\"https://future.futureverse.org/reference/future.html\" rel=\"nofollow\" target=\"_blank\">by default</a> a future is <strong>not lazy</strong>, it is <strong>eager</strong>. This means that it is computed immediately.</p>\n<p>By default, the creation of a future below (<code>eager_future</code>) takes as much time as not wrapping the code in a future, because the computation is immediate. Setting <code>lazy</code> to <code>TRUE</code> makes the future creation much faster (<code>lazy_future</code>).</p>\n<div class=\"highlight\">\n<pre>library(\"future\")\nbench::mark(\n  no_future = is.numeric(runif(n = 10000000)),\n  eager_future = future(is.numeric(runif(n = 10000000))),\n  lazy_future = future(is.numeric(runif(n = 10000000)), lazy = TRUE),\n  check = FALSE\n)\n#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.\n#&gt; # A tibble: 3 √ó 6\n#&gt;   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 no_future       235ms    236ms      4.19    76.3MB     2.80\n#&gt; 2 eager_future    241ms    242ms      4.06    83.1MB     4.06\n#&gt; 3 lazy_future     745¬µs    977¬µs    842.      13.8KB    10.0\n</pre>\n</div>\n<p>If we do retrieve the value, overall the same time is spent between creating the future and our getting the value:</p>\n<div class=\"highlight\">\n<pre>bench::mark(\n  no_future = {is.numeric(runif(n = 10000000))},\n  eager_future = {x &lt;- future(is.numeric(runif(n = 10000000))); value(x)},\n  lazy_future = {x &lt;- future(is.numeric(runif(n = 10000000)), lazy = TRUE); value(x)},\n  check = FALSE\n)\n#&gt; # A tibble: 3 √ó 6\n#&gt;   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 no_future       236ms    239ms      4.20    76.3MB     4.20\n#&gt; 2 eager_future    241ms    241ms      4.11    76.6MB     4.11\n#&gt; 3 lazy_future     253ms    254ms      3.94    76.4MB     3.94\n</pre>\n</div>\n<p>Therefore, the use of futures and the use of lazy evaluation are orthogonal concepts: you can use future with or without lazy evaluation. The future package is about <em>how</em> the value is computed (in parallel or sequentially for instance), lazy evaluation is about <em>when</em> the value is computed (right as it is defined, or only when it is needed).</p>\n<h2 id=\"lazy-as-in-lazy-database-operations\">Lazy as in lazy database operations</h2>\n<p>In the database world, queries can be lazy: the query is like a TODO list that is only executed (computed, evaluated) when you want to access the resulting table or result. Making the output tangible is called <strong>materialization</strong>.</p>\n<p>This is vocabulary we can encounter when using:</p>\n<ul>\n<li>the <a href=\"https://dbplyr.tidyverse.org/\" rel=\"nofollow\" target=\"_blank\">dbplyr package</a> maintained by Hadley Wickham, which is the dplyr back-end for databases. <em>‚ÄúAll dplyr calls are evaluated lazily, generating SQL that is only sent to the database when you request the data.‚Äù</em></li>\n</ul>\n<p>Slightly tweaked from the dbplyr README,</p>\n<div class=\"highlight\">\n<pre># load packages\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(\"dbplyr\")\n#&gt; \n#&gt; Attaching package: 'dbplyr'\n#&gt; The following objects are masked from 'package:dplyr':\n#&gt; \n#&gt;     ident, sql\n\n# create the connection and refer to the table\ncon &lt;- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\nmtcars2 &lt;- tbl(con, \"mtcars\")\n\n# create the query\nsummary &lt;- mtcars2 %&gt;% \n  group_by(cyl) %&gt;% \n  summarise(mpg = mean(mpg, na.rm = TRUE)) %&gt;% \n  arrange(desc(mpg))\n\n# the object is lazy, the value is not computed yet\n# here is what summary looks like at this stage\nsummary\n#&gt; # Source:     SQL [?? x 2]\n#&gt; # Database:   sqlite 3.47.1 [:memory:]\n#&gt; # Ordered by: desc(mpg)\n#&gt;     cyl   mpg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4  26.7\n#&gt; 2     6  19.7\n#&gt; 3     8  15.1\nnrow(summary)\n#&gt; [1] NA\n\n# we explicitly request the data, so now it's there\nanswer &lt;- collect(summary)\nnrow(answer)\n#&gt; [1] 3\n</pre>\n</div>\n<ul>\n<li>the <a href=\"https://dtplyr.tidyverse.org/index.html\" rel=\"nofollow\" target=\"_blank\">dtplyr package</a> also maintained by Hadley Wickham, which is a data.table back-end for dplyr. The <a href=\"https://dtplyr.tidyverse.org/reference/lazy_dt.html\" rel=\"nofollow\" target=\"_blank\">‚Äúlazy‚Äù data.table objects</a> <em>‚Äúcaptures the intent of dplyr verbs, only actually performing computation when requested‚Äù</em> (with <a href=\"https://dplyr.tidyverse.org/reference/compute.html\" rel=\"nofollow\" target=\"_blank\"><code>collect()</code></a> for instance). The manual also explains that this allows dtplyr to make the code more performant by simplifying the data.table calls.</li>\n</ul>\n<p>Slightly tweaked from dtplyr README,</p>\n<div class=\"highlight\">\n<pre># load packages\nlibrary(data.table)\n#&gt; \n#&gt; Attaching package: 'data.table'\n#&gt; The following objects are masked from 'package:dplyr':\n#&gt; \n#&gt;     between, first, last\nlibrary(dtplyr)\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# create a ‚Äúlazy‚Äù data table that tracks the operations performed on it.\nmtcars2 &lt;- lazy_dt(mtcars)\n\n# create the query\nsummary &lt;- mtcars2 %&gt;% \n  filter(wt &lt; 5) %&gt;% \n  mutate(l100k = 235.21 / mpg) %&gt;% # liters / 100 km\n  group_by(cyl) %&gt;% \n  summarise(l100k = mean(l100k))\n\n# the object is lazy, the value is not computed yet\nsummary\n#&gt; Source: local data table [3 x 2]\n#&gt; Call:   `_DT1`[wt &lt; 5][, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), \n#&gt;     keyby = .(cyl)]\n#&gt; \n#&gt;     cyl l100k\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4  9.05\n#&gt; 2     6 12.0 \n#&gt; 3     8 14.9 \n#&gt; \n#&gt; # Use as.data.table()/as.data.frame()/as_tibble() to access results\nnrow(summary)\n#&gt; [1] NA\n\n# we explictly request the data, so now it's there\nanswer &lt;- as_tibble(summary)\nnrow(answer)\n#&gt; [1] 3\n</pre>\n</div>\n<ul>\n<li><a href=\"https://duckplyr.tidyverse.org/dev/\" rel=\"nofollow\" target=\"_blank\">the duckplyr package</a> which deserves its own subsection as its objects are both lazy and eager.</li>\n</ul>\n<h3 id=\"duckplyr-lazy-evaluation-and-prudence\">duckplyr, lazy evaluation and prudence</h3>\n<p>The duckplyr package is a package that uses DuckDB under the hood but that is also a drop-in replacement for dplyr. These two facts create a tension:</p>\n<ul>\n<li>\n<p>When using dplyr, we are not used to explicitly collect results: the data.frames are eager by default. Adding a <a href=\"https://dplyr.tidyverse.org/reference/compute.html\" rel=\"nofollow\" target=\"_blank\"><code>collect()</code></a> step by default would confuse users and make ‚Äúdrop-in replacement‚Äù an exaggeration. Therefore, duckplyr needs eagerness!</p>\n</li>\n<li>\n<p>The whole advantage of using DuckDB under the hood is letting DuckDB optimize computations, like dtplyr does with data.table. Therefore, duckplyr needs laziness!</p>\n</li>\n</ul>\n<p>As a consequence, duckplyr is lazy on the inside for all DuckDB operations but eager on the outside, thanks to <a href=\"https://duckdb.org/2024/04/02/duckplyr.html#eager-vs-lazy-materialization\" rel=\"nofollow\" target=\"_blank\">ALTREP</a>, a powerful R feature that among other things supports <strong>deferred evaluation</strong>.</p>\n<blockquote>\n<p>‚ÄúALTREP allows R objects to have different in-memory representations, and for custom code to be executed whenever those objects are accessed.‚Äù Hannes M√ºhleisen.</p>\n</blockquote>\n<p>If the thing accessing the duckplyr data.frame is‚Ä¶</p>\n<ul>\n<li>not duckplyr, then a special callback is executed, allowing materialization of the data frame.</li>\n<li>duckplyr, then the operations continue to be lazy (until a call to <code>collect.duckplyr_df()</code> for instance).</li>\n</ul>\n<p>Therefore, duckplyr can be both lazy (within itself) and not lazy (for the outside world). ü§™</p>\n<p>Now, the default materialization can be problematic if dealing with large data: what if the materialization eats up all memory? Therefore, the duckplyr package has a safeguard called <strong>prudence</strong> to control automatic materialization (from duckplyr 1.0.0). It has three possible settings:</p>\n<ul>\n<li>lavish, automatic materialization.</li>\n</ul>\n<div class=\"highlight\">\n<pre>mtcars |&gt;\n  duckplyr::as_duckdb_tibble() |&gt;\n  dplyr::mutate(mpg2 = mpg + 2) |&gt; \n  nrow()\n#&gt; [1] 32\n</pre>\n</div>\n<ul>\n<li>stingy, no automatic materialization ever.</li>\n</ul>\n<div class=\"highlight\">\n<pre>mtcars |&gt;\n  duckplyr::as_duckdb_tibble(prudence = \"stingy\") |&gt;\n  dplyr::mutate(mpg2 = mpg + 2) |&gt; \n  nrow()\n#&gt; Error: Materialization would result in 1 rows, which exceeds the limit of 0. Use collect() or as_tibble() to materialize.\n</pre>\n</div>\n<ul>\n<li>thrifty, automatic materialization up to 1 million cells so ok here</li>\n</ul>\n<div class=\"highlight\">\n<pre>mtcars |&gt;\n  duckplyr::as_duckdb_tibble(prudence = \"thrifty\") |&gt;\n  dplyr::mutate(mpg2 = mpg + 2) |&gt; \n  nrow()\n#&gt; [1] 32\n</pre>\n</div>\n<p>By default,</p>\n<ul>\n<li>duckplyr frames created with, say, <a href=\"https://duckplyr.tidyverse.org/reference/duckdb_tibble.html\" rel=\"nofollow\" target=\"_blank\"><code>duckplyr::as_duckdb_tibble()</code></a> are ‚Äúlavish‚Äù,</li>\n<li>but duckplyr frames created with ingestion functions such as <a href=\"https://duckplyr.tidyverse.org/reference/read_file_duckdb.html\" rel=\"nofollow\" target=\"_blank\"><code>duckplyr::read_parquet_duckdb()</code></a> (presumedly large data) are ‚Äúthrifty‚Äù.</li>\n</ul>\n<h2 id=\"lazy-as-in-lazy-loading-of-data-in-packages-lazydata\">Lazy as in lazy loading of data in packages (<code>LazyData</code>)</h2>\n<p>If your R package exports data, and sets the <code>LazyData</code> field in <code>DESCRIPTION</code> to <code>true</code>, then the exported datasets are lazily loaded: they‚Äôre available without the use of <a href=\"https://rdrr.io/r/utils/data.html\" rel=\"nofollow\" target=\"_blank\"><code>data()</code></a>, but they‚Äôre not actually taking up memory until they are accessed.</p>\n<p>There‚Äôs more details on <code>LazyData</code> in the <a href=\"https://r-pkgs.org/data.html#sec-data-data\" rel=\"nofollow\" target=\"_blank\">R packages book by Hadley Wickham and Jenny Bryan</a> and in <a href=\"https://cloud.r-project.org/doc/manuals/r-devel/R-exts.html#Data-in-packages\" rel=\"nofollow\" target=\"_blank\">Writing R Extensions</a>.</p>\n<p>Note that internal data is always lazily loaded, and that data that is too big<sup id=\"fnref:1\"><a class=\"footnote-ref\" href=\"https://blog.r-hub.io/2025/02/13/lazy-meanings/#fn:1\" rel=\"nofollow\" role=\"doc-noteref\" target=\"_blank\">1</a></sup> cannot be lazily loaded.</p>\n<h2 id=\"lazy-as-in-frugal-file-modifications\">Lazy as in frugal file modifications</h2>\n<p>The <a href=\"https://pkgdown.r-lib.org/reference/build_site.html\" rel=\"nofollow\" target=\"_blank\"><code>pkgdown::build_site()</code></a> function, that creates a documentation website for an R package, features a <a href=\"https://pkgdown.r-lib.org/reference/build_site.html#arg-lazy\" rel=\"nofollow\" target=\"_blank\"><code>lazy</code> argument</a>. ‚ÄúIf <code>TRUE</code>, will only rebuild articles and reference pages if the source is newer than the destination.‚Äù</p>\n<p>It is a much simpler concept of laziness: decide right now whether it is needed to rebuild each page.</p>\n<p>The potools package, that provides tools for portability and internationalization of R packages, uses <a href=\"https://michaelchirico.github.io/potools/reference/po_update.html?q=lazy#ref-usage\" rel=\"nofollow\" target=\"_blank\">‚Äúlazy‚Äù for a similar meaning</a>.</p>\n<h2 id=\"lazy-as-in-frugal-package-testing\">Lazy as in frugal package testing</h2>\n<p>The <a href=\"https://lazytest.cynkra.com/\" rel=\"nofollow\" target=\"_blank\">lazytest package</a> by Kirill M√ºller saves you time by only re-running tests that failed during the last run:</p>\n<ul>\n<li>You run all tests once with <code>lazytest::lazytest_local()</code> instead of <a href=\"https://devtools.r-lib.org/reference/test.html\" rel=\"nofollow\" target=\"_blank\"><code>devtools::test()</code></a>. The lazytest package records which tests failed.</li>\n<li>The next call to <code>lazytest::lazytest_local()</code> only runs the tests that had failed.</li>\n</ul>\n<p>This way you can iterate on fixing tests until you get a clean run. At which stage it‚Äôs probably wise to run all tests again to check you didn‚Äôt break anything else in the meantime. üòâ</p>\n<h2 id=\"lazy-as-in-lazy-quantifiers-in-regular-expressions\">Lazy as in lazy quantifiers in regular expressions</h2>\n<p>In regular expressions you can use <a href=\"https://blog.djnavarro.net/posts/2024-12-16_regex-backreferences/#quantifiers\" rel=\"nofollow\" target=\"_blank\">quantifiers</a> to indicate how many times a pattern must appear: the pattern can be optional, appear several times, etc. You can also specify whether the tool should match as many repetitions as possible, or the fewest number of repetitions possible.</p>\n<p>Matching the fewest number of repetitions possible is ‚Äúlazy‚Äù (or stingy). Matching as many repetitions as possible is ‚Äúeager‚Äù (or greedy).</p>\n<div class=\"highlight\">\n<pre>string &lt;- \"aaaaaa\"\n# greedy! eager!\nstringr::str_match(string, \"a+\")\n#&gt;      [,1]    \n#&gt; [1,] \"aaaaaa\"\n# stingy! lazy!\nstringr::str_match(string, \"a+?\")\n#&gt;      [,1]\n#&gt; [1,] \"a\"\n</pre>\n</div>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>In the context of lazy evaluation and lazy database operations we can think of lazy as a sort of parcimonious procrastination. For lazy database operations, the laziness is what supports optimization of the whole pipeline. In the case of frugal file modifications in pkgdown and potools or frugal testing with lazytest, lazy means an informed decision is made on the spot on whether a computation is needed. In the case of lazy quantifiers in regular expressions, lazy means stingy.</p>\n<p>Overall, an user can expect ‚Äúlazy‚Äù to mean ‚Äúless waste‚Äù, but it is crucial that the documentation of the particular piece of software at hand clarifies the meaning and the potential trade-offs.</p>\n<div class=\"footnotes\" role=\"doc-endnotes\">\n<hr/>\n<ol>\n<li id=\"fn:1\">\n<p>‚Äúthose which when serialized exceed 2GB, the limit for the format on 32-bit platforms‚Äù at the time of writing, in <a href=\"https://cloud.r-project.org/doc/manuals/r-devel/R-exts.html#Data-in-packages\" rel=\"nofollow\" target=\"_blank\">Writing R Extensions</a>.¬†<a class=\"footnote-backref\" href=\"https://blog.r-hub.io/2025/02/13/lazy-meanings/#fnref:1\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©Ô∏é</a></p>\n</li>\n</ol>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://blog.r-hub.io/2025/02/13/lazy-meanings/\"> Posts on R-hub blog</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Lazy introduction to laziness in R\nPosted on\nFebruary 12, 2025\nby\nPosts on R-hub blog\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nPosts on R-hub blog\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn the programming world, laziness can often be a good thing: it is both a human quality that can motivate automation efforts, and a programming concept that avoids wasting resources such as memory. Now, when reading code or documentation, seeing the word ‚Äúlazy‚Äù can be confusing, because of its polisemy: it carries several meanings. In this post, we will enumerate the different possible definitions of ‚Äúlazy‚Äù in R code.\nLazy as in lazy evaluation\nYou might know that R provides\nlazy evaluation\n: the arguments of a function are only evaluated if they are accessed. In short, you can pass anything as an argument value to a function without any problem as long as the function does not use that value.\nFor instance, the code below works despite\nevaluation\nnot existing because the definition of the\ndo_something()\nfunction includes ellipsis and because the\nlazy\nargument is not actually used.\ndo_something <- function(x, na.rm = TRUE, ...) {\n  mean(x, na.rm = na.rm)\n}\n\ndo_something(1:10, lazy = evaluation)\n#> [1] 5.5\nThe contrary of lazy evaluation is\neager evaluation\n.\nThe\nAdvanced R book by Hadley Wickham\nfeatures a very clear introduction to lazy evaluation.\nNote that the workhorse of lazy evaluation in base R is a thing called a\npromise\nthat contains an\nexpression\n(the recipe for getting a value), an\nenvironment\n(the ingredients that are around), and a\nvalue\n. The latter is only computed when accessed, and cached once computed.\nWhat about {future}‚Äôs promises?\nMaybe you have heard the word ‚Äúpromises‚Äù in R in the context of the\nfuture package\nby Henrik Bengtsson. It provides an implementation in R of\nfutures\n, a programming concept. Its homepage state ‚ÄúIn programming, a future is an abstraction for a value that may be available at some point in the future. The state of a future can either be unresolved or resolved.‚Äù\nWhen using the {future} package, you create a future, that is associated to a\npromise\n, which is a\nplaceholder for a value\nand then the value itself (so not the same definition of ‚Äúpromise‚Äù as the ‚Äúpromises‚Äù used by base R in the context of lazy evaluation). The value can be computed asynchronously, which means in parallel. Therefore, the futures package allows R programmers to take full advantage of their local computing resources: cores, clusters, etc.\nTo come back to laziness,\nby default\na future is\nnot lazy\n, it is\neager\n. This means that it is computed immediately.\nBy default, the creation of a future below (\neager_future\n) takes as much time as not wrapping the code in a future, because the computation is immediate. Setting\nlazy\nto\nTRUE\nmakes the future creation much faster (\nlazy_future\n).\nlibrary(\"future\")\nbench::mark(\n  no_future = is.numeric(runif(n = 10000000)),\n  eager_future = future(is.numeric(runif(n = 10000000))),\n  lazy_future = future(is.numeric(runif(n = 10000000)), lazy = TRUE),\n  check = FALSE\n)\n#> Warning: Some expressions had a GC in every iteration; so filtering is disabled.\n#> # A tibble: 3 √ó 6\n#>   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 no_future       235ms    236ms      4.19    76.3MB     2.80\n#> 2 eager_future    241ms    242ms      4.06    83.1MB     4.06\n#> 3 lazy_future     745¬µs    977¬µs    842.      13.8KB    10.0\nIf we do retrieve the value, overall the same time is spent between creating the future and our getting the value:\nbench::mark(\n  no_future = {is.numeric(runif(n = 10000000))},\n  eager_future = {x <- future(is.numeric(runif(n = 10000000))); value(x)},\n  lazy_future = {x <- future(is.numeric(runif(n = 10000000)), lazy = TRUE); value(x)},\n  check = FALSE\n)\n#> # A tibble: 3 √ó 6\n#>   expression        min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 no_future       236ms    239ms      4.20    76.3MB     4.20\n#> 2 eager_future    241ms    241ms      4.11    76.6MB     4.11\n#> 3 lazy_future     253ms    254ms      3.94    76.4MB     3.94\nTherefore, the use of futures and the use of lazy evaluation are orthogonal concepts: you can use future with or without lazy evaluation. The future package is about\nhow\nthe value is computed (in parallel or sequentially for instance), lazy evaluation is about\nwhen\nthe value is computed (right as it is defined, or only when it is needed).\nLazy as in lazy database operations\nIn the database world, queries can be lazy: the query is like a TODO list that is only executed (computed, evaluated) when you want to access the resulting table or result. Making the output tangible is called\nmaterialization\n.\nThis is vocabulary we can encounter when using:\nthe\ndbplyr package\nmaintained by Hadley Wickham, which is the dplyr back-end for databases.\n‚ÄúAll dplyr calls are evaluated lazily, generating SQL that is only sent to the database when you request the data.‚Äù\nSlightly tweaked from the dbplyr README,\n# load packages\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(\"dbplyr\")\n#> \n#> Attaching package: 'dbplyr'\n#> The following objects are masked from 'package:dplyr':\n#> \n#>     ident, sql\n\n# create the connection and refer to the table\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\nmtcars2 <- tbl(con, \"mtcars\")\n\n# create the query\nsummary <- mtcars2 %>% \n  group_by(cyl) %>% \n  summarise(mpg = mean(mpg, na.rm = TRUE)) %>% \n  arrange(desc(mpg))\n\n# the object is lazy, the value is not computed yet\n# here is what summary looks like at this stage\nsummary\n#> # Source:     SQL [?? x 2]\n#> # Database:   sqlite 3.47.1 [:memory:]\n#> # Ordered by: desc(mpg)\n#>     cyl   mpg\n#>   <dbl> <dbl>\n#> 1     4  26.7\n#> 2     6  19.7\n#> 3     8  15.1\nnrow(summary)\n#> [1] NA\n\n# we explicitly request the data, so now it's there\nanswer <- collect(summary)\nnrow(answer)\n#> [1] 3\nthe\ndtplyr package\nalso maintained by Hadley Wickham, which is a data.table back-end for dplyr. The\n‚Äúlazy‚Äù data.table objects\n‚Äúcaptures the intent of dplyr verbs, only actually performing computation when requested‚Äù\n(with\ncollect()\nfor instance). The manual also explains that this allows dtplyr to make the code more performant by simplifying the data.table calls.\nSlightly tweaked from dtplyr README,\n# load packages\nlibrary(data.table)\n#> \n#> Attaching package: 'data.table'\n#> The following objects are masked from 'package:dplyr':\n#> \n#>     between, first, last\nlibrary(dtplyr)\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# create a ‚Äúlazy‚Äù data table that tracks the operations performed on it.\nmtcars2 <- lazy_dt(mtcars)\n\n# create the query\nsummary <- mtcars2 %>% \n  filter(wt < 5) %>% \n  mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n  group_by(cyl) %>% \n  summarise(l100k = mean(l100k))\n\n# the object is lazy, the value is not computed yet\nsummary\n#> Source: local data table [3 x 2]\n#> Call:   `_DT1`[wt < 5][, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), \n#>     keyby = .(cyl)]\n#> \n#>     cyl l100k\n#>   <dbl> <dbl>\n#> 1     4  9.05\n#> 2     6 12.0 \n#> 3     8 14.9 \n#> \n#> # Use as.data.table()/as.data.frame()/as_tibble() to access results\nnrow(summary)\n#> [1] NA\n\n# we explictly request the data, so now it's there\nanswer <- as_tibble(summary)\nnrow(answer)\n#> [1] 3\nthe duckplyr package\nwhich deserves its own subsection as its objects are both lazy and eager.\nduckplyr, lazy evaluation and prudence\nThe duckplyr package is a package that uses DuckDB under the hood but that is also a drop-in replacement for dplyr. These two facts create a tension:\nWhen using dplyr, we are not used to explicitly collect results: the data.frames are eager by default. Adding a\ncollect()\nstep by default would confuse users and make ‚Äúdrop-in replacement‚Äù an exaggeration. Therefore, duckplyr needs eagerness!\nThe whole advantage of using DuckDB under the hood is letting DuckDB optimize computations, like dtplyr does with data.table. Therefore, duckplyr needs laziness!\nAs a consequence, duckplyr is lazy on the inside for all DuckDB operations but eager on the outside, thanks to\nALTREP\n, a powerful R feature that among other things supports\ndeferred evaluation\n.\n‚ÄúALTREP allows R objects to have different in-memory representations, and for custom code to be executed whenever those objects are accessed.‚Äù Hannes M√ºhleisen.\nIf the thing accessing the duckplyr data.frame is‚Ä¶\nnot duckplyr, then a special callback is executed, allowing materialization of the data frame.\nduckplyr, then the operations continue to be lazy (until a call to\ncollect.duckplyr_df()\nfor instance).\nTherefore, duckplyr can be both lazy (within itself) and not lazy (for the outside world). ü§™\nNow, the default materialization can be problematic if dealing with large data: what if the materialization eats up all memory? Therefore, the duckplyr package has a safeguard called\nprudence\nto control automatic materialization (from duckplyr 1.0.0). It has three possible settings:\nlavish, automatic materialization.\nmtcars |>\n  duckplyr::as_duckdb_tibble() |>\n  dplyr::mutate(mpg2 = mpg + 2) |> \n  nrow()\n#> [1] 32\nstingy, no automatic materialization ever.\nmtcars |>\n  duckplyr::as_duckdb_tibble(prudence = \"stingy\") |>\n  dplyr::mutate(mpg2 = mpg + 2) |> \n  nrow()\n#> Error: Materialization would result in 1 rows, which exceeds the limit of 0. Use collect() or as_tibble() to materialize.\nthrifty, automatic materialization up to 1 million cells so ok here\nmtcars |>\n  duckplyr::as_duckdb_tibble(prudence = \"thrifty\") |>\n  dplyr::mutate(mpg2 = mpg + 2) |> \n  nrow()\n#> [1] 32\nBy default,\nduckplyr frames created with, say,\nduckplyr::as_duckdb_tibble()\nare ‚Äúlavish‚Äù,\nbut duckplyr frames created with ingestion functions such as\nduckplyr::read_parquet_duckdb()\n(presumedly large data) are ‚Äúthrifty‚Äù.\nLazy as in lazy loading of data in packages (\nLazyData\n)\nIf your R package exports data, and sets the\nLazyData\nfield in\nDESCRIPTION\nto\ntrue\n, then the exported datasets are lazily loaded: they‚Äôre available without the use of\ndata()\n, but they‚Äôre not actually taking up memory until they are accessed.\nThere‚Äôs more details on\nLazyData\nin the\nR packages book by Hadley Wickham and Jenny Bryan\nand in\nWriting R Extensions\n.\nNote that internal data is always lazily loaded, and that data that is too big\n1\ncannot be lazily loaded.\nLazy as in frugal file modifications\nThe\npkgdown::build_site()\nfunction, that creates a documentation website for an R package, features a\nlazy\nargument\n. ‚ÄúIf\nTRUE\n, will only rebuild articles and reference pages if the source is newer than the destination.‚Äù\nIt is a much simpler concept of laziness: decide right now whether it is needed to rebuild each page.\nThe potools package, that provides tools for portability and internationalization of R packages, uses\n‚Äúlazy‚Äù for a similar meaning\n.\nLazy as in frugal package testing\nThe\nlazytest package\nby Kirill M√ºller saves you time by only re-running tests that failed during the last run:\nYou run all tests once with\nlazytest::lazytest_local()\ninstead of\ndevtools::test()\n. The lazytest package records which tests failed.\nThe next call to\nlazytest::lazytest_local()\nonly runs the tests that had failed.\nThis way you can iterate on fixing tests until you get a clean run. At which stage it‚Äôs probably wise to run all tests again to check you didn‚Äôt break anything else in the meantime. üòâ\nLazy as in lazy quantifiers in regular expressions\nIn regular expressions you can use\nquantifiers\nto indicate how many times a pattern must appear: the pattern can be optional, appear several times, etc. You can also specify whether the tool should match as many repetitions as possible, or the fewest number of repetitions possible.\nMatching the fewest number of repetitions possible is ‚Äúlazy‚Äù (or stingy). Matching as many repetitions as possible is ‚Äúeager‚Äù (or greedy).\nstring <- \"aaaaaa\"\n# greedy! eager!\nstringr::str_match(string, \"a+\")\n#>      [,1]    \n#> [1,] \"aaaaaa\"\n# stingy! lazy!\nstringr::str_match(string, \"a+?\")\n#>      [,1]\n#> [1,] \"a\"\nConclusion\nIn the context of lazy evaluation and lazy database operations we can think of lazy as a sort of parcimonious procrastination. For lazy database operations, the laziness is what supports optimization of the whole pipeline. In the case of frugal file modifications in pkgdown and potools or frugal testing with lazytest, lazy means an informed decision is made on the spot on whether a computation is needed. In the case of lazy quantifiers in regular expressions, lazy means stingy.\nOverall, an user can expect ‚Äúlazy‚Äù to mean ‚Äúless waste‚Äù, but it is crucial that the documentation of the particular piece of software at hand clarifies the meaning and the potential trade-offs.\n‚Äúthose which when serialized exceed 2GB, the limit for the format on 32-bit platforms‚Äù at the time of writing, in\nWriting R Extensions\n.\n‚Ü©Ô∏é\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nPosts on R-hub blog\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "In the programming world, laziness can often be a good thing: it is both a human quality that can motivate automation efforts, and a programming concept that avoids wasting resources such as memory. Now, when reading code or documentation, seeing the w...",
    "meta_keywords": null,
    "og_description": "In the programming world, laziness can often be a good thing: it is both a human quality that can motivate automation efforts, and a programming concept that avoids wasting resources such as memory. Now, when reading code or documentation, seeing the w...",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "Lazy introduction to laziness in R | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 10.7,
    "sitemap_lastmod": null,
    "twitter_description": "In the programming world, laziness can often be a good thing: it is both a human quality that can motivate automation efforts, and a programming concept that avoids wasting resources such as memory. Now, when reading code or documentation, seeing the w...",
    "twitter_title": "Lazy introduction to laziness in R | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/02/lazy-introduction-to-laziness-in-r/",
    "word_count": 2140
  }
}