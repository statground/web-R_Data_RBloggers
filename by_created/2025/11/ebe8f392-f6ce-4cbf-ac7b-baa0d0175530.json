{
  "uuid": "ebe8f392-f6ce-4cbf-ac7b-baa0d0175530",
  "created_at": "2025-11-22 19:58:01",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/07/lets-talk-about-na-s/",
    "crawled_at": "2025-11-22T10:45:13.518738",
    "external_links": [
      {
        "href": "https://www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/",
        "text": "R on Biofunctor"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://www.biobits.be/biofunctor/2025/06/20/monads-everywhr",
        "text": "previous post"
      },
      {
        "href": "https://www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/",
        "text": "R on Biofunctor"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Let’s talk about NA-s! | R-bloggers",
    "images": [
      {
        "alt": "The knights who say NA",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "The knights who say NA",
        "base64": null,
        "src": "https://i0.wp.com/www.biobits.be/biofunctor/post/2025-06-26-let-s-talk-about-na-s/knight_meme.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/Plot%20the%20running%20sum-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-1.png?w=450&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-2.png?w=450&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/r-on-biofunctor/",
        "text": "R on Biofunctor"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-394315 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Let’s talk about NA-s!</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">July 22, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-on-biofunctor/\">R on Biofunctor</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/\"> R on Biofunctor</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p><img alt=\"The knights who say NA\" data-lazy-src=\"https://i0.wp.com/www.biobits.be/biofunctor/post/2025-06-26-let-s-talk-about-na-s/knight_meme.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"The knights who say NA\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.biobits.be/biofunctor/post/2025-06-26-let-s-talk-about-na-s/knight_meme.png?w=578&amp;ssl=1\"/></noscript></p>\n<blockquote>\n<p>ARTHUR: Well, what is it you want?<br/>\nHEAD KNIGHT: We want… a paste function that can deal with NA-s!</p></blockquote>\n<p>A language for statistical computing clearly needs to be able to deal with\nmissing values, and R has various ways to do so. I will briefly go through some\nof them, then propose an interesting way to spice it up a bit.</p>\n<p>Missingness is represented with <code>NA</code> values, or – rather – non-values. Every\nvector type can contain the intended values or <code>NA</code>-s. As mentioned in a\n<a href=\"https://www.biobits.be/biofunctor/2025/06/20/monads-everywhr\" rel=\"nofollow\" target=\"_blank\">previous post</a>, this resembles an\n<em>optional</em> or <em>maybe</em> type in other languages. Most of the time, it is used to\nrepresent missing observations in a dataset, but you can equally return an <code>NA</code>\nfrom your function if it’s not able to calculate the expected result.</p>\n<p>To illustrate this, let’s write a function that takes a lower case letter and returns the previous one in the alphabet.</p>\n<pre>previous_letter &lt;- function(x) {\n    # Only consider the first letter of the fist string\n    res &lt;- letters[match(substr(x[1], 1, 1), letters) - 1]\n    if (length(res) != 1L) NA_character_ else res\n}\n\nprevious_letter(\"n\")\n\n## [1] \"m\"\n\nprevious_letter(\"a\")\n\n## [1] NA\n\nprevious_letter(\"#rstats\")\n\n## [1] NA\n</pre><p>If the input starts with <code>[b-z]</code>, it will return a lowercase letter, otherwise <code>NA</code>.</p>\n<p>Producing missing values is no big deal. Dealing with them is a bit more complicated, and R has various ways to do so.</p>\n<p>Worst first! You can set the <code>na.action</code> option globally, which may or may not be used by some functions or objects. This is not recommended, because it relies on something specific to your setup, so it can have unintended behaviour in another environment. Explicit is better than implicit, you should spell out what you want to do with the missing values.</p>\n<p>Luckily, the <code>{stats}</code> package comes with a few built-in utility functions:</p>\n<ul>\n<li><strong>na.pass</strong>: leave missing values alone</li>\n<li><strong>na.omit</strong>: omit missing values and record where they were</li>\n<li><strong>na.exclude</strong>: same as above, but different class (see help)</li>\n<li><strong>na.contiguous</strong>: find the longest consecutive stretch of non-missing values in an object</li>\n<li><strong>na.fail</strong>: throw error if there are missing values</li>\n</ul>\n<details>\n<summary>See examples</summary>\n<pre>vec_na &lt;- c(1, 2, NA, 4)\nna.pass(vec_na)\n\n## [1]  1  2 NA  4\n\nna.omit(vec_na)\n\n## [1] 1 2 4\n## attr(,\"na.action\")\n## [1] 3\n## attr(,\"class\")\n## [1] \"omit\"\n\nna.exclude(vec_na)\n\n## [1] 1 2 4\n## attr(,\"na.action\")\n## [1] 3\n## attr(,\"class\")\n## [1] \"exclude\"\n\nna.contiguous(vec_na)\n\n## [1] 1 2\n## attr(,\"na.action\")\n## [1] 3 4\n## attr(,\"class\")\n## [1] \"omit\"\n\nna.fail(vec_na) |&gt; try()\n\n## Error in na.fail.default(vec_na) : missing values in object\n</pre></details>\n<p>You can also create functions to make use of these internally, or handle missingness in other ways. Have you ever used <code>median(na.rm = TRUE)</code> in your scripts? No? How about <code>mean(na.rm = TRUE)</code> No? <code>sd</code> then? You see where I’m going? All these (and other) functions have implemented <code>NA</code> handling separately. Could there be a way that developers could focus on the task at hand (e.g. calculate median of a vector of values), and not have to care about what to do with missing values?</p>\n<p>From this perspective, there are two common function types:</p>\n<ul>\n<li>Summarising functions: Reduce many values into a single scalar (e.g.\n<code>mean()</code> or <code>paste(collapse = \" \")</code>)</li>\n<li>Plain functions: Keep the values in the vector realm (e.g. <code>cumsum()</code>\nor <code>paste(collapse = NULL)</code>)</li>\n</ul>\n<h2 id=\"plain-functions\">Plain functions</h2>\n<p>The above mentioned cumulative sum function has a problem with missing values.\nOnce it hits an <code>NA</code>, it will produce <code>NA</code>-s for the rest of the result.</p>\n<pre>cumsum(vec_na)\n\n## [1]  1  3 NA NA\n</pre><p>For the most part, this is the required behaviour, but sometimes one would\nprefer to treat <code>NA</code> as missing and keep the sum going. One could think of a\nfunction wrapper to sidestep the <code>NA</code>-s in one or more function arguments,\ncalculate the result, and add back <code>NA</code>-s to the correct positions. Let’s call\nit <code>dodge_NA</code>. We can restrict which function arguments are considered when\nsearching for missing values, and only the complete cases are used in the\ncalculation (vector recycling rules apply if their lengths differ).</p>\n<details>\n<summary><code>dodge_NA()</code> function definition</summary>\n<pre># Modified from base::Vectorize()\ndodge_NA &lt;- function(FUN, these_args = arg.names)\n{\n    my_name &lt;- match.call()[1L]\n    my_args &lt;- names(match.call()[-1L])\n    arg.names &lt;- as.list(formals(args(FUN)))\n    arg.names[[\"...\"]] &lt;- NULL\n    arg.names &lt;- names(arg.names)\n    these_args &lt;- as.character(these_args)\n    if (!length(these_args))\n        return(FUN)\n    if (!all(these_args %in% arg.names))\n        stop(\"must specify names of formal arguments for '\", my_name, \"'\")\n    collisions &lt;- arg.names %in% my_args\n    if (any(collisions))\n        stop(sQuote(\"FUN\"), \" may not have argument(s) named \",\n            paste(sQuote(arg.names[collisions]), collapse = \", \"))\n    rm(arg.names, collisions, my_args, my_name)\n    (function() {\n        FUNV &lt;- function() {\n            args &lt;- lapply(as.list(match.call())[-1L], eval,\n                parent.frame())\n\n            names &lt;- names(args) %||% character(length(args))\n\n            to_consider &lt;- (names %in% these_args) | names == \"\"\n\n            max_length &lt;- max(lengths(args[to_consider]))\n            arg_df &lt;- data.frame(lapply(args[to_consider], rep, length.out = max_length))\n\n            has_fun &lt;- complete.cases(arg_df)\n            short_res &lt;- do.call(\n                what = FUN,\n                args = c(as.list(arg_df[has_fun,,drop = FALSE]),\n                         args[!to_consider]))\n            # TODO: reconsider. this can give weird results if\n            #       args[!to_consider] is not length 1\n\n            long_res &lt;- vector(\n                mode = typeof(short_res),\n                length = max_length\n            )\n\n            long_res[has_fun] &lt;- short_res\n            long_res[!has_fun] &lt;- NA\n            return(long_res)\n        }\n        formals(FUNV) &lt;- formals(args(FUN))\n        environment(FUNV) &lt;- parent.env(environment())\n        FUNV\n    })()\n}\n</pre></details>\n<p>Let’s look at some examples!</p>\n<pre>cumsum_na &lt;- dodge_NA(cumsum)\ncumsum_na(vec_na)\n\n## [1]  1  3 NA  7\n</pre><p>Now, the cumulative sum continues past the missing values.</p>\n<pre>paste_na &lt;- dodge_NA(paste)\n\npaste(vec_na, LETTERS[1:12], sep = \"\") |&gt; noquote()\n\n##  [1] 1A  2B  NAC 4D  1E  2F  NAG 4H  1I  2J  NAK 4L\n\npaste_na(vec_na, LETTERS[1:12], sep = \"\") |&gt; noquote()\n\n##  [1] 1A   2B   &lt;NA&gt; 4D   1E   2F   &lt;NA&gt; 4H   1I   2J   &lt;NA&gt; 4L\n</pre><p>There might be perfectly good reasons for wanting the string “NA” in your final\ntext, I’ve just never come across one. I <em>always</em> had to clean up the vectors\nbefore going into the paste function. It’s quite likely that I’ll package this\nwhole thing just to avoid this problem in the future.</p>\n<h2 id=\"summarising-functions\">Summarising functions</h2>\n<p>The implementation is a bit easier in this case, because we don’t need to add\nback the <code>NA</code> values in the final vector (length of one). The rest is more or\nless the same as above.</p>\n<details>\n<summary><code>dodge_NA_collapse()</code> function definition</summary>\n<pre>dodge_NA_collapse &lt;- function(FUN, these_args = arg.names) {\n    my_name &lt;- match.call()[1L]\n    my_args &lt;- names(match.call()[-1L])\n    arg.names &lt;- as.list(formals(args(FUN)))\n    arg.names[[\"...\"]] &lt;- NULL\n    arg.names &lt;- names(arg.names)\n    these_args &lt;- as.character(these_args)\n    if (!length(these_args))\n        return(FUN)\n    if (!all(these_args %in% arg.names))\n        stop(\"must specify names of formal arguments for '\", my_name, \"'\")\n    collisions &lt;- arg.names %in% my_args\n    if (any(collisions))\n        stop(sQuote(\"FUN\"), \" may not have argument(s) named \",\n            paste(sQuote(arg.names[collisions]), collapse = \", \"))\n    rm(arg.names, collisions, my_args, my_name)\n    (function() {\n        FUNV &lt;- function() {\n            args &lt;- lapply(as.list(match.call())[-1L], eval,\n                parent.frame())\n\n            names &lt;- names(args) %||% character(length(args))\n\n            to_consider &lt;- (names %in% these_args) | names == \"\"\n\n            max_length &lt;- max(lengths(args[to_consider]))\n            arg_df &lt;- data.frame(lapply(\n                args[to_consider],\n                rep,\n                length.out = max_length\n            ))\n\n            has_fun &lt;- complete.cases(arg_df)\n\n            res &lt;- do.call(\n                what = FUN,\n                args = c(as.list(arg_df[has_fun,,drop = FALSE]),\n                         args[!to_consider]))\n            # TODO: reconsider. this can give weird results if\n            #       args[!to_consider] is not length 1\n\n            if (length(res) != 1L) warning(match.call()[1L], \" produced vector of length \", length(res))\n\n            return(res)\n        }\n        formals(FUNV) &lt;- formals(args(FUN))\n        environment(FUNV) &lt;- parent.env(environment())\n        FUNV\n    })()\n}\n</pre></details>\n<p>We can find some examples when simple paste can just blow up in your face. In\nthose cases, you’d better use the dodge version.</p>\n<pre>pastecollapse_na &lt;- dodge_NA_collapse(paste)\n\npaste(\n    vec_na  + 1,\n    \"palms\",\n    sep = \"\",\n    collapse = \" \"\n)\n\n## [1] \"2palms 3palms NApalms 5palms\"\n\npastecollapse_na(\n    vec_na + 1,\n    \"palms\",\n    sep = \"\",\n    collapse = \" \"\n)\n\n## [1] \"2palms 3palms 5palms\"\n</pre><p>As you know, the mean function uses the <code>na.rm</code> option. It’s a bit annoying to\nhave to type it out each and every time, but let’s say you’re already used to that.</p>\n<p>Let’s implement a new function, <code>plusminus</code>. It will add even numbers and\nsubtract odd numbers in a vector.</p>\n<pre># plusminus :: [ int ] -&gt; int\nplusminus &lt;- function(x) {\n    Reduce(`+`, -x * (2L * (x %% 2L) - 1L))\n}\n\n\npm_data &lt;- round(runif(20) * 46)\n\n# The final plus-minus sum\nplusminus(pm_data)\n\n## [1] -45\n</pre><p>Plusminus is a vectorized function, but I’d like to visualise how it works, so\nlet’s create a function to plot the running plusminus sum at each position. The\nnumbers to be added/subtracted are displayed along the curve.</p>\n<details>\n<summary><code>plot_running_sum()</code> function definition</summary>\n<pre>plot_running_sum &lt;- function(x, sumfun = plusminus) {\n    pos &lt;- seq_along(x)\n    running_sum &lt;- vapply(pos, \\(p) sumfun(x[1:p]), 0)\n    reinj &lt;- range(running_sum, na.rm = TRUE) # A-ha!\n    plot(pos, running_sum, type = \"b\", ylim = reinj * c(1, 1.1))\n    text(x = pos, y = running_sum + reinj[2] * 0.1, labels = x)\n    return(invisible(running_sum))\n}\n</pre></details>\n<pre>plot_running_sum(pm_data)\n</pre><img data-lazy-src=\"https://i0.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/Plot%20the%20running%20sum-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/Plot%20the%20running%20sum-1.png?w=450&amp;ssl=1\"/></noscript>\n<p>Now, should we add error handling to the function? Do we implement <code>na.rm</code>\noption with if statements within the body… Or shall we just <em>dodge</em> this\nchore?</p>\n<pre>plusminus_NA_ready &lt;- dodge_NA_collapse(plusminus)\n\n# Break the data\npm_data[13] &lt;- NA\n\n# Can't handle it\nplusminus(pm_data)\n\n## [1] NA\n\n# Can handle it\nplusminus_NA_ready(pm_data)\n\n## [1] -20\n\nplot_running_sum(pm_data, sumfun = plusminus)\n</pre><img data-lazy-src=\"https://i1.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-1.png?w=450&amp;ssl=1\"/></noscript>\n<pre>plot_running_sum(pm_data, sumfun = plusminus_NA_ready)\n</pre><img data-lazy-src=\"https://i2.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-2.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/index_files/figure-html/unnamed-chunk-9-2.png?w=450&amp;ssl=1\"/></noscript>\n<p>I hope this illustrates my point: focus on the logic, and not the <code>NA</code> handling,\nwhich is the same boring boilerplate in many different functions.</p>\n<h2 id=\"conclfusion\">Con[cl|f]usion</h2>\n<p>So what’s <em>really</em> going on here? The whole thinking started with monads. In a\nmonadic realm, you’d usually need a <code>bind</code> (<code>&gt;&gt;=</code>) function to chain\ncomputations. That’s because the usual functions start from scalar and produce a\nmonadic value (see equations below).</p>\n<p><code>$$\\displaylines{fun :: a \\rightarrow m~b \\\\ bind :: m~a \\rightarrow  (a \\rightarrow m~b) \\rightarrow m~b}$$</code></p>\n<p>In R, this is quite different. We are already in <em>vector+maybe</em> land, and we\nusually don’t leave it. Also, R functions rarely take only a single argument.\nMultiple arguments can contain <code>NA</code>-s (optional values). So a classic <code>bind</code>\nfunction would be ill-suited in this environment. Bind would only work on single\nargument (or curried) functions. And on top of that, it would add another infix\noperator, which may annoy some (many?) people.</p>\n<p>Instead, I decided to go for a function wrapper. It takes a function that can\nhandle non-missing input values only, and imbue it with the capability of\ndodging them.</p>\n<p><code>$$wrap :: (a \\rightarrow \\ldots \\rightarrow b \\rightarrow m~c) \\rightarrow (m~a \\rightarrow  m~\\ldots \\rightarrow b \\rightarrow m~c)$$</code></p>\n<p>This approach has some disadvantages, for example, the need for two\nwrappers for the two types of functions (summarising and plain). On the other\nhand, it will cope quite well with some R-specifics, and the resulting function\ncan be simply piped into with a native or magrittr pipe, like we’re used to.</p>\n<p>Next, I’d like to check if this can be extended to the other monad which is\nnative to R, the vector.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.biobits.be/biofunctor/2025/07/23/lets-talk-about-nas/\"> R on Biofunctor</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Let’s talk about NA-s!\nPosted on\nJuly 22, 2025\nby\nR on Biofunctor\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nR on Biofunctor\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nARTHUR: Well, what is it you want?\nHEAD KNIGHT: We want… a paste function that can deal with NA-s!\nA language for statistical computing clearly needs to be able to deal with\nmissing values, and R has various ways to do so. I will briefly go through some\nof them, then propose an interesting way to spice it up a bit.\nMissingness is represented with\nNA\nvalues, or – rather – non-values. Every\nvector type can contain the intended values or\nNA\n-s. As mentioned in a\nprevious post\n, this resembles an\noptional\nor\nmaybe\ntype in other languages. Most of the time, it is used to\nrepresent missing observations in a dataset, but you can equally return an\nNA\nfrom your function if it’s not able to calculate the expected result.\nTo illustrate this, let’s write a function that takes a lower case letter and returns the previous one in the alphabet.\nprevious_letter <- function(x) {\n    # Only consider the first letter of the fist string\n    res <- letters[match(substr(x[1], 1, 1), letters) - 1]\n    if (length(res) != 1L) NA_character_ else res\n}\n\nprevious_letter(\"n\")\n\n## [1] \"m\"\n\nprevious_letter(\"a\")\n\n## [1] NA\n\nprevious_letter(\"#rstats\")\n\n## [1] NA\nIf the input starts with\n[b-z]\n, it will return a lowercase letter, otherwise\nNA\n.\nProducing missing values is no big deal. Dealing with them is a bit more complicated, and R has various ways to do so.\nWorst first! You can set the\nna.action\noption globally, which may or may not be used by some functions or objects. This is not recommended, because it relies on something specific to your setup, so it can have unintended behaviour in another environment. Explicit is better than implicit, you should spell out what you want to do with the missing values.\nLuckily, the\n{stats}\npackage comes with a few built-in utility functions:\nna.pass\n: leave missing values alone\nna.omit\n: omit missing values and record where they were\nna.exclude\n: same as above, but different class (see help)\nna.contiguous\n: find the longest consecutive stretch of non-missing values in an object\nna.fail\n: throw error if there are missing values\nSee examples\nvec_na <- c(1, 2, NA, 4)\nna.pass(vec_na)\n\n## [1]  1  2 NA  4\n\nna.omit(vec_na)\n\n## [1] 1 2 4\n## attr(,\"na.action\")\n## [1] 3\n## attr(,\"class\")\n## [1] \"omit\"\n\nna.exclude(vec_na)\n\n## [1] 1 2 4\n## attr(,\"na.action\")\n## [1] 3\n## attr(,\"class\")\n## [1] \"exclude\"\n\nna.contiguous(vec_na)\n\n## [1] 1 2\n## attr(,\"na.action\")\n## [1] 3 4\n## attr(,\"class\")\n## [1] \"omit\"\n\nna.fail(vec_na) |> try()\n\n## Error in na.fail.default(vec_na) : missing values in object\nYou can also create functions to make use of these internally, or handle missingness in other ways. Have you ever used\nmedian(na.rm = TRUE)\nin your scripts? No? How about\nmean(na.rm = TRUE)\nNo?\nsd\nthen? You see where I’m going? All these (and other) functions have implemented\nNA\nhandling separately. Could there be a way that developers could focus on the task at hand (e.g. calculate median of a vector of values), and not have to care about what to do with missing values?\nFrom this perspective, there are two common function types:\nSummarising functions: Reduce many values into a single scalar (e.g.\nmean()\nor\npaste(collapse = \" \")\n)\nPlain functions: Keep the values in the vector realm (e.g.\ncumsum()\nor\npaste(collapse = NULL)\n)\nPlain functions\nThe above mentioned cumulative sum function has a problem with missing values.\nOnce it hits an\nNA\n, it will produce\nNA\n-s for the rest of the result.\ncumsum(vec_na)\n\n## [1]  1  3 NA NA\nFor the most part, this is the required behaviour, but sometimes one would\nprefer to treat\nNA\nas missing and keep the sum going. One could think of a\nfunction wrapper to sidestep the\nNA\n-s in one or more function arguments,\ncalculate the result, and add back\nNA\n-s to the correct positions. Let’s call\nit\ndodge_NA\n. We can restrict which function arguments are considered when\nsearching for missing values, and only the complete cases are used in the\ncalculation (vector recycling rules apply if their lengths differ).\ndodge_NA()\nfunction definition\n# Modified from base::Vectorize()\ndodge_NA <- function(FUN, these_args = arg.names)\n{\n    my_name <- match.call()[1L]\n    my_args <- names(match.call()[-1L])\n    arg.names <- as.list(formals(args(FUN)))\n    arg.names[[\"...\"]] <- NULL\n    arg.names <- names(arg.names)\n    these_args <- as.character(these_args)\n    if (!length(these_args))\n        return(FUN)\n    if (!all(these_args %in% arg.names))\n        stop(\"must specify names of formal arguments for '\", my_name, \"'\")\n    collisions <- arg.names %in% my_args\n    if (any(collisions))\n        stop(sQuote(\"FUN\"), \" may not have argument(s) named \",\n            paste(sQuote(arg.names[collisions]), collapse = \", \"))\n    rm(arg.names, collisions, my_args, my_name)\n    (function() {\n        FUNV <- function() {\n            args <- lapply(as.list(match.call())[-1L], eval,\n                parent.frame())\n\n            names <- names(args) %||% character(length(args))\n\n            to_consider <- (names %in% these_args) | names == \"\"\n\n            max_length <- max(lengths(args[to_consider]))\n            arg_df <- data.frame(lapply(args[to_consider], rep, length.out = max_length))\n\n            has_fun <- complete.cases(arg_df)\n            short_res <- do.call(\n                what = FUN,\n                args = c(as.list(arg_df[has_fun,,drop = FALSE]),\n                         args[!to_consider]))\n            # TODO: reconsider. this can give weird results if\n            #       args[!to_consider] is not length 1\n\n            long_res <- vector(\n                mode = typeof(short_res),\n                length = max_length\n            )\n\n            long_res[has_fun] <- short_res\n            long_res[!has_fun] <- NA\n            return(long_res)\n        }\n        formals(FUNV) <- formals(args(FUN))\n        environment(FUNV) <- parent.env(environment())\n        FUNV\n    })()\n}\nLet’s look at some examples!\ncumsum_na <- dodge_NA(cumsum)\ncumsum_na(vec_na)\n\n## [1]  1  3 NA  7\nNow, the cumulative sum continues past the missing values.\npaste_na <- dodge_NA(paste)\n\npaste(vec_na, LETTERS[1:12], sep = \"\") |> noquote()\n\n##  [1] 1A  2B  NAC 4D  1E  2F  NAG 4H  1I  2J  NAK 4L\n\npaste_na(vec_na, LETTERS[1:12], sep = \"\") |> noquote()\n\n##  [1] 1A   2B   <NA> 4D   1E   2F   <NA> 4H   1I   2J   <NA> 4L\nThere might be perfectly good reasons for wanting the string “NA” in your final\ntext, I’ve just never come across one. I\nalways\nhad to clean up the vectors\nbefore going into the paste function. It’s quite likely that I’ll package this\nwhole thing just to avoid this problem in the future.\nSummarising functions\nThe implementation is a bit easier in this case, because we don’t need to add\nback the\nNA\nvalues in the final vector (length of one). The rest is more or\nless the same as above.\ndodge_NA_collapse()\nfunction definition\ndodge_NA_collapse <- function(FUN, these_args = arg.names) {\n    my_name <- match.call()[1L]\n    my_args <- names(match.call()[-1L])\n    arg.names <- as.list(formals(args(FUN)))\n    arg.names[[\"...\"]] <- NULL\n    arg.names <- names(arg.names)\n    these_args <- as.character(these_args)\n    if (!length(these_args))\n        return(FUN)\n    if (!all(these_args %in% arg.names))\n        stop(\"must specify names of formal arguments for '\", my_name, \"'\")\n    collisions <- arg.names %in% my_args\n    if (any(collisions))\n        stop(sQuote(\"FUN\"), \" may not have argument(s) named \",\n            paste(sQuote(arg.names[collisions]), collapse = \", \"))\n    rm(arg.names, collisions, my_args, my_name)\n    (function() {\n        FUNV <- function() {\n            args <- lapply(as.list(match.call())[-1L], eval,\n                parent.frame())\n\n            names <- names(args) %||% character(length(args))\n\n            to_consider <- (names %in% these_args) | names == \"\"\n\n            max_length <- max(lengths(args[to_consider]))\n            arg_df <- data.frame(lapply(\n                args[to_consider],\n                rep,\n                length.out = max_length\n            ))\n\n            has_fun <- complete.cases(arg_df)\n\n            res <- do.call(\n                what = FUN,\n                args = c(as.list(arg_df[has_fun,,drop = FALSE]),\n                         args[!to_consider]))\n            # TODO: reconsider. this can give weird results if\n            #       args[!to_consider] is not length 1\n\n            if (length(res) != 1L) warning(match.call()[1L], \" produced vector of length \", length(res))\n\n            return(res)\n        }\n        formals(FUNV) <- formals(args(FUN))\n        environment(FUNV) <- parent.env(environment())\n        FUNV\n    })()\n}\nWe can find some examples when simple paste can just blow up in your face. In\nthose cases, you’d better use the dodge version.\npastecollapse_na <- dodge_NA_collapse(paste)\n\npaste(\n    vec_na  + 1,\n    \"palms\",\n    sep = \"\",\n    collapse = \" \"\n)\n\n## [1] \"2palms 3palms NApalms 5palms\"\n\npastecollapse_na(\n    vec_na + 1,\n    \"palms\",\n    sep = \"\",\n    collapse = \" \"\n)\n\n## [1] \"2palms 3palms 5palms\"\nAs you know, the mean function uses the\nna.rm\noption. It’s a bit annoying to\nhave to type it out each and every time, but let’s say you’re already used to that.\nLet’s implement a new function,\nplusminus\n. It will add even numbers and\nsubtract odd numbers in a vector.\n# plusminus :: [ int ] -> int\nplusminus <- function(x) {\n    Reduce(`+`, -x * (2L * (x %% 2L) - 1L))\n}\n\npm_data <- round(runif(20) * 46)\n\n# The final plus-minus sum\nplusminus(pm_data)\n\n## [1] -45\nPlusminus is a vectorized function, but I’d like to visualise how it works, so\nlet’s create a function to plot the running plusminus sum at each position. The\nnumbers to be added/subtracted are displayed along the curve.\nplot_running_sum()\nfunction definition\nplot_running_sum <- function(x, sumfun = plusminus) {\n    pos <- seq_along(x)\n    running_sum <- vapply(pos, \\(p) sumfun(x[1:p]), 0)\n    reinj <- range(running_sum, na.rm = TRUE) # A-ha!\n    plot(pos, running_sum, type = \"b\", ylim = reinj * c(1, 1.1))\n    text(x = pos, y = running_sum + reinj[2] * 0.1, labels = x)\n    return(invisible(running_sum))\n}\nplot_running_sum(pm_data)\nNow, should we add error handling to the function? Do we implement\nna.rm\noption with if statements within the body… Or shall we just\ndodge\nthis\nchore?\nplusminus_NA_ready <- dodge_NA_collapse(plusminus)\n\n# Break the data\npm_data[13] <- NA\n\n# Can't handle it\nplusminus(pm_data)\n\n## [1] NA\n\n# Can handle it\nplusminus_NA_ready(pm_data)\n\n## [1] -20\n\nplot_running_sum(pm_data, sumfun = plusminus)\nplot_running_sum(pm_data, sumfun = plusminus_NA_ready)\nI hope this illustrates my point: focus on the logic, and not the\nNA\nhandling,\nwhich is the same boring boilerplate in many different functions.\nCon[cl|f]usion\nSo what’s\nreally\ngoing on here? The whole thinking started with monads. In a\nmonadic realm, you’d usually need a\nbind\n(\n>>=\n) function to chain\ncomputations. That’s because the usual functions start from scalar and produce a\nmonadic value (see equations below).\n$$\\displaylines{fun :: a \\rightarrow m~b \\\\ bind :: m~a \\rightarrow  (a \\rightarrow m~b) \\rightarrow m~b}$$\nIn R, this is quite different. We are already in\nvector+maybe\nland, and we\nusually don’t leave it. Also, R functions rarely take only a single argument.\nMultiple arguments can contain\nNA\n-s (optional values). So a classic\nbind\nfunction would be ill-suited in this environment. Bind would only work on single\nargument (or curried) functions. And on top of that, it would add another infix\noperator, which may annoy some (many?) people.\nInstead, I decided to go for a function wrapper. It takes a function that can\nhandle non-missing input values only, and imbue it with the capability of\ndodging them.\n$$wrap :: (a \\rightarrow \\ldots \\rightarrow b \\rightarrow m~c) \\rightarrow (m~a \\rightarrow  m~\\ldots \\rightarrow b \\rightarrow m~c)$$\nThis approach has some disadvantages, for example, the need for two\nwrappers for the two types of functions (summarising and plain). On the other\nhand, it will cope quite well with some R-specifics, and the resulting function\ncan be simply piped into with a native or magrittr pipe, like we’re used to.\nNext, I’d like to check if this can be extended to the other monad which is\nnative to R, the vector.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nR on Biofunctor\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "ARTHUR: Well, what is it you want? HEAD KNIGHT: We want… a paste function that can deal with NA-s! A language for statistical computing clearly needs to be able to deal with missing values, and R has various ways to do so. I will briefly go th...",
    "meta_keywords": null,
    "og_description": "ARTHUR: Well, what is it you want? HEAD KNIGHT: We want… a paste function that can deal with NA-s! A language for statistical computing clearly needs to be able to deal with missing values, and R has various ways to do so. I will briefly go th...",
    "og_image": "https://www.biobits.be/biofunctor/post/2025-06-26-let-s-talk-about-na-s/knight_meme.png",
    "og_title": "Let’s talk about NA-s! | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 9.7,
    "sitemap_lastmod": null,
    "twitter_description": "ARTHUR: Well, what is it you want? HEAD KNIGHT: We want… a paste function that can deal with NA-s! A language for statistical computing clearly needs to be able to deal with missing values, and R has various ways to do so. I will briefly go th...",
    "twitter_title": "Let’s talk about NA-s! | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/07/lets-talk-about-na-s/",
    "word_count": 1946
  }
}