{
  "uuid": "36d89ae2-b7a0-4d40-ac69-39c40b8aa38b",
  "created_at": "2025-11-22 19:58:09",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/07/smooth-v4-3-0-in-r-whats-new-and-whats-next/",
    "crawled_at": "2025-11-22T10:46:06.532231",
    "external_links": [
      {
        "href": "https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/",
        "text": "Archives R - Open Forecasting"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://github.com/config-i1/smooth/issues",
        "text": "file an issue on github"
      },
      {
        "href": "https://openforecast.org/2020/08/17/accuracy-of-forecasting-methods-can-you-tell-the-difference/",
        "text": "this post"
      },
      {
        "href": "https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0.png&nocache=1",
        "text": null
      },
      {
        "href": "https://openforecast.org/adam/ADAMETSMultiplicativeAlternative.html",
        "text": "Section 6.6"
      },
      {
        "href": "https://openforecast.org/2025/06/30/iif-open-source-forecasting-software-workshop-and-smooth/",
        "text": "here"
      },
      {
        "href": "https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/",
        "text": "smooth v4.3.0 in R: what’s new and what’s next?"
      },
      {
        "href": "https://openforecast.org/",
        "text": "Open Forecasting"
      },
      {
        "href": "https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/",
        "text": "Archives R - Open Forecasting"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "smooth v4.3.0 in R: what’s new and what’s next? | R-bloggers",
    "images": [
      {
        "alt": "Nemenyi test for the smooth functions",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "Nemenyi test for the smooth functions",
        "base64": "data:image/jpeg;base64,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",
        "src": "https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&nocache=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/ivan-svetunkov/",
        "text": "Ivan Svetunkov"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-393750 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">smooth v4.3.0 in R: what’s new and what’s next?</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">July 4, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/ivan-svetunkov/\">Ivan Svetunkov</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/\"> Archives R - Open Forecasting</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Good news! The smooth package v4.3.0 is now on CRAN. And there are several things worth mentioning, so I have written this post.</p>\n<h3>New default initialisation mechanism</h3>\n<p>Since the beginning of the package, the <code>smooth</code> functions supported three ways for initialising the state vector (the vector that includes level, trend, seasonal indices): optimisation, backcasting and values provided by user. The former has been considered the standard way of estimating ETS, while the backcasting was originally proposed by Box &amp; Jenkins (1970) and was only implemented in the <code>smooth</code> (at least, I haven’t seen it anywhere else). The main advantage of the latter is in computational time, because you do not need to estimate every single value of the state vector. The new ADAM core that I developed during COVID lockdown, had some improvements for the backcasting, and I noticed that <code>adam()</code> produced more accurate forecasts with it than with the optimisation. But I needed more testing, so I have not changed anything back then.</p>\n<p>However, my recent work with Kandrika Pritularga on capturing uncertainty in ETS, have demonstrated that backcasting solves some fundamental problems with the variance of states – the optimisation cannot handle so many parameters, and asymptotic properties of ETS do not make sense in that case (we’ll release the paper as soon as we finish the experiments). So, with this evidence on hands and additional tests, I have made a decision to switch from the optimisation to backcasting as the default initialisation mechanism for all the <strong>smooth</strong> functions.</p>\n<p>The final users should not feel much difference, but it should work faster now and (hopefully) more accurately. If this is not the case, please get in touch or <a href=\"https://github.com/config-i1/smooth/issues\" rel=\"nofollow\" target=\"_blank\">file an issue on github</a>.</p>\n<p>Also, rest assured the <code>initial=\"optimal\"</code> is available and will stay available as an option in all the <code>smooth</code> functions, so, you can always switch back to it if you don’t like backcasting.</p>\n<p>Finally, I have introduce a new initialisation mechanism called “two-stage”, the idea of which is to apply backcasting first and then to optimise the obtained state values. It is slower, but is supposed to be better than the standard optimisation.</p>\n<h3>ADAM core</h3>\n<p>Every single function in the <code>smooth</code> package now uses ADAM C++ core, and the old core will be discontinued starting from v4.5.0 of the package. This applies to the functions: <code>es()</code>, <code>ssarima()</code>, <code>msarima()</code>, <code>ces()</code>, <code>gum()</code>, <code>sma()</code>. There are now the legacy versions of these functions in the package with the prefix “_old” (e.g. <code>es_old()</code>), which will be removed in the smooth v4.5.0. The new engine also helped <code>ssarima()</code>, which now became slightly more accurate than before. Unfortunately, there are still some issues with the initialisation of the seasonal <code>ssarima()</code>, which I have failed to solve completely. But I hope that over time this will be resolved as well.</p>\n<h3>smooth performance update</h3>\n<p>I have applied all the smooth functions together with the <code>ets()</code> and <code>auto.arima()</code> from the <code>forecast</code> package to the M1, M3 and Tourism competition data and have measured their performances in terms of RMSSE, scaled Cumulative Error (sCE) and computational time. I used the following R code for that:</p>\n<div class=\"su-spoiler su-spoiler-style-fancy su-spoiler-icon-plus su-spoiler-closed\" data-anchor-in-url=\"no\" data-scroll-offset=\"0\"><div class=\"su-spoiler-title\" role=\"button\" tabindex=\"0\"><span class=\"su-spoiler-icon\"></span>Long and boring code in R</div><div class=\"su-spoiler-content su-u-clearfix su-u-trim\">\n<pre>library(Mcomp)\nlibrary(Tcomp)\n\nlibrary(forecast)\nlibrary(smooth)\n\n# I work on Linux and use doMC. Substitute this with doParallel if you use Windows\nlibrary(doMC)\nregisterDoMC(detectCores())\n\n# Create a small but neat function that will return a vector of error measures\nerrorMeasuresFunction &lt;- function(object, holdout, insample){\n\tholdout &lt;- as.vector(holdout);\n\tinsample &lt;- as.vector(insample);\n\treturn(c(measures(holdout, object$mean, insample),\n\t\t\t mean(holdout &lt; object$upper &amp; holdout &gt; object$lower),\n\t\t\t mean(object$upper-object$lower)/mean(insample),\n\t\t\t pinball(holdout, object$upper, 0.975)/mean(insample),\n\t\t\t pinball(holdout, object$lower, 0.025)/mean(insample),\n\t\t\t sMIS(holdout, object$lower, object$upper, mean(insample),0.95),\n\t\t\t object$timeElapsed))\n}\n\n# Datasets to use\ndatasets &lt;- c(M1,M3,tourism)\ndatasetLength &lt;- length(datasets)\n# Types of models to try\nmethodsNames &lt;- c(\"ETS\", \"Auto ARIMA\",\n\t\t\t\t  \"ADAM ETS Back\", \"ADAM ETS Opt\", \"ADAM ETS Two\",\n\t\t\t\t  \"ES Back\", \"ES Opt\", \"ES Two\",\n\t\t\t\t  \"ADAM ARIMA Back\", \"ADAM ARIMA Opt\", \"ADAM ARIMA Two\",\n\t\t\t\t  \"MSARIMA Back\", \"MSARIMA Opt\", \"MSARIMA Two\",\n\t\t\t\t  \"SSARIMA Back\", \"SSARIMA Opt\", \"SSARIMA Two\",\n\t\t\t\t  \"CES Back\", \"CES Opt\", \"CES Two\",\n\t\t\t\t  \"GUM Back\", \"GUM Opt\", \"GUM Two\");\nmethodsNumber &lt;- length(methodsNames);\ntest &lt;- adam(datasets[[125]]);\n\ntestResults20250603 &lt;- array(NA,c(methodsNumber,datasetLength,length(test$accuracy)+6),\n                             dimnames=list(methodsNames, NULL,\n                                           c(names(test$accuracy),\n                                             \"Coverage\",\"Range\",\n                                             \"pinballUpper\",\"pinballLower\",\"sMIS\",\n                                             \"Time\")));\n\n#### ETS from forecast package ####\nj &lt;- 1;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- ets(datasets[[i]]$x);\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, level=95);\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### AUTOARIMA ####\nj &lt;- 2;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime &lt;- Sys.time()\n    test &lt;- auto.arima(datasets[[i]]$x);\n    testForecast &lt;- forecast(test, h=datasets[[i]]$h, level=95);\n    testForecast$timeElapsed &lt;- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ETS Backcasting ####\nj &lt;- 3;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- adam(datasets[[i]],\"ZXZ\", initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ETS Optimal ####\nj &lt;- 4;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- adam(datasets[[i]],\"ZXZ\", initial=\"opt\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ETS Two-stage ####\nj &lt;- 5;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- adam(datasets[[i]],\"ZXZ\", initial=\"two\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ES Backcasting ####\nj &lt;- 6;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- es(datasets[[i]],\"ZXZ\", initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ES Optimal ####\nj &lt;- 7;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- es(datasets[[i]],\"ZXZ\", initial=\"opt\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ES Two-stage ####\nj &lt;- 8;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- es(datasets[[i]],\"ZXZ\", initial=\"two\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ARIMA Backcasting ####\nj &lt;- 9;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.adam(datasets[[i]], \"NNN\", initial=\"back\", distribution=c(\"dnorm\"));\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ARIMA Optimal ####\nj &lt;- 10;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.adam(datasets[[i]], \"NNN\", initial=\"opt\", distribution=c(\"dnorm\"));\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### ADAM ARIMA Two-stage ####\nj &lt;- 11;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.adam(datasets[[i]], \"NNN\", initial=\"two\", distribution=c(\"dnorm\"));\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### MSARIMA Backcasting ####\nj &lt;- 12;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.msarima(datasets[[i]], initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### MSARIMA Optimal ####\nj &lt;- 13;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.msarima(datasets[[i]], initial=\"opt\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### MSARIMA Two-stage ####\nj &lt;- 14;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.msarima(datasets[[i]], initial=\"two\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### SSARIMA Backcasting ####\nj &lt;- 15;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.ssarima(datasets[[i]], initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### SSARIMA Optimal ####\nj &lt;- 16;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime &lt;- Sys.time()\n    test &lt;- auto.ssarima(datasets[[i]], initial=\"opt\");\n    testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n    testForecast$timeElapsed &lt;- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### SSARIMA Two-stage ####\nj &lt;- 17;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime &lt;- Sys.time()\n    test &lt;- auto.ssarima(datasets[[i]], initial=\"two\");\n    testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n    testForecast$timeElapsed &lt;- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### CES Backcasting ####\nj &lt;- 18;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.ces(datasets[[i]], initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### CES Optimal ####\nj &lt;- 19;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.ces(datasets[[i]], initial=\"opt\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### CES Two-stage ####\nj &lt;- 20;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.ces(datasets[[i]], initial=\"two\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### GUM Backcasting ####\nj &lt;- 21;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.gum(datasets[[i]], initial=\"back\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### GUM Optimal ####\nj &lt;- 22;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.gum(datasets[[i]], initial=\"opt\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);\n\n#### GUM Two-stage ####\nj &lt;- 23;\nresult &lt;- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime &lt;- Sys.time()\n  test &lt;- auto.gum(datasets[[i]], initial=\"two\");\n  testForecast &lt;- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed &lt;- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] &lt;- t(result);</pre>\n<p># Summary of results<br/>\ncbind(t(apply(testResults20250603[c(1:8,12:23),,\"RMSSE\"],1,quantile)),<br/>\n\t  mean=apply(testResults20250603[c(1:8,12:23),,\"RMSSE\"],1,mean),<br/>\n\t  sCE=apply(testResults20250603[c(1:8,12:23),,\"sCE\"],1,mean),<br/>\n\t  Time=apply(testResults20250603[c(1:8,12:23),,\"Time\"],1,mean)) |&gt; round(3)<br/>\n</p></div></div>\n<p>The table below shows the distribution of RMSSE, the mean sCE and mean Time. The boldface shows the best performing model.</p>\n<pre>                    min   Q1  median   Q3     max  mean    sCE  Time\nETS                0.024 0.677 1.181 2.376  51.616 1.970  0.299 0.385\nAuto ARIMA         0.025 0.680 1.179 2.358  51.616 1.986  0.124 1.467\n\nADAM ETS Back      0.015 0.666 1.175 2.276  51.616 1.921  0.470 0.218\nADAM ETS Opt       0.020 0.666 1.190 2.311  51.616 1.937  0.299 0.432\nADAM ETS Two       0.025 0.666 1.179 2.330  51.616 1.951  0.330 0.579\n\nES Back            0.015 0.672 1.174 2.284  51.616 1.921  0.464 0.219\nES Opt             0.020 0.672 1.186 2.316  51.616 1.943  0.302 0.497\nES Two             0.024 0.668 1.181 2.346  51.616 1.952  0.346 0.562\n\nMSARIMA Back       0.025 0.710 1.188 2.383  51.616 2.028  0.067 0.780\nMSARIMA Opt        0.025 0.724 1.242 2.489  51.616 2.083  0.088 1.905\nMSARIMA Two        0.025 0.718 1.250 2.485  51.906 2.075  0.083 2.431\n\nSSARIMA Back       0.045 0.738 1.248 2.383  51.616 2.063  0.167 1.747\nSSARIMA Opt        0.025 0.774 1.292 2.413  51.616 2.040  0.178 7.324\nSSARIMA Two        0.025 0.742 1.241 2.414  51.616 2.027  0.183 8.096\n\nCES Back           0.046 0.695 1.189 2.355  51.342 1.981  0.125 0.185\nCES Opt            0.030 0.698 1.218 2.327  49.480 2.001 -0.135 0.834\nCES Two            0.025 0.696 1.207 2.343  51.242 1.993 -0.078 1.006\n\nGUM Back           0.046 0.707 1.215 2.399  51.134 2.049 -0.285 3.575\nGUM Opt            0.026 0.795 1.381 2.717 240.143 2.932 -0.549 4.668\nGUM Two            0.026 0.803 1.406 2.826 240.143 3.041 -0.593 4.703</pre>\n<p>Several notes:</p>\n<ul>\n<li>ES is a wrapper of ADAM ETS. The main difference between them is that the former uses the Gamma distribution for the multiplicative error models, while the latter relies on the Normal one.</li>\n<li>MSARIMA is a wrapper for ADAM ARIMA, which is why I don't report the latter in the results.</li>\n</ul>\n<p>One thing you can notice from the output above, is that the models with backcasting consistently produce more accurate forecasts across all measures. I explain this with the idea that they tend not to overfit the data as much as the optimal initialisation does.</p>\n<p>To see the stochastic dominance of the forecasting models, I conducted the modification of the MCB/Nemenyi test, explained in <a href=\"https://openforecast.org/2020/08/17/accuracy-of-forecasting-methods-can-you-tell-the-difference/\" rel=\"nofollow\" target=\"_blank\">this post</a>:</p>\n<pre>par(mar=c(10,3,4,1))\ngreybox::rmcb(t(testResults20250603[c(1:8,12:23),,\"RMSSE\"]), outplot=\"mcb\")</pre>\n<div class=\"wp-caption aligncenter\" id=\"attachment_3908\" style=\"width: 310px\"><a href=\"https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0.png&amp;nocache=1\" rel=\"nofollow\" target=\"_blank\"><img alt=\"Nemenyi test for the smooth functions\" aria-describedby=\"caption-attachment-3908\" class=\"size-medium wp-image-3908\" data-lazy-sizes=\"(max-width: 300px) 100vw, 300px\" data-lazy-src=\"https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&amp;nocache=1\" decoding=\"async\" fetchpriority=\"high\" height=\"175\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" srcset_temp=\"https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&amp;nocache=1 300w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-1024x597.png&amp;nocache=1 1024w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-768x448.png&amp;nocache=1 768w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0.png&amp;nocache=1 1200w\" width=\"300\"/><noscript><img alt=\"Nemenyi test for the smooth functions\" aria-describedby=\"caption-attachment-3908\" class=\"size-medium wp-image-3908\" decoding=\"async\" fetchpriority=\"high\" height=\"175\" loading=\"lazy\" sizes=\"(max-width: 300px) 100vw, 300px\" src=\"https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&amp;nocache=1\" srcset_temp=\"https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&amp;nocache=1 300w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-1024x597.png&amp;nocache=1 1024w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-768x448.png&amp;nocache=1 768w, https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0.png&amp;nocache=1 1200w\" width=\"300\"/></noscript></a><p class=\"wp-caption-text\" id=\"caption-attachment-3908\">Nemenyi test for the smooth functions</p></div>\n<p>The image shows mean ranks for each of the models and whether the performance of those is significant on the 5% level or not. It is apparent that ADAM ETS has the lowest rank, no matter what the initialisation is used, but its performance does not differ significantly from the <code>es()</code>, <code>ets()</code> and <code>auto.arima()</code>. Also, <code>auto.arima()</code> significantly outperforms <code>msarima()</code> and <code>ssarima()</code> on this data, which could be due to their initialisation. Still, backcasting seems to help all the functions in terms of accuracy in comparison with the \"optimal\" and \"two-stage\" initials.</p>\n<h3>What's next?</h3>\n<p>I am now working on a modified formulation for ETS, which should fix some issues with the multiplicative trend and make the ETS safer. This is based on <a href=\"https://openforecast.org/adam/ADAMETSMultiplicativeAlternative.html\" rel=\"nofollow\" target=\"_blank\">Section 6.6</a> of the online version of the ADAM monograph (it is not in the printed version). I am not sure whether this will improve the accuracy further, but I hope that it will make some of the ETS models more resilient than they are right now. I specifically need the multiplicative trend model, which sometimes behave like crazy due to its formulation.</p>\n<p>I also plan to translate all the simulation functions to the ADAM core. This applies to <code>sim.es()</code>, <code>sim.ssarima()</code>, <code>sim.gum()</code> and <code>sim.ces()</code>. Currently they rely on the older one, and I want to get rid of it. Having said that, the method <code>simulate()</code> applied to the new <code>smooth</code> functions already uses the new core. It just lacks the flexibility that the other functions have.</p>\n<p>Furthermore, I want to rewrite the <code>oes()</code> function and substitute it with <code>oadam()</code>, which would use a better engine, supporting more features, such as multiple frequencies and ARIMA for the occurrence. This is a lot of work, and I probably will need help with that.</p>\n<p>Finally, Filotas Theodosiou, Leonidas Tsaprounis, and I are working on the translation of the R code of the <code>smooth</code> to Python. You can read a bit more about this project <a href=\"https://openforecast.org/2025/06/30/iif-open-source-forecasting-software-workshop-and-smooth/\" rel=\"nofollow\" target=\"_blank\">here</a>. There are several other people who decided to help us, but the progress so far has been a bit slow, because of the code translation. If you want to help, please get in touch.</p>\n<p>Message <a href=\"https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/\" rel=\"nofollow\" target=\"_blank\">smooth v4.3.0 in R: what’s new and what’s next?</a> first appeared on <a href=\"https://openforecast.org/\" rel=\"nofollow\" target=\"_blank\">Open Forecasting</a>.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://openforecast.org/2025/07/04/smooth-v4-3-0-in-r-what-s-new-and-what-s-next/\"> Archives R - Open Forecasting</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "smooth v4.3.0 in R: what’s new and what’s next?\nPosted on\nJuly 4, 2025\nby\nIvan Svetunkov\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nArchives R - Open Forecasting\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nGood news! The smooth package v4.3.0 is now on CRAN. And there are several things worth mentioning, so I have written this post.\nNew default initialisation mechanism\nSince the beginning of the package, the\nsmooth\nfunctions supported three ways for initialising the state vector (the vector that includes level, trend, seasonal indices): optimisation, backcasting and values provided by user. The former has been considered the standard way of estimating ETS, while the backcasting was originally proposed by Box & Jenkins (1970) and was only implemented in the\nsmooth\n(at least, I haven’t seen it anywhere else). The main advantage of the latter is in computational time, because you do not need to estimate every single value of the state vector. The new ADAM core that I developed during COVID lockdown, had some improvements for the backcasting, and I noticed that\nadam()\nproduced more accurate forecasts with it than with the optimisation. But I needed more testing, so I have not changed anything back then.\nHowever, my recent work with Kandrika Pritularga on capturing uncertainty in ETS, have demonstrated that backcasting solves some fundamental problems with the variance of states – the optimisation cannot handle so many parameters, and asymptotic properties of ETS do not make sense in that case (we’ll release the paper as soon as we finish the experiments). So, with this evidence on hands and additional tests, I have made a decision to switch from the optimisation to backcasting as the default initialisation mechanism for all the\nsmooth\nfunctions.\nThe final users should not feel much difference, but it should work faster now and (hopefully) more accurately. If this is not the case, please get in touch or\nfile an issue on github\n.\nAlso, rest assured the\ninitial=\"optimal\"\nis available and will stay available as an option in all the\nsmooth\nfunctions, so, you can always switch back to it if you don’t like backcasting.\nFinally, I have introduce a new initialisation mechanism called “two-stage”, the idea of which is to apply backcasting first and then to optimise the obtained state values. It is slower, but is supposed to be better than the standard optimisation.\nADAM core\nEvery single function in the\nsmooth\npackage now uses ADAM C++ core, and the old core will be discontinued starting from v4.5.0 of the package. This applies to the functions:\nes()\n,\nssarima()\n,\nmsarima()\n,\nces()\n,\ngum()\n,\nsma()\n. There are now the legacy versions of these functions in the package with the prefix “_old” (e.g.\nes_old()\n), which will be removed in the smooth v4.5.0. The new engine also helped\nssarima()\n, which now became slightly more accurate than before. Unfortunately, there are still some issues with the initialisation of the seasonal\nssarima()\n, which I have failed to solve completely. But I hope that over time this will be resolved as well.\nsmooth performance update\nI have applied all the smooth functions together with the\nets()\nand\nauto.arima()\nfrom the\nforecast\npackage to the M1, M3 and Tourism competition data and have measured their performances in terms of RMSSE, scaled Cumulative Error (sCE) and computational time. I used the following R code for that:\nLong and boring code in R\nlibrary(Mcomp)\nlibrary(Tcomp)\n\nlibrary(forecast)\nlibrary(smooth)\n\n# I work on Linux and use doMC. Substitute this with doParallel if you use Windows\nlibrary(doMC)\nregisterDoMC(detectCores())\n\n# Create a small but neat function that will return a vector of error measures\nerrorMeasuresFunction <- function(object, holdout, insample){\n\tholdout <- as.vector(holdout);\n\tinsample <- as.vector(insample);\n\treturn(c(measures(holdout, object$mean, insample),\n\t\t\t mean(holdout < object$upper & holdout > object$lower),\n\t\t\t mean(object$upper-object$lower)/mean(insample),\n\t\t\t pinball(holdout, object$upper, 0.975)/mean(insample),\n\t\t\t pinball(holdout, object$lower, 0.025)/mean(insample),\n\t\t\t sMIS(holdout, object$lower, object$upper, mean(insample),0.95),\n\t\t\t object$timeElapsed))\n}\n\n# Datasets to use\ndatasets <- c(M1,M3,tourism)\ndatasetLength <- length(datasets)\n# Types of models to try\nmethodsNames <- c(\"ETS\", \"Auto ARIMA\",\n\t\t\t\t  \"ADAM ETS Back\", \"ADAM ETS Opt\", \"ADAM ETS Two\",\n\t\t\t\t  \"ES Back\", \"ES Opt\", \"ES Two\",\n\t\t\t\t  \"ADAM ARIMA Back\", \"ADAM ARIMA Opt\", \"ADAM ARIMA Two\",\n\t\t\t\t  \"MSARIMA Back\", \"MSARIMA Opt\", \"MSARIMA Two\",\n\t\t\t\t  \"SSARIMA Back\", \"SSARIMA Opt\", \"SSARIMA Two\",\n\t\t\t\t  \"CES Back\", \"CES Opt\", \"CES Two\",\n\t\t\t\t  \"GUM Back\", \"GUM Opt\", \"GUM Two\");\nmethodsNumber <- length(methodsNames);\ntest <- adam(datasets[[125]]);\n\ntestResults20250603 <- array(NA,c(methodsNumber,datasetLength,length(test$accuracy)+6),\n                             dimnames=list(methodsNames, NULL,\n                                           c(names(test$accuracy),\n                                             \"Coverage\",\"Range\",\n                                             \"pinballUpper\",\"pinballLower\",\"sMIS\",\n                                             \"Time\")));\n\n#### ETS from forecast package ####\nj <- 1;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n  startTime <- Sys.time()\n  test <- ets(datasets[[i]]$x);\n  testForecast <- forecast(test, h=datasets[[i]]$h, level=95);\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### AUTOARIMA ####\nj <- 2;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime <- Sys.time()\n    test <- auto.arima(datasets[[i]]$x);\n    testForecast <- forecast(test, h=datasets[[i]]$h, level=95);\n    testForecast$timeElapsed <- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ETS Backcasting ####\nj <- 3;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- adam(datasets[[i]],\"ZXZ\", initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ETS Optimal ####\nj <- 4;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- adam(datasets[[i]],\"ZXZ\", initial=\"opt\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ETS Two-stage ####\nj <- 5;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- adam(datasets[[i]],\"ZXZ\", initial=\"two\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ES Backcasting ####\nj <- 6;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- es(datasets[[i]],\"ZXZ\", initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ES Optimal ####\nj <- 7;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- es(datasets[[i]],\"ZXZ\", initial=\"opt\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ES Two-stage ####\nj <- 8;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- es(datasets[[i]],\"ZXZ\", initial=\"two\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ARIMA Backcasting ####\nj <- 9;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.adam(datasets[[i]], \"NNN\", initial=\"back\", distribution=c(\"dnorm\"));\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ARIMA Optimal ####\nj <- 10;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.adam(datasets[[i]], \"NNN\", initial=\"opt\", distribution=c(\"dnorm\"));\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### ADAM ARIMA Two-stage ####\nj <- 11;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.adam(datasets[[i]], \"NNN\", initial=\"two\", distribution=c(\"dnorm\"));\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"pred\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### MSARIMA Backcasting ####\nj <- 12;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.msarima(datasets[[i]], initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### MSARIMA Optimal ####\nj <- 13;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.msarima(datasets[[i]], initial=\"opt\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### MSARIMA Two-stage ####\nj <- 14;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.msarima(datasets[[i]], initial=\"two\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### SSARIMA Backcasting ####\nj <- 15;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.ssarima(datasets[[i]], initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### SSARIMA Optimal ####\nj <- 16;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime <- Sys.time()\n    test <- auto.ssarima(datasets[[i]], initial=\"opt\");\n    testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n    testForecast$timeElapsed <- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### SSARIMA Two-stage ####\nj <- 17;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"forecast\") %dopar% {\n    startTime <- Sys.time()\n    test <- auto.ssarima(datasets[[i]], initial=\"two\");\n    testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n    testForecast$timeElapsed <- Sys.time() - startTime;\n    return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### CES Backcasting ####\nj <- 18;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.ces(datasets[[i]], initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### CES Optimal ####\nj <- 19;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.ces(datasets[[i]], initial=\"opt\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### CES Two-stage ####\nj <- 20;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.ces(datasets[[i]], initial=\"two\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### GUM Backcasting ####\nj <- 21;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.gum(datasets[[i]], initial=\"back\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### GUM Optimal ####\nj <- 22;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.gum(datasets[[i]], initial=\"opt\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n\n#### GUM Two-stage ####\nj <- 23;\nresult <- foreach(i=1:datasetLength, .combine=\"cbind\", .packages=\"smooth\") %dopar% {\n  startTime <- Sys.time()\n  test <- auto.gum(datasets[[i]], initial=\"two\");\n  testForecast <- forecast(test, h=datasets[[i]]$h, interval=\"parametric\");\n  testForecast$timeElapsed <- Sys.time() - startTime;\n  return(errorMeasuresFunction(testForecast, datasets[[i]]$xx, datasets[[i]]$x));\n}\ntestResults20250603[j,,] <- t(result);\n# Summary of results\ncbind(t(apply(testResults20250603[c(1:8,12:23),,\"RMSSE\"],1,quantile)),\nmean=apply(testResults20250603[c(1:8,12:23),,\"RMSSE\"],1,mean),\nsCE=apply(testResults20250603[c(1:8,12:23),,\"sCE\"],1,mean),\nTime=apply(testResults20250603[c(1:8,12:23),,\"Time\"],1,mean)) |> round(3)\nThe table below shows the distribution of RMSSE, the mean sCE and mean Time. The boldface shows the best performing model.\nmin   Q1  median   Q3     max  mean    sCE  Time\nETS                0.024 0.677 1.181 2.376  51.616 1.970  0.299 0.385\nAuto ARIMA         0.025 0.680 1.179 2.358  51.616 1.986  0.124 1.467\n\nADAM ETS Back      0.015 0.666 1.175 2.276  51.616 1.921  0.470 0.218\nADAM ETS Opt       0.020 0.666 1.190 2.311  51.616 1.937  0.299 0.432\nADAM ETS Two       0.025 0.666 1.179 2.330  51.616 1.951  0.330 0.579\n\nES Back            0.015 0.672 1.174 2.284  51.616 1.921  0.464 0.219\nES Opt             0.020 0.672 1.186 2.316  51.616 1.943  0.302 0.497\nES Two             0.024 0.668 1.181 2.346  51.616 1.952  0.346 0.562\n\nMSARIMA Back       0.025 0.710 1.188 2.383  51.616 2.028  0.067 0.780\nMSARIMA Opt        0.025 0.724 1.242 2.489  51.616 2.083  0.088 1.905\nMSARIMA Two        0.025 0.718 1.250 2.485  51.906 2.075  0.083 2.431\n\nSSARIMA Back       0.045 0.738 1.248 2.383  51.616 2.063  0.167 1.747\nSSARIMA Opt        0.025 0.774 1.292 2.413  51.616 2.040  0.178 7.324\nSSARIMA Two        0.025 0.742 1.241 2.414  51.616 2.027  0.183 8.096\n\nCES Back           0.046 0.695 1.189 2.355  51.342 1.981  0.125 0.185\nCES Opt            0.030 0.698 1.218 2.327  49.480 2.001 -0.135 0.834\nCES Two            0.025 0.696 1.207 2.343  51.242 1.993 -0.078 1.006\n\nGUM Back           0.046 0.707 1.215 2.399  51.134 2.049 -0.285 3.575\nGUM Opt            0.026 0.795 1.381 2.717 240.143 2.932 -0.549 4.668\nGUM Two            0.026 0.803 1.406 2.826 240.143 3.041 -0.593 4.703\nSeveral notes:\nES is a wrapper of ADAM ETS. The main difference between them is that the former uses the Gamma distribution for the multiplicative error models, while the latter relies on the Normal one.\nMSARIMA is a wrapper for ADAM ARIMA, which is why I don't report the latter in the results.\nOne thing you can notice from the output above, is that the models with backcasting consistently produce more accurate forecasts across all measures. I explain this with the idea that they tend not to overfit the data as much as the optimal initialisation does.\nTo see the stochastic dominance of the forecasting models, I conducted the modification of the MCB/Nemenyi test, explained in\nthis post\n:\npar(mar=c(10,3,4,1))\ngreybox::rmcb(t(testResults20250603[c(1:8,12:23),,\"RMSSE\"]), outplot=\"mcb\")\nNemenyi test for the smooth functions\nThe image shows mean ranks for each of the models and whether the performance of those is significant on the 5% level or not. It is apparent that ADAM ETS has the lowest rank, no matter what the initialisation is used, but its performance does not differ significantly from the\nes()\n,\nets()\nand\nauto.arima()\n. Also,\nauto.arima()\nsignificantly outperforms\nmsarima()\nand\nssarima()\non this data, which could be due to their initialisation. Still, backcasting seems to help all the functions in terms of accuracy in comparison with the \"optimal\" and \"two-stage\" initials.\nWhat's next?\nI am now working on a modified formulation for ETS, which should fix some issues with the multiplicative trend and make the ETS safer. This is based on\nSection 6.6\nof the online version of the ADAM monograph (it is not in the printed version). I am not sure whether this will improve the accuracy further, but I hope that it will make some of the ETS models more resilient than they are right now. I specifically need the multiplicative trend model, which sometimes behave like crazy due to its formulation.\nI also plan to translate all the simulation functions to the ADAM core. This applies to\nsim.es()\n,\nsim.ssarima()\n,\nsim.gum()\nand\nsim.ces()\n. Currently they rely on the older one, and I want to get rid of it. Having said that, the method\nsimulate()\napplied to the new\nsmooth\nfunctions already uses the new core. It just lacks the flexibility that the other functions have.\nFurthermore, I want to rewrite the\noes()\nfunction and substitute it with\noadam()\n, which would use a better engine, supporting more features, such as multiple frequencies and ARIMA for the occurrence. This is a lot of work, and I probably will need help with that.\nFinally, Filotas Theodosiou, Leonidas Tsaprounis, and I are working on the translation of the R code of the\nsmooth\nto Python. You can read a bit more about this project\nhere\n. There are several other people who decided to help us, but the progress so far has been a bit slow, because of the code translation. If you want to help, please get in touch.\nMessage\nsmooth v4.3.0 in R: what’s new and what’s next?\nfirst appeared on\nOpen Forecasting\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nArchives R - Open Forecasting\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "Good news! The smooth package v4.3.0 is now on CRAN. And there are several things worth mentioning, so I have written this post. New default initialisation mechanism Since the beginning of the package, the smooth functions supported three ways for initialising the state vector (the vector that includes level, trend, seasonal indices): optimisation, backcasting and […] Message smooth v4.3.0 in R: what’s new and what’s next? first appeared on Open Forecasting.",
    "meta_keywords": null,
    "og_description": "Good news! The smooth package v4.3.0 is now on CRAN. And there are several things worth mentioning, so I have written this post. New default initialisation mechanism Since the beginning of the package, the smooth functions supported three ways for initialising the state vector (the vector that includes level, trend, seasonal indices): optimisation, backcasting and […] Message smooth v4.3.0 in R: what’s new and what’s next? first appeared on Open Forecasting.",
    "og_image": "https://openforecast.org/wp-content/webpc-passthru.php?src=https://openforecast.org/wp-content/uploads/2025/07/2025-07-04-smooth-v4-3-0-300x175.png&nocache=1",
    "og_title": "smooth v4.3.0 in R: what’s new and what’s next? | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 15.3,
    "sitemap_lastmod": null,
    "twitter_description": "Good news! The smooth package v4.3.0 is now on CRAN. And there are several things worth mentioning, so I have written this post. New default initialisation mechanism Since the beginning of the package, the smooth functions supported three ways for initialising the state vector (the vector that includes level, trend, seasonal indices): optimisation, backcasting and […] Message smooth v4.3.0 in R: what’s new and what’s next? first appeared on Open Forecasting.",
    "twitter_title": "smooth v4.3.0 in R: what’s new and what’s next? | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/07/smooth-v4-3-0-in-r-whats-new-and-whats-next/",
    "word_count": 3057
  }
}