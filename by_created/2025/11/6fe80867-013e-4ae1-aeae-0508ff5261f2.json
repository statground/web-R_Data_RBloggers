{
  "uuid": "6fe80867-013e-4ae1-aeae-0508ff5261f2",
  "created_at": "2025-11-17 20:39:07",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2023/11/advent-of-code-2022/",
    "crawled_at": "2025-11-17T09:48:18.130287",
    "external_links": [
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/",
        "text": "rstats on Irregularly Scheduled Programming"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://adventofcode.com/",
        "text": "Advent of Code"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day1",
        "text": "Day 1: Calorie Counting"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day2",
        "text": "Day 2: Rock Paper Scissors"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day3",
        "text": "Day 3: Rucksack Reorganization"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day4",
        "text": "Day 4: Camp Cleanup"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day5",
        "text": "Day 5: Supply Stacks"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day6",
        "text": "Day 6: Tuning Trouble"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day7",
        "text": "Day 7: No Space Left On Device"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day8",
        "text": "Day 8: Treetop Tree House"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day9",
        "text": "Day 9: Rope Bridge"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day10",
        "text": "Day 10: Cathode-Ray Tube"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day11",
        "text": "Day 11: Monkey in the Middle"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day12",
        "text": "Day 12: Hill Climbing Algorithm"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day13",
        "text": "Day 13: Distress Signal"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day14",
        "text": "Day 14: Regolith Reservoir"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day15",
        "text": "Day 15: Beacon Exclusion Zone"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day16",
        "text": "Day 16: Proboscidea Volcanium"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day17",
        "text": "Day 17: Pyroclastic Flow"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day18",
        "text": "Day 18: Boiling Boulders"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day19",
        "text": "Day 19: Not Enough Minerals"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day20",
        "text": "Day 20: Grove Positioning System"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day21",
        "text": "Day 21: Monkey Math"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day22",
        "text": "Day 22: Monkey Map"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day23",
        "text": "Day 23: Unstable Diffusion"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day24",
        "text": "Day 24: Blizzard Basin"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day25",
        "text": "Day 25: Full of Hot Air"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day1",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day01.R",
        "text": "R"
      },
      {
        "href": "https://github.com/tjmahr/aoc",
        "text": "{aoc}"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/01.rs",
        "text": "Rust"
      },
      {
        "href": "https://github.com/fspoettel/advent-of-code-rust",
        "text": "{advent-of-code-rust}"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day2",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day02.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/02.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day3",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day03.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/03.rs",
        "text": "Rust"
      },
      {
        "href": "https://www.reddit.com/r/rust/comments/zbikje/comment/iys0sgr/",
        "text": "a Reddit thread"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day4",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day04.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/04.rs",
        "text": "Rust"
      },
      {
        "href": "https://stackoverflow.com/a/325964/4168169",
        "text": "StackOverflow"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day5",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day05.R",
        "text": "R"
      },
      {
        "href": "https://github.com/moodymudskipper/unglue",
        "text": "{unglue}"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/05.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day6",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day06.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/06.rs",
        "text": "Rust"
      },
      {
        "href": "https://stat.ethz.ch/R-manual/R-devel/library/utils/html/hashtab.html",
        "text": "such a structure in the form ofutils::hashtab()"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day7",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day07.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/08.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day8",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day08.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/09.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day9",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day09.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/09.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day10",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day10.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/10.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day11",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day11.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/11.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day12",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day12.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/12.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day13",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day13.R",
        "text": "R"
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/13.rs",
        "text": "Rust"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day14",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day14.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day15",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day15.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day16",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day16.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day17",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day17.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day18",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day18.R",
        "text": "R"
      },
      {
        "href": "https://github.com/coolbutuseless/isocubes",
        "text": "{isocubes}"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day19",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day19.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day20",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day20.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day21",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day21.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day22",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day22.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day23",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day23.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day24",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day24.R",
        "text": "R"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day25",
        "text": null
      },
      {
        "href": "https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day25.R",
        "text": "R"
      },
      {
        "href": "https://fosstodon.org/@jonocarroll",
        "text": "Mastodon"
      },
      {
        "href": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/",
        "text": "rstats on Irregularly Scheduled Programming"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Advent of Code 2022 | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day09.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12_test.gif?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12.gif?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.gif?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day17.gif?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day18.png?w=578&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jonathan-carroll/",
        "text": "Jonathan Carroll"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-380363 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Advent of Code 2022</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 27, 2023</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jonathan-carroll/\">Jonathan Carroll</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/\"> rstats on Irregularly Scheduled Programming</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 3.8.9--><p>In the lead up to Christmas each year, <a href=\"https://adventofcode.com/\" rel=\"nofollow\" target=\"_blank\">Advent of Code</a>\noffers a series of 25 puzzles which start out reasonably simple, but get progressively harder, eventually requiring knowledge of algorithms and dynamic programming techniques. Last year\nI solved these in (strictly) base R on the day they were released (or as close to as\nI could). I then (starting Dec 27) went back and re-solved (13 of) them in Rust.</p>\n<p>This post details what I learned along the way and some fun visualisations I made.</p>\n<p>As I eventually ran out of time before the 2023 AoC event, some of the latter\nsolutions are just links to my GitHub repo without comment. I‚Äôll try to update those\nat some point.</p>\n<br/>\n<details open=\"\">\n<summary>\nQuicklinks (click here to hide):\n</summary>\n<ul style=\"columns: 3; -webkit-columns: 3; -moz-columns: 3;\">\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day1\" rel=\"nofollow\" target=\"_blank\">Day 1: Calorie Counting</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day2\" rel=\"nofollow\" target=\"_blank\">Day 2: Rock Paper Scissors</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day3\" rel=\"nofollow\" target=\"_blank\">Day 3: Rucksack Reorganization</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day4\" rel=\"nofollow\" target=\"_blank\">Day 4: Camp Cleanup</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day5\" rel=\"nofollow\" target=\"_blank\">Day 5: Supply Stacks</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day6\" rel=\"nofollow\" target=\"_blank\">Day 6: Tuning Trouble</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day7\" rel=\"nofollow\" target=\"_blank\">Day 7: No Space Left On Device</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day8\" rel=\"nofollow\" target=\"_blank\">Day 8: Treetop Tree House</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day9\" rel=\"nofollow\" target=\"_blank\">Day 9: Rope Bridge</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day10\" rel=\"nofollow\" target=\"_blank\">Day 10: Cathode-Ray Tube</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day11\" rel=\"nofollow\" target=\"_blank\">Day 11: Monkey in the Middle</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day12\" rel=\"nofollow\" target=\"_blank\">Day 12: Hill Climbing Algorithm</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day13\" rel=\"nofollow\" target=\"_blank\">Day 13: Distress Signal</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day14\" rel=\"nofollow\" target=\"_blank\">Day 14: Regolith Reservoir</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day15\" rel=\"nofollow\" target=\"_blank\">Day 15: Beacon Exclusion Zone</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day16\" rel=\"nofollow\" target=\"_blank\">Day 16: Proboscidea Volcanium</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day17\" rel=\"nofollow\" target=\"_blank\">Day 17: Pyroclastic Flow</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day18\" rel=\"nofollow\" target=\"_blank\">Day 18: Boiling Boulders</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day19\" rel=\"nofollow\" target=\"_blank\">Day 19: Not Enough Minerals</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day20\" rel=\"nofollow\" target=\"_blank\">Day 20: Grove Positioning System</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day21\" rel=\"nofollow\" target=\"_blank\">Day 21: Monkey Math</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day22\" rel=\"nofollow\" target=\"_blank\">Day 22: Monkey Map</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day23\" rel=\"nofollow\" target=\"_blank\">Day 23: Unstable Diffusion</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day24\" rel=\"nofollow\" target=\"_blank\">Day 24: Blizzard Basin</a>\n</li>\n<li>\n<a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day25\" rel=\"nofollow\" target=\"_blank\">Day 25: Full of Hot Air</a>\n</li>\n</ul>\n</details>\n<p><br/></p>\n<div class=\"section level1\" id=\"day-1-calorie-counting\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day1\" id=\"day1\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 1: Calorie Counting</h1>\n<div class=\"section level2\" id=\"r\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day01.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>I hadn‚Äôt participated in AoC before this, so part of this day involved setting up\na clean way to get the puzzle into R and figure out how I was going to run/test\nmy solutions. The <a href=\"https://github.com/tjmahr/aoc\" rel=\"nofollow\" target=\"_blank\">{aoc}</a> package makes this quite smooth\nby using a session cookie to fetch the puzzle from the website and scaffold the input and\nfunctions for a given day.</p>\n<p>Each puzzle has a small worked example, which requires a small example data input. For the\nfirst two weeks I painstakingly copied this input from the puzzle text to the templated\n<code>example_input_xx</code> function. The actual input for the puzzle is typically much larger\nand I believe is randomised from a handful of variants so that not everyone gets the\nexact same input, which makes sharing solutions less of a problem. This input is\nstored in a <code>.txt</code> file in the <code>inst/</code> directory by the {aoc} package, which also\ntemplates a <code>run-dayxx.R</code> file which reads said input.</p>\n<p>All that‚Äôs left for the user is to fill in the <code>fxxa</code> and <code>fxxb</code> functions which\nsolve the part a and part b of each day‚Äôs puzzle.</p>\n<p>Solving the puzzle begins with parsing the input data, which may be a newline-delimited\nseries of numbers, or something more complex. In this case, groups of numbers\ndelimited by a blank line. This puzzle asks us to find the group with the largest total.\nWith the data loaded as a long string containing newlines <code>\\n</code> I split at a double-newline,\nthen spit within each group at the remaining newline, trimmed the string, converted\nto an integer, and summed the result, which gives a total value per group. Finally, I\ndetermined the largest value from the groups with the pattern <code>x[which.max(x)]</code></p>\n<pre>f01a &lt;- function(x) {\n  xvec &lt;- strsplit(x, \"\\n\\n\")[[1]]\n  tots &lt;- unlist(lapply(xvec, \\(y) sum(as.integer(trimws(strsplit(y, \"\\n\")[[1]])))))\n  tots[which.max(tots)]\n}</pre>\n<p>An alternative would have been to sort <code>tots</code> and take the first value.</p>\n<p>The second part of each puzzle expands the problem - in this case, rather than just the\nlargest value from a group, it asks for the largest three groups</p>\n<pre>f01b &lt;- function(x) {\n  xvec &lt;- strsplit(x, \"\\n\\n\")[[1]]\n  tots &lt;- unlist(lapply(xvec, \\(y) sum(as.integer(trimws(strsplit(y, \"\\n\")[[1]])))))\n  res &lt;- 0\n  for (i in 1:3) {\n    n &lt;- which.max(tots)\n    res &lt;- res + tots[n]\n    tots &lt;- tots[-n]\n  }\n  res\n}</pre>\n<p>In hindsight, <code>sum(head(sort(tots, decreasing = TRUE), 3))</code> looks like it would have been clearer.</p>\n<p>I wasn‚Äôt interested in the performance of my solutions, but for the sake of comparison\nlater, here is how long these take to run over the real input, which contains <code>2251</code> lines</p>\n<pre>microbenchmark::microbenchmark(f01a(x), f01b(x), times = 100, check = NULL)\nUnit: milliseconds\n    expr      min       lq     mean   median       uq      max neval cld\n f01a(x) 21.21986 21.50103 22.26573 21.63479 21.82128 31.41858   100   a\n f01b(x) 21.18393 21.52034 22.29896 21.67297 21.87063 32.98093   100   a</pre>\n<p>Running the final solutions from the templated <code>inst/run-dayxx.R</code> file involves building the\npackage (so that the daily functions are available) and running</p>\n<pre>library(adventofcode22)\nx &lt;- readLines(\"./inst/input01.txt\")\nx &lt;- paste(x, collapse = \"\\n\")\n\np1 &lt;- f01a(x)\np2 &lt;- f01b(x)</pre>\n</div>\n<div class=\"section level2\" id=\"rust\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/01.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>Returning to these puzzles from Rust presents the same issue - how do I get the inputs\nand parse them? The equivalent to the {aoc} package in Rust is a template repository\n<a href=\"https://github.com/fspoettel/advent-of-code-rust\" rel=\"nofollow\" target=\"_blank\">{advent-of-code-rust}</a> which adds some\nfunctionality to <code>cargo</code> to scaffold and solve each day‚Äôs puzzle.</p>\n<p>This crate also adds some helper functions for reading in the inputs and some tests for\nconfirming that the solutions successfully solve with the example data.</p>\n<p>Working with arbitrary data in Rust was a bit of a learning experience for me - until\nthis point I‚Äôd worked with known structures where I knew exactly what size and shape\nto expect, and as such I could define what needed to happen. With the puzzle input,\nI needed to learn how to work with unknown lengths and anticipate what might not work.</p>\n<p>I learned from my R solutions that a shared ‚Äòhelper‚Äô function to read the data is\nquite useful, so I started there. As with the R solution, splitting the data into\ngroups at a double newline produces the ‚Äòelf‚Äô groups. Splitting each of those groups\ninvolved a <code>map</code> which splits each group‚Äôs text into <code>lines()</code>, converts to integers (<code>u32</code>)\nwith <code>parse()</code>, then <code>sum()</code>s each group, <code>collect()</code>ing the result from each group back\ninto a vector. The <code>unwrap()</code> in the middle of this is because <code>parse()</code> can fail -\nsomething may not be representable as an integer - so <code>parse()</code> returns a <code>Result</code> type,\nwhich can be either a value, or an error. <code>unwrap()</code> simply says ‚Äúthis will never fail, but\nif it does, crash the entire program‚Äù.</p>\n<pre>fn parse01(input: &amp;str) -&gt; Vec&lt;u32&gt; {\n    let elf = input.split(\"\\n\\n\").collect::&lt;Vec&lt;&amp;str&gt;&gt;();\n    let calories: Vec&lt;u32&gt; = elf\n        .into_iter()\n        .map(|x| x.lines().map(|l| l.parse::&lt;u32&gt;().unwrap()).sum())\n        .collect();\n    calories\n}</pre>\n<p>Actually solving the first part is then just converting the vector to an iterator and\ntaking the maximum value</p>\n<pre>pub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let calories = parse01(input);\n    calories.into_iter().max()\n}</pre>\n<p>This returns an <code>Option</code> because a) that‚Äôs what the solution template requires, and b)\n<code>into_iter()</code> needs to be able to run out of values.</p>\n<p>For the second part I took advantage of the idea I should have had for the R solution\nand sorted the result (in-place), reversed it (in-place), took the first 3 values,\nand summed them</p>\n<pre>pub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let mut calories = parse01(input);\n    calories.sort();\n    calories.reverse();\n    let top3 = calories.iter().take(3);\n    Some(top3.sum())\n}</pre>\n<p>Running this solution, the timing seems impressive</p>\n<pre>cargo solve 01\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/01`\nüéÑ Part 1 üéÑ\n72718 (elapsed: 1.01ms)\nüéÑ Part 2 üéÑ\n213089 (elapsed: 1.07ms)</pre>\n<p>(about 20x faster than the R solution) except that this is the debug build -\nit still has debug symbols and some other things\nthat make it not as fast as it can be. Using a <code>release</code> build‚Ä¶</p>\n<pre>cargo solve 01 --release\n    Finished release [optimized + debuginfo] target(s) in 0.02s\n     Running `target/release/01`\nüéÑ Part 1 üéÑ\n72718 (elapsed: 115.74¬µs)\nüéÑ Part 2 üéÑ\n213089 (elapsed: 116.51¬µs)</pre>\n<p>Yes - one hundred microseconds. ü§Ø</p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-2-rock-paper-scissors\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day2\" id=\"day2\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 2: Rock Paper Scissors</h1>\n<div class=\"section level2\" id=\"r-1\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day02.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>This puzzle involves combinations of A, B, C and X, Y, Z which lead to different\nconfigurations. I don‚Äôt know if it‚Äôs quite cheating, but I just hardcoded the\nresults into some helper functions</p>\n<pre>f02_helper &lt;- function(x) {\n  switch(x,\n         AX = 1 + 3,\n         AY = 2 + 6,\n         AZ = 3 + 0,\n         BX = 1 + 0,\n         BY = 2 + 3,\n         BZ = 3 + 6,\n         CX = 1 + 6,\n         CY = 2 + 0,\n         CZ = 3 + 3)\n}</pre>\n<p>and summed the matching values, dropping spaces</p>\n<pre>f02a &lt;- function(x) {\n  x &lt;- gsub(\" \", \"\", x)\n  sum(sapply(x, f02_helper))\n}</pre>\n<p>The second part is just a variation on this, so another helper and the same idea</p>\n<pre>f02b_helper &lt;- function(x) {\n  switch(x,\n         AX = 3 + 0,\n         AY = 1 + 3,\n         AZ = 2 + 6,\n         BX = 1 + 0,\n         BY = 2 + 3,\n         BZ = 3 + 6,\n         CX = 2 + 0,\n         CY = 3 + 3,\n         CZ = 1 + 6)\n}\n\nf02b &lt;- function(x) {\n  x &lt;- gsub(\" \", \"\", x)\n  sum(sapply(x, f02b_helper))\n}</pre>\n<p>There was probably an algorithmic way to achieve this, but the answer works.</p>\n<p>For comparison sake‚Ä¶</p>\n<pre>microbenchmark::microbenchmark(f02a(x), f02b(x), times = 100, check = NULL)\nUnit: milliseconds\n    expr      min       lq     mean   median       uq      max neval cld\n f02a(x) 4.814174 4.921636 5.225773 4.992835 5.259293 8.873809   100   a\n f02b(x) 4.837843 4.918625 5.142451 4.984148 5.117036 7.762490   100   a</pre>\n</div>\n<div class=\"section level2\" id=\"rust-1\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/02.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>I could do similar with Rust, using a <code>match</code> clause inside a <code>map</code></p>\n<pre>pub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let guide = parse02(input);\n    let res: Vec&lt;u32&gt; = guide\n        .into_iter()\n        .map(|x| match x.as_str() {\n            \"AX\" =&gt; 1 + 3,\n            \"AY\" =&gt; 2 + 6,\n            \"AZ\" =&gt; 3 + 0,\n            \"BX\" =&gt; 1 + 0,\n            \"BY\" =&gt; 2 + 3,\n            \"BZ\" =&gt; 3 + 6,\n            \"CX\" =&gt; 1 + 6,\n            \"CY\" =&gt; 2 + 0,\n            \"CZ\" =&gt; 3 + 3,\n            _ =&gt; 0,\n        })\n        .collect();\n    Some(res.iter().sum())\n}\n\npub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let guide = parse02(input);\n    let res: Vec&lt;u32&gt; = guide\n        .into_iter()\n        .map(|x| match x.as_str() {\n            \"AX\" =&gt; 3 + 0,\n            \"AY\" =&gt; 1 + 3,\n            \"AZ\" =&gt; 2 + 6,\n            \"BX\" =&gt; 1 + 0,\n            \"BY\" =&gt; 2 + 3,\n            \"BZ\" =&gt; 3 + 6,\n            \"CX\" =&gt; 2 + 0,\n            \"CY\" =&gt; 3 + 3,\n            \"CZ\" =&gt; 1 + 6,\n            _ =&gt; 0,\n        })\n        .collect();\n    Some(res.iter().sum())\n}</pre>\n<p>This time, the difference in timing wasn‚Äôt so pronounced</p>\n<pre>cargo solve 02 --release\n    Finished release [optimized + debuginfo] target(s) in 0.02s\n     Running `target/release/02`\nüéÑ Part 1 üéÑ\n15422 (elapsed: 699.20¬µs)\nüéÑ Part 2 üéÑ\n15442 (elapsed: 527.74¬µs)</pre>\n<p>Still faster, but now we‚Äôre dealing with string comparisons.</p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-3-rucksack-reorganization\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day3\" id=\"day3\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 3: Rucksack Reorganization</h1>\n<div class=\"section level2\" id=\"r-2\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day03.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>This puzzle involves ‚Äòrucksacks‚Äô containing letters so we‚Äôre going to be doing more\nstring comparisons. The problem statement says that we need to find the single\ncharacter that is common between the first and second halves of a string. As will be\na common theme, I approached this by first solving it for one input as a helper, then mapping\nover all the inputs. My solution involves splitting the first and second halves of the\nstring with <code>strsplit()</code>, finding the intersection of these (which should be a single\ncharacter), and matching that to either lowercase or uppercase letters, which R nicely\nhas as inbuilt data structures <code>letters</code> and <code>LETTERS</code>, respectively. This makes for, I\nbelieve, a fairly compact solution</p>\n<pre>f03a &lt;- function(x) {\n  sum(sapply(x, f03_helper))\n}\n\nf03_helper &lt;- function(x) {\n  half &lt;- nchar(x)/2\n  comp1 &lt;- strsplit(substring(x, 1, half), \"\")[[1]]\n  comp2 &lt;- strsplit(substring(x, half+1), \"\")[[1]]\n  solo &lt;- intersect(comp1, comp2)\n  prio &lt;- match(solo, c(letters, LETTERS))\n  prio\n}</pre>\n<p>The second part expands to using 3 groups instead of the two halves. I needed a\nway to split the input (one string per line) into groups of 3. I haven‚Äôt used this\nin a very long time, but I remembered learning about ‚Äú<strong>g</strong>enerate factor <strong>l</strong>evels‚Äù <code>gl()</code> back\nwhen I first learned R. This produces a sequence of factors which can be passed to <code>split()</code>,\nso splitting 12 lines into blocks of 3 would produce 4 levels:</p>\n<pre>gl(12/3, 3)\r\n##  [1] 1 1 1 2 2 2 3 3 3 4 4 4\n## Levels: 1 2 3 4</pre>\n<p>Aside from that, the only other difference was the double intersection - it‚Äôs a shame\nthat <code>intersect</code> only takes two arguments, so I just need to perform it twice</p>\n<pre>f03b &lt;- function(x) {\n  grps &lt;- split(x, as.integer(gl(length(x)/3, 3)))\n  sum(sapply(grps, f03b_helper))\n}\n\nf03b_helper &lt;- function(x) {\n  x1 &lt;- strsplit(x[1], \"\")[[1]]\n  x2 &lt;- strsplit(x[2], \"\")[[1]]\n  x3 &lt;- strsplit(x[3], \"\")[[1]]\n  comm &lt;- intersect(intersect(x1, x2), x3)\n  prio &lt;- match(comm, c(letters, LETTERS))\n  prio\n}</pre>\n</div>\n<div class=\"section level2\" id=\"rust-2\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/03.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>Figuring out how to do this in Rust took a bit more effort. I don‚Äôt know if it was\nthe <em>best</em> way, but I found I could take an intersection of a <code>HashSet</code> object. Rust\nhas a nice <code>split_at()</code> method which helps split the strings, and (as with the <code>lines()</code> used\nearlier) a <code>chars()</code> method to split into individual characters. No inbuilt <code>letters</code>,\nthough, so I used an ASCII lookup trick to calculate the priority.</p>\n<pre>use std::collections::HashSet;\n\nfn parse03(input: &amp;str) -&gt; Vec&lt;String&gt; {\n    input.lines().map(|x| x.to_string()).collect()\n}\n\nfn shared_item(rucksack: String) -&gt; Vec&lt;char&gt; {\n    let l = rucksack.len();\n    let (str1, str2) = rucksack.split_at(l / 2);\n\n    let comp1: HashSet&lt;char&gt; = HashSet::from_iter(str1.chars());\n    let comp2: HashSet&lt;char&gt; = HashSet::from_iter(str2.chars());\n\n    let common = comp1.intersection(&amp;comp2);\n\n    common.copied().collect()\n}\n\nfn priority(item: char) -&gt; u32 {\n    match item {\n        lowercase @ 'a'..='z' =&gt; lowercase as u32 - ('a' as u32) + 1,\n        uppercase @ 'A'..='Z' =&gt; uppercase as u32 - ('A' as u32) + 27,\n        _ =&gt; 0,\n    }\n}\n\npub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let parsed = parse03(&amp;input);\n    let repeated: Vec&lt;_&gt; = parsed.iter().map(|x| shared_item(x.to_owned())).collect();\n    let mut s = 0;\n    for c in repeated {\n        s += priority(c[0])\n    }\n    Some(s)\n}</pre>\n<p>Definitely not as clean as the R solution, here. For the second part, I found\nsome help in <a href=\"https://www.reddit.com/r/rust/comments/zbikje/comment/iys0sgr/\" rel=\"nofollow\" target=\"_blank\">a Reddit thread</a>\nabout a three-way intersection. Here, the <code>chunks(n)</code> method nicely produces the three\ngroups</p>\n<pre>fn badge(rucksacks: Vec&lt;String&gt;) -&gt; Vec&lt;char&gt; {\n    let mut badges = vec![];\n\n    for group in rucksacks.chunks(3) {\n        let h1: HashSet&lt;char&gt; = HashSet::from_iter(group[0].chars());\n        let h2: HashSet&lt;char&gt; = HashSet::from_iter(group[1].chars());\n        let h3: HashSet&lt;char&gt; = HashSet::from_iter(group[2].chars());\n\n        let common: Vec&lt;_&gt; = h1\n            .iter()\n            .filter(|e| h2.contains(e) &amp;&amp; h3.contains(e))\n            .collect();\n        badges.push(*common[0]);\n    }\n\n    badges\n}\n\npub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let parsed = parse03(&amp;input);\n    let badge: Vec&lt;_&gt; = badge(parsed);\n    let mut s = 0;\n    for c in badge {\n        s += priority(c)\n    }\n    Some(s)\n}</pre>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-4-camp-cleanup\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day4\" id=\"day4\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 4: Camp Cleanup</h1>\n<p>Now the parsing gets harder. This puzzle involves finding where ranges overlap, so</p>\n<pre>5-7: ....567..  \n7-9: ......789  </pre>\n<p>overlap at the 7, while</p>\n<pre>2-6: .23456...  \n4-8: ...45678.  </pre>\n<p>overlaps at 4, 5, and 6.</p>\n<div class=\"section level2\" id=\"r-3\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day04.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>Again, taking the ‚Äúdo it once, then map‚Äù approach, I converted the format <code>a-b</code> into\n<code>a:b</code> and then <code>eval(parse(text))</code>‚Äôd the result. This worked surprisingly well. The\npuzzle then asks how many times one of the pair is entirely contained within the other,\nso <code>all()</code> and <code>%in%</code> are great help here.</p>\n<pre>f04a &lt;- function(x) {\n  sum(sapply(x, f04_helper))\n}\n\nf04_helper &lt;- function(x) {\n  both &lt;- sapply(sub(\"-\", \":\", strsplit(x, \",\")[[1]]), \\(y) eval(parse(text = y)), simplify = FALSE, USE.NAMES = FALSE)\n  all(both[[1]] %in% both[[2]]) || all(both[[2]] %in% both[[1]])\n}</pre>\n<p>The second part asks for how many overlap at all, so it‚Äôs just a change from <code>all()</code> to <code>any()</code></p>\n<pre>f04b &lt;- function(x) {\n  sum(sapply(x, f04b_helper))\n}\n\nf04b_helper &lt;- function(x) {\n  both &lt;- sapply(sub(\"-\", \":\", strsplit(x, \",\")[[1]]), \\(y) eval(parse(text = y)), simplify = FALSE, USE.NAMES = FALSE)\n  any(both[[1]] %in% both[[2]]) || any(both[[2]] %in% both[[1]])\n}</pre>\n</div>\n<div class=\"section level2\" id=\"rust-3\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/04.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>I created a structure to contain the ranges, parsed out the strings into\nactual ranges, and parsed the input</p>\n<pre>#[derive(Debug)]\nstruct Assignments {\n    sections: String,\n}\n\nimpl Assignments {\n    fn ids(&amp;self) -&gt; std::ops::Range&lt;u32&gt; {\n        let rangelimits = &amp;self.sections.split_once('-').unwrap();\n        let start = rangelimits.0.parse::&lt;u32&gt;().unwrap();\n        let end = rangelimits.1.parse::&lt;u32&gt;().unwrap();\n        start..end\n    }\n}\n\nfn create_assignments(line: &amp;str) -&gt; Vec&lt;Assignments&gt; {\n    let pair = line.split_once(',').unwrap();\n    let p1 = Assignments {\n        sections: pair.0.to_string(),\n    };\n    let p2 = Assignments {\n        sections: pair.1.to_string(),\n    };\n    vec![p1, p2]\n}\n\nfn parse04(input: &amp;str) -&gt; Vec&lt;Vec&lt;Assignments&gt;&gt; {\n    let l = input.lines();\n    l.into_iter().map(|x| create_assignments(x)).collect()\n}</pre>\n<p>Having to do this in Rust made me a happy that R has an <code>intersect()</code> function, because now I\nneeded one and had to code it by hand (I think‚Ä¶)</p>\n<p>To determine if one range is fully contained within another, I compared the start\nand end values. Iterating over the pairs I just incremented a counter for those\nwhich were fully overlapping</p>\n<pre>fn fully_contains(pairs: Vec&lt;Assignments&gt;) -&gt; bool {\n    let p1 = pairs[0].ids();\n    let p2 = pairs[1].ids();\n    if p1.len() &gt;= p2.len() {\n        return p1.start &lt;= p2.start &amp;&amp; p1.end &gt;= p2.end;\n    } else {\n        return p2.start &lt;= p1.start &amp;&amp; p2.end &gt;= p1.end;\n    }\n}\n\npub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let all_assignments = parse04(input);\n    let mut overlapping = 0;\n    for ass in all_assignments {\n        if fully_contains(ass) {\n            overlapping += 1;\n        }\n    }\n    Some(overlapping)\n}</pre>\n<p>For the second part, I needed another algorithm, so <a href=\"https://stackoverflow.com/a/325964/4168169\" rel=\"nofollow\" target=\"_blank\">StackOverflow</a> to the rescue</p>\n<pre>fn overlap_at_all(pairs: Vec&lt;Assignments&gt;) -&gt; bool {\n    let p1 = pairs[0].ids();\n    let p2 = pairs[1].ids();\n    // https://stackoverflow.com/a/325964/4168169\n    // (StartA &lt;= EndB) and (EndA &gt;= StartB)\n    p1.start &lt;= p2.end &amp;&amp; p1.end &gt;= p2.start\n}\n\npub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let all_assignments = parse04(input);\n    let mut overlapping = 0;\n    for ass in all_assignments {\n        if overlap_at_all(ass) {\n            overlapping += 1;\n        }\n    }\n    Some(overlapping)\n}</pre>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-5-supply-stacks\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day5\" id=\"day5\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 5: Supply Stacks</h1>\n<div class=\"section level2\" id=\"r-4\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day05.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>This one made me a little more afraid as it involved parsing ASCII-art-like input</p>\n<pre>    [D]\n[N] [C]\n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2</pre>\n<p>Starting with the ‚Äústacks‚Äù, I realised that a ‚Äúcrate‚Äù involved 4 characters and\npossibly a space (e.g.¬†<code>[A]</code>) so I could substring into those. I reversed them\nso that the top ‚Äúcrate‚Äù was first</p>\n<pre>extract_stack &lt;- function(x) {\n  # split into stacks\n  n &lt;- seq(1, nc &lt;- nchar(x), by = 4)\n  stack &lt;- substring(x, n, c(n[-1]-1, nc))\n  stack &lt;- trimws(sub(\"]\", \"\", sub(\"[\", \"\", stack, fixed = TRUE), fixed = TRUE))\n  stack\n}\n\nget_stacks &lt;- function(x) {\n  x &lt;- x[1:(grep(\"^$\", x)-1)]\n  y &lt;- t(sapply(x, extract_stack, USE.NAMES = FALSE))\n  stackno &lt;- y[nrow(y), ]\n  y &lt;- y[-nrow(y), ]\n  z &lt;- as.list(as.data.frame(y))\n  z &lt;- lapply(z, rev)\n  z &lt;- lapply(z, \\(w) w[w != \"\"])\n  z\n}</pre>\n<p>Parsing the instructions was a great opportunity for something like <a href=\"https://github.com/moodymudskipper/unglue\" rel=\"nofollow\" target=\"_blank\"><code>{unglue}</code></a>, if only I wasn‚Äôt limiting\nmyself to strictly base R. Nonetheless, the instructions formed a straightforward\npattern, so it wasn‚Äôt too hard to work with</p>\n<pre>get_instruction &lt;- function(x) {\n  x &lt;- sub(\"move \", \"\", x)\n  n &lt;- as.integer(sub(\"([0-9]+).*\", \"\\\\1\", x))\n  x &lt;- sub(\"^.*?from \", \"\", x)\n  from = as.integer(sub(\"([0-9]+).*\", \"\\\\1\", x))\n  to &lt;- as.integer(sub(\"^.*?to \", \"\", x))\n  data.frame(n, from, to)\n}\n\nget_instructions &lt;- function(x) {\n  x &lt;- x[(grep(\"^$\", x)+1):length(x)]\n  y &lt;- lapply(x, get_instruction)\n  do.call(rbind, y)\n}</pre>\n<p>Performing the crane operations only involved selecting some number (1 or several)\nof elements from the <code>head</code> of some list and appending it to another</p>\n<pre>crane &lt;- function(stack, inst, model) {\n  for (r in seq_len(nrow(inst))) {\n    stack &lt;- .crane(stack, inst[r, ], model)\n  }\n  stack\n}\n\n.crane &lt;- function(stack, inst, model) {\n  sfrom &lt;- paste0(\"V\", inst$from)\n  sto &lt;- paste0(\"V\", inst$to)\n  pick &lt;- tail(stack[[sfrom]], inst$n)\n  if (model == 9000) {\n    pick &lt;- rev(pick)\n  }\n  stack[[sfrom]] &lt;- head(stack[[sfrom]], -inst$n)\n  stack[[sto]] &lt;- c(stack[[sto]], pick)\n  stack\n}</pre>\n<p>The flexibility and symmetry of <code>head(n)</code>, <code>head(-n)</code>, <code>tail(n)</code>, and <code>tail(-n)</code> made\nthis particularly nice. This was one instance where I re-used my solution to the first\npart with an argument for the second part.</p>\n</div>\n<div class=\"section level2\" id=\"rust-4\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/05.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>If I thought the input parsing was hard in R, I wasn‚Äôt looking forward to doing it\nin Rust. I implemented the stacks in much the same way - taking 4 <code>chars</code> at a time</p>\n<pre>#[derive(Debug)]\nstruct Stacks {\n    stacks: String,\n}\n\nimpl Stacks {\n    fn crates(&amp;self) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {\n        let stacklines = &amp;self\n            .stacks\n            .lines()\n            .into_iter()\n            .map(|x| x.chars().collect::&lt;Vec&lt;char&gt;&gt;())\n            .collect::&lt;Vec&lt;Vec&lt;char&gt;&gt;&gt;();\n        let mut stackentries = vec![];\n        for l in stacklines.iter() {\n            stackentries.push(l.iter().skip(1).step_by(4).collect::&lt;Vec&lt;&amp;char&gt;&gt;());\n        }\n        // reshape to stacks\n        let mut stack = vec![vec![' '; 50]; stackentries[1].len()];\n        for s in 0..stackentries.len() - 1 {\n            for el in 0..stackentries[s].len() {\n                stack[el][s] = stackentries[s][el].to_owned()\n            }\n        }\n        for s in 0..stack.len() {\n            stack[s].reverse();\n            stack[s].retain(|x| *x != ' ');\n        }\n\n        stack\n    }\n}</pre>\n<p>The instructions invited a regex solution, but I found it to be (relatively) slow.\nI tried the ‚Äòunglue‚Äô approach</p>\n<pre>let re = Regex::new(r\"move (\\d*) from (\\d*) to (\\d*)\").unwrap();\nlet caps = re.captures(&amp;self.input).unwrap();</pre>\n<p>and this ended up taking 89ms. The full R solution took 257ms which is certainly more,\nbut I expected a better improvement moving to Rust. I refactored to avoid using the regex,\ninstead just filtering to chars that parsed as numbers</p>\n<pre>#[derive(Debug)]\nstruct Instructions {\n    input: String,\n}\n\nimpl Instructions {\n    fn parse(&amp;self) -&gt; (usize, usize, usize) {\n        let instr = String::from(&amp;self.input);\n        let caps = instr\n            .split_whitespace()\n            .filter(|c| c.parse::&lt;usize&gt;().is_ok())\n            .collect::&lt;Vec&lt;_&gt;&gt;();\n        let moveto = caps[0].parse::&lt;usize&gt;().unwrap();\n        let from = caps[1].parse::&lt;usize&gt;().unwrap();\n        let to = caps[2].parse::&lt;usize&gt;().unwrap();\n\n        (moveto, from, to)\n    }\n}</pre>\n<p>and this version ran in 403¬µs - much better.</p>\n<p>Putting the two pieces together as a tuple</p>\n<pre>fn parse05(input: &amp;str) -&gt; (Stacks, Vec&lt;Instructions&gt;) {\n    let parts = input.split_once(\"\\n\\n\").unwrap();\n    let stacks = Stacks {\n        stacks: String::from(parts.0),\n    };\n    let instr = parts\n        .1\n        .lines()\n        .map(|x| Instructions {\n            input: String::from(x),\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n    (stacks, instr)\n}</pre>\n<p>Actually running the simulation required a <code>crane</code> function</p>\n<pre>fn crane(crates: Vec&lt;Vec&lt;char&gt;&gt;, instr: (usize, usize, usize)) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {\n    let mut tmpcrates = crates.clone();\n    for _i in 0..instr.0 {\n        let tomove: char = tmpcrates[instr.1 - 1].pop().unwrap();\n        tmpcrates[instr.2 - 1].push(tomove);\n    }\n    tmpcrates\n}\n\npub fn part_one(input: &amp;str) -&gt; Option&lt;String&gt; {\n    let (stacks, instr) = parse05(&amp;input);\n    let mut crates = stacks.crates();\n    for i in 0..instr.len() {\n        crates = crane(crates, instr[i].parse());\n    }\n    let tops = crates.iter().map(|s| s.last().unwrap()).collect::&lt;String&gt;();\n    Some(tops)\n}</pre>\n<p>and, not reusing the solution, part two</p>\n<pre>fn crane9001(crates: Vec&lt;Vec&lt;char&gt;&gt;, instr: (usize, usize, usize)) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {\n    let mut tmpcrates = crates.clone(); \n    let new_len = tmpcrates[instr.1 - 1].len();\n    let mut tomove = vec![];\n    for _i in 0..instr.0 {\n        tomove.push(tmpcrates[instr.1 - 1].pop().unwrap());\n    }\n    tomove.reverse();\n    tmpcrates[instr.1 - 1].truncate(new_len - instr.0);\n    for x in tomove.into_iter() {\n        tmpcrates[instr.2 - 1].push(x);\n    }\n    tmpcrates\n}\n\npub fn part_two(input: &amp;str) -&gt; Option&lt;String&gt; {\n    let (stacks, instr) = parse05(&amp;input);\n    let mut crates = stacks.crates();\n\n    for i in 0..instr.len() {\n        crates = crane9001(crates, instr[i].parse());\n    }\n    let tops = crates.iter().map(|s| s.last().unwrap()).collect::&lt;String&gt;();\n    Some(tops)\n}</pre>\n<p>Not as bad as it could have been. The fact that Rust treats strings as a\nvector of Chars (as many other languages do) makes some of this a lot nicer. It‚Äôs\nsomething I do wish R did differently now that I‚Äôve used it in other places, but\nstrings are hard.</p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-6-tuning-trouble\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day6\" id=\"day6\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 6: Tuning Trouble</h1>\n<p>After complaining about strings the previous day, parsing this one sounded potentially\ntricky, but I think it worked out nicely. The problem involves finiding the first\ngroup of 4 characters where they are all different.</p>\n<div class=\"section level2\" id=\"r-5\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day06.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>Returning to the ‚Äôdo it once, then <code>*apply</code> approach, I was happy to know that\nR‚Äôs <code>substring</code> is vectorised, so the <code>first</code> and <code>last</code> arguments can be\nvectors, e.g.¬†taking 10 letters at a time of the alphabet</p>\n<pre>l &lt;- paste0(letters, collapse = \"\")\nl\r\n## [1] \"abcdefghijklmnopqrstuvwxyz\"\r\nsubstring(l, seq(1, 17), seq(10, 26))\r\n##  [1] \"abcdefghij\" \"bcdefghijk\" \"cdefghijkl\" \"defghijklm\" \"efghijklmn\"\n##  [6] \"fghijklmno\" \"ghijklmnop\" \"hijklmnopq\" \"ijklmnopqr\" \"jklmnopqrs\"\n## [11] \"klmnopqrst\" \"lmnopqrstu\" \"mnopqrstuv\" \"nopqrstuvw\" \"opqrstuvwx\"\n## [16] \"pqrstuvwxy\" \"qrstuvwxyz\"</pre>\n<p>This is the exact sort of grouping I need for this puzzle. The rest is figuring\nout if the group contains 4 unique characters. The offset is to account for the\nnumber of characters since the start of the original string</p>\n<pre>f06_helper &lt;- function(x) {\n  grp4 &lt;- substring(x, seq(1, nchar(x)), seq(4, nchar(x)))\n  4 + which(sapply(strsplit(grp4, \"\"), \\(y) length(unique(y))) == 4)[1] - 1\n}\n\nf06a &lt;- function(x) {\n  sapply(x, f06_helper)\n}</pre>\n<p>The second part really could have just been adding an argument to specify the group\nlength, but I went the long way around</p>\n<pre>f06b_helper &lt;- function(x) {\n  grp14 &lt;- substring(x, seq(1, nchar(x)), seq(14, nchar(x)))\n  14 + which(sapply(strsplit(grp14, \"\"), \\(y) length(unique(y))) == 14)[1] - 1\n}\n\nf06b &lt;- function(x) {\n  sapply(x, f06b_helper)\n}</pre>\n</div>\n<div class=\"section level2\" id=\"rust-5\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/06.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>Without R‚Äôs vectorised substring, I needed to parse 4 characters at a time - again I was\nthankful that Rust treats strings as a series of Chars. To keep track of which Chars\nhad been seen in the last 4 Chars I used a <code>HashSet</code>. I was pleased to learn that R does\nin fact have <a href=\"https://stat.ethz.ch/R-manual/R-devel/library/utils/html/hashtab.html\" rel=\"nofollow\" target=\"_blank\">such a structure in the form of <code>utils::hashtab()</code></a>\nbut this is only available in newer versions of R</p>\n<pre>use std::collections::HashSet;\n\npub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let mut i: u32 = 1;\n    let mut recent = HashSet::new();\n    let mut lastchars = vec![' '; 3];\n\n    for c in input.chars() {\n        for j in 0..3 {\n            recent.insert(lastchars[j]);\n        }\n        recent.insert(c);\n        if i &gt; 3 &amp;&amp; recent.len() == 4 {\n            break\n        };\n        for i in 0..2 {\n            lastchars[i] = lastchars[i+1];\n        }\n        lastchars[2] = c;\n        recent.clear();\n        i += 1;\n    }\n    Some(i)\n}</pre>\n<p>The second part is again very similar, and again rather than adapting my solution\nI wrote a new one for part two</p>\n<pre>pub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let mut i: u32 = 1;\n    let mut recent = HashSet::new();\n    let mut lastchars = vec![' '; 13];\n\n    for c in input.chars() {\n        for j in 0..13 {\n            recent.insert(lastchars[j]);\n        }\n        recent.insert(c);\n        if i &gt; 13 &amp;&amp; recent.len() == 14 {\n            break\n        };\n        for i in 0..12 {\n            lastchars[i] = lastchars[i+1];\n        }\n        lastchars[12] = c;\n        recent.clear();\n        i += 1;\n    }\n    Some(i)\n}</pre>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-7-no-space-left-on-device\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day7\" id=\"day7\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 7: No Space Left On Device</h1>\n<p>The input for this puzzle is a bit gnarly</p>\n<pre>$ cd /\n$ ls\ndir a\n14848514 b.txt\n8504156 c.dat\n...</pre>\n<p>but it turned out a brute-force replacement approach didn‚Äôt work too badly.</p>\n<div class=\"section level2\" id=\"r-6\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day07.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>There‚Äôs probably some good algorithm to deal with this, but instead I wrote a lot of\nfor-loops to see what needed to be done. The tricky part of the recursion was having\nsomewhere to keep track of a) which directory I was currently in, and b) what I‚Äôd already\nseen. I‚Äôm sure a recursive approach could be of help here, but instead I used an\n<code>environment</code> because I knew it was somewhat memory efficient; a global list would need\nto keep allocating and be slow.</p>\n<pre>f07a &lt;- function(x) {\n  dir_env &lt;- new.env()\n  current_dir &lt;- \"/\"\n  assign(current_dir, 0, envir = dir_env)\n  for (inst in x) {\n    if (inst == \"$ cd /\") next\n    if (inst == \"$ cd ..\") {\n      current_dir &lt;- head(current_dir, -1)\n      next\n    }\n    if (startsWith(inst, \"$ cd\")) {\n      dir &lt;- sub(\"$ cd \", \"\", inst, fixed = TRUE)\n      current_dir &lt;- c(current_dir, dir)\n        assign(paste0(current_dir, collapse = \"/\"), 0, envir = dir_env)\n      next\n    }\n    if (inst == \"$ ls\") next\n    if (startsWith(inst, \"dir\")) {\n      dir &lt;- sub(\"dir \", \"\", inst)\n      next\n    } else if (grepl(\"^[0-9]\", inst)) {\n      l &lt;- strsplit(inst, \" \")[[1]]\n      size &lt;- l[1]\n      for (d in seq_along(current_dir)) {\n          this.d &lt;- paste0(current_dir[1:d], collapse = \"/\")\n          assign(this.d, dir_env[[this.d]] + as.integer(size), envir = dir_env)\n      }\n      next\n    } else {\n      stop(\"what?\")\n    }\n  }\n  sizes &lt;- sapply(ls(dir_env), get, env = dir_env)\n  res &lt;- sum(sizes[which(sizes &lt;= 100000)])\n  list(del = res, env = dir_env)\n}</pre>\n<p>This isn‚Äôt recursive, but it works. The second part is much shorter, since it\ncan reuse the first part</p>\n<pre>f07b &lt;- function(x) {\n  alldirs &lt;- f07a(x)$env\n  todelete &lt;- alldirs[[\"/\"]] - 40000000\n  sizes &lt;- sapply(ls(alldirs), get, env = alldirs)\n  candidates &lt;- sizes[which(sizes &gt;= todelete)]\n  smallest &lt;- candidates[which.min(candidates)]\n  smallest\n}</pre>\n</div>\n<div class=\"section level2\" id=\"rust-6\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/08.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n<p>Here I took the same approach, but using a <code>HashMap</code> as the filesystem</p>\n<pre>use std::{collections::HashMap};\n\npub fn part_one(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let mut dir_deque = vec![];\n    let mut current_dir = String::from(\"\");\n    let mut filesystem = HashMap::new();\n    for l in input.lines() {\n        if l == \"$ cd ..\" {\n            dir_deque.pop().unwrap();\n            current_dir = dir_deque.join(\"\");\n            continue;\n        } else if l == \"$ cd /\" {\n            current_dir = String::from(\"/\");\n            filesystem.insert(current_dir.clone(), 0);\n            dir_deque = vec![String::from(\"/\")];\n            continue;\n        } else if l.starts_with(\"dir\") {\n            continue;\n        } else if l.starts_with(\"$ cd\") {\n            let new_dir = l.replace(\"$ cd \", \"\");\n            dir_deque.push(new_dir.clone() + &amp;\"/\");\n            current_dir = current_dir + &amp;new_dir.clone() + &amp;\"/\";\n            filesystem.insert(current_dir.clone(), 0);\n            continue;\n        } else if char::is_digit(l.chars().nth(1).unwrap(), 10) {\n            let parts = l.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;();\n            let dir_size = parts[0].parse::&lt;u32&gt;().unwrap();\n            for d in 0..dir_deque.len() {\n                let this_d = dir_deque[0..=d].join(\"\");\n                let known_size = filesystem.get(&amp;this_d).unwrap();\n                filesystem.insert(this_d, known_size + dir_size);\n            }\n            continue;\n        }\n    }\n\n    let totalsize = filesystem.iter()\n            .filter(|&amp;(_k, v)| *v &lt;= 1e5 as u32)\n            .map(|(_k, v)| *v)\n            .collect::&lt;Vec&lt;u32&gt;&gt;()\n            .iter()\n            .sum();\n\n    Some(totalsize)\n        \n}\n\npub fn part_two(input: &amp;str) -&gt; Option&lt;u32&gt; {\n    let mut dir_deque = vec![];\n    let mut current_dir = String::from(\"\");\n    let mut filesystem = HashMap::new();\n    for l in input.lines() {\n        if l == \"$ cd ..\" {\n            dir_deque.pop().unwrap();\n            current_dir = dir_deque.join(\"\");\n            continue;\n        } else if l == \"$ cd /\" {\n            current_dir = String::from(\"/\");\n            filesystem.insert(current_dir.clone(), 0);\n            dir_deque = vec![String::from(\"/\")];\n            continue;\n        } else if l.starts_with(\"dir\") {\n            continue;\n        } else if l.starts_with(\"$ cd\") {\n            let new_dir = l.replace(\"$ cd \", \"\");\n            dir_deque.push(new_dir.clone() + &amp;\"/\");\n            current_dir = current_dir + &amp;new_dir.clone() + &amp;\"/\";\n            filesystem.insert(current_dir.clone(), 0);\n            continue;\n        } else if char::is_digit(l.chars().nth(1).unwrap(), 10) {\n            let parts = l.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;();\n            let dir_size = parts[0].parse::&lt;u32&gt;().unwrap();\n            for d in 0..dir_deque.len() {\n                let this_d = dir_deque[0..=d].join(\"\");\n                let known_size = filesystem.get(&amp;this_d).unwrap();\n                filesystem.insert(this_d, known_size + dir_size);\n            }\n            continue;\n        }\n    }\n\n    let to_delete = filesystem.get(\"/\").unwrap() - (4e7 as u32);\n    let candidates = filesystem.iter()\n        .filter(|&amp;(_k, v)| *v &gt;= to_delete)\n        .map(|(_k, v)| *v)\n        .collect::&lt;Vec&lt;u32&gt;&gt;();\n    Some(*candidates.iter().min().unwrap())\n\n}</pre>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-8-treetop-tree-house\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day8\" id=\"day8\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 8: Treetop Tree House</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-7\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day08.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n<div class=\"section level2\" id=\"rust-7\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/09.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-9-rope-bridge\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day9\" id=\"day9\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 9: Rope Bridge</h1>\n<p>This one involves keeping track of the positions of several ‚Äòknots‚Äô in a rope as it moves.</p>\n<div class=\"section level2\" id=\"r-8\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day09.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>I wrote a <em>lot</em> of helper functions for this one</p>\n<pre>f09a &lt;- function(x) {\n  visited &lt;- list()\n  head_pos &lt;- c(5, 1)\n  tail_pos &lt;- c(5, 1)\n  # print_grid(head_pos, tail_pos)\n  visited &lt;- c(visited, list(tail_pos))\n  for (instr in x) {\n    tmp &lt;- move_rope(head_pos, tail_pos, instr)\n    head_pos &lt;- tmp[[1]]\n    tail_pos &lt;- tmp[[2]]\n    visited &lt;- c(visited, tmp[[3]])\n  }\n  length(unique(visited))\n}\n\nprint_grid &lt;- function(head_pos, tail_pos, size = 6) {\n  grid &lt;- matrix(\".\", nrow = size, ncol = size)\n  grid[matrix(tail_pos, ncol = 2)] &lt;- \"T\"\n  grid[matrix(head_pos, ncol = 2)] &lt;- \"H\"\n  print(grid)\n}\n\nprint_knots &lt;- function(k, size = 10) {\n  grid &lt;- matrix(\".\", nrow = size, ncol = size)\n  for (i in seq_len(length(k))) {\n    grid[matrix(k[[i]], ncol = 2)] &lt;- i\n  }\n  print(grid)\n}\n\nmove_head &lt;- function(head_pos, dir) {\n  if (dir == \"L\") return(c(head_pos[1], head_pos[2] - 1))\n  if (dir == \"R\") return(c(head_pos[1], head_pos[2] + 1))\n  if (dir == \"U\") return(c(head_pos[1] - 1, head_pos[2]))\n  if (dir == \"D\") return(c(head_pos[1] + 1, head_pos[2]))\n}\n\nmove_rope &lt;- function(head_pos, tail_pos, x) {\n  visited &lt;- list()\n  dir &lt;- sub(\" .*\", \"\", x)\n  dist &lt;- as.integer(sub(\"[LRUD] \", \"\", x))\n  for (i in seq_len(dist)) {\n    head_pos &lt;- move_head(head_pos, dir)\n    tail_pos &lt;- move_tail(head_pos, tail_pos)\n    visited &lt;- c(visited, list(tail_pos))\n  }\n  return(list(head_pos, tail_pos, visited))\n}\n\nmove_knots &lt;- function(knots, x) {\n  visited &lt;- list()\n  dir &lt;- sub(\" .*\", \"\", x)\n  dist &lt;- as.integer(sub(\"[LRUD] \", \"\", x))\n  for (i in seq_len(dist)) {\n    knots[[1]] &lt;- move_head(knots[[1]], dir)\n    for (i in 2:10) {\n      knots[[i]] &lt;- move_tail(knots[[i-1]], knots[[i]])\n    }\n    visited &lt;- c(visited, list(knots[[10]]))\n  }\n  return(list(knots, visited))\n}\n\ntouching &lt;- function(head_pos, tail_pos) {\n  (head_pos[1] == tail_pos[1] &amp;&amp; head_pos[2] == tail_pos[2]) ||\n  (abs(head_pos[1] - tail_pos[1]) &lt;= 1 &amp;&amp; abs(head_pos[2] - tail_pos[2]) &lt;= 1)\n}\n\nmove_tail &lt;- function(head_pos, tail_pos) {\n  if (touching(head_pos, tail_pos)) return(tail_pos)\n  if (tail_pos[1] == head_pos[1]) return(c(tail_pos[1], tail_pos[2] + sign(head_pos[2] - tail_pos[2])*1))\n  if (tail_pos[2] == head_pos[2]) return(c(tail_pos[1] + sign(head_pos[1] - tail_pos[1]*1), tail_pos[2]))\n  return(c(tail_pos[1] + sign(head_pos[1] - tail_pos[1])*1, tail_pos[2] + sign(head_pos[2] - tail_pos[2])*1))\n}</pre>\n<p>This was also the first one I found the time to plot - here I plotted the path of the 10th knot,\nas well as the positions of the other knots after each step</p>\n<p><img data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day09.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day09.png?w=578&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"rust-8\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/09.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-10-cathode-ray-tube\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day10\" id=\"day10\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 10: Cathode-Ray Tube</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-9\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day10.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n<div class=\"section level2\" id=\"rust-9\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/10.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-11-monkey-in-the-middle\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day11\" id=\"day11\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 11: Monkey in the Middle</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-10\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day11.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n<div class=\"section level2\" id=\"rust-10\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/11.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-12-hill-climbing-algorithm\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day12\" id=\"day12\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 12: Hill Climbing Algorithm</h1>\n<p>This one required that I learn a pathfinding algorithm - something I hadn‚Äôt really done before. I ended up\nlearning (and implementing) Dijkstra‚Äôs Algorithm for finding the shortest paths between nodes in a graph.</p>\n<div class=\"section level2\" id=\"r-11\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day12.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<pre>f12a &lt;- function(x) {\n  rows &lt;- strsplit(x, \"\")\n  grid &lt;- matrix(unlist(rows), ncol = nchar(x[1]), byrow = TRUE)\n  ngrid &lt;- grid\n  ngrid[which(grid == \"S\", arr.ind = TRUE)] &lt;- \"a\"\n  ngrid[which(grid == \"E\", arr.ind = TRUE)] &lt;- \"z\"\n  ngrid[] &lt;- match(ngrid[], letters)\n  mode(ngrid) &lt;- \"integer\"\n  startat &lt;- which(t(grid) == \"S\")\n  endat &lt;- which(t(grid) == \"E\")\n  min_path &lt;- dijkstra(ngrid, endat, dir = -1)\n  min_pathp[startat]\n}\n\nget_pos &lt;- function(grid, v) {\n  i &lt;- floor((v-1)/ncol(grid))+1\n  j &lt;- ((v-1) %% ncol(grid))+1\n  return(c(i, j))\n}\n\ncan_reach &lt;- function(ngrid, v, dir = 1) {\n  x &lt;- get_pos(ngrid, v)\n  i &lt;- x[1]\n  j &lt;- x[2]\n  # can only move 1 row away\n  res &lt;- abs(floor(0:(prod(dim(ngrid))-1) / ncol(ngrid)) + 1 - i) &lt;= 1 &amp;\n    # can only move 1 col away\n    abs((0:(prod(dim(ngrid))-1)%%ncol(ngrid)) + 1 - j) &lt;= 1 &amp;\n    # can't move diagonally\n    abs(floor(0:(prod(dim(ngrid))-1) / ncol(ngrid)) + 1 - i) + abs((0:(prod(dim(ngrid))-1)%%ncol(ngrid)) + 1 - j) == 1\n    if (dir == 1) {\n    # can only step up 1\n      res &lt;- res &amp; c(t(ngrid - ngrid[i, j] &lt;= 1))\n    } else {\n      res &lt;- res &amp; c(t(ngrid[i, j] - ngrid &lt;= 1))\n    }\n  as.integer(res)\n}\n\ndijkstra &lt;- function(grid, start, dir = -1){\n  #' Implementation of dijkstra using on-demand query\n  #' derived from https://www.algorithms-and-technologies.com/dijkstra/r\n  #' This returns an array containing the length of the shortest path from the start node to each other node.\n  #' It is only guaranteed to return correct results if there are no negative edges in the graph. Positive cycles are fine.\n  #' This has a runtime of O(|V|^2) (|V| = number of Nodes), for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)\n  #' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.\n  #' @param start the node to start from.\n  #' @param dir are we going up or down? passed to can_reach()\n  #' @return an array containing the shortest distances from the given start node to each other node\n\n  # This contains the distances from the start node to all other nodes\n  distances = rep(Inf, prod(dim(grid)))\n  paths = rep(list(), prod(dim(grid)))\n\n  # This contains whether a node was already visited\n  visited = rep(FALSE, prod(dim(grid)))\n\n  # The distance from the start node to itself is of course 0\n  distances[start] = 0\n  paths[[start]] = start\n\n  # While there are nodes left to visit...\n  repeat{\n\n    # ... find the node with the currently shortest distance from the start node...\n    shortest_distance = Inf\n    shortest_index = -1\n    for(i in seq_along(distances)) {\n      # ... by going through all nodes that haven't been visited yet\n      if(distances[i] &lt; shortest_distance &amp;&amp; !visited[i]){\n        shortest_distance = distances[i]\n        shortest_index = i\n      }\n    }\n\n    if(shortest_index == -1){\n      # There was no node not yet visited --&gt; We are done\n      return (list(distances, paths))\n    }\n    # ...then, for all neighboring nodes that haven't been visited yet....\n    g &lt;- can_reach(grid, shortest_index, dir = dir)\n    for(i in seq_along(g)) {\n      # ...if the path over this edge is shorter...\n      if(g[i] != 0 &amp;&amp; distances[i] &gt; distances[shortest_index] + g[i]){\n        # ...Save this path as new shortest path.\n        distances[i] = distances[shortest_index] + g[i]\n        paths[[i]] &lt;- c(paths[[shortest_index]], i)\n      }\n      # Lastly, note that we are finished with this node.\n      visited[shortest_index] = TRUE\n    }\n  }\n}</pre>\n<p>With a decent amount of plotting code, I ended up with an animation showing the solution\nfor the test data</p>\n<p><img data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12_test.gif?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12_test.gif?w=578&amp;ssl=1\"/></noscript></p>\n<p>which I was very pleased about. Even better, was the full solution animation</p>\n<p><img data-lazy-src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12.gif?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day12.gif?w=578&amp;ssl=1\"/></noscript></p>\n</div>\n<div class=\"section level2\" id=\"rust-11\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/12.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-13-distress-signal\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day13\" id=\"day13\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 13: Distress Signal</h1>\n<p>This one involves comparing nested lists like <code>[[1],[2,3,4]]</code> vs <code>[[1],4]</code>. I really want to go back\nand try this one in Haskell because those comparisons are (I believe) built-in.</p>\n<div class=\"section level2\" id=\"r-12\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day13.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n<div class=\"section level2\" id=\"rust-12\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/Rust/src/bin/13.rs\" rel=\"nofollow\" target=\"_blank\">Rust</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-14-regolith-reservoir\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day14\" id=\"day14\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 14: Regolith Reservoir</h1>\n<p>I didn‚Äôt finish my Rust solution for this one, but I was very happy with my R solution. The goal here\nis to fill the area with falling sand, allowing for some obstacles.</p>\n<div class=\"section level2\" id=\"r-13\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day14.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<pre>f14a &lt;- function(x) {\n  allrocks &lt;- lapply(x, rocks)\n  cave &lt;- matrix(\".\", nrow = 200, ncol = 1500)\n  for (r in allrocks) {\n    for (rr in seq_along(r[-1])) {\n      f &lt;- fill_rocks(r[rr], r[rr+1])\n      cave[f] &lt;- \"#\"\n    }\n  }\n  done &lt;- FALSE\n  while(!done) {\n    cave &lt;- fall(cave, c(1, 500+500))\n    done &lt;- cave[matrix(c(1,1), ncol = 2)] == \"X\"\n  }\n  sum(cave == \"o\")\n}\n\nfall &lt;- function(cave, sand, crit = \"fall\") {\n  down &lt;- c(sand[1]+1, sand[2])\n  if (crit == \"fall\" &amp;&amp; down[1] &gt; 200) {\n    cave[matrix(c(1,1), ncol = 2)] &lt;- \"X\"\n    return(cave)\n  } else if (blocked(cave, c(1, 500+500))) {\n    sandmat &lt;&lt;- rbind(sandmat, c(1, 500+500))\n    cave[matrix(c(1,500+500), ncol = 2)] &lt;- \"o\"\n    cave[matrix(c(1,1), ncol = 2)] &lt;- \"X\"\n    return(cave)\n  }\n  if (blocked(cave, down)) {\n    downleft &lt;- c(sand[1]+1, sand[2]-1)\n    if (blocked(cave, downleft)) {\n      downright &lt;- c(sand[1]+1, sand[2]+1)\n      if (blocked(cave, downright)) {\n        sandmat &lt;&lt;- rbind(sandmat, sand)\n        cave[matrix(sand, ncol = 2)] &lt;- \"o\"\n      } else {\n        return(fall(cave, downright))\n      }\n    } else {\n      return(fall(cave, downleft))\n    }\n  } else {\n    return(fall(cave, down))\n  }\n  return(cave)\n}\n\nblocked &lt;- function(cave, x) {\n  cave[matrix(x, ncol = 2)] %in% c(\"#\", \"o\")\n}\n\nrocks &lt;- function(x) {\n  rocks &lt;- strsplit(x, \" -&gt; \")[[1]]\n  rocks &lt;- strsplit(rocks, \",\")\n  for (r in seq_along(rocks)) {\n    rocks[[r]] &lt;- as.integer(rocks[[r]])\n    rocks[[r]][1] &lt;- rocks[[r]][1] + 500\n  }\n  rocks\n}\n\nfill_rocks &lt;- function(x, y) {\n  x &lt;- x[[1]]\n  x[2] &lt;- x[2] + 1\n  y &lt;- y[[1]]\n  y[2] &lt;- y[2] + 1\n  # horizontal\n  if (x[1] == y[1]) {\n    span &lt;- x[2]:y[2]\n    return(matrix(c(span, rep(x[1], length(span))), ncol = 2, byrow = FALSE))\n  }\n  # vertical\n  if (x[2] == y[2]) {\n    span &lt;- x[1]:y[1]\n    return(matrix(c(rep(x[2], length(span)), span), ncol = 2, byrow = FALSE))\n  }\n}</pre>\n<p>I animated the falling sand, filling up the cave, but with <em>so</em> many particles it didn‚Äôt go very well,\nespecially when limiting the frames</p>\n<p><img data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.gif?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.gif?w=578&amp;ssl=1\"/></noscript></p>\n<p>Instead, a render of the final solution, with the sand coloured by the time at which it came to\nrest, looked much cooler</p>\n<p><img data-lazy-src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day14.png?w=578&amp;ssl=1\"/></noscript></p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-15-beacon-exclusion-zone\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day15\" id=\"day15\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 15: Beacon Exclusion Zone</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-14\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day15.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-16-proboscidea-volcanium\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day16\" id=\"day16\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 16: Proboscidea Volcanium</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-15\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day16.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-17-pyroclastic-flow\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day17\" id=\"day17\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 17: Pyroclastic Flow</h1>\n<p>While it was never mentioned by name, this one was essentially a game of Tetris.</p>\n<div class=\"section level2\" id=\"r-16\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day17.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>At this point, there‚Äôs too much code to copy inline. Check out the repo links.</p>\n<p>I couldn‚Äôt help but plot this one as an animation‚Ä¶</p>\n<p><img data-lazy-src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day17.gif?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i1.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day17.gif?w=578&amp;ssl=1\"/></noscript></p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-18-boiling-boulders\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day18\" id=\"day18\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 18: Boiling Boulders</h1>\n<p>I got to learn even more algorithms for this one - this time a flood-fill algorithm.</p>\n<div class=\"section level2\" id=\"r-17\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day18.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>I took advantage of one of coolbutuseless‚Äô packages <a href=\"https://github.com/coolbutuseless/isocubes\" rel=\"nofollow\" target=\"_blank\">{isocubes}</a>\nto plot the shape of the lava droplet</p>\n<p><img data-lazy-src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day18.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img data-recalc-dims=\"1\" src=\"https://i2.wp.com/jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day18.png?w=578&amp;ssl=1\"/></noscript></p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-19-not-enough-minerals\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day19\" id=\"day19\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 19: Not Enough Minerals</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-18\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day19.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-20-grove-positioning-system\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day20\" id=\"day20\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 20: Grove Positioning System</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-19\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day20.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-21-monkey-math\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day21\" id=\"day21\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 21: Monkey Math</h1>\n<p>I had no intentions of making it on to the leaderboard for timing, even though the puzzles were\nreleased at an entirely reasonable time for me. I actually got to this one late in the\nevening due to some other commitments, but I am quietly confident that my R solution could\nhave been one of the fastest solves‚Ä¶</p>\n<p>The problem is figuring out what the value of the ‚Äòroot‚Äô monkey is, given the following operations</p>\n<pre>root: pppw + sjmn\ndbpl: 5\ncczh: sllz + lgvd\nzczc: 2\nptdq: humn - dvpt\ndvpt: 3\nlfqf: 4\nhumn: 5\nljgn: 2\nsjmn: drzm * dbpl\nsllz: 4\npppw: cczh / lfqf\nlgvd: ljgn * ptdq\ndrzm: hmdt - zczc\nhmdt: 32</pre>\n<div class=\"section level2\" id=\"r-20\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day21.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n<p>I realised fairly quickly that I could just make each of the connections a function call,\nand evaluate the entire stack! This was very fast to write, and I got to my full solution\nfaster than most of those at the top of the leaderboard, but much later in the day.</p>\n<pre>f21a &lt;- function(x) {\n  defs &lt;- sapply(x, parseInput)\n  for (d in defs) {\n    eval(parse(text = d))\n  }\n  format(root(), scientific = FALSE)\n}\n\nparseInput &lt;- function(x) {\n  monkey &lt;- sub(\"^(.*):.*\", \"\\\\1\", x)\n  ret &lt;- sub(\".*: (.*)$\", \"\\\\1\", x)\n  if (is.na(suppressWarnings(as.integer(ret)))) {\n    ret &lt;- strsplit(ret, \" \")[[1]]\n    v1 &lt;- ret[1]\n    op &lt;- ret[2]\n    v2 &lt;- ret[3]\n    def &lt;- paste0(monkey, \" &lt;- function() { \", v1, \"() \", op, \" \", v2, \"() }\")\n  } else {\n    def &lt;- paste0(monkey, \" &lt;- function() { \", ret, \" }\")\n  }\n}</pre>\n<p>Sure, sometimes (most of the time), <code>eval(parse(text = ))</code> is a terrible idea, but in\nthis case it worked out great!</p>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-22-monkey-map\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day22\" id=\"day22\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 22: Monkey Map</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-21\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day22.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-23-unstable-diffusion\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day23\" id=\"day23\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 23: Unstable Diffusion</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-22\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day23.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-24-blizzard-basin\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day24\" id=\"day24\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 24: Blizzard Basin</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-23\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day24.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"day-25-full-of-hot-air\">\n<h1><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/#day25\" id=\"day25\" rel=\"nofollow\" target=\"_blank\"><i aria-hidden=\"true\" class=\"fa fa-link\"></i></a> Day 25: Full of Hot Air</h1>\n<p>(see links)</p>\n<div class=\"section level2\" id=\"r-24\">\n<h2><a href=\"https://github.com/jonocarroll/advent-of-code/blob/main/2022/R/R/day25.R\" rel=\"nofollow\" target=\"_blank\">R</a></h2>\n</div>\n</div>\n<div class=\"section level1\" id=\"summary\">\n<h1>Summary</h1>\n<p>I really enjoyed advent of code, and I ended up donating as thanks for providing such\na nice experience. I‚Äôll be having a go at AoC 2023 but won‚Äôt be so strict; I may not\nsolve each puzzle <em>on the day it‚Äôs released</em> and I will be allowing myself to use whatever\nlibraries and whatever languages I want.</p>\n<p>Will you be participating? I‚Äôd love to compare solutions once we‚Äôre done! I can be found on\n<a href=\"https://fosstodon.org/@jonocarroll\" rel=\"nofollow\" target=\"_blank\">Mastodon</a> and I‚Äôll be commenting on the puzzles as I go.</p>\n<br/>\n<details>\n<summary>\n<tt>devtools::session_info()</tt>\n</summary>\n<pre>## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##  setting  value\n##  version  R version 4.3.2 (2023-10-31)\n##  os       Pop!_OS 22.04 LTS\n##  system   x86_64, linux-gnu\n##  ui       X11\n##  language (EN)\n##  collate  en_AU.UTF-8\n##  ctype    en_AU.UTF-8\n##  tz       Australia/Adelaide\n##  date     2023-11-28\n##  pandoc   3.1.8 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/x86_64/ (via rmarkdown)\n## \n## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##  package     * version date (UTC) lib source\n##  blogdown      1.18    2023-06-19 [1] CRAN (R 4.3.2)\n##  bookdown      0.36    2023-10-16 [1] CRAN (R 4.3.2)\n##  bslib         0.5.1   2023-08-11 [3] CRAN (R 4.3.1)\n##  cachem        1.0.8   2023-05-01 [3] CRAN (R 4.3.0)\n##  callr         3.7.3   2022-11-02 [3] CRAN (R 4.2.2)\n##  cli           3.6.1   2023-03-23 [3] CRAN (R 4.2.3)\n##  crayon        1.5.2   2022-09-29 [3] CRAN (R 4.2.1)\n##  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.3.2)\n##  digest        0.6.33  2023-07-07 [3] CRAN (R 4.3.1)\n##  ellipsis      0.3.2   2021-04-29 [3] CRAN (R 4.1.1)\n##  evaluate      0.22    2023-09-29 [3] CRAN (R 4.3.1)\n##  fastmap       1.1.1   2023-02-24 [3] CRAN (R 4.2.2)\n##  fs            1.6.3   2023-07-20 [3] CRAN (R 4.3.1)\n##  glue          1.6.2   2022-02-24 [3] CRAN (R 4.2.0)\n##  htmltools     0.5.6.1 2023-10-06 [3] CRAN (R 4.3.1)\n##  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.2)\n##  httpuv        1.6.12  2023-10-23 [1] CRAN (R 4.3.2)\n##  icecream      0.2.1   2023-09-27 [1] CRAN (R 4.3.2)\n##  jquerylib     0.1.4   2021-04-26 [3] CRAN (R 4.1.2)\n##  jsonlite      1.8.7   2023-06-29 [3] CRAN (R 4.3.1)\n##  knitr         1.44    2023-09-11 [3] CRAN (R 4.3.1)\n##  later         1.3.1   2023-05-02 [1] CRAN (R 4.3.2)\n##  lifecycle     1.0.3   2022-10-07 [3] CRAN (R 4.2.1)\n##  magrittr      2.0.3   2022-03-30 [3] CRAN (R 4.2.0)\n##  memoise       2.0.1   2021-11-26 [3] CRAN (R 4.2.0)\n##  mime          0.12    2021-09-28 [3] CRAN (R 4.2.0)\n##  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.3.2)\n##  pkgbuild      1.4.2   2023-06-26 [1] CRAN (R 4.3.2)\n##  pkgload       1.3.3   2023-09-22 [1] CRAN (R 4.3.2)\n##  prettyunits   1.2.0   2023-09-24 [3] CRAN (R 4.3.1)\n##  processx      3.8.2   2023-06-30 [3] CRAN (R 4.3.1)\n##  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.3.2)\n##  promises      1.2.1   2023-08-10 [1] CRAN (R 4.3.2)\n##  ps            1.7.5   2023-04-18 [3] CRAN (R 4.3.0)\n##  purrr         1.0.2   2023-08-10 [3] CRAN (R 4.3.1)\n##  R6            2.5.1   2021-08-19 [3] CRAN (R 4.2.0)\n##  Rcpp          1.0.11  2023-07-06 [1] CRAN (R 4.3.2)\n##  remotes       2.4.2.1 2023-07-18 [1] CRAN (R 4.3.2)\n##  rlang         1.1.1   2023-04-28 [3] CRAN (R 4.3.0)\n##  rmarkdown     2.25    2023-09-18 [3] CRAN (R 4.3.1)\n##  rstudioapi    0.15.0  2023-07-07 [3] CRAN (R 4.3.1)\n##  sass          0.4.7   2023-07-15 [3] CRAN (R 4.3.1)\n##  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n##  shiny         1.7.5.1 2023-10-14 [1] CRAN (R 4.3.2)\n##  stringi       1.7.12  2023-01-11 [3] CRAN (R 4.2.2)\n##  stringr       1.5.0   2022-12-02 [3] CRAN (R 4.3.0)\n##  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.3.2)\n##  usethis       2.2.2   2023-07-06 [1] CRAN (R 4.3.2)\n##  vctrs         0.6.4   2023-10-12 [3] CRAN (R 4.3.1)\n##  xfun          0.40    2023-08-09 [3] CRAN (R 4.3.1)\n##  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.3.2)\n##  yaml          2.3.7   2023-01-23 [3] CRAN (R 4.2.2)\n## \n##  [1] /home/jono/R/x86_64-pc-linux-gnu-library/4.3\n##  [2] /usr/local/lib/R/site-library\n##  [3] /usr/lib/R/site-library\n##  [4] /usr/lib/R/library\n## \n## ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</pre>\n</details>\n<p><br/></p>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 3.8.9-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jcarroll.com.au/2023/11/28/advent-of-code-2022/\"> rstats on Irregularly Scheduled Programming</a></strong>.</div>\n<hr>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</hr></div> </div>\n</article>",
    "main_text": "Advent of Code 2022\nPosted on\nNovember 27, 2023\nby\nJonathan Carroll\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nrstats on Irregularly Scheduled Programming\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn the lead up to Christmas each year,\nAdvent of Code\noffers a series of 25 puzzles which start out reasonably simple, but get progressively harder, eventually requiring knowledge of algorithms and dynamic programming techniques. Last year\nI solved these in (strictly) base R on the day they were released (or as close to as\nI could). I then (starting Dec 27) went back and re-solved (13 of) them in Rust.\nThis post details what I learned along the way and some fun visualisations I made.\nAs I eventually ran out of time before the 2023 AoC event, some of the latter\nsolutions are just links to my GitHub repo without comment. I‚Äôll try to update those\nat some point.\nQuicklinks (click here to hide):\nDay 1: Calorie Counting\nDay 2: Rock Paper Scissors\nDay 3: Rucksack Reorganization\nDay 4: Camp Cleanup\nDay 5: Supply Stacks\nDay 6: Tuning Trouble\nDay 7: No Space Left On Device\nDay 8: Treetop Tree House\nDay 9: Rope Bridge\nDay 10: Cathode-Ray Tube\nDay 11: Monkey in the Middle\nDay 12: Hill Climbing Algorithm\nDay 13: Distress Signal\nDay 14: Regolith Reservoir\nDay 15: Beacon Exclusion Zone\nDay 16: Proboscidea Volcanium\nDay 17: Pyroclastic Flow\nDay 18: Boiling Boulders\nDay 19: Not Enough Minerals\nDay 20: Grove Positioning System\nDay 21: Monkey Math\nDay 22: Monkey Map\nDay 23: Unstable Diffusion\nDay 24: Blizzard Basin\nDay 25: Full of Hot Air\nDay 1: Calorie Counting\nR\nI hadn‚Äôt participated in AoC before this, so part of this day involved setting up\na clean way to get the puzzle into R and figure out how I was going to run/test\nmy solutions. The\n{aoc}\npackage makes this quite smooth\nby using a session cookie to fetch the puzzle from the website and scaffold the input and\nfunctions for a given day.\nEach puzzle has a small worked example, which requires a small example data input. For the\nfirst two weeks I painstakingly copied this input from the puzzle text to the templated\nexample_input_xx\nfunction. The actual input for the puzzle is typically much larger\nand I believe is randomised from a handful of variants so that not everyone gets the\nexact same input, which makes sharing solutions less of a problem. This input is\nstored in a\n.txt\nfile in the\ninst/\ndirectory by the {aoc} package, which also\ntemplates a\nrun-dayxx.R\nfile which reads said input.\nAll that‚Äôs left for the user is to fill in the\nfxxa\nand\nfxxb\nfunctions which\nsolve the part a and part b of each day‚Äôs puzzle.\nSolving the puzzle begins with parsing the input data, which may be a newline-delimited\nseries of numbers, or something more complex. In this case, groups of numbers\ndelimited by a blank line. This puzzle asks us to find the group with the largest total.\nWith the data loaded as a long string containing newlines\n\\n\nI split at a double-newline,\nthen spit within each group at the remaining newline, trimmed the string, converted\nto an integer, and summed the result, which gives a total value per group. Finally, I\ndetermined the largest value from the groups with the pattern\nx[which.max(x)]\nf01a <- function(x) {\n  xvec <- strsplit(x, \"\\n\\n\")[[1]]\n  tots <- unlist(lapply(xvec, \\(y) sum(as.integer(trimws(strsplit(y, \"\\n\")[[1]])))))\n  tots[which.max(tots)]\n}\nAn alternative would have been to sort\ntots\nand take the first value.\nThe second part of each puzzle expands the problem - in this case, rather than just the\nlargest value from a group, it asks for the largest three groups\nf01b <- function(x) {\n  xvec <- strsplit(x, \"\\n\\n\")[[1]]\n  tots <- unlist(lapply(xvec, \\(y) sum(as.integer(trimws(strsplit(y, \"\\n\")[[1]])))))\n  res <- 0\n  for (i in 1:3) {\n    n <- which.max(tots)\n    res <- res + tots[n]\n    tots <- tots[-n]\n  }\n  res\n}\nIn hindsight,\nsum(head(sort(tots, decreasing = TRUE), 3))\nlooks like it would have been clearer.\nI wasn‚Äôt interested in the performance of my solutions, but for the sake of comparison\nlater, here is how long these take to run over the real input, which contains\n2251\nlines\nmicrobenchmark::microbenchmark(f01a(x), f01b(x), times = 100, check = NULL)\nUnit: milliseconds\n    expr      min       lq     mean   median       uq      max neval cld\n f01a(x) 21.21986 21.50103 22.26573 21.63479 21.82128 31.41858   100   a\n f01b(x) 21.18393 21.52034 22.29896 21.67297 21.87063 32.98093   100   a\nRunning the final solutions from the templated\ninst/run-dayxx.R\nfile involves building the\npackage (so that the daily functions are available) and running\nlibrary(adventofcode22)\nx <- readLines(\"./inst/input01.txt\")\nx <- paste(x, collapse = \"\\n\")\n\np1 <- f01a(x)\np2 <- f01b(x)\nRust\nReturning to these puzzles from Rust presents the same issue - how do I get the inputs\nand parse them? The equivalent to the {aoc} package in Rust is a template repository\n{advent-of-code-rust}\nwhich adds some\nfunctionality to\ncargo\nto scaffold and solve each day‚Äôs puzzle.\nThis crate also adds some helper functions for reading in the inputs and some tests for\nconfirming that the solutions successfully solve with the example data.\nWorking with arbitrary data in Rust was a bit of a learning experience for me - until\nthis point I‚Äôd worked with known structures where I knew exactly what size and shape\nto expect, and as such I could define what needed to happen. With the puzzle input,\nI needed to learn how to work with unknown lengths and anticipate what might not work.\nI learned from my R solutions that a shared ‚Äòhelper‚Äô function to read the data is\nquite useful, so I started there. As with the R solution, splitting the data into\ngroups at a double newline produces the ‚Äòelf‚Äô groups. Splitting each of those groups\ninvolved a\nmap\nwhich splits each group‚Äôs text into\nlines()\n, converts to integers (\nu32\n)\nwith\nparse()\n, then\nsum()\ns each group,\ncollect()\ning the result from each group back\ninto a vector. The\nunwrap()\nin the middle of this is because\nparse()\ncan fail -\nsomething may not be representable as an integer - so\nparse()\nreturns a\nResult\ntype,\nwhich can be either a value, or an error.\nunwrap()\nsimply says ‚Äúthis will never fail, but\nif it does, crash the entire program‚Äù.\nfn parse01(input: &str) -> Vec<u32> {\n    let elf = input.split(\"\\n\\n\").collect::<Vec<&str>>();\n    let calories: Vec<u32> = elf\n        .into_iter()\n        .map(|x| x.lines().map(|l| l.parse::<u32>().unwrap()).sum())\n        .collect();\n    calories\n}\nActually solving the first part is then just converting the vector to an iterator and\ntaking the maximum value\npub fn part_one(input: &str) -> Option<u32> {\n    let calories = parse01(input);\n    calories.into_iter().max()\n}\nThis returns an\nOption\nbecause a) that‚Äôs what the solution template requires, and b)\ninto_iter()\nneeds to be able to run out of values.\nFor the second part I took advantage of the idea I should have had for the R solution\nand sorted the result (in-place), reversed it (in-place), took the first 3 values,\nand summed them\npub fn part_two(input: &str) -> Option<u32> {\n    let mut calories = parse01(input);\n    calories.sort();\n    calories.reverse();\n    let top3 = calories.iter().take(3);\n    Some(top3.sum())\n}\nRunning this solution, the timing seems impressive\ncargo solve 01\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/01`\nüéÑ Part 1 üéÑ\n72718 (elapsed: 1.01ms)\nüéÑ Part 2 üéÑ\n213089 (elapsed: 1.07ms)\n(about 20x faster than the R solution) except that this is the debug build -\nit still has debug symbols and some other things\nthat make it not as fast as it can be. Using a\nrelease\nbuild‚Ä¶\ncargo solve 01 --release\n    Finished release [optimized + debuginfo] target(s) in 0.02s\n     Running `target/release/01`\nüéÑ Part 1 üéÑ\n72718 (elapsed: 115.74¬µs)\nüéÑ Part 2 üéÑ\n213089 (elapsed: 116.51¬µs)\nYes - one hundred microseconds. ü§Ø\nDay 2: Rock Paper Scissors\nR\nThis puzzle involves combinations of A, B, C and X, Y, Z which lead to different\nconfigurations. I don‚Äôt know if it‚Äôs quite cheating, but I just hardcoded the\nresults into some helper functions\nf02_helper <- function(x) {\n  switch(x,\n         AX = 1 + 3,\n         AY = 2 + 6,\n         AZ = 3 + 0,\n         BX = 1 + 0,\n         BY = 2 + 3,\n         BZ = 3 + 6,\n         CX = 1 + 6,\n         CY = 2 + 0,\n         CZ = 3 + 3)\n}\nand summed the matching values, dropping spaces\nf02a <- function(x) {\n  x <- gsub(\" \", \"\", x)\n  sum(sapply(x, f02_helper))\n}\nThe second part is just a variation on this, so another helper and the same idea\nf02b_helper <- function(x) {\n  switch(x,\n         AX = 3 + 0,\n         AY = 1 + 3,\n         AZ = 2 + 6,\n         BX = 1 + 0,\n         BY = 2 + 3,\n         BZ = 3 + 6,\n         CX = 2 + 0,\n         CY = 3 + 3,\n         CZ = 1 + 6)\n}\n\nf02b <- function(x) {\n  x <- gsub(\" \", \"\", x)\n  sum(sapply(x, f02b_helper))\n}\nThere was probably an algorithmic way to achieve this, but the answer works.\nFor comparison sake‚Ä¶\nmicrobenchmark::microbenchmark(f02a(x), f02b(x), times = 100, check = NULL)\nUnit: milliseconds\n    expr      min       lq     mean   median       uq      max neval cld\n f02a(x) 4.814174 4.921636 5.225773 4.992835 5.259293 8.873809   100   a\n f02b(x) 4.837843 4.918625 5.142451 4.984148 5.117036 7.762490   100   a\nRust\nI could do similar with Rust, using a\nmatch\nclause inside a\nmap\npub fn part_one(input: &str) -> Option<u32> {\n    let guide = parse02(input);\n    let res: Vec<u32> = guide\n        .into_iter()\n        .map(|x| match x.as_str() {\n            \"AX\" => 1 + 3,\n            \"AY\" => 2 + 6,\n            \"AZ\" => 3 + 0,\n            \"BX\" => 1 + 0,\n            \"BY\" => 2 + 3,\n            \"BZ\" => 3 + 6,\n            \"CX\" => 1 + 6,\n            \"CY\" => 2 + 0,\n            \"CZ\" => 3 + 3,\n            _ => 0,\n        })\n        .collect();\n    Some(res.iter().sum())\n}\n\npub fn part_two(input: &str) -> Option<u32> {\n    let guide = parse02(input);\n    let res: Vec<u32> = guide\n        .into_iter()\n        .map(|x| match x.as_str() {\n            \"AX\" => 3 + 0,\n            \"AY\" => 1 + 3,\n            \"AZ\" => 2 + 6,\n            \"BX\" => 1 + 0,\n            \"BY\" => 2 + 3,\n            \"BZ\" => 3 + 6,\n            \"CX\" => 2 + 0,\n            \"CY\" => 3 + 3,\n            \"CZ\" => 1 + 6,\n            _ => 0,\n        })\n        .collect();\n    Some(res.iter().sum())\n}\nThis time, the difference in timing wasn‚Äôt so pronounced\ncargo solve 02 --release\n    Finished release [optimized + debuginfo] target(s) in 0.02s\n     Running `target/release/02`\nüéÑ Part 1 üéÑ\n15422 (elapsed: 699.20¬µs)\nüéÑ Part 2 üéÑ\n15442 (elapsed: 527.74¬µs)\nStill faster, but now we‚Äôre dealing with string comparisons.\nDay 3: Rucksack Reorganization\nR\nThis puzzle involves ‚Äòrucksacks‚Äô containing letters so we‚Äôre going to be doing more\nstring comparisons. The problem statement says that we need to find the single\ncharacter that is common between the first and second halves of a string. As will be\na common theme, I approached this by first solving it for one input as a helper, then mapping\nover all the inputs. My solution involves splitting the first and second halves of the\nstring with\nstrsplit()\n, finding the intersection of these (which should be a single\ncharacter), and matching that to either lowercase or uppercase letters, which R nicely\nhas as inbuilt data structures\nletters\nand\nLETTERS\n, respectively. This makes for, I\nbelieve, a fairly compact solution\nf03a <- function(x) {\n  sum(sapply(x, f03_helper))\n}\n\nf03_helper <- function(x) {\n  half <- nchar(x)/2\n  comp1 <- strsplit(substring(x, 1, half), \"\")[[1]]\n  comp2 <- strsplit(substring(x, half+1), \"\")[[1]]\n  solo <- intersect(comp1, comp2)\n  prio <- match(solo, c(letters, LETTERS))\n  prio\n}\nThe second part expands to using 3 groups instead of the two halves. I needed a\nway to split the input (one string per line) into groups of 3. I haven‚Äôt used this\nin a very long time, but I remembered learning about ‚Äú\ng\nenerate factor\nl\nevels‚Äù\ngl()\nback\nwhen I first learned R. This produces a sequence of factors which can be passed to\nsplit()\n,\nso splitting 12 lines into blocks of 3 would produce 4 levels:\ngl(12/3, 3)\n##  [1] 1 1 1 2 2 2 3 3 3 4 4 4\n## Levels: 1 2 3 4\nAside from that, the only other difference was the double intersection - it‚Äôs a shame\nthat\nintersect\nonly takes two arguments, so I just need to perform it twice\nf03b <- function(x) {\n  grps <- split(x, as.integer(gl(length(x)/3, 3)))\n  sum(sapply(grps, f03b_helper))\n}\n\nf03b_helper <- function(x) {\n  x1 <- strsplit(x[1], \"\")[[1]]\n  x2 <- strsplit(x[2], \"\")[[1]]\n  x3 <- strsplit(x[3], \"\")[[1]]\n  comm <- intersect(intersect(x1, x2), x3)\n  prio <- match(comm, c(letters, LETTERS))\n  prio\n}\nRust\nFiguring out how to do this in Rust took a bit more effort. I don‚Äôt know if it was\nthe\nbest\nway, but I found I could take an intersection of a\nHashSet\nobject. Rust\nhas a nice\nsplit_at()\nmethod which helps split the strings, and (as with the\nlines()\nused\nearlier) a\nchars()\nmethod to split into individual characters. No inbuilt\nletters\n,\nthough, so I used an ASCII lookup trick to calculate the priority.\nuse std::collections::HashSet;\n\nfn parse03(input: &str) -> Vec<String> {\n    input.lines().map(|x| x.to_string()).collect()\n}\n\nfn shared_item(rucksack: String) -> Vec<char> {\n    let l = rucksack.len();\n    let (str1, str2) = rucksack.split_at(l / 2);\n\n    let comp1: HashSet<char> = HashSet::from_iter(str1.chars());\n    let comp2: HashSet<char> = HashSet::from_iter(str2.chars());\n\n    let common = comp1.intersection(&comp2);\n\n    common.copied().collect()\n}\n\nfn priority(item: char) -> u32 {\n    match item {\n        lowercase @ 'a'..='z' => lowercase as u32 - ('a' as u32) + 1,\n        uppercase @ 'A'..='Z' => uppercase as u32 - ('A' as u32) + 27,\n        _ => 0,\n    }\n}\n\npub fn part_one(input: &str) -> Option<u32> {\n    let parsed = parse03(&input);\n    let repeated: Vec<_> = parsed.iter().map(|x| shared_item(x.to_owned())).collect();\n    let mut s = 0;\n    for c in repeated {\n        s += priority(c[0])\n    }\n    Some(s)\n}\nDefinitely not as clean as the R solution, here. For the second part, I found\nsome help in\na Reddit thread\nabout a three-way intersection. Here, the\nchunks(n)\nmethod nicely produces the three\ngroups\nfn badge(rucksacks: Vec<String>) -> Vec<char> {\n    let mut badges = vec![];\n\n    for group in rucksacks.chunks(3) {\n        let h1: HashSet<char> = HashSet::from_iter(group[0].chars());\n        let h2: HashSet<char> = HashSet::from_iter(group[1].chars());\n        let h3: HashSet<char> = HashSet::from_iter(group[2].chars());\n\n        let common: Vec<_> = h1\n            .iter()\n            .filter(|e| h2.contains(e) && h3.contains(e))\n            .collect();\n        badges.push(*common[0]);\n    }\n\n    badges\n}\n\npub fn part_two(input: &str) -> Option<u32> {\n    let parsed = parse03(&input);\n    let badge: Vec<_> = badge(parsed);\n    let mut s = 0;\n    for c in badge {\n        s += priority(c)\n    }\n    Some(s)\n}\nDay 4: Camp Cleanup\nNow the parsing gets harder. This puzzle involves finding where ranges overlap, so\n5-7: ....567..  \n7-9: ......789\noverlap at the 7, while\n2-6: .23456...  \n4-8: ...45678.\noverlaps at 4, 5, and 6.\nR\nAgain, taking the ‚Äúdo it once, then map‚Äù approach, I converted the format\na-b\ninto\na:b\nand then\neval(parse(text))\n‚Äôd the result. This worked surprisingly well. The\npuzzle then asks how many times one of the pair is entirely contained within the other,\nso\nall()\nand\n%in%\nare great help here.\nf04a <- function(x) {\n  sum(sapply(x, f04_helper))\n}\n\nf04_helper <- function(x) {\n  both <- sapply(sub(\"-\", \":\", strsplit(x, \",\")[[1]]), \\(y) eval(parse(text = y)), simplify = FALSE, USE.NAMES = FALSE)\n  all(both[[1]] %in% both[[2]]) || all(both[[2]] %in% both[[1]])\n}\nThe second part asks for how many overlap at all, so it‚Äôs just a change from\nall()\nto\nany()\nf04b <- function(x) {\n  sum(sapply(x, f04b_helper))\n}\n\nf04b_helper <- function(x) {\n  both <- sapply(sub(\"-\", \":\", strsplit(x, \",\")[[1]]), \\(y) eval(parse(text = y)), simplify = FALSE, USE.NAMES = FALSE)\n  any(both[[1]] %in% both[[2]]) || any(both[[2]] %in% both[[1]])\n}\nRust\nI created a structure to contain the ranges, parsed out the strings into\nactual ranges, and parsed the input\n#[derive(Debug)]\nstruct Assignments {\n    sections: String,\n}\n\nimpl Assignments {\n    fn ids(&self) -> std::ops::Range<u32> {\n        let rangelimits = &self.sections.split_once('-').unwrap();\n        let start = rangelimits.0.parse::<u32>().unwrap();\n        let end = rangelimits.1.parse::<u32>().unwrap();\n        start..end\n    }\n}\n\nfn create_assignments(line: &str) -> Vec<Assignments> {\n    let pair = line.split_once(',').unwrap();\n    let p1 = Assignments {\n        sections: pair.0.to_string(),\n    };\n    let p2 = Assignments {\n        sections: pair.1.to_string(),\n    };\n    vec![p1, p2]\n}\n\nfn parse04(input: &str) -> Vec<Vec<Assignments>> {\n    let l = input.lines();\n    l.into_iter().map(|x| create_assignments(x)).collect()\n}\nHaving to do this in Rust made me a happy that R has an\nintersect()\nfunction, because now I\nneeded one and had to code it by hand (I think‚Ä¶)\nTo determine if one range is fully contained within another, I compared the start\nand end values. Iterating over the pairs I just incremented a counter for those\nwhich were fully overlapping\nfn fully_contains(pairs: Vec<Assignments>) -> bool {\n    let p1 = pairs[0].ids();\n    let p2 = pairs[1].ids();\n    if p1.len() >= p2.len() {\n        return p1.start <= p2.start && p1.end >= p2.end;\n    } else {\n        return p2.start <= p1.start && p2.end >= p1.end;\n    }\n}\n\npub fn part_one(input: &str) -> Option<u32> {\n    let all_assignments = parse04(input);\n    let mut overlapping = 0;\n    for ass in all_assignments {\n        if fully_contains(ass) {\n            overlapping += 1;\n        }\n    }\n    Some(overlapping)\n}\nFor the second part, I needed another algorithm, so\nStackOverflow\nto the rescue\nfn overlap_at_all(pairs: Vec<Assignments>) -> bool {\n    let p1 = pairs[0].ids();\n    let p2 = pairs[1].ids();\n    // https://stackoverflow.com/a/325964/4168169\n    // (StartA <= EndB) and (EndA >= StartB)\n    p1.start <= p2.end && p1.end >= p2.start\n}\n\npub fn part_two(input: &str) -> Option<u32> {\n    let all_assignments = parse04(input);\n    let mut overlapping = 0;\n    for ass in all_assignments {\n        if overlap_at_all(ass) {\n            overlapping += 1;\n        }\n    }\n    Some(overlapping)\n}\nDay 5: Supply Stacks\nR\nThis one made me a little more afraid as it involved parsing ASCII-art-like input\n[D]\n[N] [C]\n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2\nStarting with the ‚Äústacks‚Äù, I realised that a ‚Äúcrate‚Äù involved 4 characters and\npossibly a space (e.g.\n[A]\n) so I could substring into those. I reversed them\nso that the top ‚Äúcrate‚Äù was first\nextract_stack <- function(x) {\n  # split into stacks\n  n <- seq(1, nc <- nchar(x), by = 4)\n  stack <- substring(x, n, c(n[-1]-1, nc))\n  stack <- trimws(sub(\"]\", \"\", sub(\"[\", \"\", stack, fixed = TRUE), fixed = TRUE))\n  stack\n}\n\nget_stacks <- function(x) {\n  x <- x[1:(grep(\"^$\", x)-1)]\n  y <- t(sapply(x, extract_stack, USE.NAMES = FALSE))\n  stackno <- y[nrow(y), ]\n  y <- y[-nrow(y), ]\n  z <- as.list(as.data.frame(y))\n  z <- lapply(z, rev)\n  z <- lapply(z, \\(w) w[w != \"\"])\n  z\n}\nParsing the instructions was a great opportunity for something like\n{unglue}\n, if only I wasn‚Äôt limiting\nmyself to strictly base R. Nonetheless, the instructions formed a straightforward\npattern, so it wasn‚Äôt too hard to work with\nget_instruction <- function(x) {\n  x <- sub(\"move \", \"\", x)\n  n <- as.integer(sub(\"([0-9]+).*\", \"\\\\1\", x))\n  x <- sub(\"^.*?from \", \"\", x)\n  from = as.integer(sub(\"([0-9]+).*\", \"\\\\1\", x))\n  to <- as.integer(sub(\"^.*?to \", \"\", x))\n  data.frame(n, from, to)\n}\n\nget_instructions <- function(x) {\n  x <- x[(grep(\"^$\", x)+1):length(x)]\n  y <- lapply(x, get_instruction)\n  do.call(rbind, y)\n}\nPerforming the crane operations only involved selecting some number (1 or several)\nof elements from the\nhead\nof some list and appending it to another\ncrane <- function(stack, inst, model) {\n  for (r in seq_len(nrow(inst))) {\n    stack <- .crane(stack, inst[r, ], model)\n  }\n  stack\n}\n\n.crane <- function(stack, inst, model) {\n  sfrom <- paste0(\"V\", inst$from)\n  sto <- paste0(\"V\", inst$to)\n  pick <- tail(stack[[sfrom]], inst$n)\n  if (model == 9000) {\n    pick <- rev(pick)\n  }\n  stack[[sfrom]] <- head(stack[[sfrom]], -inst$n)\n  stack[[sto]] <- c(stack[[sto]], pick)\n  stack\n}\nThe flexibility and symmetry of\nhead(n)\n,\nhead(-n)\n,\ntail(n)\n, and\ntail(-n)\nmade\nthis particularly nice. This was one instance where I re-used my solution to the first\npart with an argument for the second part.\nRust\nIf I thought the input parsing was hard in R, I wasn‚Äôt looking forward to doing it\nin Rust. I implemented the stacks in much the same way - taking 4\nchars\nat a time\n#[derive(Debug)]\nstruct Stacks {\n    stacks: String,\n}\n\nimpl Stacks {\n    fn crates(&self) -> Vec<Vec<char>> {\n        let stacklines = &self\n            .stacks\n            .lines()\n            .into_iter()\n            .map(|x| x.chars().collect::<Vec<char>>())\n            .collect::<Vec<Vec<char>>>();\n        let mut stackentries = vec![];\n        for l in stacklines.iter() {\n            stackentries.push(l.iter().skip(1).step_by(4).collect::<Vec<&char>>());\n        }\n        // reshape to stacks\n        let mut stack = vec![vec![' '; 50]; stackentries[1].len()];\n        for s in 0..stackentries.len() - 1 {\n            for el in 0..stackentries[s].len() {\n                stack[el][s] = stackentries[s][el].to_owned()\n            }\n        }\n        for s in 0..stack.len() {\n            stack[s].reverse();\n            stack[s].retain(|x| *x != ' ');\n        }\n\n        stack\n    }\n}\nThe instructions invited a regex solution, but I found it to be (relatively) slow.\nI tried the ‚Äòunglue‚Äô approach\nlet re = Regex::new(r\"move (\\d*) from (\\d*) to (\\d*)\").unwrap();\nlet caps = re.captures(&self.input).unwrap();\nand this ended up taking 89ms. The full R solution took 257ms which is certainly more,\nbut I expected a better improvement moving to Rust. I refactored to avoid using the regex,\ninstead just filtering to chars that parsed as numbers\n#[derive(Debug)]\nstruct Instructions {\n    input: String,\n}\n\nimpl Instructions {\n    fn parse(&self) -> (usize, usize, usize) {\n        let instr = String::from(&self.input);\n        let caps = instr\n            .split_whitespace()\n            .filter(|c| c.parse::<usize>().is_ok())\n            .collect::<Vec<_>>();\n        let moveto = caps[0].parse::<usize>().unwrap();\n        let from = caps[1].parse::<usize>().unwrap();\n        let to = caps[2].parse::<usize>().unwrap();\n\n        (moveto, from, to)\n    }\n}\nand this version ran in 403¬µs - much better.\nPutting the two pieces together as a tuple\nfn parse05(input: &str) -> (Stacks, Vec<Instructions>) {\n    let parts = input.split_once(\"\\n\\n\").unwrap();\n    let stacks = Stacks {\n        stacks: String::from(parts.0),\n    };\n    let instr = parts\n        .1\n        .lines()\n        .map(|x| Instructions {\n            input: String::from(x),\n        })\n        .collect::<Vec<_>>();\n    (stacks, instr)\n}\nActually running the simulation required a\ncrane\nfunction\nfn crane(crates: Vec<Vec<char>>, instr: (usize, usize, usize)) -> Vec<Vec<char>> {\n    let mut tmpcrates = crates.clone();\n    for _i in 0..instr.0 {\n        let tomove: char = tmpcrates[instr.1 - 1].pop().unwrap();\n        tmpcrates[instr.2 - 1].push(tomove);\n    }\n    tmpcrates\n}\n\npub fn part_one(input: &str) -> Option<String> {\n    let (stacks, instr) = parse05(&input);\n    let mut crates = stacks.crates();\n    for i in 0..instr.len() {\n        crates = crane(crates, instr[i].parse());\n    }\n    let tops = crates.iter().map(|s| s.last().unwrap()).collect::<String>();\n    Some(tops)\n}\nand, not reusing the solution, part two\nfn crane9001(crates: Vec<Vec<char>>, instr: (usize, usize, usize)) -> Vec<Vec<char>> {\n    let mut tmpcrates = crates.clone(); \n    let new_len = tmpcrates[instr.1 - 1].len();\n    let mut tomove = vec![];\n    for _i in 0..instr.0 {\n        tomove.push(tmpcrates[instr.1 - 1].pop().unwrap());\n    }\n    tomove.reverse();\n    tmpcrates[instr.1 - 1].truncate(new_len - instr.0);\n    for x in tomove.into_iter() {\n        tmpcrates[instr.2 - 1].push(x);\n    }\n    tmpcrates\n}\n\npub fn part_two(input: &str) -> Option<String> {\n    let (stacks, instr) = parse05(&input);\n    let mut crates = stacks.crates();\n\n    for i in 0..instr.len() {\n        crates = crane9001(crates, instr[i].parse());\n    }\n    let tops = crates.iter().map(|s| s.last().unwrap()).collect::<String>();\n    Some(tops)\n}\nNot as bad as it could have been. The fact that Rust treats strings as a\nvector of Chars (as many other languages do) makes some of this a lot nicer. It‚Äôs\nsomething I do wish R did differently now that I‚Äôve used it in other places, but\nstrings are hard.\nDay 6: Tuning Trouble\nAfter complaining about strings the previous day, parsing this one sounded potentially\ntricky, but I think it worked out nicely. The problem involves finiding the first\ngroup of 4 characters where they are all different.\nR\nReturning to the ‚Äôdo it once, then\n*apply\napproach, I was happy to know that\nR‚Äôs\nsubstring\nis vectorised, so the\nfirst\nand\nlast\narguments can be\nvectors, e.g.¬†taking 10 letters at a time of the alphabet\nl <- paste0(letters, collapse = \"\")\nl\n## [1] \"abcdefghijklmnopqrstuvwxyz\"\nsubstring(l, seq(1, 17), seq(10, 26))\n##  [1] \"abcdefghij\" \"bcdefghijk\" \"cdefghijkl\" \"defghijklm\" \"efghijklmn\"\n##  [6] \"fghijklmno\" \"ghijklmnop\" \"hijklmnopq\" \"ijklmnopqr\" \"jklmnopqrs\"\n## [11] \"klmnopqrst\" \"lmnopqrstu\" \"mnopqrstuv\" \"nopqrstuvw\" \"opqrstuvwx\"\n## [16] \"pqrstuvwxy\" \"qrstuvwxyz\"\nThis is the exact sort of grouping I need for this puzzle. The rest is figuring\nout if the group contains 4 unique characters. The offset is to account for the\nnumber of characters since the start of the original string\nf06_helper <- function(x) {\n  grp4 <- substring(x, seq(1, nchar(x)), seq(4, nchar(x)))\n  4 + which(sapply(strsplit(grp4, \"\"), \\(y) length(unique(y))) == 4)[1] - 1\n}\n\nf06a <- function(x) {\n  sapply(x, f06_helper)\n}\nThe second part really could have just been adding an argument to specify the group\nlength, but I went the long way around\nf06b_helper <- function(x) {\n  grp14 <- substring(x, seq(1, nchar(x)), seq(14, nchar(x)))\n  14 + which(sapply(strsplit(grp14, \"\"), \\(y) length(unique(y))) == 14)[1] - 1\n}\n\nf06b <- function(x) {\n  sapply(x, f06b_helper)\n}\nRust\nWithout R‚Äôs vectorised substring, I needed to parse 4 characters at a time - again I was\nthankful that Rust treats strings as a series of Chars. To keep track of which Chars\nhad been seen in the last 4 Chars I used a\nHashSet\n. I was pleased to learn that R does\nin fact have\nsuch a structure in the form of\nutils::hashtab()\nbut this is only available in newer versions of R\nuse std::collections::HashSet;\n\npub fn part_one(input: &str) -> Option<u32> {\n    let mut i: u32 = 1;\n    let mut recent = HashSet::new();\n    let mut lastchars = vec![' '; 3];\n\n    for c in input.chars() {\n        for j in 0..3 {\n            recent.insert(lastchars[j]);\n        }\n        recent.insert(c);\n        if i > 3 && recent.len() == 4 {\n            break\n        };\n        for i in 0..2 {\n            lastchars[i] = lastchars[i+1];\n        }\n        lastchars[2] = c;\n        recent.clear();\n        i += 1;\n    }\n    Some(i)\n}\nThe second part is again very similar, and again rather than adapting my solution\nI wrote a new one for part two\npub fn part_two(input: &str) -> Option<u32> {\n    let mut i: u32 = 1;\n    let mut recent = HashSet::new();\n    let mut lastchars = vec![' '; 13];\n\n    for c in input.chars() {\n        for j in 0..13 {\n            recent.insert(lastchars[j]);\n        }\n        recent.insert(c);\n        if i > 13 && recent.len() == 14 {\n            break\n        };\n        for i in 0..12 {\n            lastchars[i] = lastchars[i+1];\n        }\n        lastchars[12] = c;\n        recent.clear();\n        i += 1;\n    }\n    Some(i)\n}\nDay 7: No Space Left On Device\nThe input for this puzzle is a bit gnarly\n$ cd /\n$ ls\ndir a\n14848514 b.txt\n8504156 c.dat\n...\nbut it turned out a brute-force replacement approach didn‚Äôt work too badly.\nR\nThere‚Äôs probably some good algorithm to deal with this, but instead I wrote a lot of\nfor-loops to see what needed to be done. The tricky part of the recursion was having\nsomewhere to keep track of a) which directory I was currently in, and b) what I‚Äôd already\nseen. I‚Äôm sure a recursive approach could be of help here, but instead I used an\nenvironment\nbecause I knew it was somewhat memory efficient; a global list would need\nto keep allocating and be slow.\nf07a <- function(x) {\n  dir_env <- new.env()\n  current_dir <- \"/\"\n  assign(current_dir, 0, envir = dir_env)\n  for (inst in x) {\n    if (inst == \"$ cd /\") next\n    if (inst == \"$ cd ..\") {\n      current_dir <- head(current_dir, -1)\n      next\n    }\n    if (startsWith(inst, \"$ cd\")) {\n      dir <- sub(\"$ cd \", \"\", inst, fixed = TRUE)\n      current_dir <- c(current_dir, dir)\n        assign(paste0(current_dir, collapse = \"/\"), 0, envir = dir_env)\n      next\n    }\n    if (inst == \"$ ls\") next\n    if (startsWith(inst, \"dir\")) {\n      dir <- sub(\"dir \", \"\", inst)\n      next\n    } else if (grepl(\"^[0-9]\", inst)) {\n      l <- strsplit(inst, \" \")[[1]]\n      size <- l[1]\n      for (d in seq_along(current_dir)) {\n          this.d <- paste0(current_dir[1:d], collapse = \"/\")\n          assign(this.d, dir_env[[this.d]] + as.integer(size), envir = dir_env)\n      }\n      next\n    } else {\n      stop(\"what?\")\n    }\n  }\n  sizes <- sapply(ls(dir_env), get, env = dir_env)\n  res <- sum(sizes[which(sizes <= 100000)])\n  list(del = res, env = dir_env)\n}\nThis isn‚Äôt recursive, but it works. The second part is much shorter, since it\ncan reuse the first part\nf07b <- function(x) {\n  alldirs <- f07a(x)$env\n  todelete <- alldirs[[\"/\"]] - 40000000\n  sizes <- sapply(ls(alldirs), get, env = alldirs)\n  candidates <- sizes[which(sizes >= todelete)]\n  smallest <- candidates[which.min(candidates)]\n  smallest\n}\nRust\nHere I took the same approach, but using a\nHashMap\nas the filesystem\nuse std::{collections::HashMap};\n\npub fn part_one(input: &str) -> Option<u32> {\n    let mut dir_deque = vec![];\n    let mut current_dir = String::from(\"\");\n    let mut filesystem = HashMap::new();\n    for l in input.lines() {\n        if l == \"$ cd ..\" {\n            dir_deque.pop().unwrap();\n            current_dir = dir_deque.join(\"\");\n            continue;\n        } else if l == \"$ cd /\" {\n            current_dir = String::from(\"/\");\n            filesystem.insert(current_dir.clone(), 0);\n            dir_deque = vec![String::from(\"/\")];\n            continue;\n        } else if l.starts_with(\"dir\") {\n            continue;\n        } else if l.starts_with(\"$ cd\") {\n            let new_dir = l.replace(\"$ cd \", \"\");\n            dir_deque.push(new_dir.clone() + &\"/\");\n            current_dir = current_dir + &new_dir.clone() + &\"/\";\n            filesystem.insert(current_dir.clone(), 0);\n            continue;\n        } else if char::is_digit(l.chars().nth(1).unwrap(), 10) {\n            let parts = l.split_whitespace().collect::<Vec<_>>();\n            let dir_size = parts[0].parse::<u32>().unwrap();\n            for d in 0..dir_deque.len() {\n                let this_d = dir_deque[0..=d].join(\"\");\n                let known_size = filesystem.get(&this_d).unwrap();\n                filesystem.insert(this_d, known_size + dir_size);\n            }\n            continue;\n        }\n    }\n\n    let totalsize = filesystem.iter()\n            .filter(|&(_k, v)| *v <= 1e5 as u32)\n            .map(|(_k, v)| *v)\n            .collect::<Vec<u32>>()\n            .iter()\n            .sum();\n\n    Some(totalsize)\n        \n}\n\npub fn part_two(input: &str) -> Option<u32> {\n    let mut dir_deque = vec![];\n    let mut current_dir = String::from(\"\");\n    let mut filesystem = HashMap::new();\n    for l in input.lines() {\n        if l == \"$ cd ..\" {\n            dir_deque.pop().unwrap();\n            current_dir = dir_deque.join(\"\");\n            continue;\n        } else if l == \"$ cd /\" {\n            current_dir = String::from(\"/\");\n            filesystem.insert(current_dir.clone(), 0);\n            dir_deque = vec![String::from(\"/\")];\n            continue;\n        } else if l.starts_with(\"dir\") {\n            continue;\n        } else if l.starts_with(\"$ cd\") {\n            let new_dir = l.replace(\"$ cd \", \"\");\n            dir_deque.push(new_dir.clone() + &\"/\");\n            current_dir = current_dir + &new_dir.clone() + &\"/\";\n            filesystem.insert(current_dir.clone(), 0);\n            continue;\n        } else if char::is_digit(l.chars().nth(1).unwrap(), 10) {\n            let parts = l.split_whitespace().collect::<Vec<_>>();\n            let dir_size = parts[0].parse::<u32>().unwrap();\n            for d in 0..dir_deque.len() {\n                let this_d = dir_deque[0..=d].join(\"\");\n                let known_size = filesystem.get(&this_d).unwrap();\n                filesystem.insert(this_d, known_size + dir_size);\n            }\n            continue;\n        }\n    }\n\n    let to_delete = filesystem.get(\"/\").unwrap() - (4e7 as u32);\n    let candidates = filesystem.iter()\n        .filter(|&(_k, v)| *v >= to_delete)\n        .map(|(_k, v)| *v)\n        .collect::<Vec<u32>>();\n    Some(*candidates.iter().min().unwrap())\n\n}\nDay 8: Treetop Tree House\n(see links)\nR\nRust\nDay 9: Rope Bridge\nThis one involves keeping track of the positions of several ‚Äòknots‚Äô in a rope as it moves.\nR\nI wrote a\nlot\nof helper functions for this one\nf09a <- function(x) {\n  visited <- list()\n  head_pos <- c(5, 1)\n  tail_pos <- c(5, 1)\n  # print_grid(head_pos, tail_pos)\n  visited <- c(visited, list(tail_pos))\n  for (instr in x) {\n    tmp <- move_rope(head_pos, tail_pos, instr)\n    head_pos <- tmp[[1]]\n    tail_pos <- tmp[[2]]\n    visited <- c(visited, tmp[[3]])\n  }\n  length(unique(visited))\n}\n\nprint_grid <- function(head_pos, tail_pos, size = 6) {\n  grid <- matrix(\".\", nrow = size, ncol = size)\n  grid[matrix(tail_pos, ncol = 2)] <- \"T\"\n  grid[matrix(head_pos, ncol = 2)] <- \"H\"\n  print(grid)\n}\n\nprint_knots <- function(k, size = 10) {\n  grid <- matrix(\".\", nrow = size, ncol = size)\n  for (i in seq_len(length(k))) {\n    grid[matrix(k[[i]], ncol = 2)] <- i\n  }\n  print(grid)\n}\n\nmove_head <- function(head_pos, dir) {\n  if (dir == \"L\") return(c(head_pos[1], head_pos[2] - 1))\n  if (dir == \"R\") return(c(head_pos[1], head_pos[2] + 1))\n  if (dir == \"U\") return(c(head_pos[1] - 1, head_pos[2]))\n  if (dir == \"D\") return(c(head_pos[1] + 1, head_pos[2]))\n}\n\nmove_rope <- function(head_pos, tail_pos, x) {\n  visited <- list()\n  dir <- sub(\" .*\", \"\", x)\n  dist <- as.integer(sub(\"[LRUD] \", \"\", x))\n  for (i in seq_len(dist)) {\n    head_pos <- move_head(head_pos, dir)\n    tail_pos <- move_tail(head_pos, tail_pos)\n    visited <- c(visited, list(tail_pos))\n  }\n  return(list(head_pos, tail_pos, visited))\n}\n\nmove_knots <- function(knots, x) {\n  visited <- list()\n  dir <- sub(\" .*\", \"\", x)\n  dist <- as.integer(sub(\"[LRUD] \", \"\", x))\n  for (i in seq_len(dist)) {\n    knots[[1]] <- move_head(knots[[1]], dir)\n    for (i in 2:10) {\n      knots[[i]] <- move_tail(knots[[i-1]], knots[[i]])\n    }\n    visited <- c(visited, list(knots[[10]]))\n  }\n  return(list(knots, visited))\n}\n\ntouching <- function(head_pos, tail_pos) {\n  (head_pos[1] == tail_pos[1] && head_pos[2] == tail_pos[2]) ||\n  (abs(head_pos[1] - tail_pos[1]) <= 1 && abs(head_pos[2] - tail_pos[2]) <= 1)\n}\n\nmove_tail <- function(head_pos, tail_pos) {\n  if (touching(head_pos, tail_pos)) return(tail_pos)\n  if (tail_pos[1] == head_pos[1]) return(c(tail_pos[1], tail_pos[2] + sign(head_pos[2] - tail_pos[2])*1))\n  if (tail_pos[2] == head_pos[2]) return(c(tail_pos[1] + sign(head_pos[1] - tail_pos[1]*1), tail_pos[2]))\n  return(c(tail_pos[1] + sign(head_pos[1] - tail_pos[1])*1, tail_pos[2] + sign(head_pos[2] - tail_pos[2])*1))\n}\nThis was also the first one I found the time to plot - here I plotted the path of the 10th knot,\nas well as the positions of the other knots after each step\nRust\nDay 10: Cathode-Ray Tube\n(see links)\nR\nRust\nDay 11: Monkey in the Middle\n(see links)\nR\nRust\nDay 12: Hill Climbing Algorithm\nThis one required that I learn a pathfinding algorithm - something I hadn‚Äôt really done before. I ended up\nlearning (and implementing) Dijkstra‚Äôs Algorithm for finding the shortest paths between nodes in a graph.\nR\nf12a <- function(x) {\n  rows <- strsplit(x, \"\")\n  grid <- matrix(unlist(rows), ncol = nchar(x[1]), byrow = TRUE)\n  ngrid <- grid\n  ngrid[which(grid == \"S\", arr.ind = TRUE)] <- \"a\"\n  ngrid[which(grid == \"E\", arr.ind = TRUE)] <- \"z\"\n  ngrid[] <- match(ngrid[], letters)\n  mode(ngrid) <- \"integer\"\n  startat <- which(t(grid) == \"S\")\n  endat <- which(t(grid) == \"E\")\n  min_path <- dijkstra(ngrid, endat, dir = -1)\n  min_pathp[startat]\n}\n\nget_pos <- function(grid, v) {\n  i <- floor((v-1)/ncol(grid))+1\n  j <- ((v-1) %% ncol(grid))+1\n  return(c(i, j))\n}\n\ncan_reach <- function(ngrid, v, dir = 1) {\n  x <- get_pos(ngrid, v)\n  i <- x[1]\n  j <- x[2]\n  # can only move 1 row away\n  res <- abs(floor(0:(prod(dim(ngrid))-1) / ncol(ngrid)) + 1 - i) <= 1 &\n    # can only move 1 col away\n    abs((0:(prod(dim(ngrid))-1)%%ncol(ngrid)) + 1 - j) <= 1 &\n    # can't move diagonally\n    abs(floor(0:(prod(dim(ngrid))-1) / ncol(ngrid)) + 1 - i) + abs((0:(prod(dim(ngrid))-1)%%ncol(ngrid)) + 1 - j) == 1\n    if (dir == 1) {\n    # can only step up 1\n      res <- res & c(t(ngrid - ngrid[i, j] <= 1))\n    } else {\n      res <- res & c(t(ngrid[i, j] - ngrid <= 1))\n    }\n  as.integer(res)\n}\n\ndijkstra <- function(grid, start, dir = -1){\n  #' Implementation of dijkstra using on-demand query\n  #' derived from https://www.algorithms-and-technologies.com/dijkstra/r\n  #' This returns an array containing the length of the shortest path from the start node to each other node.\n  #' It is only guaranteed to return correct results if there are no negative edges in the graph. Positive cycles are fine.\n  #' This has a runtime of O(|V|^2) (|V| = number of Nodes), for a faster implementation see @see ../fast/Dijkstra.java (using adjacency lists)\n  #' @param graph an adjacency-matrix-representation of the graph where (x,y) is the weight of the edge or 0 if there is no edge.\n  #' @param start the node to start from.\n  #' @param dir are we going up or down? passed to can_reach()\n  #' @return an array containing the shortest distances from the given start node to each other node\n\n  # This contains the distances from the start node to all other nodes\n  distances = rep(Inf, prod(dim(grid)))\n  paths = rep(list(), prod(dim(grid)))\n\n  # This contains whether a node was already visited\n  visited = rep(FALSE, prod(dim(grid)))\n\n  # The distance from the start node to itself is of course 0\n  distances[start] = 0\n  paths[[start]] = start\n\n  # While there are nodes left to visit...\n  repeat{\n\n    # ... find the node with the currently shortest distance from the start node...\n    shortest_distance = Inf\n    shortest_index = -1\n    for(i in seq_along(distances)) {\n      # ... by going through all nodes that haven't been visited yet\n      if(distances[i] < shortest_distance && !visited[i]){\n        shortest_distance = distances[i]\n        shortest_index = i\n      }\n    }\n\n    if(shortest_index == -1){\n      # There was no node not yet visited --> We are done\n      return (list(distances, paths))\n    }\n    # ...then, for all neighboring nodes that haven't been visited yet....\n    g <- can_reach(grid, shortest_index, dir = dir)\n    for(i in seq_along(g)) {\n      # ...if the path over this edge is shorter...\n      if(g[i] != 0 && distances[i] > distances[shortest_index] + g[i]){\n        # ...Save this path as new shortest path.\n        distances[i] = distances[shortest_index] + g[i]\n        paths[[i]] <- c(paths[[shortest_index]], i)\n      }\n      # Lastly, note that we are finished with this node.\n      visited[shortest_index] = TRUE\n    }\n  }\n}\nWith a decent amount of plotting code, I ended up with an animation showing the solution\nfor the test data\nwhich I was very pleased about. Even better, was the full solution animation\nRust\nDay 13: Distress Signal\nThis one involves comparing nested lists like\n[[1],[2,3,4]]\nvs\n[[1],4]\n. I really want to go back\nand try this one in Haskell because those comparisons are (I believe) built-in.\nR\nRust\nDay 14: Regolith Reservoir\nI didn‚Äôt finish my Rust solution for this one, but I was very happy with my R solution. The goal here\nis to fill the area with falling sand, allowing for some obstacles.\nR\nf14a <- function(x) {\n  allrocks <- lapply(x, rocks)\n  cave <- matrix(\".\", nrow = 200, ncol = 1500)\n  for (r in allrocks) {\n    for (rr in seq_along(r[-1])) {\n      f <- fill_rocks(r[rr], r[rr+1])\n      cave[f] <- \"#\"\n    }\n  }\n  done <- FALSE\n  while(!done) {\n    cave <- fall(cave, c(1, 500+500))\n    done <- cave[matrix(c(1,1), ncol = 2)] == \"X\"\n  }\n  sum(cave == \"o\")\n}\n\nfall <- function(cave, sand, crit = \"fall\") {\n  down <- c(sand[1]+1, sand[2])\n  if (crit == \"fall\" && down[1] > 200) {\n    cave[matrix(c(1,1), ncol = 2)] <- \"X\"\n    return(cave)\n  } else if (blocked(cave, c(1, 500+500))) {\n    sandmat <<- rbind(sandmat, c(1, 500+500))\n    cave[matrix(c(1,500+500), ncol = 2)] <- \"o\"\n    cave[matrix(c(1,1), ncol = 2)] <- \"X\"\n    return(cave)\n  }\n  if (blocked(cave, down)) {\n    downleft <- c(sand[1]+1, sand[2]-1)\n    if (blocked(cave, downleft)) {\n      downright <- c(sand[1]+1, sand[2]+1)\n      if (blocked(cave, downright)) {\n        sandmat <<- rbind(sandmat, sand)\n        cave[matrix(sand, ncol = 2)] <- \"o\"\n      } else {\n        return(fall(cave, downright))\n      }\n    } else {\n      return(fall(cave, downleft))\n    }\n  } else {\n    return(fall(cave, down))\n  }\n  return(cave)\n}\n\nblocked <- function(cave, x) {\n  cave[matrix(x, ncol = 2)] %in% c(\"#\", \"o\")\n}\n\nrocks <- function(x) {\n  rocks <- strsplit(x, \" -> \")[[1]]\n  rocks <- strsplit(rocks, \",\")\n  for (r in seq_along(rocks)) {\n    rocks[[r]] <- as.integer(rocks[[r]])\n    rocks[[r]][1] <- rocks[[r]][1] + 500\n  }\n  rocks\n}\n\nfill_rocks <- function(x, y) {\n  x <- x[[1]]\n  x[2] <- x[2] + 1\n  y <- y[[1]]\n  y[2] <- y[2] + 1\n  # horizontal\n  if (x[1] == y[1]) {\n    span <- x[2]:y[2]\n    return(matrix(c(span, rep(x[1], length(span))), ncol = 2, byrow = FALSE))\n  }\n  # vertical\n  if (x[2] == y[2]) {\n    span <- x[1]:y[1]\n    return(matrix(c(rep(x[2], length(span)), span), ncol = 2, byrow = FALSE))\n  }\n}\nI animated the falling sand, filling up the cave, but with\nso\nmany particles it didn‚Äôt go very well,\nespecially when limiting the frames\nInstead, a render of the final solution, with the sand coloured by the time at which it came to\nrest, looked much cooler\nDay 15: Beacon Exclusion Zone\n(see links)\nR\nDay 16: Proboscidea Volcanium\n(see links)\nR\nDay 17: Pyroclastic Flow\nWhile it was never mentioned by name, this one was essentially a game of Tetris.\nR\nAt this point, there‚Äôs too much code to copy inline. Check out the repo links.\nI couldn‚Äôt help but plot this one as an animation‚Ä¶\nDay 18: Boiling Boulders\nI got to learn even more algorithms for this one - this time a flood-fill algorithm.\nR\nI took advantage of one of coolbutuseless‚Äô packages\n{isocubes}\nto plot the shape of the lava droplet\nDay 19: Not Enough Minerals\n(see links)\nR\nDay 20: Grove Positioning System\n(see links)\nR\nDay 21: Monkey Math\nI had no intentions of making it on to the leaderboard for timing, even though the puzzles were\nreleased at an entirely reasonable time for me. I actually got to this one late in the\nevening due to some other commitments, but I am quietly confident that my R solution could\nhave been one of the fastest solves‚Ä¶\nThe problem is figuring out what the value of the ‚Äòroot‚Äô monkey is, given the following operations\nroot: pppw + sjmn\ndbpl: 5\ncczh: sllz + lgvd\nzczc: 2\nptdq: humn - dvpt\ndvpt: 3\nlfqf: 4\nhumn: 5\nljgn: 2\nsjmn: drzm * dbpl\nsllz: 4\npppw: cczh / lfqf\nlgvd: ljgn * ptdq\ndrzm: hmdt - zczc\nhmdt: 32\nR\nI realised fairly quickly that I could just make each of the connections a function call,\nand evaluate the entire stack! This was very fast to write, and I got to my full solution\nfaster than most of those at the top of the leaderboard, but much later in the day.\nf21a <- function(x) {\n  defs <- sapply(x, parseInput)\n  for (d in defs) {\n    eval(parse(text = d))\n  }\n  format(root(), scientific = FALSE)\n}\n\nparseInput <- function(x) {\n  monkey <- sub(\"^(.*):.*\", \"\\\\1\", x)\n  ret <- sub(\".*: (.*)$\", \"\\\\1\", x)\n  if (is.na(suppressWarnings(as.integer(ret)))) {\n    ret <- strsplit(ret, \" \")[[1]]\n    v1 <- ret[1]\n    op <- ret[2]\n    v2 <- ret[3]\n    def <- paste0(monkey, \" <- function() { \", v1, \"() \", op, \" \", v2, \"() }\")\n  } else {\n    def <- paste0(monkey, \" <- function() { \", ret, \" }\")\n  }\n}\nSure, sometimes (most of the time),\neval(parse(text = ))\nis a terrible idea, but in\nthis case it worked out great!\nDay 22: Monkey Map\n(see links)\nR\nDay 23: Unstable Diffusion\n(see links)\nR\nDay 24: Blizzard Basin\n(see links)\nR\nDay 25: Full of Hot Air\n(see links)\nR\nSummary\nI really enjoyed advent of code, and I ended up donating as thanks for providing such\na nice experience. I‚Äôll be having a go at AoC 2023 but won‚Äôt be so strict; I may not\nsolve each puzzle\non the day it‚Äôs released\nand I will be allowing myself to use whatever\nlibraries and whatever languages I want.\nWill you be participating? I‚Äôd love to compare solutions once we‚Äôre done! I can be found on\nMastodon\nand I‚Äôll be commenting on the puzzles as I go.\ndevtools::session_info()\n## ‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##  setting  value\n##  version  R version 4.3.2 (2023-10-31)\n##  os       Pop!_OS 22.04 LTS\n##  system   x86_64, linux-gnu\n##  ui       X11\n##  language (EN)\n##  collate  en_AU.UTF-8\n##  ctype    en_AU.UTF-8\n##  tz       Australia/Adelaide\n##  date     2023-11-28\n##  pandoc   3.1.8 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/x86_64/ (via rmarkdown)\n## \n## ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n##  package     * version date (UTC) lib source\n##  blogdown      1.18    2023-06-19 [1] CRAN (R 4.3.2)\n##  bookdown      0.36    2023-10-16 [1] CRAN (R 4.3.2)\n##  bslib         0.5.1   2023-08-11 [3] CRAN (R 4.3.1)\n##  cachem        1.0.8   2023-05-01 [3] CRAN (R 4.3.0)\n##  callr         3.7.3   2022-11-02 [3] CRAN (R 4.2.2)\n##  cli           3.6.1   2023-03-23 [3] CRAN (R 4.2.3)\n##  crayon        1.5.2   2022-09-29 [3] CRAN (R 4.2.1)\n##  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.3.2)\n##  digest        0.6.33  2023-07-07 [3] CRAN (R 4.3.1)\n##  ellipsis      0.3.2   2021-04-29 [3] CRAN (R 4.1.1)\n##  evaluate      0.22    2023-09-29 [3] CRAN (R 4.3.1)\n##  fastmap       1.1.1   2023-02-24 [3] CRAN (R 4.2.2)\n##  fs            1.6.3   2023-07-20 [3] CRAN (R 4.3.1)\n##  glue          1.6.2   2022-02-24 [3] CRAN (R 4.2.0)\n##  htmltools     0.5.6.1 2023-10-06 [3] CRAN (R 4.3.1)\n##  htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.2)\n##  httpuv        1.6.12  2023-10-23 [1] CRAN (R 4.3.2)\n##  icecream      0.2.1   2023-09-27 [1] CRAN (R 4.3.2)\n##  jquerylib     0.1.4   2021-04-26 [3] CRAN (R 4.1.2)\n##  jsonlite      1.8.7   2023-06-29 [3] CRAN (R 4.3.1)\n##  knitr         1.44    2023-09-11 [3] CRAN (R 4.3.1)\n##  later         1.3.1   2023-05-02 [1] CRAN (R 4.3.2)\n##  lifecycle     1.0.3   2022-10-07 [3] CRAN (R 4.2.1)\n##  magrittr      2.0.3   2022-03-30 [3] CRAN (R 4.2.0)\n##  memoise       2.0.1   2021-11-26 [3] CRAN (R 4.2.0)\n##  mime          0.12    2021-09-28 [3] CRAN (R 4.2.0)\n##  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.3.2)\n##  pkgbuild      1.4.2   2023-06-26 [1] CRAN (R 4.3.2)\n##  pkgload       1.3.3   2023-09-22 [1] CRAN (R 4.3.2)\n##  prettyunits   1.2.0   2023-09-24 [3] CRAN (R 4.3.1)\n##  processx      3.8.2   2023-06-30 [3] CRAN (R 4.3.1)\n##  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.3.2)\n##  promises      1.2.1   2023-08-10 [1] CRAN (R 4.3.2)\n##  ps            1.7.5   2023-04-18 [3] CRAN (R 4.3.0)\n##  purrr         1.0.2   2023-08-10 [3] CRAN (R 4.3.1)\n##  R6            2.5.1   2021-08-19 [3] CRAN (R 4.2.0)\n##  Rcpp          1.0.11  2023-07-06 [1] CRAN (R 4.3.2)\n##  remotes       2.4.2.1 2023-07-18 [1] CRAN (R 4.3.2)\n##  rlang         1.1.1   2023-04-28 [3] CRAN (R 4.3.0)\n##  rmarkdown     2.25    2023-09-18 [3] CRAN (R 4.3.1)\n##  rstudioapi    0.15.0  2023-07-07 [3] CRAN (R 4.3.1)\n##  sass          0.4.7   2023-07-15 [3] CRAN (R 4.3.1)\n##  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n##  shiny         1.7.5.1 2023-10-14 [1] CRAN (R 4.3.2)\n##  stringi       1.7.12  2023-01-11 [3] CRAN (R 4.2.2)\n##  stringr       1.5.0   2022-12-02 [3] CRAN (R 4.3.0)\n##  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.3.2)\n##  usethis       2.2.2   2023-07-06 [1] CRAN (R 4.3.2)\n##  vctrs         0.6.4   2023-10-12 [3] CRAN (R 4.3.1)\n##  xfun          0.40    2023-08-09 [3] CRAN (R 4.3.1)\n##  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.3.2)\n##  yaml          2.3.7   2023-01-23 [3] CRAN (R 4.2.2)\n## \n##  [1] /home/jono/R/x86_64-pc-linux-gnu-library/4.3\n##  [2] /usr/local/lib/R/site-library\n##  [3] /usr/lib/R/site-library\n##  [4] /usr/lib/R/library\n## \n## ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nrstats on Irregularly Scheduled Programming\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "In the lead up to Christmas each year, Advent of Code offers a series of 25 puzzles which start out reasonably simple, but get progressively harder, eventually requiring knowledge of algorithms and dynamic programming techniques. Last year I solved the...",
    "meta_keywords": null,
    "og_description": "In the lead up to Christmas each year, Advent of Code offers a series of 25 puzzles which start out reasonably simple, but get progressively harder, eventually requiring knowledge of algorithms and dynamic programming techniques. Last year I solved the...",
    "og_image": "https://jcarroll.com.au/2023/11/28/advent-of-code-2022/images/vis-day09.png",
    "og_title": "Advent of Code 2022 | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 38.9,
    "sitemap_lastmod": "2023-11-28T00:00:00+00:00",
    "twitter_description": "In the lead up to Christmas each year, Advent of Code offers a series of 25 puzzles which start out reasonably simple, but get progressively harder, eventually requiring knowledge of algorithms and dynamic programming techniques. Last year I solved the...",
    "twitter_title": "Advent of Code 2022 | R-bloggers",
    "url": "https://www.r-bloggers.com/2023/11/advent-of-code-2022/",
    "word_count": 7783
  }
}