{
  "uuid": "46cc5f29-f89f-452e-98ec-9903497ece25",
  "created_at": "2025-11-22 19:57:46",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/08/learning-the-basics-of-phylogenetic-analysis/",
    "crawled_at": "2025-11-22T10:43:36.057094",
    "external_links": [
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/",
        "text": "r on Everyday Is A School Day"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#movitation",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/amr/",
        "text": "last hands-on experience on Bioconductor"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#disclaimer",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#the-end-goal",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#objectives",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#phylo",
        "text": "What is phylogenetic analysis?"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#workflow",
        "text": "The workflow"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/@16s",
        "text": "Extract 16S rRna"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#align",
        "text": "Align"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#distance",
        "text": "Distance Calculation"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#tree",
        "text": "Tree construction"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#dataviz",
        "text": "Visualizing Phylogenetic tree"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#ecoli",
        "text": "Ecoli Large Dataset"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#others",
        "text": "Other Genus"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#opportunity",
        "text": "Opportunities for improvement"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#lesson",
        "text": "Lessons Learnt"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#phylo",
        "text": null
      },
      {
        "href": "https://journals.asm.org/doi/10.1128/microbiolspec.ame-0006-2018",
        "text": "contact tracing, outbreak assessment"
      },
      {
        "href": "https://en.wikipedia.org/wiki/Phylogenetics",
        "text": "Here is a quick wiki"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#lets-download-all-ecoli-fasta",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/amr/",
        "text": "previous opportunity improvement"
      },
      {
        "href": "https://www.ncbi.nlm.nih.gov/datasets/docs/v2/command-line-tools/download-and-install/",
        "text": "NCBI dataset CLI"
      },
      {
        "href": "https://www.ncbi.nlm.nih.gov/datasets/docs/v2/command-line-tools/download-and-install/",
        "text": "See here"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#terminal",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#workflow",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#16s",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/amr/",
        "text": "from before"
      },
      {
        "href": "https://github.com/tseemann/barrnap",
        "text": "check out their github"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#terminal-1",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#back-to-r",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#align",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#distance",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#tree",
        "text": null
      },
      {
        "href": "https://github.com/somme89/rapidNJ",
        "text": "RapidNJ"
      },
      {
        "href": "https://github.com/johnlees/rapidNJ-M1.git",
        "text": "John Lees"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#example-on-how-to-use-for-large-dataset",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#mean-imputation-for-nas-if-exists",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#dataviz",
        "text": null
      },
      {
        "href": "https://yulab-smu.top/treedata-book/chapter4.html",
        "text": "Data Integration, Manipulation and Visualization of Phylogenetic Trees"
      },
      {
        "href": "https://github.com/rambaut/figtree/releases",
        "text": "FigTree"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/",
        "text": null
      },
      {
        "href": "https://github.com/rambaut/figtree/releases",
        "text": "FigTree"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#other-genus",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#16s",
        "text": "previously"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#acknowledgement",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#opportunity",
        "text": null
      },
      {
        "href": "https://github.com/ArcInstitute/evo2",
        "text": "evo2"
      },
      {
        "href": "https://pmc.ncbi.nlm.nih.gov/articles/PMC10269621/",
        "text": "read this"
      },
      {
        "href": "https://bomeara.github.io/taxon2tree/",
        "text": "taxon2tree by Brian O‚ÄôMeara"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/#lesson",
        "text": null
      },
      {
        "href": "https://www.kenkoonwong.com/blog/",
        "text": "comment or visit my other blogs"
      },
      {
        "href": "https://bsky.app/profile/kenkoonwong.bsky.social",
        "text": "BlueSky"
      },
      {
        "href": "https://twitter.com/kenkoonwong/",
        "text": "twitter"
      },
      {
        "href": "https://github.com/kenkoonwong/",
        "text": "GitHub"
      },
      {
        "href": "https://med-mastodon.com/@kenkoonwong",
        "text": "Mastodon"
      },
      {
        "href": "https://www.kenkoonwong.com/contact/",
        "text": "contact me"
      },
      {
        "href": "https://www.kenkoonwong.com/blog/phylo/",
        "text": "r on Everyday Is A School Day"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Learning The Basics of Phylogenetic Analysis | R-bloggers",
    "images": [
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.kenkoonwong.com/blog/phylo/16s.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap_genome.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.kenkoonwong.com/blog/phylo/alignment.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/www.kenkoonwong.com/blog/phylo/align_contig.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i1.wp.com/www.kenkoonwong.com/blog/phylo/distance_matrix.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/phylo1.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/plot_phylo.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/esbl_phylo.png?w=578&ssl=1"
      },
      {
        "alt": "image",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": "image",
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/proportion.png?w=60%25&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i2.wp.com/www.kenkoonwong.com/blog/phylo/16s_mixed.png?w=578&ssl=1"
      },
      {
        "alt": null,
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
      },
      {
        "alt": null,
        "base64": null,
        "src": "https://i0.wp.com/www.kenkoonwong.com/blog/phylo/mixed_phylo.png?w=578&ssl=1"
      }
    ],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/r-on-everyday-is-a-school-day/",
        "text": "r on Everyday Is A School Day"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-395105 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Learning The Basics of Phylogenetic Analysis</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">August 30, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/r-on-everyday-is-a-school-day/\">r on Everyday Is A School Day</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.kenkoonwong.com/blog/phylo/\"> r on Everyday Is A School Day</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><blockquote>\n<p>üß¨üî¨ Explore phylogenetic analysis from genome to tree! Basic workflow with R/Bioconductor. Learnt to work with large genomic dataset. Extract 16S rRNA from 10K+ E.coli strains using dataset dehydrate, barrnap for extraction, rapidNJ for tree building &amp; FigTree for visualization.</p>\n</blockquote>\n<h2 id=\"movitation\">Movitation:\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#movitation\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<p>After that \n<a href=\"https://www.kenkoonwong.com/blog/amr/\" rel=\"nofollow\" target=\"_blank\">last hands-on experience on Bioconductor</a>, we will continue our journey in phylogenetic analysis. I‚Äôve always been intrigued in how biologists piece these phylogenetic tree together and I want to know the big idea of how this is done. We‚Äôll again be using Bioconductor. Let‚Äôs go!</p>\n<h4 id=\"disclaimer\">Disclaimer:\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#disclaimer\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<p><em>I am not a bioinformatician and do not work with genes directly, the articles and method presented is my attempt to get a birds eye view on how we went from different isolates to piecing them together onto a single tree. Please take this with a grain of salt. Verify the information presented. If you noted some error in this article, please let me know so that I can learn! Also, some of the analysis results were not run during rmarkdown knitting because that causes a significant delay, however, the results posted here should be reprodicuble. Please again let me know if they are not</em></p>\n<h2 id=\"the-end-goal\">The End Goal:\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#the-end-goal\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<ol>\n<li>Get a basic workflow of how this is done</li>\n<li>Assess Many Many Ecoli strains</li>\n<li>Assess Different Genus on a single tree</li>\n</ol>\n<p>Looks quite doable! Along the line, we may have some deeper dive to look at the machinery behind. Ultimately, we want to visualize beuatiful trees! üå¥ Like this.</p>\n<p><img alt=\"\" data-lazy-src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&amp;ssl=1\"/></noscript></p>\n<h2 id=\"objectives\">Objectives:\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#objectives\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<ul>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#phylo\" rel=\"nofollow\" target=\"_blank\">What is phylogenetic analysis?</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#workflow\" rel=\"nofollow\" target=\"_blank\">The workflow</a>\n<ul>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/@16s\" rel=\"nofollow\" target=\"_blank\">Extract 16S rRna</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#align\" rel=\"nofollow\" target=\"_blank\">Align</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#distance\" rel=\"nofollow\" target=\"_blank\">Distance Calculation</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#tree\" rel=\"nofollow\" target=\"_blank\">Tree construction</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#dataviz\" rel=\"nofollow\" target=\"_blank\">Visualizing Phylogenetic tree</a></li>\n</ul>\n</li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#ecoli\" rel=\"nofollow\" target=\"_blank\">Ecoli Large Dataset</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#others\" rel=\"nofollow\" target=\"_blank\">Other Genus</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#opportunity\" rel=\"nofollow\" target=\"_blank\">Opportunities for improvement</a></li>\n<li>\n<a href=\"https://www.kenkoonwong.com/blog/phylo/#lesson\" rel=\"nofollow\" target=\"_blank\">Lessons Learnt</a></li>\n</ul>\n<h2 id=\"phylo\">What is phylogenetic analysis?\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#phylo\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<p>Phylogenetic analysis is a method used to study the evolutionary relationships between organisms. It involves comparing genetic sequences, such as DNA or RNA, to infer how species are related through common ancestry. This analysis can help identify how different organisms have evolved over time and can be particularly useful in \n<a href=\"https://journals.asm.org/doi/10.1128/microbiolspec.ame-0006-2018\" rel=\"nofollow\" target=\"_blank\">contact tracing, outbreak assessment</a>. \n<a href=\"https://en.wikipedia.org/wiki/Phylogenetics\" rel=\"nofollow\" target=\"_blank\">Here is a quick wiki</a></p>\n<h4 id=\"lets-download-all-ecoli-fasta\">Let‚Äôs Download ALL Ecoli Fasta\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#lets-download-all-ecoli-fasta\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<p>One of our \n<a href=\"https://www.kenkoonwong.com/blog/amr/\" rel=\"nofollow\" target=\"_blank\">previous opportunity improvement</a> is to learn to use \n<a href=\"https://www.ncbi.nlm.nih.gov/datasets/docs/v2/command-line-tools/download-and-install/\" rel=\"nofollow\" target=\"_blank\">NCBI dataset CLI</a>. We‚Äôll be using that this time because if you try to download more than 10,000 of fasta via website or event the CLI itself, it won‚Äôt be as smooth, at least from my multiple tries. I‚Äôve attempted maybe 5-6 times and couldn‚Äôt complete the download even when I used <code>datasets</code> and unable to resume downloads. However, the most stable is actually to <code>download dehydrated</code> then <code>rehydrate</code>. \n<a href=\"https://www.ncbi.nlm.nih.gov/datasets/docs/v2/command-line-tools/download-and-install/\" rel=\"nofollow\" target=\"_blank\">See here</a></p>\n<h4 id=\"terminal\">Terminal\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#terminal\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<pre>curl -o datasets 'https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/v2/mac/datasets'\nchmod +x datasets dataformat\ndatasets download genome taxon \"Escherichia coli\" \\\n  --assembly-level scaffold,chromosome,complete \\\n  --dehydrated \\\n  --filename ecoli_high_quality_dehydrated.zip\nunzip ecoli_genomes_dehydrated.zip \ncd ncbi_dataset\ndatasets rehydrate --directory\n</pre><blockquote>\n<p>For large genome downloads, use <code>datasets dehydrated</code> then <code>rehydrate</code>. It‚Äôs easier to resume download if connection got lost.</p>\n</blockquote>\n<p>You notice above that we left off <code>contig</code> and just included scaffold, chromosome, and complete? That‚Äôs because there were 300,000 sequences if we include all of them. I definitely don‚Äôt need all of those packages. With scaffold, chromosome, and complete, we got 30,000+ and the entire zip file was <code>58 gigs</code> of data. üòµ‚Äçüí´</p>\n<p>Just for my education:</p>\n<ul>\n<li><code>Contig</code> ‚Äì Short for ‚Äúcontiguous sequence.‚Äù This is a continuous stretch of DNA sequence with no gaps. Contigs are assembled from overlapping sequencing reads, but they represent isolated pieces without known relationships to other contigs.</li>\n<li><code>Scaffold</code> ‚Äì A collection of contigs that have been ordered and oriented relative to each other, often with gaps of estimated size between them. Scaffolding uses additional information like paired-end reads or mate-pair libraries to determine how contigs should be arranged, even when the sequence connecting them isn‚Äôt fully resolved.</li>\n<li><code>Chromosome</code> ‚Äì Contigs and scaffolds have been assembled into chromosome-scale sequences that represent entire chromosomes. This typically requires additional long-range information like Hi-C data, optical mapping, or long-read sequencing to achieve proper chromosome-level organization.</li>\n<li><code>Complete</code> ‚Äì The highest level of assembly where the entire genome is finished with no gaps, including challenging repetitive regions, centromeres, and telomeres. This represents a truly complete, end-to-end sequence of all chromosomes.</li>\n</ul>\n<h2 id=\"workflow\">The Workflow\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#workflow\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<p>The workflow for phylogenetic analysis typically involves several key steps:</p>\n<blockquote>\n<p>Extract 16s rRNA -&gt; Align -&gt; Calculate Distance -&gt; Construct Tree</p>\n</blockquote>\n<h3 id=\"16s\">Extract 16S rRNA\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#16s\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h3>\n<p>This step involves obtaining the genetic material from the organisms of interest, such as bacteria or viruses. For example, in the case of antibiotic resistance, researchers might extract the 16S rRNA gene, which is commonly used for bacterial identification. The reason for extracting 16S rRNA in bacteria is beccause the sequence are highly conserved across different species, making it a reliable marker for phylogenetic analysis. The 16S rRNA gene is present in all bacteria and archaea, and its sequence can provide insights into the evolutionary relationships between different microbial species. Let‚Äôs dive into the code to do this. We‚Äôll use the same 2 groups we used before, regular Ecoli and ESBL Ecoli \n<a href=\"https://www.kenkoonwong.com/blog/amr/\" rel=\"nofollow\" target=\"_blank\">from before</a></p>\n<pre>library(Biostrings)\nlibrary(DECIPHER)\n\n# load data\npath1 &lt;- \"/path/to/your/first/ecoli/data\"\n\nnon_esbl_ecoli_files &lt;- list.files(path1, pattern = \"*.fna\", recursive = T)\nnon_esbl_ecoli &lt;- DNAStringSet()\nfor (i in non_esbl_ecoli_files) {\n  seq_i &lt;- readDNAStringSet(paste0(path1,i))[1]\n  non_esbl_ecoli &lt;- c(non_esbl_ecoli,seq_i)\n}\n\npath2 &lt;- \"/path/to/your/second/ecoli/data\"\nesbl_ecoli_files &lt;- list.files(path2, pattern = \"*.fna\", recursive = T)\nesbl_ecoli &lt;- DNAStringSet()\nfor (i in esbl_ecoli_files) {\n  seq_i &lt;- readDNAStringSet(paste0(path2,i))[1]\n  esbl_ecoli &lt;- c(esbl_ecoli,seq_i)\n}\n\nall_ecoli &lt;- c(non_esbl_ecoli, esbl_ecoli)\n\n# extract 16s\ndata(\"NonCodingRNA_Bacteria\")\nx &lt;- NonCodingRNA_Bacteria$`rRNA_16S-RF00177`\nall_ecoli[1]\nrrna &lt;- FindNonCoding(x = x, myXStringSet = all_ecoli[1:5], verbose = T) \nrrna\n</pre><p><img alt=\"\" data-lazy-src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/16s.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/16s.png?w=578&amp;ssl=1\"/></noscript>\nThe reason I only used <code>all_ecoli[1:5]</code> is because it‚Äôs EXTREMELY slow to extract 16s with <code>DECIPHER</code>. Later on we‚Äôll use an external tool called <code>barrnap</code> to extract our 10k contigs seemlessly. Let‚Äôs continue.</p>\n<pre>(extract &lt;- ExtractGenes(x = rrna, myDNAStringSet = all_ecoli[1:5]))\n</pre><p><img alt=\"\" data-lazy-src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Look at that beauty! Because <code>DECIPHER</code> extracted multiple <code>16s</code> sequences, hence we see there are 35 rows of data, even though we‚Äôre only using 5 strains of Ecoli. Since we‚Äôre having trouble with extracting 16s with DECIPHER, speed being the issue, let‚Äôs try <code>barrnap</code>! To install is, \n<a href=\"https://github.com/tseemann/barrnap\" rel=\"nofollow\" target=\"_blank\">check out their github</a></p>\n<h4 id=\"terminal-1\">Terminal\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#terminal-1\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<pre>brew install brewsci/bio/barrnap\n</pre>\n<h4 id=\"back-to-r\">Back to R\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#back-to-r\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<pre>writeXStringSet(all_ecoli, filepath = \"40_ecoli.fasta\")\nsystem(\"barrnap --threads 90 40_ecoli.fasta &gt; 40_ecoli_16s.gff\")\n\nlibrary(ape)\n(df &lt;- read.gff(\"40_ecoli_16s\"))\n</pre><p><img alt=\"\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Alright, let‚Äôs turn this into a dataframe, extract 16s only, and choose the first one with <code>+</code> and we‚Äôll have our 16s! Take note that there is a column called <code>score</code>, it is <code>evalue</code>, the lower (closer to zero) the better. These all look pretty good. Remember, the tool only tells you where the positions are, you have to go back to your genome and extract those. Let‚Äôs go!</p>\n<pre>library(tidyverse)\n\ndf &lt;- df |&gt;\n  as_tibble() |&gt;\n  filter(str_detect(attributes, \"16S\")) |&gt;\n  filter(strand == \"+\") |&gt;\n  distinct(seqid, .keep_all = T)\n\nall_sequences &lt;- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name &lt;- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly &lt;- all_ecoli[str_detect(all_ecoli |&gt; names(), name)]\n  seq_i &lt;- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences &lt;- c(all_sequences, seq_i)\n}\n\nall_sequences\n</pre><p><img alt=\"\" data-lazy-src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap_genome.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/extract_16s_barrnap_genome.png?w=578&amp;ssl=1\"/></noscript>\nAgain, what a beauty! These sequences look quite conversed, don‚Äôt they? Take note that a 16s rRNA sequence is about 1538 base pairs, there is one on the glance that is only 1537. This is going to be a problem if we‚Äôre trying to calculate distance. Hence, <code>align</code> is crucial to ensure they all have the same length of sequence.</p>\n<blockquote>\n<p>Barrnap is truly an efficient tool to extract 16s positions from bacteria! The ‚Äìthreads option is awesome if you have lots of cpu to spare! This is will very helpful when we have to extract 10k sequences</p>\n</blockquote>\n<h3 id=\"align\">Align\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#align\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h3>\n<p>Alignment is a crucial step in phylogenetic analysis as it ensures that the sequences being compared are of the same length and that homologous positions are aligned correctly. This is important because differences in sequence length or misaligned positions can lead to inaccurate distance calculations and, consequently, incorrect phylogenetic trees. By aligning sequences, we can accurately identify conserved regions, mutations, insertions, and deletions, which are essential for inferring evolutionary relationships. Let‚Äôs align our 16s sequences using <code>DECIPHER</code></p>\n<pre>alignment &lt;- AlignSeqs(all_sequences, verbose = TRUE)\n</pre><p><img alt=\"\" data-lazy-src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/alignment.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/alignment.png?w=578&amp;ssl=1\"/></noscript></p>\n<pre>alignment[36] |&gt; as.character()\n</pre><p><img alt=\"\" data-lazy-src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/align_contig.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/align_contig.png?w=578&amp;ssl=1\"/></noscript>\nRemember that one contig that we saw previously with 1 missing nucleotide? <code>DECIPHER</code> basically adds a <code>-</code> to the missing position. The method behind this is very interesting! We will take a deep dive next time. But it uses <code>dynamic programming</code> to find the optimal alignment by minimizing the number of mismatches and gaps. It constructs a scoring matrix based on matches, mismatches, and gap penalties, then traces back through the matrix to determine the best alignment path. This <code>dynamic programming</code> actually is a different <code>dynamic programming</code> than the one used in reinforcement learning, I think.</p>\n<h3 id=\"distance\">Distance Calculation\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#distance\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h3>\n<p>Distance calculation is a crucial step in making sense of all these 16s rRNA sequences.By calculating distances, we can determine how closely related different organisms are, which is essential for constructing accurate phylogenetic trees. Various methods exist for distance calculation, such as p-distance (proportion of differing sites), Jukes-Cantor, and Kimura models, each accounting for different aspects of sequence evolution. Let‚Äôs use <code>Jukes-Cantor</code></p>\n<pre>distances &lt;- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n## This is just to show the matrix without names\ndist &lt;- as.matrix(distances)\nrownames(dist) &lt;- NULL\ncolnames(dist) &lt;- NULL\ndist\n</pre><p><img alt=\"\" data-lazy-src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/distance_matrix.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.kenkoonwong.com/blog/phylo/distance_matrix.png?w=578&amp;ssl=1\"/></noscript>\nnotice that [1,1], [2,2] ‚Ä¶ are 0 because they are essentially comparing themselves. These methods are really intriguing. Can‚Äôt say I understood all of them but maybe one day we‚Äôll take a deeper dive into these algorithms and its math behind them! Can‚Äôt wait! On to the next, tree construction!</p>\n<h3 id=\"tree\">Tree construction\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#tree\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h3>\n<pre>tree &lt;- nj(distances)\n</pre><p>Here, we basically used neighbor joining to construct our tree. Neighbor-joining is a distance-based method for constructing phylogenetic trees that focuses on minimizing the total branch length of the tree. It starts with a star-like structure and iteratively joins pairs of taxa (or nodes) that minimize the overall distance, effectively grouping closely related organisms together.</p>\n<p>Take note that this function from <code>ape</code> will not work well when it‚Äôs a large dataset. It will be VERY slow! We will instead use \n<a href=\"https://github.com/somme89/rapidNJ\" rel=\"nofollow\" target=\"_blank\">RapidNJ</a> for that. An external tool but, wow the speed! Within seconds!</p>\n<p>If you are using Mac M1/2 and want to use advantage of Mac M1/2 architecture, you can compile rapidNJ from source but from \n<a href=\"https://github.com/johnlees/rapidNJ-M1.git\" rel=\"nofollow\" target=\"_blank\">John Lees</a>:</p>\n<pre>git clone https://github.com/johnlees/rapidNJ-M1.git\ncd rapidNJ-M1\nmake -j\n</pre>\n<h4 id=\"example-on-how-to-use-for-large-dataset\">Example on how to use for large dataset\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#example-on-how-to-use-for-large-dataset\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<pre>library(phangorn)\n\ndist &lt;- as.matrix(distances)\nnames_list &lt;- dist |&gt; rownames() |&gt; str_split(pattern = \" \") \nnames &lt;- c()\nfor (i in 1:length(names_list)) {\n  names &lt;- c(names, names_list[[i]][1])\n}\n\nrownames(dist) &lt;- names\ncolnames(dist) &lt;- names\nphangorn::writeDist(dist, file = \"all_ecoli_phylip\", format = \"phylip\")\nsystem(\"rapidnj -i pd all_ecoli_phylip &gt; all_ecoli_tree.newick\")\n</pre><p>Turn your <code>dist</code> format into matrix, remove any spaces on your matrix row and column names, write a <code>phylip</code> file then use <code>rapidNJ</code> to build tree.</p>\n<p>There may be times where there are <code>NA</code>s on our matrix. We can use the function below to impute number to make sure we don‚Äôt have <code>NA</code>s. I‚Äôm actually not sure if rapidNJ can handle NAs, I know <code>ape::njs</code> can but it will again be very slow for large datasets.</p>\n<h4 id=\"mean-imputation-for-nas-if-exists\">Mean Imputation for NAs if Exists\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#mean-imputation-for-nas-if-exists\" rel=\"nofollow\" target=\"_blank\"></a>\n</h4>\n<pre>impute_mean_distance &lt;- function(dist_matrix) {\n  mat &lt;- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist &lt;- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] &lt;- mean_dist\n  \n  return(mat)\n}\n\n# Apply mean imputation\ndist_imputed_mean &lt;- impute_mean_distance(dist_mat)\n</pre>\n<h3 id=\"dataviz\">Visualizing Phylogenetic tree\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#dataviz\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h3>\n<pre>plot(tree, \n     main = \"E. coli 16S rRNA Phylogenetic Tree\",\n     sub = paste(\"Based on\", length(tree$tip.label), \"16S sequences\"),\n     cex = 0.8,\n     edge.width = 2)\n</pre><p><img alt=\"\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/phylo1.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/phylo1.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>I marked red boxes on the ESBL strains to see if it shows much insight. Not really. I was hoping to see some of the ESBL Ecoli are in the same clade but it doesn‚Äôt seem like it. Maybe because we only used 40 strains. Technically, these ESBLs are controlled by plasmids, I suspect the chromosome sequence shouldn‚Äôt really matter much, which means we should see clustering between both ESBLs and non-ESBLs.</p>\n<p>The interpretation of the tree is essentially pay attention to the nodes, not the distances between each strains. The nodes represents a latent ancestor. The closer the nodes, the more related they are. Reminds me of a latent variable. If we want to compare between 2 strains, we basically count how many nodes are between their relationships.</p>\n<p>\n<a href=\"https://yulab-smu.top/treedata-book/chapter4.html\" rel=\"nofollow\" target=\"_blank\">Data Integration, Manipulation and Visualization of Phylogenetic Trees</a> has a very good chapter on viualizing tree using <code>ggtree</code>, it‚Äôs REALLY neat!</p>\n<p>Again, if we have large dataset, we need to use something else. <code>plot</code> itself is pretty fast, but not ggtree. We‚Äôll use external tool again called \n<a href=\"https://github.com/rambaut/figtree/releases\" rel=\"nofollow\" target=\"_blank\">FigTree</a> to plot our large tree. It‚Äôs faster and easier to navigate with a GUI, but will need java.</p>\n<h2 id=\"\">Ecoli Large Dataset\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<details>\n<summary>click to expand code</summary>\n<pre>########## asessing all ecoli\nlibrary(Biostrings)\nlibrary(tidyverse)\nlibrary(ape)\nlibrary(DECIPHER)\n\npath &lt;- \"path/to/your/ecoli/data\"\nfiles &lt;- list.files(path = path, pattern = \"*.fna\", recursive = T)\n\nall_ecoli &lt;- DNAStringSet()\nfor (i in files) {\n  dna_i &lt;- readDNAStringSet(paste0(path,i))[1]\n  all_ecoli &lt;- c(all_ecoli,dna_i)\n}\n\n# save it since it took sometime to read all\nwriteXStringSet(all_ecoli, filepath = \"all_ecoli.fasta\")\n\n# load it if working in subsequent sessions\nall_ecoli &lt;- readDNAStringSet(\"all_ecoli.fasta\")\n\n# extract 16s\nsystem(\"barrnap --threads 90 all_ecoli.fasta &gt; all_ecoli_16s.gff\")\n\n# use position to get our 16s sequence\ndf &lt;- read.gff(\"all_ecoli_16s.gff\") |&gt; \n  as_tibble() |&gt;\n  filter(str_detect(attributes, \"16S\")) |&gt;\n  filter(strand == \"+\") |&gt;\n  distinct(seqid, .keep_all = T)\n\nall_sequences &lt;- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name &lt;- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly &lt;- all_ecoli[str_detect(all_ecoli |&gt; names(), name)]\n  seq_i &lt;- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences &lt;- c(all_sequences, seq_i)\n  print(i)\n}\n\n# align\nalignment &lt;- AlignSeqs(all_sequences, verbose = TRUE)\n\n# Save alignment\nwriteXStringSet(alignment, \"all_ecoli_16s_alignment.fasta\")\n\n\n# load it (when returning from a new session)\nalignment &lt;- readDNAStringSet(\"all_ecoli_16s_alignment.fasta\")\n\n# Calculate distances\ndistances &lt;- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n# save \nsave(distances, file = \"all_ecoli_distance.rda\")\n\n# load it (when returning from a new session)\nload(\"all_ecoli_distance.rda\")\ndist_mat &lt;- as.matrix(distances)\n\n# impute NA\nimpute_mean_distance &lt;- function(dist_matrix) {\n  mat &lt;- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist &lt;- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] &lt;- mean_dist\n  \n  return(mat)\n}\n\n\n# Apply mean imputation\ndist_imputed_mean &lt;- impute_mean_distance(dist_mat)\n\n# converting to philip\ndist_final &lt;- dist_imputed_mean\n\n### using phangorn for phylip\nlibrary(phangorn)\n\n# rapidnj cannot handle spaces\nnames_list &lt;- dist_final |&gt; rownames() |&gt; str_split(pattern = \" \") \nnames &lt;- c()\nfor (i in 1:length(names_list)) {\n  names &lt;- c(names, names_list[[i]][1])\n}\n\nrownames(dist_final) &lt;- names\ncolnames(dist_final) &lt;- names\nphangorn::writeDist(dist_final, file = \"all_ecoli_phylip\", format = \"phylip\")\n\n# build tree w rapidnj\nsystem(\"rapidnj -i pd all_ecoli_phylip &gt; all_ecoli_tree.newick\")\n\n# read tree\nlibrary(ape)\ntree &lt;- read.tree(\"all_ecoli_tree.newick\")\n\n# Remove long branches\nthreshold &lt;- 0.0001\nsampled_tree$edge.length &lt;- ifelse(sampled_tree$edge.length &gt; threshold, threshold, sampled_tree$edge.length)\n\n# set negative value to 0\nsampled_tree$edge.length &lt;- ifelse(sampled_tree$edge.length &lt; 0, 0, sampled_tree$edge.length)\n\nplot(sampled_tree,\n     type = \"fan\",\n     main = paste(length(sampled_tree$tip.label),\" E. coli 16S rRNA Phylogenetic Tree\"),\n     cex = 0.1,\n     edge.width = 1,\n     show.tip.label = F)\n\nwrite.tree(sampled_tree, file = \"modified_ecol.newick\")\n</pre></details>\n<p>This is the default <code>plot</code> function. Efficient but needs some improvement.</p>\n<p><img alt=\"\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/plot_phylo.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/plot_phylo.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Now, if we use \n<a href=\"https://github.com/rambaut/figtree/releases\" rel=\"nofollow\" target=\"_blank\">FigTree</a>, we can make into something like we saw upfront.</p>\n<p><img alt=\"\" data-lazy-src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg?w=578&amp;ssl=1\"/></noscript>\nTo be quite frank. This looks quite pretty, but it doesn‚Äôt really give me much information other than certain ecoli strains have clades and some clusters together. But without the names, we can‚Äôt really say much and to put all these 10k+ names on the plot is just a group of meaningless mess. What if we sample these contigs, and revisit our topic of whether esbl and non-esbl tend to have their own clade or it doesn‚Äôt matter because it‚Äôs blaCTX-M, blaSHV, blaTEM are on plasmids, not chromosomes like what we‚Äôre trying to assess here.</p>\n<p>Let‚Äôs dive a bit deeper. Let‚Äôs only show the tip label of the ESBLs in red and see if there is a cluster of them.</p>\n<details>\n<summary>click to expand code</summary>\n<pre>alignment &lt;- readDNAStringSet(\"all_ecoli_16s_alignment.fasta\")\n\nsample_alignment &lt;- alignment\n  \nesbl_index &lt;- names(sample_alignment) |&gt; str_detect(\"ESBL|esbl\") |&gt; which()\nname_list &lt;- c()\nfor (i in 1:length(sample_alignment)) {\n  seq &lt;- sample_alignment[i] |&gt; names() |&gt; str_split(\" \")\n  if (i %in% esbl_index) {\n    name &lt;- paste0(seq[[1]][1],\"-ESBL\")\n  } else {\n  name &lt;- seq[[1]][1]\n  }\n  name_list &lt;- c(name_list, name)\n}\n\nnames(sample_alignment) &lt;- name_list\n\ndistances &lt;- DistanceMatrix(sample_alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n# tree &lt;- nj(distances)\ndist_mat &lt;- as.matrix(distances)\n\n# impute NA\nimpute_mean_distance &lt;- function(dist_matrix) {\n  mat &lt;- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist &lt;- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] &lt;- mean_dist\n  \n  return(mat)\n}\n\n\n# Apply mean imputation\ndist_imputed_mean &lt;- impute_mean_distance(dist_mat)\n\n# converting to philip\ndist_final &lt;- dist_imputed_mean\n\n### using phangorn for phylip\nlibrary(phangorn)\nphangorn::writeDist(dist_final, file = \"all_ecoli_phylip_2\", format = \"phylip\")\n\n# build tree w rapidnj\nsystem(\"rapidnj -i pd all_ecoli_phylip_2 &gt; all_ecoli_tree_2.newick\")\n\ntree &lt;- read.tree(\"all_ecoli_tree_2.newick\")\n\n\ntree$edge.length |&gt; summary()\nthreshold &lt;- 0.0001\ntree$edge.length &lt;- ifelse(tree$edge.length &gt; threshold, threshold, tree$edge.length)\n\n# set neg to 0\ntree$edge.length &lt;- ifelse(tree$edge.length &lt; 0, 0, tree$edge.length)\n\nplot(tree,\n     main = \"E. coli 16S rRNA Phylogenetic Tree\",\n     sub = paste(\"Based on\", length(tree$tip.label), \"16S sequences\"),\n     cex = 1,\n     edge.width = 2)\n\nlibrary(ggtree)\n\n# Assuming your tree object is called 'tree'\np &lt;- ggtree(tree, layout = \"circular\") +\n  geom_tiplab(aes(label = ifelse(grepl(\"ESBL\", label), label, \"\")), \n              color = \"red\",\n              size = 2)\np\n\nesbl_parent_node &lt;- tree$tip.label[tree$edge[,2]] |&gt; str_detect(\"ESBL\") |&gt; which()\n\ndf_esbl_parent &lt;- tibble(parent_node=as.numeric(),isolate=as.character())\nfor (i in esbl_parent_node) {\n  idx_parent_node &lt;- tree$edge[i,1]\n  isolate &lt;- tree$edge[tree$edge[,1] == idx_parent_node, 2]\n  df_esbl_parent &lt;- df_esbl_parent |&gt;\n    bind_rows(tibble(parent_node=idx_parent_node,isolate=tree$tip.label[isolate]))\n  print(tree$tip.label[isolate])\n}\n\n\ndf_esbl_parent &lt;- df_esbl_parent |&gt;\n  distinct()\n\ndf_table &lt;- df_esbl_parent |&gt;\n  group_by(parent_node) |&gt;\n  mutate(esbl = case_when(\n    str_detect(isolate, \"ESBL\") ~ 2,\n    is.na(isolate) ~ 0,\n    TRUE ~ 1\n  )) |&gt;\n  summarize(sum = sum(esbl)) \n\ndf_table |&gt;\n  select(sum) |&gt;\n  mutate(name = case_when(\n    sum == 4 ~ \"ESBL_ESBL\",\n    sum == 3 ~ \"ESBL_nonESBL\",\n    sum == 2 ~ \"ESBL_NA\"\n  )) |&gt;\n  select(name) |&gt;\n  group_by(name) |&gt;\n  summarize(n = n()) |&gt;\n  mutate(prop = n/sum(n))\n</pre></details>\n<p><img alt=\"\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/esbl_phylo.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/esbl_phylo.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Doesn‚Äôt seem like it. If ESBL strains were to have come later, or branched off from a specific ancestry, we should be seeing a more clustered branch, but it seems to be more wide spread across the tree.</p>\n<p>Let‚Äôs take a deeper dive on looking at the tree data itself. If ESBL strains are more clustered together, we should be seeing more ESBL strains to have the same parent node (latent) than an ESBL strain with a non-ESBL strain.</p>\n<p align=\"center\">\n<img alt=\"image\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/proportion.png?w=60%25&amp;ssl=1\" data-recalc-dims=\"1\" height=\"auto\" loading=\"lazy\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"image\" data-recalc-dims=\"1\" height=\"auto\" loading=\"lazy\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/proportion.png?w=60%25&amp;ssl=1\"/></noscript>\n</p>\n<p>This shows that 33% of the ESBL strains have a non-ESBL strain that share its parent. Whereas 23.8% of ESBL strains share a parent with another ESBL strain. And 42.9% have parents with latent child (meaning another latent strain which we don‚Äôt know whether it‚Äôs ESBL or non-ESBL that bracnhed off to another phyla).</p>\n<p><em>The code to generate the <code>ggtree</code> plot and proportion table is available on github.</em></p>\n<h2 id=\"other-genus\">Other Genus\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#other-genus\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<p>Now, what if we include other genus of bacteria into a single tree? Let‚Äôs grab <code>klebsiella aerogenes</code>, <code>pseudomonas aureginosa</code>, <code>enterobacter spp</code>, <code>staph aureus</code>, and we‚Äôll sample our existing <code>escherichia coli</code> and see if they would be in different branches? In theory they should be!</p>\n<p>Looking at a glance, their 16s rRNA sequence look different too among different genus! If you still remember, \n<a href=\"https://www.kenkoonwong.com/blog/phylo/#16s\" rel=\"nofollow\" target=\"_blank\">previously</a> our Ecoli 16s rRNA were quite similar.</p>\n<p><img alt=\"\" data-lazy-src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/16s_mixed.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/www.kenkoonwong.com/blog/phylo/16s_mixed.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Now let‚Äôs plot the phylogenetic tree</p>\n<p><img alt=\"\" data-lazy-src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/mixed_phylo.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.kenkoonwong.com/blog/phylo/mixed_phylo.png?w=578&amp;ssl=1\"/></noscript></p>\n<p>Wow, they do cluster close to each other! That is really cool! It also looks like complete seperation! that‚Äôs amazing!</p>\n<details>\n<summary>click to expand code</summary>\n<pre>#### assessing other genus\necoli &lt;- sample(all_ecoli,10)\n\n## create function\ngrab_fasta &lt;- function(path) {\n  files &lt;- list.files(path = path, pattern = \"*.fna\", recursive = T)\n  seq &lt;- DNAStringSet()\n  for (i in files) {\n    dna_i &lt;- readDNAStringSet(paste0(path,i))[1]\n    seq &lt;- c(seq,dna_i)\n  }\n  return(seq)\n}\n\nkleb &lt;- grab_fasta(path = \"kleb_aerogene/ncbi_dataset/data/\")\npseudo &lt;- grab_fasta(path = \"pseudomonas/ncbi_dataset/data/\")\nstaph &lt;- grab_fasta(path = \"staph_aureus/ncbi_dataset/data/\")\nentero &lt;- grab_fasta(path = \"enterobacter/ncbi_dataset/data/\")\nall &lt;- c(ecoli, kleb, pseudo, staph, entero)\n\nwriteXStringSet(all, \"mixed_bacteria.fasta\")\n\nsystem(\"barrnap --threads 90 mixed_bacteria.fasta &gt; mixed_bacteria.gff\")\n\ndf &lt;- read.gff(\"mixed_bacteria.gff\") |&gt; \n  as_tibble() |&gt;\n  filter(str_detect(attributes, \"16S\")) |&gt;\n  filter(strand == \"+\") |&gt;\n  distinct(seqid, .keep_all = T)\n\nall_sequences &lt;- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name &lt;- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly &lt;- all[str_detect(all |&gt; names(), name)]\n  seq_i &lt;- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences &lt;- c(all_sequences, seq_i)\n  print(i)\n}\n\nnew_name &lt;- c()\nfor (i in 1:length(all_sequences)) {\n  name &lt;- all_sequences[i] |&gt; names() |&gt; str_split(\" \")\n  new_name &lt;- c(new_name, paste0(name[[1]][1],\"_\",str_to_lower(name[[1]][2]),\"_\",name[[1]][3]))\n}\n\nnames(all_sequences) &lt;- new_name\n\nalignment &lt;- AlignSeqs(all_sequences)\n\ndistances &lt;- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\ntree &lt;- nj(distances)\n\ngenus_info &lt;- tibble(label = new_name) |&gt;\n  mutate(genus = case_when(  \n  str_detect(label, \"pseudomonas\") ~ 1,\n    str_detect(label, \"escherichia\") ~ 2,\n    str_detect(label, \"staph\") ~ 3,\n    str_detect(label, \"aerogen\") ~ 4,\n    TRUE ~ 5\n  ) |&gt; as.factor())\n\nggtree(tree, layout = \"circular\", branch.length = \"none\") %&lt;+% genus_info +\n  geom_tree(aes(color=genus)) +\n  geom_tiplab(aes(color=genus),size = 4) +\n  geom_nodelab(aes(color=genus)) +\n  theme(legend.position = \"none\")\n</pre></details>\n<h2 id=\"acknowledgement\">Acknowledgement\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#acknowledgement\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<p>I would like to thank Jonathan Ryder and Joseph Marcus for their assistance in choosing the best looking phylo tree as a feature for this blog! And also provided me the space to bounce off some ideas and theory of phylogenetic analysis. Much appreciated! üôå</p>\n<h2 id=\"opportunity\">Opportunities for improvement\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#opportunity\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<ul>\n<li>will perform a deeper dive on dynamic programming (alignment method)</li>\n<li>will perform a deeper dive on distance calculation</li>\n<li>to include both + and - strand from barrnap output, so not to miss out of some 16s extraction</li>\n<li>use more <code>ggtree</code>, I do see potential. Rendering is slow for large dataset though</li>\n<li>learn when to use appropriate layout for different questions to be answered</li>\n<li>maybe look into candida species with all the name changes, is it because of phlogeny? would it make more sense looking it through the lens of phylogeny?</li>\n<li>use this technique in simulated contact tracing (might use \n<a href=\"https://github.com/ArcInstitute/evo2\" rel=\"nofollow\" target=\"_blank\">evo2</a> for genome inferences)</li>\n<li>learn how close does a bacteria need to be wither another in terms of node to be considered as similar to each other. ?1 node ?2 nodes. \n<a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC10269621/\" rel=\"nofollow\" target=\"_blank\">read this</a></li>\n<li>Go through John Blishak‚Äôs <code>differential expression analysis with llama in R</code> course</li>\n<li>Will give \n<a href=\"https://bomeara.github.io/taxon2tree/\" rel=\"nofollow\" target=\"_blank\">taxon2tree by Brian O‚ÄôMeara</a> a try</li>\n</ul>\n<h2 id=\"lesson\">Lessons Learnt\n  <a href=\"https://www.kenkoonwong.com/blog/phylo/#lesson\" rel=\"nofollow\" target=\"_blank\"><svg aria-hidden=\"true\" class=\"anchor-symbol\" height=\"26\" viewbox=\"0 0 22 22\" width=\"26\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M0 0h24v24H0z\" fill=\"currentColor\"></path>\n<path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z\"></path>\n</svg></a>\n</h2>\n<ul>\n<li>learnt the basic workflow of phylogenetic analysis</li>\n<li>learnt and used <code>barrnap</code> an external tool for a quicker 16s rRNA extraction</li>\n<li>learnt and used <code>rapidnj</code> for neighbor joining for large dataset</li>\n<li>learnt and used <code>FigTree</code> for visualizing large phylogenetic tree. And it has a GUI!</li>\n<li>learnt a bit of <code>ggtree</code> to add colors to a phylo tree</li>\n<li>learnt to use <code>&lt;details&gt;&lt;summary&gt;click here&lt;/summary&gt;texts to hide by default&lt;/details&gt;</code> to hide code chunks to decluster!</li>\n</ul>\n<p>If you like this article:</p>\n<ul>\n<li>please feel free to send me a \n<a href=\"https://www.kenkoonwong.com/blog/\" rel=\"nofollow\" target=\"_blank\">comment or visit my other blogs</a></li>\n<li>please feel free to follow me on \n<a href=\"https://bsky.app/profile/kenkoonwong.bsky.social\" rel=\"nofollow\" target=\"_blank\">BlueSky</a>, \n<a href=\"https://twitter.com/kenkoonwong/\" rel=\"nofollow\" target=\"_blank\">twitter</a>, \n<a href=\"https://github.com/kenkoonwong/\" rel=\"nofollow\" target=\"_blank\">GitHub</a> or \n<a href=\"https://med-mastodon.com/@kenkoonwong\" rel=\"nofollow\" target=\"_blank\">Mastodon</a></li>\n<li>if you would like collaborate please feel free to \n<a href=\"https://www.kenkoonwong.com/contact/\" rel=\"nofollow\" target=\"_blank\">contact me</a></li>\n</ul>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.kenkoonwong.com/blog/phylo/\"> r on Everyday Is A School Day</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Learning The Basics of Phylogenetic Analysis\nPosted on\nAugust 30, 2025\nby\nr on Everyday Is A School Day\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nr on Everyday Is A School Day\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nüß¨üî¨ Explore phylogenetic analysis from genome to tree! Basic workflow with R/Bioconductor. Learnt to work with large genomic dataset. Extract 16S rRNA from 10K+ E.coli strains using dataset dehydrate, barrnap for extraction, rapidNJ for tree building & FigTree for visualization.\nMovitation:\nAfter that\nlast hands-on experience on Bioconductor\n, we will continue our journey in phylogenetic analysis. I‚Äôve always been intrigued in how biologists piece these phylogenetic tree together and I want to know the big idea of how this is done. We‚Äôll again be using Bioconductor. Let‚Äôs go!\nDisclaimer:\nI am not a bioinformatician and do not work with genes directly, the articles and method presented is my attempt to get a birds eye view on how we went from different isolates to piecing them together onto a single tree. Please take this with a grain of salt. Verify the information presented. If you noted some error in this article, please let me know so that I can learn! Also, some of the analysis results were not run during rmarkdown knitting because that causes a significant delay, however, the results posted here should be reprodicuble. Please again let me know if they are not\nThe End Goal:\nGet a basic workflow of how this is done\nAssess Many Many Ecoli strains\nAssess Different Genus on a single tree\nLooks quite doable! Along the line, we may have some deeper dive to look at the machinery behind. Ultimately, we want to visualize beuatiful trees! üå¥ Like this.\nObjectives:\nWhat is phylogenetic analysis?\nThe workflow\nExtract 16S rRna\nAlign\nDistance Calculation\nTree construction\nVisualizing Phylogenetic tree\nEcoli Large Dataset\nOther Genus\nOpportunities for improvement\nLessons Learnt\nWhat is phylogenetic analysis?\nPhylogenetic analysis is a method used to study the evolutionary relationships between organisms. It involves comparing genetic sequences, such as DNA or RNA, to infer how species are related through common ancestry. This analysis can help identify how different organisms have evolved over time and can be particularly useful in\ncontact tracing, outbreak assessment\n.\nHere is a quick wiki\nLet‚Äôs Download ALL Ecoli Fasta\nOne of our\nprevious opportunity improvement\nis to learn to use\nNCBI dataset CLI\n. We‚Äôll be using that this time because if you try to download more than 10,000 of fasta via website or event the CLI itself, it won‚Äôt be as smooth, at least from my multiple tries. I‚Äôve attempted maybe 5-6 times and couldn‚Äôt complete the download even when I used\ndatasets\nand unable to resume downloads. However, the most stable is actually to\ndownload dehydrated\nthen\nrehydrate\n.\nSee here\nTerminal\ncurl -o datasets 'https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/v2/mac/datasets'\nchmod +x datasets dataformat\ndatasets download genome taxon \"Escherichia coli\" \\\n  --assembly-level scaffold,chromosome,complete \\\n  --dehydrated \\\n  --filename ecoli_high_quality_dehydrated.zip\nunzip ecoli_genomes_dehydrated.zip \ncd ncbi_dataset\ndatasets rehydrate --directory\nFor large genome downloads, use\ndatasets dehydrated\nthen\nrehydrate\n. It‚Äôs easier to resume download if connection got lost.\nYou notice above that we left off\ncontig\nand just included scaffold, chromosome, and complete? That‚Äôs because there were 300,000 sequences if we include all of them. I definitely don‚Äôt need all of those packages. With scaffold, chromosome, and complete, we got 30,000+ and the entire zip file was\n58 gigs\nof data. üòµ‚Äçüí´\nJust for my education:\nContig\n‚Äì Short for ‚Äúcontiguous sequence.‚Äù This is a continuous stretch of DNA sequence with no gaps. Contigs are assembled from overlapping sequencing reads, but they represent isolated pieces without known relationships to other contigs.\nScaffold\n‚Äì A collection of contigs that have been ordered and oriented relative to each other, often with gaps of estimated size between them. Scaffolding uses additional information like paired-end reads or mate-pair libraries to determine how contigs should be arranged, even when the sequence connecting them isn‚Äôt fully resolved.\nChromosome\n‚Äì Contigs and scaffolds have been assembled into chromosome-scale sequences that represent entire chromosomes. This typically requires additional long-range information like Hi-C data, optical mapping, or long-read sequencing to achieve proper chromosome-level organization.\nComplete\n‚Äì The highest level of assembly where the entire genome is finished with no gaps, including challenging repetitive regions, centromeres, and telomeres. This represents a truly complete, end-to-end sequence of all chromosomes.\nThe Workflow\nThe workflow for phylogenetic analysis typically involves several key steps:\nExtract 16s rRNA -> Align -> Calculate Distance -> Construct Tree\nExtract 16S rRNA\nThis step involves obtaining the genetic material from the organisms of interest, such as bacteria or viruses. For example, in the case of antibiotic resistance, researchers might extract the 16S rRNA gene, which is commonly used for bacterial identification. The reason for extracting 16S rRNA in bacteria is beccause the sequence are highly conserved across different species, making it a reliable marker for phylogenetic analysis. The 16S rRNA gene is present in all bacteria and archaea, and its sequence can provide insights into the evolutionary relationships between different microbial species. Let‚Äôs dive into the code to do this. We‚Äôll use the same 2 groups we used before, regular Ecoli and ESBL Ecoli\nfrom before\nlibrary(Biostrings)\nlibrary(DECIPHER)\n\n# load data\npath1 <- \"/path/to/your/first/ecoli/data\"\n\nnon_esbl_ecoli_files <- list.files(path1, pattern = \"*.fna\", recursive = T)\nnon_esbl_ecoli <- DNAStringSet()\nfor (i in non_esbl_ecoli_files) {\n  seq_i <- readDNAStringSet(paste0(path1,i))[1]\n  non_esbl_ecoli <- c(non_esbl_ecoli,seq_i)\n}\n\npath2 <- \"/path/to/your/second/ecoli/data\"\nesbl_ecoli_files <- list.files(path2, pattern = \"*.fna\", recursive = T)\nesbl_ecoli <- DNAStringSet()\nfor (i in esbl_ecoli_files) {\n  seq_i <- readDNAStringSet(paste0(path2,i))[1]\n  esbl_ecoli <- c(esbl_ecoli,seq_i)\n}\n\nall_ecoli <- c(non_esbl_ecoli, esbl_ecoli)\n\n# extract 16s\ndata(\"NonCodingRNA_Bacteria\")\nx <- NonCodingRNA_Bacteria$`rRNA_16S-RF00177`\nall_ecoli[1]\nrrna <- FindNonCoding(x = x, myXStringSet = all_ecoli[1:5], verbose = T) \nrrna\nThe reason I only used\nall_ecoli[1:5]\nis because it‚Äôs EXTREMELY slow to extract 16s with\nDECIPHER\n. Later on we‚Äôll use an external tool called\nbarrnap\nto extract our 10k contigs seemlessly. Let‚Äôs continue.\n(extract <- ExtractGenes(x = rrna, myDNAStringSet = all_ecoli[1:5]))\nLook at that beauty! Because\nDECIPHER\nextracted multiple\n16s\nsequences, hence we see there are 35 rows of data, even though we‚Äôre only using 5 strains of Ecoli. Since we‚Äôre having trouble with extracting 16s with DECIPHER, speed being the issue, let‚Äôs try\nbarrnap\n! To install is,\ncheck out their github\nTerminal\nbrew install brewsci/bio/barrnap\nBack to R\nwriteXStringSet(all_ecoli, filepath = \"40_ecoli.fasta\")\nsystem(\"barrnap --threads 90 40_ecoli.fasta > 40_ecoli_16s.gff\")\n\nlibrary(ape)\n(df <- read.gff(\"40_ecoli_16s\"))\nAlright, let‚Äôs turn this into a dataframe, extract 16s only, and choose the first one with\n+\nand we‚Äôll have our 16s! Take note that there is a column called\nscore\n, it is\nevalue\n, the lower (closer to zero) the better. These all look pretty good. Remember, the tool only tells you where the positions are, you have to go back to your genome and extract those. Let‚Äôs go!\nlibrary(tidyverse)\n\ndf <- df |>\n  as_tibble() |>\n  filter(str_detect(attributes, \"16S\")) |>\n  filter(strand == \"+\") |>\n  distinct(seqid, .keep_all = T)\n\nall_sequences <- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name <- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly <- all_ecoli[str_detect(all_ecoli |> names(), name)]\n  seq_i <- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences <- c(all_sequences, seq_i)\n}\n\nall_sequences\nAgain, what a beauty! These sequences look quite conversed, don‚Äôt they? Take note that a 16s rRNA sequence is about 1538 base pairs, there is one on the glance that is only 1537. This is going to be a problem if we‚Äôre trying to calculate distance. Hence,\nalign\nis crucial to ensure they all have the same length of sequence.\nBarrnap is truly an efficient tool to extract 16s positions from bacteria! The ‚Äìthreads option is awesome if you have lots of cpu to spare! This is will very helpful when we have to extract 10k sequences\nAlign\nAlignment is a crucial step in phylogenetic analysis as it ensures that the sequences being compared are of the same length and that homologous positions are aligned correctly. This is important because differences in sequence length or misaligned positions can lead to inaccurate distance calculations and, consequently, incorrect phylogenetic trees. By aligning sequences, we can accurately identify conserved regions, mutations, insertions, and deletions, which are essential for inferring evolutionary relationships. Let‚Äôs align our 16s sequences using\nDECIPHER\nalignment <- AlignSeqs(all_sequences, verbose = TRUE)\nalignment[36] |> as.character()\nRemember that one contig that we saw previously with 1 missing nucleotide?\nDECIPHER\nbasically adds a\n-\nto the missing position. The method behind this is very interesting! We will take a deep dive next time. But it uses\ndynamic programming\nto find the optimal alignment by minimizing the number of mismatches and gaps. It constructs a scoring matrix based on matches, mismatches, and gap penalties, then traces back through the matrix to determine the best alignment path. This\ndynamic programming\nactually is a different\ndynamic programming\nthan the one used in reinforcement learning, I think.\nDistance Calculation\nDistance calculation is a crucial step in making sense of all these 16s rRNA sequences.By calculating distances, we can determine how closely related different organisms are, which is essential for constructing accurate phylogenetic trees. Various methods exist for distance calculation, such as p-distance (proportion of differing sites), Jukes-Cantor, and Kimura models, each accounting for different aspects of sequence evolution. Let‚Äôs use\nJukes-Cantor\ndistances <- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n## This is just to show the matrix without names\ndist <- as.matrix(distances)\nrownames(dist) <- NULL\ncolnames(dist) <- NULL\ndist\nnotice that [1,1], [2,2] ‚Ä¶ are 0 because they are essentially comparing themselves. These methods are really intriguing. Can‚Äôt say I understood all of them but maybe one day we‚Äôll take a deeper dive into these algorithms and its math behind them! Can‚Äôt wait! On to the next, tree construction!\nTree construction\ntree <- nj(distances)\nHere, we basically used neighbor joining to construct our tree. Neighbor-joining is a distance-based method for constructing phylogenetic trees that focuses on minimizing the total branch length of the tree. It starts with a star-like structure and iteratively joins pairs of taxa (or nodes) that minimize the overall distance, effectively grouping closely related organisms together.\nTake note that this function from\nape\nwill not work well when it‚Äôs a large dataset. It will be VERY slow! We will instead use\nRapidNJ\nfor that. An external tool but, wow the speed! Within seconds!\nIf you are using Mac M1/2 and want to use advantage of Mac M1/2 architecture, you can compile rapidNJ from source but from\nJohn Lees\n:\ngit clone https://github.com/johnlees/rapidNJ-M1.git\ncd rapidNJ-M1\nmake -j\nExample on how to use for large dataset\nlibrary(phangorn)\n\ndist <- as.matrix(distances)\nnames_list <- dist |> rownames() |> str_split(pattern = \" \") \nnames <- c()\nfor (i in 1:length(names_list)) {\n  names <- c(names, names_list[[i]][1])\n}\n\nrownames(dist) <- names\ncolnames(dist) <- names\nphangorn::writeDist(dist, file = \"all_ecoli_phylip\", format = \"phylip\")\nsystem(\"rapidnj -i pd all_ecoli_phylip > all_ecoli_tree.newick\")\nTurn your\ndist\nformat into matrix, remove any spaces on your matrix row and column names, write a\nphylip\nfile then use\nrapidNJ\nto build tree.\nThere may be times where there are\nNA\ns on our matrix. We can use the function below to impute number to make sure we don‚Äôt have\nNA\ns. I‚Äôm actually not sure if rapidNJ can handle NAs, I know\nape::njs\ncan but it will again be very slow for large datasets.\nMean Imputation for NAs if Exists\nimpute_mean_distance <- function(dist_matrix) {\n  mat <- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist <- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] <- mean_dist\n  \n  return(mat)\n}\n\n# Apply mean imputation\ndist_imputed_mean <- impute_mean_distance(dist_mat)\nVisualizing Phylogenetic tree\nplot(tree, \n     main = \"E. coli 16S rRNA Phylogenetic Tree\",\n     sub = paste(\"Based on\", length(tree$tip.label), \"16S sequences\"),\n     cex = 0.8,\n     edge.width = 2)\nI marked red boxes on the ESBL strains to see if it shows much insight. Not really. I was hoping to see some of the ESBL Ecoli are in the same clade but it doesn‚Äôt seem like it. Maybe because we only used 40 strains. Technically, these ESBLs are controlled by plasmids, I suspect the chromosome sequence shouldn‚Äôt really matter much, which means we should see clustering between both ESBLs and non-ESBLs.\nThe interpretation of the tree is essentially pay attention to the nodes, not the distances between each strains. The nodes represents a latent ancestor. The closer the nodes, the more related they are. Reminds me of a latent variable. If we want to compare between 2 strains, we basically count how many nodes are between their relationships.\nData Integration, Manipulation and Visualization of Phylogenetic Trees\nhas a very good chapter on viualizing tree using\nggtree\n, it‚Äôs REALLY neat!\nAgain, if we have large dataset, we need to use something else.\nplot\nitself is pretty fast, but not ggtree. We‚Äôll use external tool again called\nFigTree\nto plot our large tree. It‚Äôs faster and easier to navigate with a GUI, but will need java.\nEcoli Large Dataset\nclick to expand code\n########## asessing all ecoli\nlibrary(Biostrings)\nlibrary(tidyverse)\nlibrary(ape)\nlibrary(DECIPHER)\n\npath <- \"path/to/your/ecoli/data\"\nfiles <- list.files(path = path, pattern = \"*.fna\", recursive = T)\n\nall_ecoli <- DNAStringSet()\nfor (i in files) {\n  dna_i <- readDNAStringSet(paste0(path,i))[1]\n  all_ecoli <- c(all_ecoli,dna_i)\n}\n\n# save it since it took sometime to read all\nwriteXStringSet(all_ecoli, filepath = \"all_ecoli.fasta\")\n\n# load it if working in subsequent sessions\nall_ecoli <- readDNAStringSet(\"all_ecoli.fasta\")\n\n# extract 16s\nsystem(\"barrnap --threads 90 all_ecoli.fasta > all_ecoli_16s.gff\")\n\n# use position to get our 16s sequence\ndf <- read.gff(\"all_ecoli_16s.gff\") |> \n  as_tibble() |>\n  filter(str_detect(attributes, \"16S\")) |>\n  filter(strand == \"+\") |>\n  distinct(seqid, .keep_all = T)\n\nall_sequences <- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name <- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly <- all_ecoli[str_detect(all_ecoli |> names(), name)]\n  seq_i <- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences <- c(all_sequences, seq_i)\n  print(i)\n}\n\n# align\nalignment <- AlignSeqs(all_sequences, verbose = TRUE)\n\n# Save alignment\nwriteXStringSet(alignment, \"all_ecoli_16s_alignment.fasta\")\n\n# load it (when returning from a new session)\nalignment <- readDNAStringSet(\"all_ecoli_16s_alignment.fasta\")\n\n# Calculate distances\ndistances <- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n# save \nsave(distances, file = \"all_ecoli_distance.rda\")\n\n# load it (when returning from a new session)\nload(\"all_ecoli_distance.rda\")\ndist_mat <- as.matrix(distances)\n\n# impute NA\nimpute_mean_distance <- function(dist_matrix) {\n  mat <- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist <- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] <- mean_dist\n  \n  return(mat)\n}\n\n# Apply mean imputation\ndist_imputed_mean <- impute_mean_distance(dist_mat)\n\n# converting to philip\ndist_final <- dist_imputed_mean\n\n### using phangorn for phylip\nlibrary(phangorn)\n\n# rapidnj cannot handle spaces\nnames_list <- dist_final |> rownames() |> str_split(pattern = \" \") \nnames <- c()\nfor (i in 1:length(names_list)) {\n  names <- c(names, names_list[[i]][1])\n}\n\nrownames(dist_final) <- names\ncolnames(dist_final) <- names\nphangorn::writeDist(dist_final, file = \"all_ecoli_phylip\", format = \"phylip\")\n\n# build tree w rapidnj\nsystem(\"rapidnj -i pd all_ecoli_phylip > all_ecoli_tree.newick\")\n\n# read tree\nlibrary(ape)\ntree <- read.tree(\"all_ecoli_tree.newick\")\n\n# Remove long branches\nthreshold <- 0.0001\nsampled_tree$edge.length <- ifelse(sampled_tree$edge.length > threshold, threshold, sampled_tree$edge.length)\n\n# set negative value to 0\nsampled_tree$edge.length <- ifelse(sampled_tree$edge.length < 0, 0, sampled_tree$edge.length)\n\nplot(sampled_tree,\n     type = \"fan\",\n     main = paste(length(sampled_tree$tip.label),\" E. coli 16S rRNA Phylogenetic Tree\"),\n     cex = 0.1,\n     edge.width = 1,\n     show.tip.label = F)\n\nwrite.tree(sampled_tree, file = \"modified_ecol.newick\")\nThis is the default\nplot\nfunction. Efficient but needs some improvement.\nNow, if we use\nFigTree\n, we can make into something like we saw upfront.\nTo be quite frank. This looks quite pretty, but it doesn‚Äôt really give me much information other than certain ecoli strains have clades and some clusters together. But without the names, we can‚Äôt really say much and to put all these 10k+ names on the plot is just a group of meaningless mess. What if we sample these contigs, and revisit our topic of whether esbl and non-esbl tend to have their own clade or it doesn‚Äôt matter because it‚Äôs blaCTX-M, blaSHV, blaTEM are on plasmids, not chromosomes like what we‚Äôre trying to assess here.\nLet‚Äôs dive a bit deeper. Let‚Äôs only show the tip label of the ESBLs in red and see if there is a cluster of them.\nclick to expand code\nalignment <- readDNAStringSet(\"all_ecoli_16s_alignment.fasta\")\n\nsample_alignment <- alignment\n  \nesbl_index <- names(sample_alignment) |> str_detect(\"ESBL|esbl\") |> which()\nname_list <- c()\nfor (i in 1:length(sample_alignment)) {\n  seq <- sample_alignment[i] |> names() |> str_split(\" \")\n  if (i %in% esbl_index) {\n    name <- paste0(seq[[1]][1],\"-ESBL\")\n  } else {\n  name <- seq[[1]][1]\n  }\n  name_list <- c(name_list, name)\n}\n\nnames(sample_alignment) <- name_list\n\ndistances <- DistanceMatrix(sample_alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\n\n# tree <- nj(distances)\ndist_mat <- as.matrix(distances)\n\n# impute NA\nimpute_mean_distance <- function(dist_matrix) {\n  mat <- as.matrix(dist_matrix)\n  \n  # Calculate mean excluding NAs\n  mean_dist <- mean(mat, na.rm = TRUE)\n  \n  # Replace NAs with mean\n  mat[is.na(mat)] <- mean_dist\n  \n  return(mat)\n}\n\n# Apply mean imputation\ndist_imputed_mean <- impute_mean_distance(dist_mat)\n\n# converting to philip\ndist_final <- dist_imputed_mean\n\n### using phangorn for phylip\nlibrary(phangorn)\nphangorn::writeDist(dist_final, file = \"all_ecoli_phylip_2\", format = \"phylip\")\n\n# build tree w rapidnj\nsystem(\"rapidnj -i pd all_ecoli_phylip_2 > all_ecoli_tree_2.newick\")\n\ntree <- read.tree(\"all_ecoli_tree_2.newick\")\n\ntree$edge.length |> summary()\nthreshold <- 0.0001\ntree$edge.length <- ifelse(tree$edge.length > threshold, threshold, tree$edge.length)\n\n# set neg to 0\ntree$edge.length <- ifelse(tree$edge.length < 0, 0, tree$edge.length)\n\nplot(tree,\n     main = \"E. coli 16S rRNA Phylogenetic Tree\",\n     sub = paste(\"Based on\", length(tree$tip.label), \"16S sequences\"),\n     cex = 1,\n     edge.width = 2)\n\nlibrary(ggtree)\n\n# Assuming your tree object is called 'tree'\np <- ggtree(tree, layout = \"circular\") +\n  geom_tiplab(aes(label = ifelse(grepl(\"ESBL\", label), label, \"\")), \n              color = \"red\",\n              size = 2)\np\n\nesbl_parent_node <- tree$tip.label[tree$edge[,2]] |> str_detect(\"ESBL\") |> which()\n\ndf_esbl_parent <- tibble(parent_node=as.numeric(),isolate=as.character())\nfor (i in esbl_parent_node) {\n  idx_parent_node <- tree$edge[i,1]\n  isolate <- tree$edge[tree$edge[,1] == idx_parent_node, 2]\n  df_esbl_parent <- df_esbl_parent |>\n    bind_rows(tibble(parent_node=idx_parent_node,isolate=tree$tip.label[isolate]))\n  print(tree$tip.label[isolate])\n}\n\ndf_esbl_parent <- df_esbl_parent |>\n  distinct()\n\ndf_table <- df_esbl_parent |>\n  group_by(parent_node) |>\n  mutate(esbl = case_when(\n    str_detect(isolate, \"ESBL\") ~ 2,\n    is.na(isolate) ~ 0,\n    TRUE ~ 1\n  )) |>\n  summarize(sum = sum(esbl)) \n\ndf_table |>\n  select(sum) |>\n  mutate(name = case_when(\n    sum == 4 ~ \"ESBL_ESBL\",\n    sum == 3 ~ \"ESBL_nonESBL\",\n    sum == 2 ~ \"ESBL_NA\"\n  )) |>\n  select(name) |>\n  group_by(name) |>\n  summarize(n = n()) |>\n  mutate(prop = n/sum(n))\nDoesn‚Äôt seem like it. If ESBL strains were to have come later, or branched off from a specific ancestry, we should be seeing a more clustered branch, but it seems to be more wide spread across the tree.\nLet‚Äôs take a deeper dive on looking at the tree data itself. If ESBL strains are more clustered together, we should be seeing more ESBL strains to have the same parent node (latent) than an ESBL strain with a non-ESBL strain.\nThis shows that 33% of the ESBL strains have a non-ESBL strain that share its parent. Whereas 23.8% of ESBL strains share a parent with another ESBL strain. And 42.9% have parents with latent child (meaning another latent strain which we don‚Äôt know whether it‚Äôs ESBL or non-ESBL that bracnhed off to another phyla).\nThe code to generate the\nggtree\nplot and proportion table is available on github.\nOther Genus\nNow, what if we include other genus of bacteria into a single tree? Let‚Äôs grab\nklebsiella aerogenes\n,\npseudomonas aureginosa\n,\nenterobacter spp\n,\nstaph aureus\n, and we‚Äôll sample our existing\nescherichia coli\nand see if they would be in different branches? In theory they should be!\nLooking at a glance, their 16s rRNA sequence look different too among different genus! If you still remember,\npreviously\nour Ecoli 16s rRNA were quite similar.\nNow let‚Äôs plot the phylogenetic tree\nWow, they do cluster close to each other! That is really cool! It also looks like complete seperation! that‚Äôs amazing!\nclick to expand code\n#### assessing other genus\necoli <- sample(all_ecoli,10)\n\n## create function\ngrab_fasta <- function(path) {\n  files <- list.files(path = path, pattern = \"*.fna\", recursive = T)\n  seq <- DNAStringSet()\n  for (i in files) {\n    dna_i <- readDNAStringSet(paste0(path,i))[1]\n    seq <- c(seq,dna_i)\n  }\n  return(seq)\n}\n\nkleb <- grab_fasta(path = \"kleb_aerogene/ncbi_dataset/data/\")\npseudo <- grab_fasta(path = \"pseudomonas/ncbi_dataset/data/\")\nstaph <- grab_fasta(path = \"staph_aureus/ncbi_dataset/data/\")\nentero <- grab_fasta(path = \"enterobacter/ncbi_dataset/data/\")\nall <- c(ecoli, kleb, pseudo, staph, entero)\n\nwriteXStringSet(all, \"mixed_bacteria.fasta\")\n\nsystem(\"barrnap --threads 90 mixed_bacteria.fasta > mixed_bacteria.gff\")\n\ndf <- read.gff(\"mixed_bacteria.gff\") |> \n  as_tibble() |>\n  filter(str_detect(attributes, \"16S\")) |>\n  filter(strand == \"+\") |>\n  distinct(seqid, .keep_all = T)\n\nall_sequences <- DNAStringSet()\nfor (i in 1:nrow(df)) {\n  name <- paste0(\"^\",df[[i, \"seqid\"]]) \n  assembly <- all[str_detect(all |> names(), name)]\n  seq_i <- subseq(assembly, start = df[[i, \"start\"]], end = df[[i, \"end\"]])\n  all_sequences <- c(all_sequences, seq_i)\n  print(i)\n}\n\nnew_name <- c()\nfor (i in 1:length(all_sequences)) {\n  name <- all_sequences[i] |> names() |> str_split(\" \")\n  new_name <- c(new_name, paste0(name[[1]][1],\"_\",str_to_lower(name[[1]][2]),\"_\",name[[1]][3]))\n}\n\nnames(all_sequences) <- new_name\n\nalignment <- AlignSeqs(all_sequences)\n\ndistances <- DistanceMatrix(alignment, \n                            correction = \"Jukes-Cantor\",\n                            type = \"dist\", \n                            verbose = TRUE)\ntree <- nj(distances)\n\ngenus_info <- tibble(label = new_name) |>\n  mutate(genus = case_when(  \n  str_detect(label, \"pseudomonas\") ~ 1,\n    str_detect(label, \"escherichia\") ~ 2,\n    str_detect(label, \"staph\") ~ 3,\n    str_detect(label, \"aerogen\") ~ 4,\n    TRUE ~ 5\n  ) |> as.factor())\n\nggtree(tree, layout = \"circular\", branch.length = \"none\") %<+% genus_info +\n  geom_tree(aes(color=genus)) +\n  geom_tiplab(aes(color=genus),size = 4) +\n  geom_nodelab(aes(color=genus)) +\n  theme(legend.position = \"none\")\nAcknowledgement\nI would like to thank Jonathan Ryder and Joseph Marcus for their assistance in choosing the best looking phylo tree as a feature for this blog! And also provided me the space to bounce off some ideas and theory of phylogenetic analysis. Much appreciated! üôå\nOpportunities for improvement\nwill perform a deeper dive on dynamic programming (alignment method)\nwill perform a deeper dive on distance calculation\nto include both + and - strand from barrnap output, so not to miss out of some 16s extraction\nuse more\nggtree\n, I do see potential. Rendering is slow for large dataset though\nlearn when to use appropriate layout for different questions to be answered\nmaybe look into candida species with all the name changes, is it because of phlogeny? would it make more sense looking it through the lens of phylogeny?\nuse this technique in simulated contact tracing (might use\nevo2\nfor genome inferences)\nlearn how close does a bacteria need to be wither another in terms of node to be considered as similar to each other. ?1 node ?2 nodes.\nread this\nGo through John Blishak‚Äôs\ndifferential expression analysis with llama in R\ncourse\nWill give\ntaxon2tree by Brian O‚ÄôMeara\na try\nLessons Learnt\nlearnt the basic workflow of phylogenetic analysis\nlearnt and used\nbarrnap\nan external tool for a quicker 16s rRNA extraction\nlearnt and used\nrapidnj\nfor neighbor joining for large dataset\nlearnt and used\nFigTree\nfor visualizing large phylogenetic tree. And it has a GUI!\nlearnt a bit of\nggtree\nto add colors to a phylo tree\nlearnt to use\n<details><summary>click here</summary>texts to hide by default</details>\nto hide code chunks to decluster!\nIf you like this article:\nplease feel free to send me a\ncomment or visit my other blogs\nplease feel free to follow me on\nBlueSky\n,\ntwitter\n,\nGitHub\nor\nMastodon\nif you would like collaborate please feel free to\ncontact me\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nr on Everyday Is A School Day\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "üß¨üî¨ Explore phylogenetic analysis from genome to tree! Basic workflow with R/Bioconductor. Learnt to work with large genomic dataset. Extract 16S rRNA from 10K+ E.coli strains using dataset dehydrate, barrnap for extraction, rapidNJ for tree building & FigTree for visualization. Movitation: After that last hands-on experience on Bioconductor, we will continue our journey in phylogenetic analysis. I‚Äôve always been intrigued in how biologists piece these phylogenetic tree together and I want to know the big idea of how this is done. We‚Äôll again be using Bioconductor. Let‚Äôs go! Disclaimer: I am not a bioinformatician and do not work with genes directly, the articles and method presented is my attempt to get a birds eye view on how we went from different isolates to piecing them together onto a single tree. Please take this with a grain of salt. Verify the information presented. If you noted some error in this article, please let me know so that I can learn! Also, some of the analysis results were not run during rmarkdown knitting because that causes a significant delay, however, the results posted here should be reprodicuble. Please again let me know if they are not The End Goal: Get a basic workflow of how this is done Assess Many Many Ecoli strains Assess Different Genus on a single tree Looks quite doable! Along the line, we may have some deeper dive to look at the machinery behind. Ultimately, we want to visualize beuatiful trees! üå¥ Like this. Objectives: What is phylogenetic analysis? The workflow Extract 16S rRna Align Distance Calculation Tree construction Visualizing Phylogenetic tree Ecoli Large Dataset Other Genus Opportunities for improvement Lessons Learnt What is phylogenetic analysis? Phylogenetic analysis is a method used to study the evolutionary relationships between organisms. It involves comparing genetic sequences, such as DNA or RNA, to infer how species are related through common ancestry. This analysis can help identify how different organisms have evolved over time and can be particularly useful in contact tracing, outbreak assessment. Here is a quick wiki Let‚Äôs Download ALL Ecoli Fasta One of our previous opportunity improvement is to learn to use NCBI dataset CLI. We‚Äôll be using that this time because if you try to download more than 10,000 of fasta via website or event the CLI itself, it won‚Äôt be as smooth, at least from my multiple tries. I‚Äôve attempted maybe 5-6 times and couldn‚Äôt complete the download even when I used datasets and unable to resume downloads. However, the most stable is actually to download dehydrated then rehydrate. See here Terminal curl -o datasets 'https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/v2/mac/datasets' chmod +x datasets dataformat datasets download genome taxon \"Escherichia coli\" \\ --assembly-level scaffold,chromosome,complete \\ --dehydrated \\ --filename ecoli_high_quality_dehydrated.zip unzip ecoli_genomes_dehydrated.zip cd ncbi_dataset datasets rehydrate --directory For large genome downloads, use datasets dehydrated then rehydrate. It‚Äôs easier to resume download if connection got lost. You notice above that we left off contig and just included scaffold, chromosome, and complete? That‚Äôs because there were 300,000 sequences if we include all of them. I definitely don‚Äôt need all of those packages. With scaffold, chromosome, and complete, we got 30,000+ and the entire zip file was 58 gigs of data. üòµ‚Äçüí´ Just for my education: Contig - Short for ‚Äúcontiguous sequence.‚Äù This is a continuous stretch of DNA sequence with no gaps. Contigs are assembled from overlapping sequencing reads, but they represent isolated pieces without known relationships to other contigs. Scaffold - A collection of contigs that have been ordered and oriented relative to each other, often with gaps of estimated size between them. Scaffolding uses additional information like paired-end reads or mate-pair libraries to determine how contigs should be arranged, even when the sequence connecting them isn‚Äôt fully resolved. Chromosome - Contigs and scaffolds have been assembled into chromosome-scale sequences that represent entire chromosomes. This typically requires additional long-range information like Hi-C data, optical mapping, or long-read sequencing to achieve proper chromosome-level organization. Complete - The highest level of assembly where the entire genome is finished with no gaps, including challenging repetitive regions, centromeres, and telomeres. This represents a truly complete, end-to-end sequence of all chromosomes. The Workflow The workflow for phylogenetic analysis typically involves several key steps: Extract 16s rRNA -> Align -> Calculate Distance -> Construct Tree Extract 16S rRNA This step involves obtaining the genetic material from the organisms of interest, such as bacteria or viruses. For example, in the case of antibiotic resistance, researchers might extract the 16S rRNA gene, which is commonly used for bacterial identification. The reason for extracting 16S rRNA in bacteria is beccause the sequence are highly conserved across different species, making it a reliable marker for phylogenetic analysis. The 16S rRNA gene is present in all bacteria and archaea, and its sequence can provide insights into the evolutionary relationships between different microbial species. Let‚Äôs dive into the code to do this. We‚Äôll use the same 2 groups we used before, regular Ecoli and ESBL Ecoli from before library(Biostrings) library(DECIPHER) # load data path1",
    "meta_keywords": null,
    "og_description": "üß¨üî¨ Explore phylogenetic analysis from genome to tree! Basic workflow with R/Bioconductor. Learnt to work with large genomic dataset. Extract 16S rRNA from 10K+ E.coli strains using dataset dehydrate, barrnap for extraction, rapidNJ for tree building & FigTree for visualization. Movitation: After that last hands-on experience on Bioconductor, we will continue our journey in phylogenetic analysis. I‚Äôve always been intrigued in how biologists piece these phylogenetic tree together and I want to know the big idea of how this is done. We‚Äôll again be using Bioconductor. Let‚Äôs go! Disclaimer: I am not a bioinformatician and do not work with genes directly, the articles and method presented is my attempt to get a birds eye view on how we went from different isolates to piecing them together onto a single tree. Please take this with a grain of salt. Verify the information presented. If you noted some error in this article, please let me know so that I can learn! Also, some of the analysis results were not run during rmarkdown knitting because that causes a significant delay, however, the results posted here should be reprodicuble. Please again let me know if they are not The End Goal: Get a basic workflow of how this is done Assess Many Many Ecoli strains Assess Different Genus on a single tree Looks quite doable! Along the line, we may have some deeper dive to look at the machinery behind. Ultimately, we want to visualize beuatiful trees! üå¥ Like this. Objectives: What is phylogenetic analysis? The workflow Extract 16S rRna Align Distance Calculation Tree construction Visualizing Phylogenetic tree Ecoli Large Dataset Other Genus Opportunities for improvement Lessons Learnt What is phylogenetic analysis? Phylogenetic analysis is a method used to study the evolutionary relationships between organisms. It involves comparing genetic sequences, such as DNA or RNA, to infer how species are related through common ancestry. This analysis can help identify how different organisms have evolved over time and can be particularly useful in contact tracing, outbreak assessment. Here is a quick wiki Let‚Äôs Download ALL Ecoli Fasta One of our previous opportunity improvement is to learn to use NCBI dataset CLI. We‚Äôll be using that this time because if you try to download more than 10,000 of fasta via website or event the CLI itself, it won‚Äôt be as smooth, at least from my multiple tries. I‚Äôve attempted maybe 5-6 times and couldn‚Äôt complete the download even when I used datasets and unable to resume downloads. However, the most stable is actually to download dehydrated then rehydrate. See here Terminal curl -o datasets 'https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/v2/mac/datasets' chmod +x datasets dataformat datasets download genome taxon \"Escherichia coli\" \\ --assembly-level scaffold,chromosome,complete \\ --dehydrated \\ --filename ecoli_high_quality_dehydrated.zip unzip ecoli_genomes_dehydrated.zip cd ncbi_dataset datasets rehydrate --directory For large genome downloads, use datasets dehydrated then rehydrate. It‚Äôs easier to resume download if connection got lost. You notice above that we left off contig and just included scaffold, chromosome, and complete? That‚Äôs because there were 300,000 sequences if we include all of them. I definitely don‚Äôt need all of those packages. With scaffold, chromosome, and complete, we got 30,000+ and the entire zip file was 58 gigs of data. üòµ‚Äçüí´ Just for my education: Contig - Short for ‚Äúcontiguous sequence.‚Äù This is a continuous stretch of DNA sequence with no gaps. Contigs are assembled from overlapping sequencing reads, but they represent isolated pieces without known relationships to other contigs. Scaffold - A collection of contigs that have been ordered and oriented relative to each other, often with gaps of estimated size between them. Scaffolding uses additional information like paired-end reads or mate-pair libraries to determine how contigs should be arranged, even when the sequence connecting them isn‚Äôt fully resolved. Chromosome - Contigs and scaffolds have been assembled into chromosome-scale sequences that represent entire chromosomes. This typically requires additional long-range information like Hi-C data, optical mapping, or long-read sequencing to achieve proper chromosome-level organization. Complete - The highest level of assembly where the entire genome is finished with no gaps, including challenging repetitive regions, centromeres, and telomeres. This represents a truly complete, end-to-end sequence of all chromosomes. The Workflow The workflow for phylogenetic analysis typically involves several key steps: Extract 16s rRNA -> Align -> Calculate Distance -> Construct Tree Extract 16S rRNA This step involves obtaining the genetic material from the organisms of interest, such as bacteria or viruses. For example, in the case of antibiotic resistance, researchers might extract the 16S rRNA gene, which is commonly used for bacterial identification. The reason for extracting 16S rRNA in bacteria is beccause the sequence are highly conserved across different species, making it a reliable marker for phylogenetic analysis. The 16S rRNA gene is present in all bacteria and archaea, and its sequence can provide insights into the evolutionary relationships between different microbial species. Let‚Äôs dive into the code to do this. We‚Äôll use the same 2 groups we used before, regular Ecoli and ESBL Ecoli from before library(Biostrings) library(DECIPHER) # load data path1",
    "og_image": "https://www.kenkoonwong.com/blog/phylo/figtree_phylo.jpeg",
    "og_title": "Learning The Basics of Phylogenetic Analysis | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 20,
    "sitemap_lastmod": null,
    "twitter_description": "üß¨üî¨ Explore phylogenetic analysis from genome to tree! Basic workflow with R/Bioconductor. Learnt to work with large genomic dataset. Extract 16S rRNA from 10K+ E.coli strains using dataset dehydrate, barrnap for extraction, rapidNJ for tree building & FigTree for visualization. Movitation: After that last hands-on experience on Bioconductor, we will continue our journey in phylogenetic analysis. I‚Äôve always been intrigued in how biologists piece these phylogenetic tree together and I want to know the big idea of how this is done. We‚Äôll again be using Bioconductor. Let‚Äôs go! Disclaimer: I am not a bioinformatician and do not work with genes directly, the articles and method presented is my attempt to get a birds eye view on how we went from different isolates to piecing them together onto a single tree. Please take this with a grain of salt. Verify the information presented. If you noted some error in this article, please let me know so that I can learn! Also, some of the analysis results were not run during rmarkdown knitting because that causes a significant delay, however, the results posted here should be reprodicuble. Please again let me know if they are not The End Goal: Get a basic workflow of how this is done Assess Many Many Ecoli strains Assess Different Genus on a single tree Looks quite doable! Along the line, we may have some deeper dive to look at the machinery behind. Ultimately, we want to visualize beuatiful trees! üå¥ Like this. Objectives: What is phylogenetic analysis? The workflow Extract 16S rRna Align Distance Calculation Tree construction Visualizing Phylogenetic tree Ecoli Large Dataset Other Genus Opportunities for improvement Lessons Learnt What is phylogenetic analysis? Phylogenetic analysis is a method used to study the evolutionary relationships between organisms. It involves comparing genetic sequences, such as DNA or RNA, to infer how species are related through common ancestry. This analysis can help identify how different organisms have evolved over time and can be particularly useful in contact tracing, outbreak assessment. Here is a quick wiki Let‚Äôs Download ALL Ecoli Fasta One of our previous opportunity improvement is to learn to use NCBI dataset CLI. We‚Äôll be using that this time because if you try to download more than 10,000 of fasta via website or event the CLI itself, it won‚Äôt be as smooth, at least from my multiple tries. I‚Äôve attempted maybe 5-6 times and couldn‚Äôt complete the download even when I used datasets and unable to resume downloads. However, the most stable is actually to download dehydrated then rehydrate. See here Terminal curl -o datasets 'https://ftp.ncbi.nlm.nih.gov/pub/datasets/command-line/v2/mac/datasets' chmod +x datasets dataformat datasets download genome taxon \"Escherichia coli\" \\ --assembly-level scaffold,chromosome,complete \\ --dehydrated \\ --filename ecoli_high_quality_dehydrated.zip unzip ecoli_genomes_dehydrated.zip cd ncbi_dataset datasets rehydrate --directory For large genome downloads, use datasets dehydrated then rehydrate. It‚Äôs easier to resume download if connection got lost. You notice above that we left off contig and just included scaffold, chromosome, and complete? That‚Äôs because there were 300,000 sequences if we include all of them. I definitely don‚Äôt need all of those packages. With scaffold, chromosome, and complete, we got 30,000+ and the entire zip file was 58 gigs of data. üòµ‚Äçüí´ Just for my education: Contig - Short for ‚Äúcontiguous sequence.‚Äù This is a continuous stretch of DNA sequence with no gaps. Contigs are assembled from overlapping sequencing reads, but they represent isolated pieces without known relationships to other contigs. Scaffold - A collection of contigs that have been ordered and oriented relative to each other, often with gaps of estimated size between them. Scaffolding uses additional information like paired-end reads or mate-pair libraries to determine how contigs should be arranged, even when the sequence connecting them isn‚Äôt fully resolved. Chromosome - Contigs and scaffolds have been assembled into chromosome-scale sequences that represent entire chromosomes. This typically requires additional long-range information like Hi-C data, optical mapping, or long-read sequencing to achieve proper chromosome-level organization. Complete - The highest level of assembly where the entire genome is finished with no gaps, including challenging repetitive regions, centromeres, and telomeres. This represents a truly complete, end-to-end sequence of all chromosomes. The Workflow The workflow for phylogenetic analysis typically involves several key steps: Extract 16s rRNA -> Align -> Calculate Distance -> Construct Tree Extract 16S rRNA This step involves obtaining the genetic material from the organisms of interest, such as bacteria or viruses. For example, in the case of antibiotic resistance, researchers might extract the 16S rRNA gene, which is commonly used for bacterial identification. The reason for extracting 16S rRNA in bacteria is beccause the sequence are highly conserved across different species, making it a reliable marker for phylogenetic analysis. The 16S rRNA gene is present in all bacteria and archaea, and its sequence can provide insights into the evolutionary relationships between different microbial species. Let‚Äôs dive into the code to do this. We‚Äôll use the same 2 groups we used before, regular Ecoli and ESBL Ecoli from before library(Biostrings) library(DECIPHER) # load data path1",
    "twitter_title": "Learning The Basics of Phylogenetic Analysis | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/08/learning-the-basics-of-phylogenetic-analysis/",
    "word_count": 3999
  }
}