{
  "uuid": "bf844ba4-5d97-4060-90d9-ed49c844ffdb",
  "created_at": "2025-11-22 19:57:40",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/09/r6-interfaces-for-backend-define-what-not-how/",
    "crawled_at": "2025-11-22T10:42:58.704483",
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/testable-r6-interfaces",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "http://jakubsobolewski.com/get-roadmap/",
        "text": "Level-up your testing game! Grab your copy of the R testing roadmap."
      },
      {
        "href": "https://jakubsobolewski.com/blog/testable-r6-interfaces",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "R6 Interfaces For Backend: Define What, Not How | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-395322 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">R6 Interfaces For Backend: Define What, Not How</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">September 9, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/testable-r6-interfaces\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Your Shiny app has business logic scattered everywhere.</p>\n<p>Testing it feels impossible. Every time you touch one piece, three others break. Dependencies tangle together like headphone cables in your pocket.</p>\n<p>There’s a cleaner way.</p>\n<h2 id=\"interfaces-define-what-not-how\">Interfaces Define What, Not How</h2>\n<p>R6 interfaces let you bundle concepts together without locking in implementation details. Your business logic depends on contracts, not concrete classes.</p>\n<p>Think about a Shiny app that needs to analyze customer data. Sometimes you want real database queries. During testing, you want fast fakes. In acceptance tests, you need controlled scenarios.</p>\n<p>The interface stays the same. The implementation changes.</p>\n<blockquote>\n<p><a href=\"http://jakubsobolewski.com/get-roadmap/\" rel=\"nofollow\" target=\"_blank\">Level-up your testing game! Grab your copy of the R testing roadmap.</a></p>\n</blockquote>\n<h2 id=\"implement-the-interface\">Implement The Interface</h2>\n<p>Define the behavior of your interface. What methods should it have? What parameters? What return values?</p>\n<p>Make all methods throw an error. In case a class that implements this interface forgets to override one, it should fail loudly.</p>\n<pre>CustomerAnalyzerInterface &lt;- R6::R6Class(\n  classname = \"CustomerAnalyzerInterface\",\n  public = list(\n    initialize = function() {\n      rlang::abort(\"This class cannot be instantiated.\")\n    },\n    get_customer_metrics = function(customer_id) {\n      rlang::abort(\"Not implemented.\")\n    },\n    calculate_risk_score = function(metrics) {\n      rlang::abort(\"Not implemented.\")\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      rlang::abort(\"Not implemented.\")\n    }\n  )\n)</pre>\n<p>Then depending on what your workflow is, create concrete implementations, either real or fake.</p>\n<h2 id=\"choose-your-workflow\">Choose Your Workflow</h2>\n<h3 id=\"inside-out\">Inside out</h3>\n<p>If you want to nail the business logic, write tests for the real implementation and implement it. It might be worth checking if what you need to calculate is even possible.</p>\n<ul>\n<li>Can you get the data you need?</li>\n<li>Can you run the calculations in a reasonable time?</li>\n</ul>\n<p>This approach might lead to a more complex real implementation, but you will know it works. You can always write an adapter to serve the data in the app later.</p>\n<h3 id=\"outside-in\">Outside in</h3>\n<p>If you want to get the app working, write the fake implementation to serve fake data in the app. Focus on the user and developer experience.</p>\n<ul>\n<li>Can users get what they need in the app?</li>\n<li>What should the UI look like?</li>\n<li>What code interface makes serving the interface easy?</li>\n</ul>\n<p>What you learn in this stage can inform the real implementation later.</p>\n<h2 id=\"the-real-implementation\">The Real Implementation</h2>\n<p>Your production class does the heavy lifting. It connects to databases, calls APIs, runs expensive calculations.</p>\n<pre>CustomerAnalyzer &lt;- R6::R6Class(\n  classname = \"CustomerAnalyzer\",\n  inherit = CustomerAnalyzerInterface,\n  public = list(\n    initialize = function(...) {\n      # Set up whatever is needed to work in production\n    },\n    get_customer_metrics = function(customer_id) {\n      # Query production database\n      # Call analytics service\n      # Return complex calculations\n    },\n    calculate_risk_score = function(metrics) {\n      # Run ML model prediction\n      # Factor in market conditions\n      # Return weighted score\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      # Query recommendation engine\n      # Apply business rules\n      # Return personalized actions\n    }\n  )\n)</pre>\n<h2 id=\"the-fake-implementation-for-testing\">The Fake Implementation For Testing</h2>\n<p>Testing needs control. Your fake returns known values every time.</p>\n<pre>CustomerAnalyzerFake &lt;- R6::R6Class(\n  classname = \"CustomerAnalyzerFake\",\n  inherit = CustomerAnalyzerInterface,\n  public = list(\n    initialize = function() {},\n    get_customer_metrics = function(customer_id) {\n      list(\n        revenue = 5000,\n        retention = 0.85,\n        satisfaction = 4.2\n      )\n    },\n    calculate_risk_score = function(metrics) {\n      0.3\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      c(\"Schedule follow-up call\", \"Send satisfaction survey\")\n    }\n  )\n)</pre>\n<h2 id=\"create-a-factory-for-instantiation\">Create a Factory For Instantiation</h2>\n<p>Implement a <code>make_</code>/<code>create_</code>,<code>build_</code>,<code>get_</code>/<code>new_</code> function that picks and initializes the right implementation. Environment variables or config files control the choice.</p>\n<pre>make_customer_analyzer &lt;- function(\n  type = c(\"real\", \"fake\"),\n  ... # additional parameters for initialization\n) {\n  type &lt;- match.arg(type)\n  switch(\n    type,\n    real = CustomerAnalyzerReal$new(),\n    fake = CustomerAnalyzerFake$new()\n  )\n}</pre>\n<h2 id=\"shiny-app-stays-clean-and-testable\">Shiny App Stays Clean And Testable</h2>\n<p>Business logic depends on the interface. Implementation details hide behind the factory. External dependencies become swappable. You can still develop the app if the production DB is down.</p>\n<pre>server &lt;- function(input, output, session) {\n  analyzer_type &lt;- Sys.getenv(\"ANALYZER_TYPE\", \"fake\")\n  analyzer &lt;- make_customer_analyzer(analyzer_type)\n\n  output$metrics &lt;- renderPlot({\n    req(input$customer_id)\n    metrics &lt;- analyzer$get_customer_metrics(input$customer_id)\n    chart(metrics)\n  })\n\n  # ... other server logic\n}</pre>\n<h2 id=\"testing-becomes-straightforward\">Testing Becomes Straightforward</h2>\n<p>Use the same to create the instance in your tests as in production. This is the public interface of the business logic, not the classes themselves.</p>\n<p>Test that the logic is correct in the real implementation:</p>\n<pre>test_that(\"high risk customers get urgent recommendations\", {\n  # Arrange\n  analyzer &lt;- make_customer_analyzer(\"real\")\n\n  # Act\n  recommendations &lt;- analyzer$generate_recommendations(\"customer-123\", 0.9)\n\n  # Assert\n  expect_set_equal(recommendations, c(\"Immediate outreach\"))\n})</pre>\n<p>Test that the fake fulfills the interface contract:</p>\n<pre>test_that(\"fake customer analyzer returns a recommendation\", {\n  # Arrange\n  analyzer &lt;- make_customer_analyzer(\"fake\")\n\n  # Act\n  recommendations &lt;- analyzer$generate_recommendations(\"123\", 0.3)\n\n  # Assert\n  expect_s3_class(recommendations, \"character\")\n})</pre>\n<p>For testing the app itself, use the fake implementation to serve predictable data. Especially if it depends on fragile external dependencies. Be it APIs, databases, or filesystems.</p>\n<pre>test_that(\"app shows customer metrics\", {\n  # Arrange\n  withr::with_envvar(c(ANALYZER_TYPE = \"fake\"), {\n    app &lt;- AppDriver$new(\"path/to/app\")\n  })\n\n  # Act\n  app$set_inputs(customer_id = \"123\")\n\n  # Assert\n  output &lt;- app$get_value(\"metrics\")\n  expect_true(is.character(output$src))\n})</pre>\n<p>Don’t test the same logic twice. Use fakes for acceptance testing. You’ll get a better separation of concerns, faster and more reliable tests.</p>\n<h2 id=\"acceptance-tests-control-full-scenarios\">Acceptance Tests Control Full Scenarios</h2>\n<p>The same code that runs in production runs in your tests. Only the data source changes.</p>\n<p>This pattern transforms fragile apps into testable systems. Your business logic stays isolated. Dependencies become swappable. Tests run fast and reliable.</p>\n<p>Stop fighting tangled code. Start designing with interfaces.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/testable-r6-interfaces\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "R6 Interfaces For Backend: Define What, Not How\nPosted on\nSeptember 9, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nYour Shiny app has business logic scattered everywhere.\nTesting it feels impossible. Every time you touch one piece, three others break. Dependencies tangle together like headphone cables in your pocket.\nThere’s a cleaner way.\nInterfaces Define What, Not How\nR6 interfaces let you bundle concepts together without locking in implementation details. Your business logic depends on contracts, not concrete classes.\nThink about a Shiny app that needs to analyze customer data. Sometimes you want real database queries. During testing, you want fast fakes. In acceptance tests, you need controlled scenarios.\nThe interface stays the same. The implementation changes.\nLevel-up your testing game! Grab your copy of the R testing roadmap.\nImplement The Interface\nDefine the behavior of your interface. What methods should it have? What parameters? What return values?\nMake all methods throw an error. In case a class that implements this interface forgets to override one, it should fail loudly.\nCustomerAnalyzerInterface <- R6::R6Class(\n  classname = \"CustomerAnalyzerInterface\",\n  public = list(\n    initialize = function() {\n      rlang::abort(\"This class cannot be instantiated.\")\n    },\n    get_customer_metrics = function(customer_id) {\n      rlang::abort(\"Not implemented.\")\n    },\n    calculate_risk_score = function(metrics) {\n      rlang::abort(\"Not implemented.\")\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      rlang::abort(\"Not implemented.\")\n    }\n  )\n)\nThen depending on what your workflow is, create concrete implementations, either real or fake.\nChoose Your Workflow\nInside out\nIf you want to nail the business logic, write tests for the real implementation and implement it. It might be worth checking if what you need to calculate is even possible.\nCan you get the data you need?\nCan you run the calculations in a reasonable time?\nThis approach might lead to a more complex real implementation, but you will know it works. You can always write an adapter to serve the data in the app later.\nOutside in\nIf you want to get the app working, write the fake implementation to serve fake data in the app. Focus on the user and developer experience.\nCan users get what they need in the app?\nWhat should the UI look like?\nWhat code interface makes serving the interface easy?\nWhat you learn in this stage can inform the real implementation later.\nThe Real Implementation\nYour production class does the heavy lifting. It connects to databases, calls APIs, runs expensive calculations.\nCustomerAnalyzer <- R6::R6Class(\n  classname = \"CustomerAnalyzer\",\n  inherit = CustomerAnalyzerInterface,\n  public = list(\n    initialize = function(...) {\n      # Set up whatever is needed to work in production\n    },\n    get_customer_metrics = function(customer_id) {\n      # Query production database\n      # Call analytics service\n      # Return complex calculations\n    },\n    calculate_risk_score = function(metrics) {\n      # Run ML model prediction\n      # Factor in market conditions\n      # Return weighted score\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      # Query recommendation engine\n      # Apply business rules\n      # Return personalized actions\n    }\n  )\n)\nThe Fake Implementation For Testing\nTesting needs control. Your fake returns known values every time.\nCustomerAnalyzerFake <- R6::R6Class(\n  classname = \"CustomerAnalyzerFake\",\n  inherit = CustomerAnalyzerInterface,\n  public = list(\n    initialize = function() {},\n    get_customer_metrics = function(customer_id) {\n      list(\n        revenue = 5000,\n        retention = 0.85,\n        satisfaction = 4.2\n      )\n    },\n    calculate_risk_score = function(metrics) {\n      0.3\n    },\n    generate_recommendations = function(customer_id, risk_score) {\n      c(\"Schedule follow-up call\", \"Send satisfaction survey\")\n    }\n  )\n)\nCreate a Factory For Instantiation\nImplement a\nmake_\n/\ncreate_\n,\nbuild_\n,\nget_\n/\nnew_\nfunction that picks and initializes the right implementation. Environment variables or config files control the choice.\nmake_customer_analyzer <- function(\n  type = c(\"real\", \"fake\"),\n  ... # additional parameters for initialization\n) {\n  type <- match.arg(type)\n  switch(\n    type,\n    real = CustomerAnalyzerReal$new(),\n    fake = CustomerAnalyzerFake$new()\n  )\n}\nShiny App Stays Clean And Testable\nBusiness logic depends on the interface. Implementation details hide behind the factory. External dependencies become swappable. You can still develop the app if the production DB is down.\nserver <- function(input, output, session) {\n  analyzer_type <- Sys.getenv(\"ANALYZER_TYPE\", \"fake\")\n  analyzer <- make_customer_analyzer(analyzer_type)\n\n  output$metrics <- renderPlot({\n    req(input$customer_id)\n    metrics <- analyzer$get_customer_metrics(input$customer_id)\n    chart(metrics)\n  })\n\n  # ... other server logic\n}\nTesting Becomes Straightforward\nUse the same to create the instance in your tests as in production. This is the public interface of the business logic, not the classes themselves.\nTest that the logic is correct in the real implementation:\ntest_that(\"high risk customers get urgent recommendations\", {\n  # Arrange\n  analyzer <- make_customer_analyzer(\"real\")\n\n  # Act\n  recommendations <- analyzer$generate_recommendations(\"customer-123\", 0.9)\n\n  # Assert\n  expect_set_equal(recommendations, c(\"Immediate outreach\"))\n})\nTest that the fake fulfills the interface contract:\ntest_that(\"fake customer analyzer returns a recommendation\", {\n  # Arrange\n  analyzer <- make_customer_analyzer(\"fake\")\n\n  # Act\n  recommendations <- analyzer$generate_recommendations(\"123\", 0.3)\n\n  # Assert\n  expect_s3_class(recommendations, \"character\")\n})\nFor testing the app itself, use the fake implementation to serve predictable data. Especially if it depends on fragile external dependencies. Be it APIs, databases, or filesystems.\ntest_that(\"app shows customer metrics\", {\n  # Arrange\n  withr::with_envvar(c(ANALYZER_TYPE = \"fake\"), {\n    app <- AppDriver$new(\"path/to/app\")\n  })\n\n  # Act\n  app$set_inputs(customer_id = \"123\")\n\n  # Assert\n  output <- app$get_value(\"metrics\")\n  expect_true(is.character(output$src))\n})\nDon’t test the same logic twice. Use fakes for acceptance testing. You’ll get a better separation of concerns, faster and more reliable tests.\nAcceptance Tests Control Full Scenarios\nThe same code that runs in production runs in your tests. Only the data source changes.\nThis pattern transforms fragile apps into testable systems. Your business logic stays isolated. Dependencies become swappable. Tests run fast and reliable.\nStop fighting tangled code. Start designing with interfaces.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "A Practical Guide to Faking External Dependencies and Business Logic with R6 Classes for Reliable Tests.",
    "meta_keywords": null,
    "og_description": "A Practical Guide to Faking External Dependencies and Business Logic with R6 Classes for Reliable Tests.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "R6 Interfaces For Backend: Define What, Not How | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 4.8,
    "sitemap_lastmod": null,
    "twitter_description": "A Practical Guide to Faking External Dependencies and Business Logic with R6 Classes for Reliable Tests.",
    "twitter_title": "R6 Interfaces For Backend: Define What, Not How | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/09/r6-interfaces-for-backend-define-what-not-how/",
    "word_count": 966
  }
}