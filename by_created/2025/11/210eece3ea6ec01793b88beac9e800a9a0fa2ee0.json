{
  "id": "210eece3ea6ec01793b88beac9e800a9a0fa2ee0",
  "url": "https://www.r-bloggers.com/2025/07/specialized-r-packages-for-spatial-cross-validation-sperrorest-and-blockcv/",
  "created_at_utc": "2025-11-22T19:58:06Z",
  "data": null,
  "raw_original": {
    "uuid": "80245c87-73a6-4088-a6d5-9afb35c5e11a",
    "created_at": "2025-11-22 19:58:06",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/07/specialized-r-packages-for-spatial-cross-validation-sperrorest-and-blockcv/",
      "crawled_at": "2025-11-22T10:45:46.786473",
      "external_links": [
        {
          "href": "https://geocompx.org/post/2025/sml-bp6/",
          "text": "geocompx"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://geocompx.org/post/2025/sml-bp6/post/2025/sml-bp1/",
          "text": "in part one"
        },
        {
          "href": "https://doi.org/10.32614/CRAN.package.sperrorest",
          "text": "https://doi.org/10.32614/CRAN.package.sperrorest"
        },
        {
          "href": "https://giscience-fsu.github.io/sperrorest/articles/spatial-modeling-use-case.html",
          "text": "https://giscience-fsu.github.io/sperrorest/articles/spatial-modeling-use-case.html"
        },
        {
          "href": "https://doi.org/10.1111/2041-210X.13107",
          "text": "https://doi.org/10.1111/2041-210X.13107"
        },
        {
          "href": "https://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html",
          "text": "https://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html"
        },
        {
          "href": "https://keras3.posit.co/",
          "text": "https://keras3.posit.co/"
        },
        {
          "href": "https://torch.mlverse.org/",
          "text": "https://torch.mlverse.org/"
        },
        {
          "href": "https://mlverse.github.io/luz/",
          "text": "https://mlverse.github.io/luz/"
        },
        {
          "href": "https://e-sensing.github.io/sitsbook/",
          "text": "“Satellite Image Time Series Analysis on Earth Observation Data Cubes”"
        },
        {
          "href": "https://jakubnowosad.com/",
          "text": "website"
        },
        {
          "href": "https://doi.org/10.5281/zenodo.15088973",
          "text": "https://doi.org/10.5281/zenodo.15088973"
        },
        {
          "href": "https://cran.r-project.org/web/packages/sperrorest/vignettes/custom-pred-and-model-functions.html",
          "text": "https://cran.r-project.org/web/packages/sperrorest/vignettes/custom-pred-and-model-functions.html"
        },
        {
          "href": "https://creativecommons.org/licenses/by/4.0/",
          "text": "CC BY 4.0"
        },
        {
          "href": "https://geocompx.org/post/2025/sml-bp6/",
          "text": "https://geocompx.org/post/2025/sml-bp6/"
        },
        {
          "href": "https://geocompx.org/post/2025/sml-bp6/",
          "text": "geocompx"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Specialized R packages for spatial cross-validation: sperrorest and blockCV | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-8-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-10-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-12-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-2.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-2.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-15-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-16-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-17-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-2.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-20-1.png?w=450&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-21-1.png?w=450&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/jakub-nowosad/",
          "text": "Jakub Nowosad"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-393799 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Specialized R packages for spatial cross-validation: sperrorest and blockCV</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">July 8, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakub-nowosad/\">Jakub Nowosad</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://geocompx.org/post/2025/sml-bp6/\"> geocompx</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div class=\"callout callout-style-simple callout-note\">\n<div class=\"callout-body d-flex\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-body-container\">\n<p>This is the sixth and the final blog post in a series on spatial machine learning with R.</p>\n<p>You can find the list of other blog posts in this series <a href=\"https://geocompx.org/post/2025/sml-bp6/post/2025/sml-bp1/\" rel=\"nofollow\" target=\"_blank\">in part one</a>.</p>\n</div>\n</div>\n</div>\n<p>This document provides an overview of two R packages, <strong>sperrorest</strong> and <strong>blockCV</strong>, that can be used for spatial cross validation, but are outside of standard machine learning frameworks like <strong>caret</strong>, <strong>tidymodels</strong>, or <strong>mlr3</strong>.</p>\n<p>All of the examples below use the same dataset, which includes the temperature measurements in Spain, a set of covariates, and the spatial coordinates of the temperature measurements.</p>\n<div class=\"cell\">\n<pre>spain &lt;- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg\")\ncovariates &lt;- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")\ntemperature &lt;- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\n\ntemperature &lt;- terra::extract(covariates, temperature, bind = TRUE) |&gt;\n    sf::st_as_sf()</pre>\n</div>\n<section class=\"level1\" id=\"sperrorest\">\n<h1>sperrorest</h1>\n<p>The <strong>sperrorest</strong> (<a class=\"uri\" href=\"https://doi.org/10.32614/CRAN.package.sperrorest\" rel=\"nofollow\" target=\"_blank\">https://doi.org/10.32614/CRAN.package.sperrorest</a>) package is designed for spatial error estimation and variable importance assessment for predictive models. The package itself does not fit the models but provides a set of functions for spatial cross-validation, including data partitioning and model cross-validation.</p>\n<p>While the <strong>sperrorest</strong> package has many functions (including a set of functions for data partitioning), its main function is <code>sperrorest()</code>. It performs spatial cross-validation for spatial prediction models, including variable importance assessment and prediction error estimation. To use this function, we need to provide the formula, the data, the coordinates, the model function, the model arguments, the prediction function, the sampling function, and the sampling arguments.</p>\n<p>Let’s do it step by step. First, we need to prepare the data by extracting the coordinates and creating a data frame with the dependent variable, covariates, and coordinates.</p>\n<div class=\"cell\">\n<pre>library(sperrorest)\nlibrary(ranger)\n\ncoordinates &lt;- sf::st_coordinates(temperature)\ntemperature_df &lt;- sf::st_drop_geometry(temperature)\ntemperature_df$x &lt;- coordinates[, 1]\ntemperature_df$y &lt;- coordinates[, 2]</pre>\n</div>\n<p>Second, we need to define the formula for the model and the prediction function.</p>\n<div class=\"cell\">\n<pre>response_name &lt;- \"temp\"\ncovariate_names &lt;- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\nfo &lt;- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))</pre>\n</div>\n<p>Third, we need to define the custom prediction function. The <strong>sperrorest</strong> package works with many model functions, but it requires a custom prediction function to extract the predictions from the model object. In this example, we use the <code>ranger</code> model, so we need to define a custom prediction function that extracts the predictions from the <code>ranger</code> model object. The <code>predict()</code> function from the <code>ranger</code> package returns a list with several elements, so we need to extract the predictions from this list.<sup>1</sup></p>\n<div class=\"cell\">\n<pre>mypred &lt;- function(object, newdata) {\n    predict(object, newdata)$predictions\n}</pre>\n</div>\n<p>Fourth, we can perform the spatial cross-validation using the <code>sperrorest()</code> function. We just need to provide previously prepared data, the formula, the model function, and the prediction function. Moreover, we can also define some additional parameters of the model, such as the number of trees in the <code>ranger</code> model. Finally, the important part is to define the sampling function (<code>smp_fun</code>) and its arguments (<code>smp_args</code>). The sampling function is used to partition the data into training and testing sets: here, we use the <code>partition_kmeans()</code> function to partition the data spatially into folds using k-means clustering of the coordinates.<sup>2</sup></p>\n<div class=\"cell\">\n<pre># Spatial cross-validation\nset.seed(6)\nsp_res &lt;- sperrorest(\n    formula = fo,\n    data = temperature_df,\n    coords = c(\"x\", \"y\"),\n    model_fun = ranger,\n    model_args = list(num.trees = 100),\n    pred_fun = mypred,\n    smp_fun = partition_kmeans,\n    smp_args = list(repetition = 1:2, nfold = 3),\n    progress = FALSE\n)</pre>\n</div>\n<p>The result is a list with several components, including the error at the repetition and fold levels, the resampling object, the variable importance (only when <code>importance = TRUE</code>), the benchmark, and the package version.</p>\n<div class=\"cell\">\n<pre>summary(sp_res$error_rep)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>                      mean           sd        median          IQR\ntrain_bias     0.003667002 0.0224183696   0.003667002 0.0158521812\ntrain_stddev   0.399217628 0.0044832845   0.399217628 0.0031701609\ntrain_rmse     0.399038491 0.0042677806   0.399038491 0.0030177766\ntrain_mad      0.316892003 0.0078406248   0.316892003 0.0055441590\ntrain_median   0.033006028 0.0001897285   0.033006028 0.0001341583\ntrain_iqr      0.427813987 0.0083456683   0.427813987 0.0059012787\ntrain_count  390.000000000 0.0000000000 390.000000000 0.0000000000\ntest_bias     -0.009090677 0.0742284999  -0.009090677 0.0524874756\ntest_stddev    1.447676903 0.0934364402   1.447676903 0.0660695405\ntest_rmse      1.444959463 0.0926651037   1.444959463 0.0655241232\ntest_mad       1.341466967 0.1144815717   1.341466967 0.0809506957\ntest_median    0.101932523 0.0950544902   0.101932523 0.0672136746\ntest_iqr       1.876642239 0.1533036116   1.876642239 0.1084020233\ntest_count   195.000000000 0.0000000000 195.000000000 0.0000000000</pre>\n</div>\n</div>\n<p>We can contrast the obtained results with the non-spatial cross-validation by changing the sampling function to <code>partition_cv()</code>.</p>\n<div class=\"cell\">\n<pre># Non-spatial cross-validation\nset.seed(11)\nnsp_res &lt;- sperrorest(\n    formula = fo,\n    data = temperature_df,\n    coords = c(\"x\", \"y\"),\n    model_fun = ranger,\n    model_args = list(num.trees = 100),\n    pred_fun = mypred,\n    smp_fun = partition_cv,\n    smp_args = list(repetition = 1:2, nfold = 3),\n    progress = FALSE\n)</pre>\n</div>\n<p>To compare both results, we can plot the RMSE values for the training and testing sets of both spatial and non-spatial cross-validation.</p>\n<div class=\"cell\">\n<pre>library(ggplot2)\n# Extract train/test RMSE from spatial CV\nsp_train_rmse &lt;- sp_res$error_rep$train_rmse\nsp_test_rmse &lt;- sp_res$error_rep$test_rmse\n# Extract train/test RMSE from non-spatial CV\nnsp_train_rmse &lt;- nsp_res$error_rep$train_rmse\nnsp_test_rmse &lt;- nsp_res$error_rep$test_rmse\n# Build data frame\nrmse_df &lt;- data.frame(\n    CV_Type = rep(c(\"Spatial\", \"Non-Spatial\"), each = 4),\n    Set = rep(c(\"Train\", \"Test\"), each = 2),\n    RMSE = c(sp_train_rmse, sp_test_rmse, nsp_train_rmse, nsp_test_rmse)\n)\nggplot(rmse_df, aes(x = CV_Type, y = RMSE, fill = Set)) +\n    geom_boxplot() +\n    facet_wrap(~Set) +\n    labs(title = \"RMSE Comparison\", x = \"CV Method\", y = \"RMSE\")</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-8-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-8-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The results show that the estimation using the spatial-cross validation is less optimistic than the non-spatial cross-validation for the test set.</p>\n<p>More examples of the package use can be found at <a class=\"uri\" href=\"https://giscience-fsu.github.io/sperrorest/articles/spatial-modeling-use-case.html\" rel=\"nofollow\" target=\"_blank\">https://giscience-fsu.github.io/sperrorest/articles/spatial-modeling-use-case.html</a>/</p>\n</section>\n<section class=\"level1\" id=\"blockcv\">\n<h1>blockCV</h1>\n<p>The <strong>blockCV</strong> (<a class=\"uri\" href=\"https://doi.org/10.1111/2041-210X.13107\" rel=\"nofollow\" target=\"_blank\">https://doi.org/10.1111/2041-210X.13107</a>) package provides a set of functions for block cross-validation, spatial and environmental clustering, and spatial autocorrelation estimation. The package itself does not fit the models.</p>\n<div class=\"cell\">\n<pre># remotes::install_github(\"cran/automap\")\nlibrary(blockCV)</pre>\n</div>\n<p>Cross-validation strategies separate the data into training and testing sets to evaluate the model’s performance. The <strong>blockCV</strong> package provides several cross-validation strategies, including block cross-validation, spatial clustering, environmental clustering, buffering LOO, and Nearest Neighbour Distance Matching (NNDM) LOO.</p>\n<p>The block cross-validation is performed using the <code>cv_spatial()</code> function. It assigns blocks to the training and testing folds randomly, systematically or in a checkerboard pattern (the <code>selection</code> argument).</p>\n<div class=\"cell\">\n<pre>set.seed(61)\nsb1 &lt;- cv_spatial(\n    x = temperature,\n    k = 10, # number of folds\n    size = 300000, # size of the blocks in meters\n    selection = \"random\", # random blocks-to-fold\n    iteration = 50, # find evenly dispersed folds\n    progress = FALSE,\n    biomod2 = TRUE\n)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>\n   train test\n1    170   25\n2    169   26\n3    171   24\n4    180   15\n5    181   14\n6    183   12\n7    182   13\n8    165   30\n9    179   16\n10   175   20</pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-10-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-10-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The result is a list with several components, including the folds list, the folds IDs, the biomod table, the number of folds, the input size, the column name, the blocks, and the records. For example, we can check the structure of the folds list with the <code>str()</code> function.</p>\n<div class=\"cell\">\n<pre>str(sb1$folds_list)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>List of 10\n $ :List of 2\n  ..$ : int [1:170] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:25] 23 31 57 39 58 60 21 22 32 27 ...\n $ :List of 2\n  ..$ : int [1:169] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:26] 153 155 93 108 95 91 88 154 94 140 ...\n $ :List of 2\n  ..$ : int [1:171] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:24] 12 45 175 176 166 20 177 19 167 16 ...\n $ :List of 2\n  ..$ : int [1:180] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:15] 134 138 136 133 187 192 174 173 189 190 ...\n $ :List of 2\n  ..$ : int [1:181] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:14] 161 142 143 150 160 149 146 147 158 151 ...\n $ :List of 2\n  ..$ : int [1:183] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:12] 4 8 5 2 193 1 6 194 164 3 ...\n $ :List of 2\n  ..$ : int [1:182] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:13] 128 124 129 130 127 132 131 120 126 125 ...\n $ :List of 2\n  ..$ : int [1:165] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:30] 61 70 75 52 77 83 79 86 50 48 ...\n $ :List of 2\n  ..$ : int [1:179] 23 31 57 39 58 60 21 22 32 27 ...\n  ..$ : int [1:16] 117 87 103 84 105 99 119 101 98 97 ...\n $ :List of 2\n  ..$ : int [1:175] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:20] 163 181 159 157 186 67 71 41 178 179 ...</pre>\n</div>\n</div>\n<p>The <code>cv_plot()</code> function additionally allows for the visualization of cross-validation results.</p>\n<div class=\"cell\">\n<pre>cv_plot(sb1, temperature)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-12-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-12-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>Let’s compare the results of the block cross-validation with systematic and checkerboard patterns.</p>\n<div class=\"cell\">\n<pre>set.seed(16)\nsb2 &lt;- cv_spatial(\n    x = temperature,\n    k = 10,\n    rows_cols = c(4, 6),\n    hexagon = FALSE,\n    selection = \"systematic\"\n)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>\n   train test\n1    172   23\n2    180   15\n3    177   18\n4    169   26\n5    178   17\n6    182   13\n7    180   15\n8    162   33\n9    178   17\n10   177   18</pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n<pre>cv_plot(sb2, temperature)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-2.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-13-2.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<div class=\"cell\">\n<pre>set.seed(12)\nsb3 &lt;- cv_spatial(\n    x = temperature,\n    k = 10,\n    size = 300000,\n    hexagon = FALSE,\n    selection = \"checkerboard\"\n)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>\n  train test\n1    98   97\n2    97   98</pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n<pre>cv_plot(sb3, temperature)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-2.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-14-2.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The clustering strategies (<code>cv_cluster()</code>) are used to group the data into clusters based on spatial or environmental similarity. The spatial similarity is based only on the clustering of the spatial coordinates.</p>\n<div class=\"cell\">\n<pre>set.seed(7)\nscv &lt;- cv_cluster(x = temperature, k = 10)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>   train test\n1    169   26\n2    169   26\n3    173   22\n4    178   17\n5    179   16\n6    182   13\n7    176   19\n8    171   24\n9    178   17\n10   180   15</pre>\n</div>\n<pre>cv_plot(scv, temperature)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-15-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-15-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The environmental clustering, on the other hand, is based on the clustering of the values of the covariates extracted from the raster data.</p>\n<div class=\"cell\">\n<pre>set.seed(2)\necv &lt;- cv_cluster(x = temperature, r = covariates, k = 5, scale = TRUE)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>  train test\n1   164   31\n2   190    5\n3   182   13\n4   154   41\n5    90  105</pre>\n</div>\n<pre>cv_plot(ecv, temperature)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-16-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-16-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The next cross-validation strategy is buffering LOO (also known as Spatial LOO). It is performed using the <code>cv_buffer()</code> function, which selects a buffer around each point (test point) and uses the points outside the buffer as the testing set.<sup>3</sup></p>\n<div class=\"cell\">\n<pre>set.seed(21)\nbloo &lt;- cv_buffer(x = temperature, size = 300000, progress = FALSE)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>     train            test  \n Min.   : 97.0   Min.   :1  \n Mean   :132.7   Mean   :1  \n Max.   :170.0   Max.   :1  </pre>\n</div>\n<pre>cv_plot(bloo, temperature, num_plots = c(1, 50, 100))</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-17-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-17-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>Note that above, we plot only the first, 50th, and 100th points to avoid overplotting.</p>\n<p>The last cross-validation strategy implemented in the <strong>blockCV</strong> package is the Nearest Neighbour Distance Matching (NNDM) LOO. It is performed using the <code>cv_nndm()</code> function, which tries to match the nearest neighbor distance distribution function between the test and training data to the nearest neighbor distance distribution function between the target prediction and training points. Thus, in this base, we need to provide more arguments, including a raster with the covariates, the number of samples, the sampling strategy, and the minimum training size.</p>\n<div class=\"cell\">\n<pre>set.seed(12)\nnncv &lt;- cv_nndm(\n    x = temperature,\n    r = covariates,\n    size = 300000,\n    num_sample = 5000,\n    sampling = \"regular\",\n    min_train = 0.1,\n    plot = TRUE\n)</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>     train            test  \n Min.   :192.0   Min.   :1  \n Mean   :192.9   Mean   :1  \n Max.   :193.0   Max.   :1  </pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n<pre>cv_plot(nncv, temperature, num_plots = c(1, 50, 100))</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-2.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-18-2.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>Let’s now use the block cross-validation to fit and evaluate a model.</p>\n<div class=\"cell\">\n<pre># define formula\nresponse_name &lt;- \"temp\"\ncovariate_names &lt;- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\nfo &lt;- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))\n\n# extract the folds\nfolds &lt;- sb1$folds_list\n\nmodel_rmse &lt;- data.frame(fold = seq_along(folds), rmse = rep(NA, length(folds)))\n\nfor (k in seq_along(folds)) {\n    trainSet &lt;- unlist(folds[[k]][1]) # training set indices; first element\n    testSet &lt;- unlist(folds[[k]][2]) # testing set indices; second element\n    rf &lt;- ranger(fo, temperature_df[trainSet, ], num.trees = 100) # model fitting on training set\n    pred &lt;- predict(rf, temperature_df[testSet, ])$predictions # predict the test set\n    model_rmse[k, \"rmse\"] &lt;- sqrt(mean(\n        (temperature_df[testSet, response_name] - pred)^2\n    )) # calculate RMSE\n}\nmodel_rmse</pre>\n<div class=\"cell-output cell-output-stdout\">\n<pre>   fold      rmse\n1     1 1.1401856\n2     2 0.7848595\n3     3 0.9219486\n4     4 0.8007453\n5     5 0.6485726\n6     6 1.2989341\n7     7 0.8140209\n8     8 1.2050918\n9     9 0.9696801\n10   10 0.8681127</pre>\n</div>\n</div>\n<p>The <strong>blockCV</strong> package also provides functions for checking the similarity between the folds (<code>cv_similarity()</code>) and estimating the effective range of spatial autocorrelation (<code>cv_spatial_autocor()</code>). The first function is used to check the similarity between the folds in the cross-validation.</p>\n<div class=\"cell\">\n<pre>cv_similarity(cv = sb1, x = temperature, r = covariates, progress = FALSE)</pre>\n<div class=\"cell-output cell-output-stderr\">\n<pre>Warning: The following aesthetics were dropped during statistical transformation:\ncolour.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?</pre>\n</div>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-20-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-20-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n</div>\n<p>The second function is used to estimate the effective range of spatial autocorrelation of all input raster layers or the response data – its role is to help to determine the size of the blocks in the block cross-validation.</p>\n<div class=\"cell\">\n<pre>cv_spatial_autocor(r = covariates, num_sample = 5000, progress = FALSE)</pre>\n<div class=\"cell-output-display\">\n<div>\n<figure class=\"figure\">\n<p><img class=\"img-fluid figure-img\" data-lazy-src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-21-1.png?w=450&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img class=\"img-fluid figure-img\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-21-1.png?w=450&amp;ssl=1\"/></noscript></p>\n</figure>\n</div>\n</div>\n<div class=\"cell-output cell-output-stdout\">\n<pre>[1] \"cv_spatial_autocor\"</pre>\n</div>\n</div>\n<p>More examples of the package’s use can be found at <a class=\"uri\" href=\"https://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html\" rel=\"nofollow\" target=\"_blank\">https://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html</a>.</p>\n</section>\n<section class=\"level1\" id=\"closing-remarks\">\n<h1>Closing remarks</h1>\n<p>This blog post concludes the series on machine learning for spatial data with R. It showed established frameworks for machine learning in R, such as <strong>caret</strong>, <strong>tidymodels</strong>, and <strong>mlr3</strong>, but focused on how to use them for spatial data problems. Next, we presented specialized R packages for spatial machine learning, such as <strong>spatialRF</strong>, <strong>RandomForestsGLS</strong>, and <strong>meteo</strong> and two R packages aimed for spatial cross-validation: <strong>sperrorest</strong> and <strong>blockCV</strong>.</p>\n<p>The series focused on the so-called “classical” machine learning methods, with a focus on the random forest method. At the same time, the series did not cover deep learning methods, as they require a different approach and tools. You can find more information on deep learning in R in the documentation of the packages like <strong>keras3</strong> (<a class=\"uri\" href=\"https://keras3.posit.co/\" rel=\"nofollow\" target=\"_blank\">https://keras3.posit.co/</a>), <strong>torch</strong> (<a class=\"uri\" href=\"https://torch.mlverse.org/\" rel=\"nofollow\" target=\"_blank\">https://torch.mlverse.org/</a>), or <strong>luz</strong> (<a class=\"uri\" href=\"https://mlverse.github.io/luz/\" rel=\"nofollow\" target=\"_blank\">https://mlverse.github.io/luz/</a>). Moreover, the <strong>sits</strong> package provides various deep learning tools for satellite image time series analysis – you can learn more about it in the book <a href=\"https://e-sensing.github.io/sitsbook/\" rel=\"nofollow\" target=\"_blank\">“Satellite Image Time Series Analysis on Earth Observation Data Cubes”</a>.</p>\n<p>The number of methods and tools for spatial machine learning is growing rapidly, and it is impossible to cover all of them in a single series. However, the presented packages and methods should provide a good starting point for anyone interested in spatial machine learning with R. If you have any suggestions for other packages and methods that should be included in this series, feel free to contact me – you can find my contact details on my <a href=\"https://jakubnowosad.com/\" rel=\"nofollow\" target=\"_blank\">website</a>.</p>\n<div class=\"callout callout-style-simple callout-note\">\n<div class=\"callout-body d-flex\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-body-container\">\n<p>This blog post was originally written as a supplement to the poster “An Inventory of Spatial Machine Learning Packages in R” presented at the FOSSGIS 2025 conference in Muenster, Germany. The poster is available at <a class=\"uri\" href=\"https://doi.org/10.5281/zenodo.15088973\" rel=\"nofollow\" target=\"_blank\">https://doi.org/10.5281/zenodo.15088973</a>.</p>\n</div>\n</div>\n</div>\n</section>\n<div class=\"default\" id=\"quarto-appendix\"><section class=\"footnotes footnotes-end-of-document\" id=\"footnotes\"><h2 class=\"anchored quarto-appendix-heading\">Footnotes</h2>\n<ol>\n<li id=\"fn1\"><p>More information on the custom prediction functions is at <a class=\"uri\" href=\"https://cran.r-project.org/web/packages/sperrorest/vignettes/custom-pred-and-model-functions.html\" rel=\"nofollow\" target=\"_blank\">https://cran.r-project.org/web/packages/sperrorest/vignettes/custom-pred-and-model-functions.html</a>.↩︎</p></li>\n<li id=\"fn2\"><p>There are several other partition functions available in the package, including <code>partition_disc()</code>, <code>partition_tiles()</code>, and <code>partition_cv()</code>.↩︎</p></li>\n<li id=\"fn3\"><p>This approach is a form of leave-one-out cross-validation.↩︎</p></li>\n</ol>\n</section><section class=\"quarto-appendix-contents\" id=\"quarto-reuse\"><h2 class=\"anchored quarto-appendix-heading\">Reuse</h2><div class=\"quarto-appendix-contents\"><div><a href=\"https://creativecommons.org/licenses/by/4.0/\" rel=\"nofollow\" target=\"_blank\">CC BY 4.0</a></div></div></section><section class=\"quarto-appendix-contents\" id=\"quarto-citation\"><h2 class=\"anchored quarto-appendix-heading\">Citation</h2><div><div class=\"quarto-appendix-secondary-label\">BibTeX citation:</div><pre>@online{nowosad2025,\n  author = {Nowosad, Jakub},\n  title = {Specialized {R} Packages for Spatial Cross-Validation:\n    Sperrorest and {blockCV}},\n  date = {2025-07-09},\n  url = {https://geocompx.org/post/2025/sml-bp6/},\n  langid = {en}\n}\n</pre><div class=\"quarto-appendix-secondary-label\">For attribution, please cite this work as:</div><div class=\"csl-entry quarto-appendix-citeas\" id=\"ref-nowosad2025\">\nNowosad, Jakub. 2025. <span>“Specialized R Packages for Spatial\nCross-Validation: Sperrorest and blockCV.”</span> July 9, 2025. <a href=\"https://geocompx.org/post/2025/sml-bp6/\" rel=\"nofollow\" target=\"_blank\">https://geocompx.org/post/2025/sml-bp6/</a>.\n</div></div></section></div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://geocompx.org/post/2025/sml-bp6/\"> geocompx</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Specialized R packages for spatial cross-validation: sperrorest and blockCV\nPosted on\nJuly 8, 2025\nby\nJakub Nowosad\nin\nR bloggers\n| 0 Comments\n[This article was first published on\ngeocompx\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nThis is the sixth and the final blog post in a series on spatial machine learning with R.\nYou can find the list of other blog posts in this series\nin part one\n.\nThis document provides an overview of two R packages,\nsperrorest\nand\nblockCV\n, that can be used for spatial cross validation, but are outside of standard machine learning frameworks like\ncaret\n,\ntidymodels\n, or\nmlr3\n.\nAll of the examples below use the same dataset, which includes the temperature measurements in Spain, a set of covariates, and the spatial coordinates of the temperature measurements.\nspain <- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg\")\ncovariates <- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")\ntemperature <- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\n\ntemperature <- terra::extract(covariates, temperature, bind = TRUE) |>\n    sf::st_as_sf()\nsperrorest\nThe\nsperrorest\n(\nhttps://doi.org/10.32614/CRAN.package.sperrorest\n) package is designed for spatial error estimation and variable importance assessment for predictive models. The package itself does not fit the models but provides a set of functions for spatial cross-validation, including data partitioning and model cross-validation.\nWhile the\nsperrorest\npackage has many functions (including a set of functions for data partitioning), its main function is\nsperrorest()\n. It performs spatial cross-validation for spatial prediction models, including variable importance assessment and prediction error estimation. To use this function, we need to provide the formula, the data, the coordinates, the model function, the model arguments, the prediction function, the sampling function, and the sampling arguments.\nLet’s do it step by step. First, we need to prepare the data by extracting the coordinates and creating a data frame with the dependent variable, covariates, and coordinates.\nlibrary(sperrorest)\nlibrary(ranger)\n\ncoordinates <- sf::st_coordinates(temperature)\ntemperature_df <- sf::st_drop_geometry(temperature)\ntemperature_df$x <- coordinates[, 1]\ntemperature_df$y <- coordinates[, 2]\nSecond, we need to define the formula for the model and the prediction function.\nresponse_name <- \"temp\"\ncovariate_names <- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\nfo <- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))\nThird, we need to define the custom prediction function. The\nsperrorest\npackage works with many model functions, but it requires a custom prediction function to extract the predictions from the model object. In this example, we use the\nranger\nmodel, so we need to define a custom prediction function that extracts the predictions from the\nranger\nmodel object. The\npredict()\nfunction from the\nranger\npackage returns a list with several elements, so we need to extract the predictions from this list.\n1\nmypred <- function(object, newdata) {\n    predict(object, newdata)$predictions\n}\nFourth, we can perform the spatial cross-validation using the\nsperrorest()\nfunction. We just need to provide previously prepared data, the formula, the model function, and the prediction function. Moreover, we can also define some additional parameters of the model, such as the number of trees in the\nranger\nmodel. Finally, the important part is to define the sampling function (\nsmp_fun\n) and its arguments (\nsmp_args\n). The sampling function is used to partition the data into training and testing sets: here, we use the\npartition_kmeans()\nfunction to partition the data spatially into folds using k-means clustering of the coordinates.\n2\n# Spatial cross-validation\nset.seed(6)\nsp_res <- sperrorest(\n    formula = fo,\n    data = temperature_df,\n    coords = c(\"x\", \"y\"),\n    model_fun = ranger,\n    model_args = list(num.trees = 100),\n    pred_fun = mypred,\n    smp_fun = partition_kmeans,\n    smp_args = list(repetition = 1:2, nfold = 3),\n    progress = FALSE\n)\nThe result is a list with several components, including the error at the repetition and fold levels, the resampling object, the variable importance (only when\nimportance = TRUE\n), the benchmark, and the package version.\nsummary(sp_res$error_rep)\nmean           sd        median          IQR\ntrain_bias     0.003667002 0.0224183696   0.003667002 0.0158521812\ntrain_stddev   0.399217628 0.0044832845   0.399217628 0.0031701609\ntrain_rmse     0.399038491 0.0042677806   0.399038491 0.0030177766\ntrain_mad      0.316892003 0.0078406248   0.316892003 0.0055441590\ntrain_median   0.033006028 0.0001897285   0.033006028 0.0001341583\ntrain_iqr      0.427813987 0.0083456683   0.427813987 0.0059012787\ntrain_count  390.000000000 0.0000000000 390.000000000 0.0000000000\ntest_bias     -0.009090677 0.0742284999  -0.009090677 0.0524874756\ntest_stddev    1.447676903 0.0934364402   1.447676903 0.0660695405\ntest_rmse      1.444959463 0.0926651037   1.444959463 0.0655241232\ntest_mad       1.341466967 0.1144815717   1.341466967 0.0809506957\ntest_median    0.101932523 0.0950544902   0.101932523 0.0672136746\ntest_iqr       1.876642239 0.1533036116   1.876642239 0.1084020233\ntest_count   195.000000000 0.0000000000 195.000000000 0.0000000000\nWe can contrast the obtained results with the non-spatial cross-validation by changing the sampling function to\npartition_cv()\n.\n# Non-spatial cross-validation\nset.seed(11)\nnsp_res <- sperrorest(\n    formula = fo,\n    data = temperature_df,\n    coords = c(\"x\", \"y\"),\n    model_fun = ranger,\n    model_args = list(num.trees = 100),\n    pred_fun = mypred,\n    smp_fun = partition_cv,\n    smp_args = list(repetition = 1:2, nfold = 3),\n    progress = FALSE\n)\nTo compare both results, we can plot the RMSE values for the training and testing sets of both spatial and non-spatial cross-validation.\nlibrary(ggplot2)\n# Extract train/test RMSE from spatial CV\nsp_train_rmse <- sp_res$error_rep$train_rmse\nsp_test_rmse <- sp_res$error_rep$test_rmse\n# Extract train/test RMSE from non-spatial CV\nnsp_train_rmse <- nsp_res$error_rep$train_rmse\nnsp_test_rmse <- nsp_res$error_rep$test_rmse\n# Build data frame\nrmse_df <- data.frame(\n    CV_Type = rep(c(\"Spatial\", \"Non-Spatial\"), each = 4),\n    Set = rep(c(\"Train\", \"Test\"), each = 2),\n    RMSE = c(sp_train_rmse, sp_test_rmse, nsp_train_rmse, nsp_test_rmse)\n)\nggplot(rmse_df, aes(x = CV_Type, y = RMSE, fill = Set)) +\n    geom_boxplot() +\n    facet_wrap(~Set) +\n    labs(title = \"RMSE Comparison\", x = \"CV Method\", y = \"RMSE\")\nThe results show that the estimation using the spatial-cross validation is less optimistic than the non-spatial cross-validation for the test set.\nMore examples of the package use can be found at\nhttps://giscience-fsu.github.io/sperrorest/articles/spatial-modeling-use-case.html\n/\nblockCV\nThe\nblockCV\n(\nhttps://doi.org/10.1111/2041-210X.13107\n) package provides a set of functions for block cross-validation, spatial and environmental clustering, and spatial autocorrelation estimation. The package itself does not fit the models.\n# remotes::install_github(\"cran/automap\")\nlibrary(blockCV)\nCross-validation strategies separate the data into training and testing sets to evaluate the model’s performance. The\nblockCV\npackage provides several cross-validation strategies, including block cross-validation, spatial clustering, environmental clustering, buffering LOO, and Nearest Neighbour Distance Matching (NNDM) LOO.\nThe block cross-validation is performed using the\ncv_spatial()\nfunction. It assigns blocks to the training and testing folds randomly, systematically or in a checkerboard pattern (the\nselection\nargument).\nset.seed(61)\nsb1 <- cv_spatial(\n    x = temperature,\n    k = 10, # number of folds\n    size = 300000, # size of the blocks in meters\n    selection = \"random\", # random blocks-to-fold\n    iteration = 50, # find evenly dispersed folds\n    progress = FALSE,\n    biomod2 = TRUE\n)\ntrain test\n1    170   25\n2    169   26\n3    171   24\n4    180   15\n5    181   14\n6    183   12\n7    182   13\n8    165   30\n9    179   16\n10   175   20\nThe result is a list with several components, including the folds list, the folds IDs, the biomod table, the number of folds, the input size, the column name, the blocks, and the records. For example, we can check the structure of the folds list with the\nstr()\nfunction.\nstr(sb1$folds_list)\nList of 10\n $ :List of 2\n  ..$ : int [1:170] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:25] 23 31 57 39 58 60 21 22 32 27 ...\n $ :List of 2\n  ..$ : int [1:169] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:26] 153 155 93 108 95 91 88 154 94 140 ...\n $ :List of 2\n  ..$ : int [1:171] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:24] 12 45 175 176 166 20 177 19 167 16 ...\n $ :List of 2\n  ..$ : int [1:180] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:15] 134 138 136 133 187 192 174 173 189 190 ...\n $ :List of 2\n  ..$ : int [1:181] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:14] 161 142 143 150 160 149 146 147 158 151 ...\n $ :List of 2\n  ..$ : int [1:183] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:12] 4 8 5 2 193 1 6 194 164 3 ...\n $ :List of 2\n  ..$ : int [1:182] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:13] 128 124 129 130 127 132 131 120 126 125 ...\n $ :List of 2\n  ..$ : int [1:165] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:30] 61 70 75 52 77 83 79 86 50 48 ...\n $ :List of 2\n  ..$ : int [1:179] 23 31 57 39 58 60 21 22 32 27 ...\n  ..$ : int [1:16] 117 87 103 84 105 99 119 101 98 97 ...\n $ :List of 2\n  ..$ : int [1:175] 117 87 103 84 105 99 119 101 98 97 ...\n  ..$ : int [1:20] 163 181 159 157 186 67 71 41 178 179 ...\nThe\ncv_plot()\nfunction additionally allows for the visualization of cross-validation results.\ncv_plot(sb1, temperature)\nLet’s compare the results of the block cross-validation with systematic and checkerboard patterns.\nset.seed(16)\nsb2 <- cv_spatial(\n    x = temperature,\n    k = 10,\n    rows_cols = c(4, 6),\n    hexagon = FALSE,\n    selection = \"systematic\"\n)\ntrain test\n1    172   23\n2    180   15\n3    177   18\n4    169   26\n5    178   17\n6    182   13\n7    180   15\n8    162   33\n9    178   17\n10   177   18\ncv_plot(sb2, temperature)\nset.seed(12)\nsb3 <- cv_spatial(\n    x = temperature,\n    k = 10,\n    size = 300000,\n    hexagon = FALSE,\n    selection = \"checkerboard\"\n)\ntrain test\n1    98   97\n2    97   98\ncv_plot(sb3, temperature)\nThe clustering strategies (\ncv_cluster()\n) are used to group the data into clusters based on spatial or environmental similarity. The spatial similarity is based only on the clustering of the spatial coordinates.\nset.seed(7)\nscv <- cv_cluster(x = temperature, k = 10)\ntrain test\n1    169   26\n2    169   26\n3    173   22\n4    178   17\n5    179   16\n6    182   13\n7    176   19\n8    171   24\n9    178   17\n10   180   15\ncv_plot(scv, temperature)\nThe environmental clustering, on the other hand, is based on the clustering of the values of the covariates extracted from the raster data.\nset.seed(2)\necv <- cv_cluster(x = temperature, r = covariates, k = 5, scale = TRUE)\ntrain test\n1   164   31\n2   190    5\n3   182   13\n4   154   41\n5    90  105\ncv_plot(ecv, temperature)\nThe next cross-validation strategy is buffering LOO (also known as Spatial LOO). It is performed using the\ncv_buffer()\nfunction, which selects a buffer around each point (test point) and uses the points outside the buffer as the testing set.\n3\nset.seed(21)\nbloo <- cv_buffer(x = temperature, size = 300000, progress = FALSE)\ntrain            test  \n Min.   : 97.0   Min.   :1  \n Mean   :132.7   Mean   :1  \n Max.   :170.0   Max.   :1\ncv_plot(bloo, temperature, num_plots = c(1, 50, 100))\nNote that above, we plot only the first, 50th, and 100th points to avoid overplotting.\nThe last cross-validation strategy implemented in the\nblockCV\npackage is the Nearest Neighbour Distance Matching (NNDM) LOO. It is performed using the\ncv_nndm()\nfunction, which tries to match the nearest neighbor distance distribution function between the test and training data to the nearest neighbor distance distribution function between the target prediction and training points. Thus, in this base, we need to provide more arguments, including a raster with the covariates, the number of samples, the sampling strategy, and the minimum training size.\nset.seed(12)\nnncv <- cv_nndm(\n    x = temperature,\n    r = covariates,\n    size = 300000,\n    num_sample = 5000,\n    sampling = \"regular\",\n    min_train = 0.1,\n    plot = TRUE\n)\ntrain            test  \n Min.   :192.0   Min.   :1  \n Mean   :192.9   Mean   :1  \n Max.   :193.0   Max.   :1\ncv_plot(nncv, temperature, num_plots = c(1, 50, 100))\nLet’s now use the block cross-validation to fit and evaluate a model.\n# define formula\nresponse_name <- \"temp\"\ncovariate_names <- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\nfo <- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))\n\n# extract the folds\nfolds <- sb1$folds_list\n\nmodel_rmse <- data.frame(fold = seq_along(folds), rmse = rep(NA, length(folds)))\n\nfor (k in seq_along(folds)) {\n    trainSet <- unlist(folds[[k]][1]) # training set indices; first element\n    testSet <- unlist(folds[[k]][2]) # testing set indices; second element\n    rf <- ranger(fo, temperature_df[trainSet, ], num.trees = 100) # model fitting on training set\n    pred <- predict(rf, temperature_df[testSet, ])$predictions # predict the test set\n    model_rmse[k, \"rmse\"] <- sqrt(mean(\n        (temperature_df[testSet, response_name] - pred)^2\n    )) # calculate RMSE\n}\nmodel_rmse\nfold      rmse\n1     1 1.1401856\n2     2 0.7848595\n3     3 0.9219486\n4     4 0.8007453\n5     5 0.6485726\n6     6 1.2989341\n7     7 0.8140209\n8     8 1.2050918\n9     9 0.9696801\n10   10 0.8681127\nThe\nblockCV\npackage also provides functions for checking the similarity between the folds (\ncv_similarity()\n) and estimating the effective range of spatial autocorrelation (\ncv_spatial_autocor()\n). The first function is used to check the similarity between the folds in the cross-validation.\ncv_similarity(cv = sb1, x = temperature, r = covariates, progress = FALSE)\nWarning: The following aesthetics were dropped during statistical transformation:\ncolour.\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe second function is used to estimate the effective range of spatial autocorrelation of all input raster layers or the response data – its role is to help to determine the size of the blocks in the block cross-validation.\ncv_spatial_autocor(r = covariates, num_sample = 5000, progress = FALSE)\n[1] \"cv_spatial_autocor\"\nMore examples of the package’s use can be found at\nhttps://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html\n.\nClosing remarks\nThis blog post concludes the series on machine learning for spatial data with R. It showed established frameworks for machine learning in R, such as\ncaret\n,\ntidymodels\n, and\nmlr3\n, but focused on how to use them for spatial data problems. Next, we presented specialized R packages for spatial machine learning, such as\nspatialRF\n,\nRandomForestsGLS\n, and\nmeteo\nand two R packages aimed for spatial cross-validation:\nsperrorest\nand\nblockCV\n.\nThe series focused on the so-called “classical” machine learning methods, with a focus on the random forest method. At the same time, the series did not cover deep learning methods, as they require a different approach and tools. You can find more information on deep learning in R in the documentation of the packages like\nkeras3\n(\nhttps://keras3.posit.co/\n),\ntorch\n(\nhttps://torch.mlverse.org/\n), or\nluz\n(\nhttps://mlverse.github.io/luz/\n). Moreover, the\nsits\npackage provides various deep learning tools for satellite image time series analysis – you can learn more about it in the book\n“Satellite Image Time Series Analysis on Earth Observation Data Cubes”\n.\nThe number of methods and tools for spatial machine learning is growing rapidly, and it is impossible to cover all of them in a single series. However, the presented packages and methods should provide a good starting point for anyone interested in spatial machine learning with R. If you have any suggestions for other packages and methods that should be included in this series, feel free to contact me – you can find my contact details on my\nwebsite\n.\nThis blog post was originally written as a supplement to the poster “An Inventory of Spatial Machine Learning Packages in R” presented at the FOSSGIS 2025 conference in Muenster, Germany. The poster is available at\nhttps://doi.org/10.5281/zenodo.15088973\n.\nFootnotes\nMore information on the custom prediction functions is at\nhttps://cran.r-project.org/web/packages/sperrorest/vignettes/custom-pred-and-model-functions.html\n.↩︎\nThere are several other partition functions available in the package, including\npartition_disc()\n,\npartition_tiles()\n, and\npartition_cv()\n.↩︎\nThis approach is a form of leave-one-out cross-validation.↩︎\nReuse\nCC BY 4.0\nCitation\nBibTeX citation:\n@online{nowosad2025,\n  author = {Nowosad, Jakub},\n  title = {Specialized {R} Packages for Spatial Cross-Validation:\n    Sperrorest and {blockCV}},\n  date = {2025-07-09},\n  url = {https://geocompx.org/post/2025/sml-bp6/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nNowosad, Jakub. 2025.\n“Specialized R Packages for Spatial\nCross-Validation: Sperrorest and blockCV.”\nJuly 9, 2025.\nhttps://geocompx.org/post/2025/sml-bp6/\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\ngeocompx\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "This is the sixth and the final blog post in a series on spatial machine learning with R. You can find the list of other blog posts in this series in part one. This document provides an overview of two R packages, sperrorest and blockCV,...",
      "meta_keywords": null,
      "og_description": "This is the sixth and the final blog post in a series on spatial machine learning with R. You can find the list of other blog posts in this series in part one. This document provides an overview of two R packages, sperrorest and blockCV,...",
      "og_image": "https://geocompx.org/post/2025/sml-bp6/index_files/figure-html/misc-scv-8-1.png",
      "og_title": "Specialized R packages for spatial cross-validation: sperrorest and blockCV | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 14,
      "sitemap_lastmod": null,
      "twitter_description": "This is the sixth and the final blog post in a series on spatial machine learning with R. You can find the list of other blog posts in this series in part one. This document provides an overview of two R packages, sperrorest and blockCV,...",
      "twitter_title": "Specialized R packages for spatial cross-validation: sperrorest and blockCV | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/07/specialized-r-packages-for-spatial-cross-validation-sperrorest-and-blockcv/",
      "word_count": 2809
    }
  }
}