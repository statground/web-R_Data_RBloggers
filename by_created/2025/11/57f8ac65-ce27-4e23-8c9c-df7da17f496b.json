{
  "uuid": "57f8ac65-ce27-4e23-8c9c-df7da17f496b",
  "created_at": "2025-11-22 19:59:16",
  "raw_json": {
    "article_author": null,
    "article_headline": null,
    "article_modified": null,
    "article_published": null,
    "article_section": null,
    "article_tags": null,
    "canonical_url": "https://www.r-bloggers.com/2025/02/using-options-to-inject-a-functions-internal-variable-for-reproducible-testing/",
    "crawled_at": "2025-11-22T10:54:12.912694",
    "external_links": [
      {
        "href": "https://b-rodrigues.github.io/posts/2025-02-13-testthat.html",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://www.youtube.com/watch?v=OOu6gjQ310c",
        "text": "here"
      },
      {
        "href": "https://b-rodrigues.github.io/posts/2025-02-13-testthat.html",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "h1_title": "R-bloggers",
    "html_title": "Using options() to inject a function’s internal variable for reproducible testing | R-bloggers",
    "images": [],
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/econometrics-and-free-software/",
        "text": "Econometrics and Free Software"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "lang": "en-US",
    "main_html": "<article class=\"post-390574 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Using options() to inject a function’s internal variable for reproducible testing</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">February 12, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/econometrics-and-free-software/\">Econometrics and Free Software</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://b-rodrigues.github.io/posts/2025-02-13-testthat.html\"> Econometrics and Free Software</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<p><em>No image this time</em></p>\n<p>Imagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you want your function to always reproduce this intermediary variable, regardless of what you give it as inputs. This can be useful for testing, if computing this intermediate variable is costly.</p>\n<p>In my <code>{rix}</code> package, the <code>rix()</code> function generates valid Nix expressions from R input and these Nix expressions can then be used to build reproducible development environments that include R, R packages, development libraries, and so on. If you want a 5-minute intro to <code>{rix}</code>, click <a href=\"https://www.youtube.com/watch?v=OOu6gjQ310c\" rel=\"nofollow\" target=\"_blank\">here</a>.</p>\n<p>Anyways, sometimes, computing these expressions can take some time, especially if the users wants to include remote dependencies that have themselves remote dependencies. <code>rix()</code> will try to look for suitable GitHub commits to pin all the packages for reproducibility purposes, and this can imply quite a lot of api calls. Now for my tests, I wanted to use an already generated <code>default.nix</code> file (which contains the generated Nix expression) but I didn’t want to have to recompute it every time I ran the test and I couldn’t simply use it as is for the test either. You see, that <code>default.nix</code> was in an intermediary state, before <code>rix()</code> is supposed to do some post-processing to it, which is what I actually want to test (I want to actually test the argument that makes <code>rix()</code> skip this post-processing step).</p>\n<p>So suppose <code>rix()</code> looks like this:</p>\n<div class=\"cell\">\n<pre>rix &lt;- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n  default.nix_file &lt;- ... # it's generated here\n  # Then a bunch of things happen to it\n  out &lt;- f(default.nix_file)\n  writeLines(out, path) # this is what's written\n}</pre>\n</div>\n<p>Now what I want is to be able to “overwrite” the <code>default.nix_file</code> variable on line 4 when testing, to provide want I want. This way, I can call <code>rix()</code> with some “easy” parameters that make the computations up to that point very quick. My goal is essentially to test <code>f()</code> (line 6), which begs the question, why not write <code>f()</code> as a separate function and test it? This would be the best practice, however, I don’t really have such an <code>f()</code>, rather it’s a series of complicated steps that follow and rewriting everything to make it easily testable would just take too much time.</p>\n<p>Instead, I opted for the following:</p>\n<div class=\"cell\">\n<pre>rix &lt;- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n\n  stub_default.nix &lt;- getOption(\"TESTTHAT_DEFAULT.NIX\", default = NULL)\n\n  if(!is.null(stub_default.nix)){\n    default.nix_file &lt;- readLines(stub_default.nix)\n  } else {\n    default.nix_file &lt;- ... # it's generated here if not being tested\n  }\n  out &lt;- f(default.nix_file)\n  # Then a bunch of things happen to it\n  writeLines(out, path) # this is what's written\n}</pre>\n</div>\n<p>On line 5, I get the option <code>\"TESTTHAT_DEFAULT.NIX\"</code> and if it doesn’t exist, <code>stub_default.nix</code> will be set to <code>NULL</code>. So if it’s <code>NULL</code> it’s business as usual, if not, then that <code>default.nix</code> file dedicated for testing gets passed further down. In a sense, I injected the variable I needed in the spot I needed.</p>\n<p>Then, my tests looks like this:</p>\n<div class=\"cell\">\n<pre>testthat::test_that(\"remove_duplicate_entries(), don't remove duplicates if skip\", {\n\n\n  dups_entries_default.nix &lt;- paste0(\n    testthat::test_path(),\n    \"/testdata/default-nix_samples/dups-entries_default.nix\")\n\n  tmpdir &lt;- tempdir()\n\n  # This copies the file I need in the right path\n  destination_file &lt;- file.path(tempdir(), basename(dups_entries_default.nix))\n  file.copy(dups_entries_default.nix, destination_file, overwrite = TRUE)\n\n  on.exit(\n    unlink(tmpdir, recursive = TRUE, force = TRUE),\n    add = TRUE\n  )\n\n  removed_dups &lt;- function(destination_file) {\n\n    # Set the option to the file path and clean the option afterwards\n    op &lt;- options(\"TESTTHAT_DEFAULT.NIX\" = destination_file)\n    on.exit(options(op), add = TRUE, after = FALSE)\n\n    out &lt;- rix(\n      date = \"2025-02-10\",\n      project_path = tmpdir,\n      overwrite = TRUE,\n      skip_post_processing = TRUE) # &lt;- this is actually want I wanted to test\n    file.path(destination_file)\n  }\n\n\n  testthat::expect_snapshot_file(\n    path = removed_dups(destination_file),\n    name = \"skip-dups-entries_default.nix\",\n  )\n})</pre>\n</div>\n<p>On line 22, I set the option and on line 23 I write code to remove that option once the test is done, to not mess up subsequent tests. This is a snapshot test, so now I can take a look at the resulting file, and indeed make sure that post-processing was skipped, as expected.</p>\n<p>How would you have done this?</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://b-rodrigues.github.io/posts/2025-02-13-testthat.html\"> Econometrics and Free Software</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "main_text": "Using options() to inject a function’s internal variable for reproducible testing\nPosted on\nFebruary 12, 2025\nby\nEconometrics and Free Software\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nEconometrics and Free Software\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nNo image this time\nImagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you want your function to always reproduce this intermediary variable, regardless of what you give it as inputs. This can be useful for testing, if computing this intermediate variable is costly.\nIn my\n{rix}\npackage, the\nrix()\nfunction generates valid Nix expressions from R input and these Nix expressions can then be used to build reproducible development environments that include R, R packages, development libraries, and so on. If you want a 5-minute intro to\n{rix}\n, click\nhere\n.\nAnyways, sometimes, computing these expressions can take some time, especially if the users wants to include remote dependencies that have themselves remote dependencies.\nrix()\nwill try to look for suitable GitHub commits to pin all the packages for reproducibility purposes, and this can imply quite a lot of api calls. Now for my tests, I wanted to use an already generated\ndefault.nix\nfile (which contains the generated Nix expression) but I didn’t want to have to recompute it every time I ran the test and I couldn’t simply use it as is for the test either. You see, that\ndefault.nix\nwas in an intermediary state, before\nrix()\nis supposed to do some post-processing to it, which is what I actually want to test (I want to actually test the argument that makes\nrix()\nskip this post-processing step).\nSo suppose\nrix()\nlooks like this:\nrix <- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n  default.nix_file <- ... # it's generated here\n  # Then a bunch of things happen to it\n  out <- f(default.nix_file)\n  writeLines(out, path) # this is what's written\n}\nNow what I want is to be able to “overwrite” the\ndefault.nix_file\nvariable on line 4 when testing, to provide want I want. This way, I can call\nrix()\nwith some “easy” parameters that make the computations up to that point very quick. My goal is essentially to test\nf()\n(line 6), which begs the question, why not write\nf()\nas a separate function and test it? This would be the best practice, however, I don’t really have such an\nf()\n, rather it’s a series of complicated steps that follow and rewriting everything to make it easily testable would just take too much time.\nInstead, I opted for the following:\nrix <- function(a,b,c){\n  ... # lots of code\n  ... # lots of code\n\n  stub_default.nix <- getOption(\"TESTTHAT_DEFAULT.NIX\", default = NULL)\n\n  if(!is.null(stub_default.nix)){\n    default.nix_file <- readLines(stub_default.nix)\n  } else {\n    default.nix_file <- ... # it's generated here if not being tested\n  }\n  out <- f(default.nix_file)\n  # Then a bunch of things happen to it\n  writeLines(out, path) # this is what's written\n}\nOn line 5, I get the option\n\"TESTTHAT_DEFAULT.NIX\"\nand if it doesn’t exist,\nstub_default.nix\nwill be set to\nNULL\n. So if it’s\nNULL\nit’s business as usual, if not, then that\ndefault.nix\nfile dedicated for testing gets passed further down. In a sense, I injected the variable I needed in the spot I needed.\nThen, my tests looks like this:\ntestthat::test_that(\"remove_duplicate_entries(), don't remove duplicates if skip\", {\n\n  dups_entries_default.nix <- paste0(\n    testthat::test_path(),\n    \"/testdata/default-nix_samples/dups-entries_default.nix\")\n\n  tmpdir <- tempdir()\n\n  # This copies the file I need in the right path\n  destination_file <- file.path(tempdir(), basename(dups_entries_default.nix))\n  file.copy(dups_entries_default.nix, destination_file, overwrite = TRUE)\n\n  on.exit(\n    unlink(tmpdir, recursive = TRUE, force = TRUE),\n    add = TRUE\n  )\n\n  removed_dups <- function(destination_file) {\n\n    # Set the option to the file path and clean the option afterwards\n    op <- options(\"TESTTHAT_DEFAULT.NIX\" = destination_file)\n    on.exit(options(op), add = TRUE, after = FALSE)\n\n    out <- rix(\n      date = \"2025-02-10\",\n      project_path = tmpdir,\n      overwrite = TRUE,\n      skip_post_processing = TRUE) # <- this is actually want I wanted to test\n    file.path(destination_file)\n  }\n\n  testthat::expect_snapshot_file(\n    path = removed_dups(destination_file),\n    name = \"skip-dups-entries_default.nix\",\n  )\n})\nOn line 22, I set the option and on line 23 I write code to remove that option once the test is done, to not mess up subsequent tests. This is a snapshot test, so now I can take a look at the resulting file, and indeed make sure that post-processing was skipped, as expected.\nHow would you have done this?\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nEconometrics and Free Software\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "meta_description": "No image this time Imagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you wan...",
    "meta_keywords": null,
    "og_description": "No image this time Imagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you wan...",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "og_title": "Using options() to inject a function’s internal variable for reproducible testing | R-bloggers",
    "raw_jsonld_article": null,
    "reading_time_min": 4.4,
    "sitemap_lastmod": null,
    "twitter_description": "No image this time Imagine you have a function that does something complicated, and in the middle of its definition it generates a variable. Now suppose that you want to save this variable and then re-use it for tests, what I mean is that you wan...",
    "twitter_title": "Using options() to inject a function’s internal variable for reproducible testing | R-bloggers",
    "url": "https://www.r-bloggers.com/2025/02/using-options-to-inject-a-functions-internal-variable-for-reproducible-testing/",
    "word_count": 879
  }
}