{
  "id": "c5818bd8ea3bb7b130417b12b55967536ab5727e",
  "url": "https://www.r-bloggers.com/2025/08/affordable-shiny-app-hosting-for-500-concurrent-users/",
  "created_at_utc": "2025-11-22T19:57:52Z",
  "data": null,
  "raw_original": {
    "uuid": "948881f2-eb16-4804-bb3f-36766d6d9bdd",
    "created_at": "2025-11-22 19:57:52",
    "raw_json": {
      "article_author": null,
      "article_headline": null,
      "article_modified": null,
      "article_published": null,
      "article_section": null,
      "article_tags": null,
      "canonical_url": "https://www.r-bloggers.com/2025/08/affordable-shiny-app-hosting-for-500-concurrent-users/",
      "crawled_at": "2025-11-22T10:44:13.465857",
      "external_links": [
        {
          "href": "https://www.openanalytics.eu/blog/2025/08/19/shinyproxy-cost-effective-public-app/",
          "text": "Open Analytics"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        },
        {
          "href": "https://shinyproxy.io/documentation/shinyproxy-operator/docker/#tutorial",
          "text": "documentation"
        },
        {
          "href": "https://shinyproxy.io/documentation/deploying-apps/",
          "text": "documentation"
        },
        {
          "href": "https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png?ssl=1",
          "text": null
        },
        {
          "href": "https://shinyproxy.io/documentation/configuration/#container-pre-initialization-and-sharing",
          "text": "pre-initialization and container-sharing"
        },
        {
          "href": "https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-no-capacity.png?ssl=1",
          "text": null
        },
        {
          "href": "https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-seat-wait-time.png?ssl=1",
          "text": null
        },
        {
          "href": "https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats2.png?ssl=1",
          "text": null
        },
        {
          "href": "https://shinyproxy.io/support/",
          "text": "questions or suggestions"
        },
        {
          "href": "https://www.openanalytics.eu/blog/2025/08/19/shinyproxy-cost-effective-public-app/",
          "text": "Open Analytics"
        },
        {
          "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
          "text": "daily e-mail updates"
        },
        {
          "href": "https://www.r-project.org/",
          "text": "R"
        },
        {
          "href": "https://www.r-users.com/",
          "text": "Click here if you're looking to post or find an R/data-science job"
        },
        {
          "href": "http://r-posts.com/",
          "text": "here"
        }
      ],
      "h1_title": "R-bloggers",
      "html_title": "Affordable Shiny app hosting for 500 concurrent users | R-bloggers",
      "images": [
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png?w=578&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-no-capacity.png?w=578&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-seat-wait-time.png?w=578&ssl=1"
        },
        {
          "alt": null,
          "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif"
        },
        {
          "alt": null,
          "base64": null,
          "src": "https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats2.png?w=578&ssl=1"
        }
      ],
      "internal_links": [
        {
          "href": "https://www.r-bloggers.com/author/open-analytics/",
          "text": "Open Analytics"
        },
        {
          "href": "https://www.r-bloggers.com/category/r-bloggers/",
          "text": "R bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers"
        },
        {
          "href": "https://www.r-bloggers.com/contact-us/",
          "text": "here"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        },
        {
          "href": "https://www.r-bloggers.com/",
          "text": "R-bloggers.com"
        },
        {
          "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
          "text": "learning R"
        },
        {
          "href": "https://www.r-bloggers.com/add-your-blog/",
          "text": "click here"
        }
      ],
      "lang": "en-US",
      "main_html": "<article class=\"post-394857 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Affordable Shiny app hosting for 500 concurrent users</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">August 19, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/open-analytics/\">Open Analytics</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://www.openanalytics.eu/blog/2025/08/19/shinyproxy-cost-effective-public-app/\"> Open Analytics</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<p>Cloud providers are no longer just offering traditional x86-based servers,\nARM-based servers are now becoming a serious alternative. And for good reason:\nthey’re often far more cost-effective and power-efficient than their x86\ncounterparts. For instance, we found a provider offering a server with 16\nvirtual cores and 32 GB of RAM for just €30 per month. To be realistic, most\nproviders charge between €100 and €200 per month for such a server. These\nmore expensive servers usually have less customers on a single server, improving\nthe real life performance. In this post, we’ll put one of these budget-friendly\nARM servers to the test. Of course, similar results can be achieved with an\nIntel or AMD server. The goal is to set up a production-grade ShinyProxy\nenvironment, designed to host a single public app, and see how many concurrent\nusers it can realistically handle. (And yes, the title probably gives a hint\nalready!).</p>\n<p>Although this post focuses on a specific use case, the same principles also\napply when running multiple apps with authentication.</p>\n<h2 id=\"server-selection\">Server selection</h2>\n<p>The first step is to pick a cloud provider and order a server. Choose a\ndatacenter that’s located close to your end users to minimize latency and\nimprove performance. Most providers also allow you to resize your server later\nby adding more CPU or RAM, so you can start small and scale up as demand grows.\nMake sure the server comes with a public IP address, since there is no need for\na load balancer in this setup.</p>\n<p>When it comes to the operating system, you can use any Linux distribution you\nprefer. In this tutorial, we’ll use Ubuntu 24.04. Once your server is\nprovisioned, the next step is to connect via SSH. Usually your cloud provider\nprovides documentation that explains how to do this.</p>\n<p>As a final prerequisite, you’ll need a domain name. This makes it easier to\naccess your server using a human-friendly address and is also necessary for\nconfiguring TLS. You can use either a root domain (e.g. <code>example.com</code>) or a\nsubdomain (e.g. <code>shinyproxy.example.com</code>). In your domain’s DNS settings, create\nan A record that points the domain or subdomain to your server’s public IP\naddress.</p>\n<h2 id=\"installation\">Installation</h2>\n<p>With the server up and running, the next step is to install the ShinyProxy\nOperator. This tool takes care of the ShinyProxy installation process as well as\nall the required side components, so you don’t have to manage them manually. For\ndetailed instructions, follow the\nofficial <a href=\"https://shinyproxy.io/documentation/shinyproxy-operator/docker/#tutorial\" rel=\"nofollow\" target=\"_blank\">documentation</a>.\nFor the best setup, make sure to enable TLS and the monitoring stack. At this\npoint you should be able to login and start the demo app.</p>\n<h2 id=\"inspecting-the-resource-consumption-of-the-app\">Inspecting the resource consumption of the app</h2>\n<p>With ShinyProxy deployed, you can deploy your app. Once again, the\n<a href=\"https://shinyproxy.io/documentation/deploying-apps/\" rel=\"nofollow\" target=\"_blank\">documentation</a> contains\neverything you need to know. To keep things simple, you can build the Docker\nimage on the server. For example, clone your Git repository with all your code on the\nserver and build the image using Docker. This way, you don’t need a container\nregistry. After you added the app to the ShinyProxy configuration, you can start\nit through ShinyProxy. In order to know how many concurrent\nusers are supported by the server, it’s a good idea to first have a look at the\nresources consumed by the app. Start the app, perform some user actions and run\nthe following command:</p>\n<pre>sudo docker stats\n</pre>\n<p>The output will be similar too:</p>\n<p><a href=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png?ssl=1\" rel=\"nofollow\" target=\"_blank\"><img border=\"0\" class=\"img-responsive\" data-lazy-src=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"auto\"/><noscript><img border=\"0\" class=\"img-responsive\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png?w=578&amp;ssl=1\" width=\"auto\"/></noscript></a></p>\n<p>The last line in the screenshot shows the container running our Shiny app. It\nuses about 125 MiB of RAM and very little CPU time. Keep in mind that we’re\nworking with a small demo app, CPU usage will increase if your app processes\nmore data or performs heavier computations. Most Shiny apps typically use less\nthan 500 MiB of RAM, but some can consume multiple gigabytes, especially when\nloading large datasets. To keep our example realistic, we’ll assume each app\nrequires 500 MiB of RAM. The other system components (including ShinyProxy) also\nconsume some memory. In the screenshot, these consume about 1.5 GiB. ShinyProxy\ngenerally requires up to 2 GiB of RAM. To avoid degrading server performance,\nit’s a good practice to leave a few gigabytes free. For this setup, we’ll\nreserve 4 GiB for ShinyProxy and the server itself, leaving 28 GiB available for\nthe Shiny containers. With each container using 0.5 GiB, this allows us to run\nup to 56 containers concurrently.</p>\n<h2 id=\"optimizing-the-configuration\">Optimizing the configuration</h2>\n<p>Originally, ShinyProxy created a new container for each user. While this approach\nis simple and improves security, it’s not ideal for hosting a public app with\nmany users. Fortunately, since quite some time, ShinyProxy has excellent\nsupport for what we\ncall <a href=\"https://shinyproxy.io/documentation/configuration/#container-pre-initialization-and-sharing\" rel=\"nofollow\" target=\"_blank\">pre-initialization and container-sharing</a>.\nWith this feature, a single container can serve multiple users simultaneously.\nSince the containers are pre-initialized, loading times are minimal. However,\neach Shiny container still has a limit on the number of users it can handle. For\nsimple dashboards, you can typically expect about 20 concurrent users per\ncontainer. In our example, we’ll assume 10 concurrent users per container. Given\nour 56 containers, this setup allows the server to handle up to 560 concurrent\nusers. To stay on the safe side and avoid overloading the server, we’ll round\nthis down to 500 concurrent users.</p>\n<p>With these numbers in mind, it’s time to adjust the configuration. Let’s start\nwith the app configuration.</p>\n<pre>proxy:\nspecs:\n- id: my-app\ncontainer-image: openanalytics/shinyproxy-demo\nseats-per-container: 10\nmax-total-instances: 500\nminimum-seats-available: 500\n</pre>\n<p>The <code>seats-per-container: 10</code> setting tells ShinyProxy that each container can\nhandle 10 users or “seats”. To prevent overloading the server, we limit the\ntotal number of concurrent users to 500 with the <code>max-total-instances: 500</code>\nsetting. If more than 500 users try to access the app at the same time, they\nwill see a message indicating that not enough capacity is available. Additionally, the\n<code>minimum-seats-available: 500</code> setting ensures that ShinyProxy pre-creates 50\ncontainers and keeps them running, so users can start the app immediately\nwithout waiting for containers to initialize.</p>\n<p><a href=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-no-capacity.png?ssl=1\" rel=\"nofollow\" target=\"_blank\"><img border=\"0\" class=\"img-responsive\" data-lazy-src=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-no-capacity.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"auto\"/><noscript><img border=\"0\" class=\"img-responsive\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-no-capacity.png?w=578&amp;ssl=1\" width=\"auto\"/></noscript></a></p>\n<p>In this example, we estimated the maximum number of concurrent users and limited\nthe server to that value. Since we’re deploying only one app, it makes sense to\ncreate all containers at startup. However, if you are hosting multiple apps on a\nsingle server (which ShinyProxy fully supports), it’s better to start with just a\nfew containers per app. ShinyProxy automatically creates new containers as\nusers begin accessing the apps, ensuring resources are used efficiently.</p>\n<p>While you are updating the configuration of ShinyProxy, add (or update) the\nfollowing settings as well:</p>\n<pre>proxy:\nhide-navbar: true\nlanding-page: SingleApp\nauthentication: none\n# ...\nmemory-limit: 2Gi\n</pre>\n<p>The first property hides the ShinyProxy navbar, which is often unnecessary when\nhosting a single public app. By setting <code>landing-page: SingleApp</code>, users are\nautomatically redirected to the app when they visit the landing page. Since this\nis a public app, we also disable authentication. Finally, we limit the memory\nthat ShinyProxy can use to ensure there is always enough RAM available for the\nShiny apps.</p>\n<p>After updating the configuration, the operator creates a new ShinyProxy instance\nwith the updated settings. This process usually takes a few minutes. You might\nsee a “forbidden” page if you previously logged in using a username and\npassword. This happens only once when switching from <code>authentication: simple</code> to\n<code>authentication: none</code>. To fix it, simply clear the ShinyProxy cookies in your\nbrowser.</p>\n<h2 id=\"testing-the-performance\">Testing the performance</h2>\n<p>As soon as ShinyProxy starts, it creates 50 new containers. When you launch your\napp, it loads almost instantly, thanks to the pre-initialized containers. We\ntested this setup with 500 browser sessions, and the system handled them\neffortlessly. Both ShinyProxy and the Shiny app responded quickly, and the server\nload remained minimal. Of course, actual performance depends on the resource\nconsumption of your app, but ShinyProxy is designed to manage these variations\nefficiently. The setup demonstrates that even a single ARM-based server can\neasily manage hundreds of concurrent users, delivering robust, production-grade\nperformance.</p>\n<p>The first panel in the screenshot shows how long users wait before being\nassigned a seat, and the second panel shows the number of available seats. When\nwe launched 500 sessions within just two minutes, the available seats dropped\nquickly. Even so, loading times stayed at only a few milliseconds, which makes\nit clear that ShinyProxy remains highly responsive during a sudden surge of\nhundreds of new sessions.</p>\n<p><a href=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-seat-wait-time.png?ssl=1\" rel=\"nofollow\" target=\"_blank\"><img border=\"0\" class=\"img-responsive\" data-lazy-src=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-seat-wait-time.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"auto\"/><noscript><img border=\"0\" class=\"img-responsive\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/www.openanalytics.eu/blog-img/shinyproxy-seat-wait-time.png?w=578&amp;ssl=1\" width=\"auto\"/></noscript></a></p>\n<p>Once all apps are loaded, ShinyProxy’s CPU usage drops and remains low, as shown\nby the <code>docker stats</code> output:</p>\n<p><a href=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats2.png?ssl=1\" rel=\"nofollow\" target=\"_blank\"><img border=\"0\" class=\"img-responsive\" data-lazy-src=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats2.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" width=\"auto\"/><noscript><img border=\"0\" class=\"img-responsive\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/www.openanalytics.eu/blog-img/shinyproxy-docker-stats2.png?w=578&amp;ssl=1\" width=\"auto\"/></noscript></a></p>\n<h2 id=\"monitoring\">Monitoring</h2>\n<p>Although the monitoring stack was enabled when ShinyProxy was first deployed,\ndisabling authentication means that Grafana is no longer accessible through\nShinyProxy. A simple workaround is to deploy a second ShinyProxy instance that\nstill uses authentication. This private instance can also serve as a testing\nenvironment for new development versions of your app before deploying them to\nthe public production server. To set this up, create a new configuration file in\nthe input directory, for example <code>private.shinyproxy.yaml</code>, and add the\nfollowing code:</p>\n<pre>server:\nservlet:\ncontext-path: /private\n</pre>\n<p>Be sure to update the <code>proxy.realm-id</code>, for example by setting it to <code>private</code>.</p>\n<p>After deploying the server, you can access it at the same hostname as the main\nserver, but under the <code>/private/</code> sub-path. For instance, if your server is\navailable at <code>http://localhost/,</code> the private instance is accessible at\n<code>http://localhost/private/</code>, and Grafana at <code>http://localhost/private/grafana/</code>.\nTo view the logs and metrics of the public instance, you need to adjust the\nnamespace variable in the dashboards.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>With the introduction of the ShinyProxy Operator for Docker, setting up a\nproduction-grade ShinyProxy server has never been easier. This post demonstrates\nthat only minimal configuration is needed to handle a large number of concurrent\nusers. Expensive servers or clusters aren’t required, just a single server is\nsufficient. If you need to support more users, simply scale up the server: in\nmost cases, doubling CPU and RAM roughly doubles the number of concurrent users.\nCompared to the resource usage of the Shiny apps themselves, ShinyProxy consumes\nvery little CPU and RAM, so it rarely becomes a bottleneck even under heavy\nload.</p>\n<p>Don’t hesitate to send in <a href=\"https://shinyproxy.io/support/\" rel=\"nofollow\" target=\"_blank\">questions or suggestions</a> and have fun with ShinyProxy!</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://www.openanalytics.eu/blog/2025/08/19/shinyproxy-cost-effective-public-app/\"> Open Analytics</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
      "main_text": "Affordable Shiny app hosting for 500 concurrent users\nPosted on\nAugust 19, 2025\nby\nOpen Analytics\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nOpen Analytics\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nCloud providers are no longer just offering traditional x86-based servers,\nARM-based servers are now becoming a serious alternative. And for good reason:\nthey’re often far more cost-effective and power-efficient than their x86\ncounterparts. For instance, we found a provider offering a server with 16\nvirtual cores and 32 GB of RAM for just €30 per month. To be realistic, most\nproviders charge between €100 and €200 per month for such a server. These\nmore expensive servers usually have less customers on a single server, improving\nthe real life performance. In this post, we’ll put one of these budget-friendly\nARM servers to the test. Of course, similar results can be achieved with an\nIntel or AMD server. The goal is to set up a production-grade ShinyProxy\nenvironment, designed to host a single public app, and see how many concurrent\nusers it can realistically handle. (And yes, the title probably gives a hint\nalready!).\nAlthough this post focuses on a specific use case, the same principles also\napply when running multiple apps with authentication.\nServer selection\nThe first step is to pick a cloud provider and order a server. Choose a\ndatacenter that’s located close to your end users to minimize latency and\nimprove performance. Most providers also allow you to resize your server later\nby adding more CPU or RAM, so you can start small and scale up as demand grows.\nMake sure the server comes with a public IP address, since there is no need for\na load balancer in this setup.\nWhen it comes to the operating system, you can use any Linux distribution you\nprefer. In this tutorial, we’ll use Ubuntu 24.04. Once your server is\nprovisioned, the next step is to connect via SSH. Usually your cloud provider\nprovides documentation that explains how to do this.\nAs a final prerequisite, you’ll need a domain name. This makes it easier to\naccess your server using a human-friendly address and is also necessary for\nconfiguring TLS. You can use either a root domain (e.g.\nexample.com\n) or a\nsubdomain (e.g.\nshinyproxy.example.com\n). In your domain’s DNS settings, create\nan A record that points the domain or subdomain to your server’s public IP\naddress.\nInstallation\nWith the server up and running, the next step is to install the ShinyProxy\nOperator. This tool takes care of the ShinyProxy installation process as well as\nall the required side components, so you don’t have to manage them manually. For\ndetailed instructions, follow the\nofficial\ndocumentation\n.\nFor the best setup, make sure to enable TLS and the monitoring stack. At this\npoint you should be able to login and start the demo app.\nInspecting the resource consumption of the app\nWith ShinyProxy deployed, you can deploy your app. Once again, the\ndocumentation\ncontains\neverything you need to know. To keep things simple, you can build the Docker\nimage on the server. For example, clone your Git repository with all your code on the\nserver and build the image using Docker. This way, you don’t need a container\nregistry. After you added the app to the ShinyProxy configuration, you can start\nit through ShinyProxy. In order to know how many concurrent\nusers are supported by the server, it’s a good idea to first have a look at the\nresources consumed by the app. Start the app, perform some user actions and run\nthe following command:\nsudo docker stats\nThe output will be similar too:\nThe last line in the screenshot shows the container running our Shiny app. It\nuses about 125 MiB of RAM and very little CPU time. Keep in mind that we’re\nworking with a small demo app, CPU usage will increase if your app processes\nmore data or performs heavier computations. Most Shiny apps typically use less\nthan 500 MiB of RAM, but some can consume multiple gigabytes, especially when\nloading large datasets. To keep our example realistic, we’ll assume each app\nrequires 500 MiB of RAM. The other system components (including ShinyProxy) also\nconsume some memory. In the screenshot, these consume about 1.5 GiB. ShinyProxy\ngenerally requires up to 2 GiB of RAM. To avoid degrading server performance,\nit’s a good practice to leave a few gigabytes free. For this setup, we’ll\nreserve 4 GiB for ShinyProxy and the server itself, leaving 28 GiB available for\nthe Shiny containers. With each container using 0.5 GiB, this allows us to run\nup to 56 containers concurrently.\nOptimizing the configuration\nOriginally, ShinyProxy created a new container for each user. While this approach\nis simple and improves security, it’s not ideal for hosting a public app with\nmany users. Fortunately, since quite some time, ShinyProxy has excellent\nsupport for what we\ncall\npre-initialization and container-sharing\n.\nWith this feature, a single container can serve multiple users simultaneously.\nSince the containers are pre-initialized, loading times are minimal. However,\neach Shiny container still has a limit on the number of users it can handle. For\nsimple dashboards, you can typically expect about 20 concurrent users per\ncontainer. In our example, we’ll assume 10 concurrent users per container. Given\nour 56 containers, this setup allows the server to handle up to 560 concurrent\nusers. To stay on the safe side and avoid overloading the server, we’ll round\nthis down to 500 concurrent users.\nWith these numbers in mind, it’s time to adjust the configuration. Let’s start\nwith the app configuration.\nproxy:\nspecs:\n- id: my-app\ncontainer-image: openanalytics/shinyproxy-demo\nseats-per-container: 10\nmax-total-instances: 500\nminimum-seats-available: 500\nThe\nseats-per-container: 10\nsetting tells ShinyProxy that each container can\nhandle 10 users or “seats”. To prevent overloading the server, we limit the\ntotal number of concurrent users to 500 with the\nmax-total-instances: 500\nsetting. If more than 500 users try to access the app at the same time, they\nwill see a message indicating that not enough capacity is available. Additionally, the\nminimum-seats-available: 500\nsetting ensures that ShinyProxy pre-creates 50\ncontainers and keeps them running, so users can start the app immediately\nwithout waiting for containers to initialize.\nIn this example, we estimated the maximum number of concurrent users and limited\nthe server to that value. Since we’re deploying only one app, it makes sense to\ncreate all containers at startup. However, if you are hosting multiple apps on a\nsingle server (which ShinyProxy fully supports), it’s better to start with just a\nfew containers per app. ShinyProxy automatically creates new containers as\nusers begin accessing the apps, ensuring resources are used efficiently.\nWhile you are updating the configuration of ShinyProxy, add (or update) the\nfollowing settings as well:\nproxy:\nhide-navbar: true\nlanding-page: SingleApp\nauthentication: none\n# ...\nmemory-limit: 2Gi\nThe first property hides the ShinyProxy navbar, which is often unnecessary when\nhosting a single public app. By setting\nlanding-page: SingleApp\n, users are\nautomatically redirected to the app when they visit the landing page. Since this\nis a public app, we also disable authentication. Finally, we limit the memory\nthat ShinyProxy can use to ensure there is always enough RAM available for the\nShiny apps.\nAfter updating the configuration, the operator creates a new ShinyProxy instance\nwith the updated settings. This process usually takes a few minutes. You might\nsee a “forbidden” page if you previously logged in using a username and\npassword. This happens only once when switching from\nauthentication: simple\nto\nauthentication: none\n. To fix it, simply clear the ShinyProxy cookies in your\nbrowser.\nTesting the performance\nAs soon as ShinyProxy starts, it creates 50 new containers. When you launch your\napp, it loads almost instantly, thanks to the pre-initialized containers. We\ntested this setup with 500 browser sessions, and the system handled them\neffortlessly. Both ShinyProxy and the Shiny app responded quickly, and the server\nload remained minimal. Of course, actual performance depends on the resource\nconsumption of your app, but ShinyProxy is designed to manage these variations\nefficiently. The setup demonstrates that even a single ARM-based server can\neasily manage hundreds of concurrent users, delivering robust, production-grade\nperformance.\nThe first panel in the screenshot shows how long users wait before being\nassigned a seat, and the second panel shows the number of available seats. When\nwe launched 500 sessions within just two minutes, the available seats dropped\nquickly. Even so, loading times stayed at only a few milliseconds, which makes\nit clear that ShinyProxy remains highly responsive during a sudden surge of\nhundreds of new sessions.\nOnce all apps are loaded, ShinyProxy’s CPU usage drops and remains low, as shown\nby the\ndocker stats\noutput:\nMonitoring\nAlthough the monitoring stack was enabled when ShinyProxy was first deployed,\ndisabling authentication means that Grafana is no longer accessible through\nShinyProxy. A simple workaround is to deploy a second ShinyProxy instance that\nstill uses authentication. This private instance can also serve as a testing\nenvironment for new development versions of your app before deploying them to\nthe public production server. To set this up, create a new configuration file in\nthe input directory, for example\nprivate.shinyproxy.yaml\n, and add the\nfollowing code:\nserver:\nservlet:\ncontext-path: /private\nBe sure to update the\nproxy.realm-id\n, for example by setting it to\nprivate\n.\nAfter deploying the server, you can access it at the same hostname as the main\nserver, but under the\n/private/\nsub-path. For instance, if your server is\navailable at\nhttp://localhost/,\nthe private instance is accessible at\nhttp://localhost/private/\n, and Grafana at\nhttp://localhost/private/grafana/\n.\nTo view the logs and metrics of the public instance, you need to adjust the\nnamespace variable in the dashboards.\nConclusion\nWith the introduction of the ShinyProxy Operator for Docker, setting up a\nproduction-grade ShinyProxy server has never been easier. This post demonstrates\nthat only minimal configuration is needed to handle a large number of concurrent\nusers. Expensive servers or clusters aren’t required, just a single server is\nsufficient. If you need to support more users, simply scale up the server: in\nmost cases, doubling CPU and RAM roughly doubles the number of concurrent users.\nCompared to the resource usage of the Shiny apps themselves, ShinyProxy consumes\nvery little CPU and RAM, so it rarely becomes a bottleneck even under heavy\nload.\nDon’t hesitate to send in\nquestions or suggestions\nand have fun with ShinyProxy!\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nOpen Analytics\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
      "meta_description": "Cloud providers are no longer just offering traditional x86-based servers, ARM-based servers are now becoming a serious alternative. And for good reason: they’re often far more cost-effective and power-efficient than their x86 counterparts. For ...",
      "meta_keywords": null,
      "og_description": "Cloud providers are no longer just offering traditional x86-based servers, ARM-based servers are now becoming a serious alternative. And for good reason: they’re often far more cost-effective and power-efficient than their x86 counterparts. For ...",
      "og_image": "https://www.openanalytics.eu/blog-img/shinyproxy-docker-stats.png",
      "og_title": "Affordable Shiny app hosting for 500 concurrent users | R-bloggers",
      "raw_jsonld_article": null,
      "reading_time_min": 9.5,
      "sitemap_lastmod": null,
      "twitter_description": "Cloud providers are no longer just offering traditional x86-based servers, ARM-based servers are now becoming a serious alternative. And for good reason: they’re often far more cost-effective and power-efficient than their x86 counterparts. For ...",
      "twitter_title": "Affordable Shiny app hosting for 500 concurrent users | R-bloggers",
      "url": "https://www.r-bloggers.com/2025/08/affordable-shiny-app-hosting-for-500-concurrent-users/",
      "word_count": 1897
    }
  }
}