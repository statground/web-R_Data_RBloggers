{
  "id": "3bf8541e52facc18a96617287d8d8a3033560300",
  "url": "https://www.r-bloggers.com/2025/10/behavior-driven-development-in-r-shiny-a-step-by-step-example/",
  "created_at_utc": "2026-01-04T05:35:43Z",
  "crawled_at_utc": "2026-01-04T05:36:49Z",
  "html_title": "Behavior-Driven Development in R Shiny: A Step-By-Step Example | R-bloggers",
  "meta_description": "Follow each step as I develop a form with Shiny and Behavior-Driven Development. Learn practical techniques for better software design through automated tests.",
  "data": {
    "url": "https://www.r-bloggers.com/2025/10/behavior-driven-development-in-r-shiny-a-step-by-step-example/",
    "canonical_url": "https://www.r-bloggers.com/2025/10/behavior-driven-development-in-r-shiny-a-step-by-step-example/",
    "html_title": "Behavior-Driven Development in R Shiny: A Step-By-Step Example | R-bloggers",
    "h1_title": "R-bloggers",
    "meta_description": "Follow each step as I develop a form with Shiny and Behavior-Driven Development. Learn practical techniques for better software design through automated tests.",
    "meta_keywords": null,
    "og_title": "Behavior-Driven Development in R Shiny: A Step-By-Step Example | R-bloggers",
    "og_description": "Follow each step as I develop a form with Shiny and Behavior-Driven Development. Learn practical techniques for better software design through automated tests.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "twitter_title": "Behavior-Driven Development in R Shiny: A Step-By-Step Example | R-bloggers",
    "twitter_description": "Follow each step as I develop a form with Shiny and Behavior-Driven Development. Learn practical techniques for better software design through automated tests.",
    "raw_jsonld_article": null,
    "article_headline": null,
    "article_section": null,
    "article_tags": null,
    "article_author": null,
    "article_published": null,
    "article_modified": null,
    "main_text": "Behavior-Driven Development in R Shiny: A Step-By-Step Example\nPosted on\nOctober 9, 2025\nby\njakub::sobolewski\nin\nR bloggers\n| 0 Comments\n[This article was first published on\njakub::sobolewski\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nTesting your Shiny applications shouldn‚Äôt be an afterthought.\nMany developers write tests after building features, missing the core benefit of test-first development:\ntests as design tools\n. I‚Äôll walk you through how I built a small content submission form using Behavior-Driven Development (BDD), starting from absolutely nothing.\nWhether you‚Äôre building a new app or adding a feature, the steps are the same.\nFollow along and see how tests drive design decisions, keep business value visible, and make refactoring safe.\nLevel-up your testing game! Grab your copy of the R testing roadmap.\n1. Writing the First Specification\nThe app‚Äôs purpose we‚Äôre about to build is to\nsubmit data that another app will display\n.\nBDD starts with a high-level specification describing the behavior we want to see. The first specification is the most important. It describes the core behavior that delivers value to users.\nWe have 2 choices for writing specifications:\nIn R, using\ntestthat\n. We have a full freedom to design our own domain-specific language (DSL) for expressing specifications.\nIn Gherkin syntax, using\ncucumber\n. We are constrained to Cucumber syntax, but we can write specifications in a plain text format that even non-programmers can write.\nIn this example, I choose to express specifications in R, using\ntestthat\n.\nBehavior-Driven Development is not about tools.\nYou can use any testing framework you like (or none!)\nHere‚Äôs how we can express the first specification using\ndescribe\nand\nit\nfrom\ntestthat\n:\n#' tests/testthat/test-acceptance-data_submission.R\ndescribe(\"data submission\", {\n  it(\"should submit entry to storage\", {\n    given_no_content() |>\n      when_i_submit_entry_with_all_required_fields() |>\n      then_there_are_entries(n = 1)\n  })\n})\nor we could use\ntestthat::test_that\n:\n#' tests/testthat/test-acceptance-data_submission.R\ntest_that(\"data submission should submit entry to storage\", {\n  given_no_content() |>\n    when_i_submit_entry_with_all_required_fields() |>\n    then_there_are_entries(n = 1)\n})\nIt doesn‚Äôt matter which\ntestthat\nfunctions you choose.\nNotice the language used. I describe actions from the user‚Äôs perspective, staying high-level:\nwithout naming UI elements,\nwithout naming how data is stored.\nI don‚Äôt care about implementation details yet.\nI care about behavior\n. This specification doesn‚Äôt even reveal that this will be a Shiny app. It could as well be a package that provides a function to submit content.\n‚ÄúGiven no content‚Äù ‚Äì the system starts empty.\n‚ÄúWhen I submit entry with all required fields‚Äù ‚Äì I don‚Äôt care about the actual values, just that they‚Äôre valid and needed for this flow.\n‚ÄúThen there are entries‚Äù ‚Äì this checks if entries were added to the storage.\nThis is the primary goal\n.\nüí° You can also use\nCucumber\nfor writing specifications in Gherkin syntax.\nThe specification would become:\nFeature: Data submission\n  Scenario: Submit entry to storage\n    Given no content\n    When I submit entry with all required fields\n    Then there are 1 entries\nThen you just swap DSL functions with\ncucumber::given\n,\ncucumber::when\n, and\ncucumber::then\nstep functions. The rest of the approach remains the same.\nYou might wonder, what are those functions that I‚Äôve used? They don‚Äôt exist yet, and that‚Äôs the point.\nIn test-first development, we start from interfaces we wish we had. It allows us to experiment how to express intent without writing actual implementation. We‚Äôll use the same approach in the next steps to\ndesign the code\n.\n2. Building the Test Infrastructure\nHaving written down the first specification, I will now imagine what those functions should do in more details.\n#' tests/testthat/setup-dsl.R\ngiven_no_content <- function(driver, context = new.env()) {\n  storage <- make_storage()\n  context$driver <- make_driver(storage = storage)\n  context$storage <- storage\n  context\n}\n\nwhen_i_submit_entry_with_all_required_fields <- function(context) {\n  context$driver$fill_required_fields(\n    url = \"https://example.com/\",\n    title = \"Example\"\n  )\n  context\n}\n\nthen_there_are_entries <- function(context, n) {\n  expect_equal(context$storage$size(), n)\n  context\n}\nYou might wonder again, what are those functions that I‚Äôve used? They don‚Äôt exist yet, and that‚Äôs the point.\nI imagine:\nThere will be a\nmake_storage()\nfunction to connect to the storage. I don‚Äôt even know what storage it will be: database, file, in-memory? Doesn‚Äôt matter now.\nThere will be a\nmake_driver\nfunction that will generate a driver that will be used to interact with the code. I imagine the driver will have a method\nfill_required_fields()\nto simulate user input. If the implementation is in Shiny, maybe it‚Äôll use\nshinytest2\n, maybe something else. If the implementation of the system would be a package, this object would just wrap package functions and execute them. Doesn‚Äôt matter now.\nThat the storage object will have a\nsize()\nmethod to check how many entries are stored. Again, I don‚Äôt care how it‚Äôs implemented. The interface exposes a behavior I want to test. I don‚Äôt even know how the data will be represented - table rows, documents? Doesn‚Äôt matter now. I will design it later once I discover what structure it‚Äôll be. I don‚Äôt design it upfront. What matters is that I can check how many entries are there with\nsize()\nmethod.\nEach function we‚Äôre building specification with expresses a part of a behavior I care about.\nIn\ngiven_no_content\n, I prepare preconditions: empty storage, startup of the system.\nIn\nwhen_i_submit_entry_with_all_required_fields\n, I simulate user interaction.\nIn\nthen_there_are_entries\n, I assert the storage has the entry.\nThe storage is my system boundary\n- the only responsibility of the system is to save submitted content to storage. Maybe the end-to-end process is that this submitted content is displayed in another app, but that‚Äôs outside the scope of this system.\nThis is not an E2E test, it‚Äôs an acceptance test that checks only what‚Äôs under control of this system.\n3. Implementing Driver\nGiven that I‚Äôve decided it will be a Shiny app, I can implement\nmake_driver\nwith\nshinytest2\n. I extend shinytest2 with domain-specific methods.\n#' tests/testthat/setup-driver.R\nShinyDriver <- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    fill_required_fields = function(url = NULL, title = NULL) {\n      self$set_inputs(\n        url = url,\n        title = title\n      )\n      self$click(input = \"submit\")\n    }\n  )\n)\n\nmake_driver <- function(storage) {\n  ShinyDriver$new(options = list(storage = storage))\n}\nThis hides implementation details. If required fields change, I add parameters. If input IDs change, I update them here. If I decide to not use\nset_inputs()\nit doesn‚Äôt affect the specification.\nThe test only knows that you need to pass\nurl\nand\ntitle\nto fill required fields.\nNote that filling required fields consists of setting inputs and clicking the submit button. It‚Äôs an implementation of a behavior, not just interacting with the UI.\nImplementing your tests like this groups related actions together, making tests more expressive.\nüí° The driver is a layer responsible for interacting with the system under test.\nIt could return a different driver if the implementation of the system changes. It could as well be a driver for a command-line interface, or an API client. The specification doesn‚Äôt care, it‚Äôll remain the same as long as the business behavior remains unchanged.\nIf it was an API, the\nfill_required_fields\nmethod could make an POST request to submit data.\n4. Implementing The App\nNow I finally have enough test code to start implementing the actual system, let‚Äôs start with implementing the Shiny app the driver can interact with:\n#' app.R\napp_ui <- function() {\n  fluidPage(\n    textInput(\"url\", \"URL\"),\n    textInput(\"title\", \"Title\"),\n    actionButton(\"submit\", \"Submit\")\n  )\n}\n\napp_server <- function(input, output, session) {\n  storage <- getOption(\"storage\", make_storage())\n  observeEvent(input$submit, {\n    data <- make_storage_item(url = input$url, title = input$title)\n    storage$add(data)\n  })\n}\n\nshinyApp(app_ui(), app_server)\nNote the\ngetOption(\"storage\")\npattern - this lets me inject storage during testing while keeping flexibility to use a different storage in production.\nWe still don‚Äôt have the storage code, so the specification will still fail. Here I imagine I have an extra\nmake_storage_item()\nfunction to create a storage item from form inputs.\n5. Implementing Storage\nLet‚Äôs start with the simplest storage that works:\n#' R/storage.R\nStorage <- R6::R6Class(\n  private = list(\n    store = NULL,\n    schema = tibble::tibble(\n      url = character(),\n      title = character()\n    )\n  ),\n  public = list(\n    initialize = function(store = cachem::cache_disk(\"store\")) {\n      private$store <- store\n    },\n    add = function(x) {\n      item <- tibble::tibble(\n        url = x$url,\n        title = x$title\n      )\n      items <- private$store$get(\"items\", private$schema)\n      private$store$set(\"items\", dplyr::bind_rows(items, item))\n      self\n    },\n    size = function() {\n      nrow(private$store$get(\"items\", private$schema))\n    }\n  )\n)\n\nmake_storage_item <- function(url, title) {\n  list(\n    url = url,\n    title = title\n  )\n}\n\nmake_storage <- function() {\n  Storage$new()\n}\nNow this is enough to make the first specification pass! ‚úÖ\n6. Second Specification\nThen I create a specification for filling all fields, not just required ones:\nit(\"should add entry with all fields\", {\n  given_no_content() |>\n    when_i_submit_entry_with_all_fields() |>\n    then_there_are_entries(n = 1)\n})\nI reuse existing infrastructure but extend the DSL with\nwhen_i_submit_entry_with_all_fields\n.\nThe internals of the function say what fields are available and filled:\nwhen_i_submit_entry_with_all_fields <- function(context) {\n  context$driver$fill_all_fields(\n    url = \"https://example.com/\",\n    title = \"Example\",\n    description = \"An example entry\"\n  )\n  context\n}\nShinyDriver <- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    # fill_required_fields = function(...) { ... },\n    fill_all_fields = function(url = NULL, title = NULL, description = NULL) {\n      self$set_inputs(\n        url = url,\n        title = title,\n        description = description\n      )\n      self$click(input = \"submit\")\n    }\n  )\n)\nand add the extra field to the app and storage:\napp_ui <- function() {\n  fluidPage(\n    textInput(\"url\", \"URL\"),\n    textInput(\"title\", \"Title\"),\n    textInput(\"description\", \"Description\"),  # New field\n    actionButton(\"submit\", \"Submit\")\n  )\n}\nStorage <- R6::R6Class(\n  private = list(\n    store = NULL,\n    schema = tibble::tibble(\n      url = character(),\n      title = character(),\n      description = character()  # New field\n    )\n  ),\n  public = list(\n    # initialize = function(...) { ... },\n    add = function(x) {\n      item <- tibble::tibble(\n        url = x$url,\n        title = x$title,\n        description = x$description  # New field\n      )\n      items <- private$store$get(\"items\", private$schema)\n      private$store$set(\"items\", dplyr::bind_rows(items, item))\n      self\n    },\n    # size = function(...) { ... }\n  )\n)\nThe specification is green! ‚úÖ\nLet‚Äôs pause here and reflect on what we‚Äôve done.\nWe‚Äôve worked our way outside-in, starting from high-level behaviors and working down to implementation details:\nWe started with high-level specifications describing user value without implementation details.\nWe designed interfaces (driver, storage) that express behaviors we care about.\nWe implemented the simplest possible Shiny app and storage that satisfy these specifications.\nAdditionally:\nWe‚Äôve written 2 specifications for the most important behaviors. This is easily the minimum viable set of behaviors that deliver value.\nWe‚Äôve implemented a testing infrastructure that lets us express these behaviors without caring about implementation details. If our project moves to different implementation, we can just swap the driver and storage implementations without changing the specifications.\nWe‚Äôve implemented the simplest possible Shiny app that passes these specifications.\nWe have an automated safety net that ensures the app delivers the expected behaviors.\nIt‚Äôs a solid foundation to build upon.\nNow, with the interfaces we‚Äôve established, we can add more realistic storage (e.g., database, API) and more complex app features (e.g., validation, feedback) while keeping the core behaviors intact.\n7. Storage Evolution\nWe have specifications that ensure the app works.\nNow we can move to the lower-level details and use TDD to evolve the storage implementation. We will use the same interface, so the integration with the app remains unchanged.\nIn tests we can still use the simple disk cache storage, but in production we can switch to a more robust solution, like a database or an API.\nWhen working on the storage, we ensure specifications stay green throughout -\nthat‚Äôs the safety net\n.\n8. Working on Interface Nuances\nIn specifications, we‚Äôve abstracted away from UI details. But as we build the app, we need to consider user experience.\nIt‚Äôs easy to imagine that some form validation would be useful. Users should not be able to submit the form with empty required fields.\nNow we have a choice to make:\nAdd new specification to cover validation behavior\nAdd lower-level tests to cover validation logic\nThe choice depends on how we view validation from the user‚Äôs perspective. Is it a core behavior that users care about, or an implementation detail?\nIf we decide it‚Äôs core behavior\nThen we can add it as a new specification:\nit(\"should require all required fields\", {\n  given_no_content() |>\n    when_i_submit_entry_with_missing_required_fields() |>\n    then_i_am_prompted_to_provide_required_fields()\n})\nThis specification doesn‚Äôt say ‚ÄúI see error messages next to input fields‚Äù. It says ‚ÄúI‚Äôm prompted to provide required fields‚Äù. This leaves room for different implementations.\nIt will work for a Shiny app, a command-line interface, or even an API that returns validation errors.\nRemember to not couple specifications to implementation details.\nIf we decide to implement this specification, remember to only cover the behavior. Focusing on edge cases, text of error messages, when they appear, etc. are all implementation details. Those cases don‚Äôt belong in specifications.\nPush those tests down to lower levels (e.g. module tests, unit tests).\nIf we decide it‚Äôs an implementation detail\nThen we can add lower-level tests to cover validation logic.\nTo do that, we should refactor the form into a Shiny module so that it can be tested in isolation.\nmod_form_ui <- function(id) {\n  # UI elements here\n}\n\nmod_form_server <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    # Form logic here\n    # Validation logic here\n    # Return form data\n  })\n}\nYou‚Äôll notice some\nproblems\nwith this approach: modularization breaks specifications due to namespacing. We can‚Äôt use IDs directly in the driver of specifications.\nThe\nsolution\nis to apply techniques for\nrobust shinytest2 testing\n, making tests resilient to UI changes.\nAfter refactoring, acceptance tests remained green.\nSafe to proceed.\nThen we can cover edge cases in module-level tests:\nTest submitting with missing required fields\nTest submitting with invalid fields\nTests submitting when storage is not available\nRemember to push as many tests as possible to the lowest level\n(e.g. unit test level)\nThe goal is to have fast feedback loops. If we rely only on specifications, tests will be slow, brittle and specifications will grow in number and complexity. This is the easiest way to shoot yourself in the foot.\nAlways prefer to push a test down the\ntesting pyramid.\nThe Outside-In Journey\nIt was a test-first, outside-in journey:\nStart with high-level goals\n: work down to implementation details.\nStart with simplest implementation\n: add complexity as needed.\nRefactor continuously\n: keep specifications working, feedback loops short.\nFollowing this approach, we achieved several benefits:\nTests drive design decisions.\nEach failing test forced architectural choices. Storage patterns, module structure, DSL design - all emerged from test needs.\nBusiness value stays visible.\nAny person should be able to read specifications and understand what the app does.\nImplementation details get appropriate testing levels.\nForm validation gets fast module tests. Storage gets unit tests. User workflows get specifications.\nRefactoring becomes safe.\nGreen specifications mean user value stays intact while you improve code.\nTry This Yourself\nYou don‚Äôt have excuses anymore. Here‚Äôs your playbook:\nWrite one acceptance test describing user value (it must fail)\nBuild just enough infrastructure to run it (it must fail)\nImplement the simplest solution that passes (make it pass)\nRefactor when tests provide safety (keep it passing)\nStart today.\nPick a feature. Write the specification first. See how it guides your design.\nDon‚Äôt wait for a new project to start from scratch. You can do it for a module just as well.\nYour users will thank you.\nYour future self will thank you.\nYour test suite will actually mean something.\nFurther Reading\nTo dive deeper into concepts used here, check out my other articles:\nThe cadence of Behavior-Driven Development\nTechniques for resilient UI tests\nDesigning testable R6 classes\nUnit testing vs acceptance testing\nFocus on behavior with TDD\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\njakub::sobolewski\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "main_html": "<article class=\"post-395976 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Behavior-Driven Development in R Shiny: A Step-By-Step Example</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">October 9, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/jakubsobolewski/\">jakub::sobolewski</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://jakubsobolewski.com/blog/bdd-shiny-feature\"> jakub::sobolewski</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Testing your Shiny applications shouldn‚Äôt be an afterthought.</p>\n<p>Many developers write tests after building features, missing the core benefit of test-first development: <strong>tests as design tools</strong>. I‚Äôll walk you through how I built a small content submission form using Behavior-Driven Development (BDD), starting from absolutely nothing.</p>\n<p>Whether you‚Äôre building a new app or adding a feature, the steps are the same.</p>\n<p>Follow along and see how tests drive design decisions, keep business value visible, and make refactoring safe.</p>\n<blockquote>\n<p><a href=\"https://jakubsobolewski.com/get-roadmap/\" rel=\"nofollow\" target=\"_blank\">Level-up your testing game! Grab your copy of the R testing roadmap.</a></p>\n</blockquote>\n<h2 id=\"1-writing-the-first-specification\">1. Writing the First Specification</h2>\n<p>The app‚Äôs purpose we‚Äôre about to build is to <strong>submit data that another app will display</strong>.</p>\n<p>BDD starts with a high-level specification describing the behavior we want to see. The first specification is the most important. It describes the core behavior that delivers value to users.</p>\n<p>We have 2 choices for writing specifications:</p>\n<ol>\n<li>In R, using <code>testthat</code>. We have a full freedom to design our own domain-specific language (DSL) for expressing specifications.</li>\n<li>In Gherkin syntax, using <code>cucumber</code>. We are constrained to Cucumber syntax, but we can write specifications in a plain text format that even non-programmers can write.</li>\n</ol>\n<p>In this example, I choose to express specifications in R, using <code>testthat</code>. <strong>Behavior-Driven Development is not about tools.</strong> You can use any testing framework you like (or none!)</p>\n<p>Here‚Äôs how we can express the first specification using <code>describe</code> and <code>it</code> from <code>testthat</code>:</p>\n<pre>#' tests/testthat/test-acceptance-data_submission.R\ndescribe(\"data submission\", {\n  it(\"should submit entry to storage\", {\n    given_no_content() |&gt;\n      when_i_submit_entry_with_all_required_fields() |&gt;\n      then_there_are_entries(n = 1)\n  })\n})</pre>\n<p>or we could use <code>testthat::test_that</code>:</p>\n<pre>#' tests/testthat/test-acceptance-data_submission.R\ntest_that(\"data submission should submit entry to storage\", {\n  given_no_content() |&gt;\n    when_i_submit_entry_with_all_required_fields() |&gt;\n    then_there_are_entries(n = 1)\n})</pre>\n<p><strong>It doesn‚Äôt matter which <code>testthat</code> functions you choose.</strong></p>\n<p>Notice the language used. I describe actions from the user‚Äôs perspective, staying high-level:</p>\n<ul>\n<li>without naming UI elements,</li>\n<li>without naming how data is stored.</li>\n</ul>\n<p>I don‚Äôt care about implementation details yet. <strong>I care about behavior</strong>. This specification doesn‚Äôt even reveal that this will be a Shiny app. It could as well be a package that provides a function to submit content.</p>\n<ol>\n<li>‚ÄúGiven no content‚Äù ‚Äì the system starts empty.</li>\n<li>‚ÄúWhen I submit entry with all required fields‚Äù ‚Äì I don‚Äôt care about the actual values, just that they‚Äôre valid and needed for this flow.</li>\n<li>‚ÄúThen there are entries‚Äù ‚Äì this checks if entries were added to the storage. <strong>This is the primary goal</strong>.</li>\n</ol>\n<hr/>\n<p>üí° You can also use <a href=\"https://github.com/jakubsob/cucumber\" rel=\"nofollow\" target=\"_blank\">Cucumber</a> for writing specifications in Gherkin syntax.</p>\n<p>The specification would become:</p>\n<pre>Feature: Data submission\n  Scenario: Submit entry to storage\n    Given no content\n    When I submit entry with all required fields\n    Then there are 1 entries</pre>\n<p>Then you just swap DSL functions with <code>cucumber::given</code>, <code>cucumber::when</code>, and <code>cucumber::then</code> step functions. The rest of the approach remains the same.</p>\n<hr/>\n<p><strong>You might wonder, what are those functions that I‚Äôve used? They don‚Äôt exist yet, and that‚Äôs the point.</strong></p>\n<p>In test-first development, we start from interfaces we wish we had. It allows us to experiment how to express intent without writing actual implementation. We‚Äôll use the same approach in the next steps to <strong>design the code</strong>.</p>\n<h2 id=\"2-building-the-test-infrastructure\">2. Building the Test Infrastructure</h2>\n<p>Having written down the first specification, I will now imagine what those functions should do in more details.</p>\n<pre>#' tests/testthat/setup-dsl.R\ngiven_no_content &lt;- function(driver, context = new.env()) {\n  storage &lt;- make_storage()\n  context$driver &lt;- make_driver(storage = storage)\n  context$storage &lt;- storage\n  context\n}\n\nwhen_i_submit_entry_with_all_required_fields &lt;- function(context) {\n  context$driver$fill_required_fields(\n    url = \"https://example.com/\",\n    title = \"Example\"\n  )\n  context\n}\n\nthen_there_are_entries &lt;- function(context, n) {\n  expect_equal(context$storage$size(), n)\n  context\n}</pre>\n<p><strong>You might wonder again, what are those functions that I‚Äôve used? They don‚Äôt exist yet, and that‚Äôs the point.</strong></p>\n<p>I imagine:</p>\n<ul>\n<li>There will be a <code>make_storage()</code> function to connect to the storage. I don‚Äôt even know what storage it will be: database, file, in-memory? Doesn‚Äôt matter now.</li>\n<li>There will be a <code>make_driver</code> function that will generate a driver that will be used to interact with the code. I imagine the driver will have a method <code>fill_required_fields()</code> to simulate user input. If the implementation is in Shiny, maybe it‚Äôll use <code>shinytest2</code>, maybe something else. If the implementation of the system would be a package, this object would just wrap package functions and execute them. Doesn‚Äôt matter now.</li>\n<li>That the storage object will have a <code>size()</code> method to check how many entries are stored. Again, I don‚Äôt care how it‚Äôs implemented. The interface exposes a behavior I want to test. I don‚Äôt even know how the data will be represented - table rows, documents? Doesn‚Äôt matter now. I will design it later once I discover what structure it‚Äôll be. I don‚Äôt design it upfront. What matters is that I can check how many entries are there with <code>size()</code> method.</li>\n</ul>\n<p>Each function we‚Äôre building specification with expresses a part of a behavior I care about.</p>\n<ul>\n<li>In <code>given_no_content</code>, I prepare preconditions: empty storage, startup of the system.</li>\n<li>In <code>when_i_submit_entry_with_all_required_fields</code>, I simulate user interaction.</li>\n<li>In <code>then_there_are_entries</code>, I assert the storage has the entry.</li>\n</ul>\n<p><strong>The storage is my system boundary</strong> - the only responsibility of the system is to save submitted content to storage. Maybe the end-to-end process is that this submitted content is displayed in another app, but that‚Äôs outside the scope of this system.</p>\n<p><strong>This is not an E2E test, it‚Äôs an acceptance test that checks only what‚Äôs under control of this system.</strong></p>\n<h2 id=\"3-implementing-driver\">3. Implementing Driver</h2>\n<p>Given that I‚Äôve decided it will be a Shiny app, I can implement <code>make_driver</code> with <code>shinytest2</code>. I extend shinytest2 with domain-specific methods.</p>\n<pre>#' tests/testthat/setup-driver.R\nShinyDriver &lt;- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    fill_required_fields = function(url = NULL, title = NULL) {\n      self$set_inputs(\n        url = url,\n        title = title\n      )\n      self$click(input = \"submit\")\n    }\n  )\n)\n\nmake_driver &lt;- function(storage) {\n  ShinyDriver$new(options = list(storage = storage))\n}</pre>\n<p>This hides implementation details. If required fields change, I add parameters. If input IDs change, I update them here. If I decide to not use <code>set_inputs()</code> it doesn‚Äôt affect the specification.</p>\n<p>The test only knows that you need to pass <code>url</code> and <code>title</code> to fill required fields.</p>\n<p>Note that filling required fields consists of setting inputs and clicking the submit button. It‚Äôs an implementation of a behavior, not just interacting with the UI.</p>\n<p>Implementing your tests like this groups related actions together, making tests more expressive.</p>\n<hr/>\n<p>üí° The driver is a layer responsible for interacting with the system under test.</p>\n<p>It could return a different driver if the implementation of the system changes. It could as well be a driver for a command-line interface, or an API client. The specification doesn‚Äôt care, it‚Äôll remain the same as long as the business behavior remains unchanged.</p>\n<p>If it was an API, the <code>fill_required_fields</code> method could make an POST request to submit data.</p>\n<hr/>\n<h2 id=\"4-implementing-the-app\">4. Implementing The App</h2>\n<p>Now I finally have enough test code to start implementing the actual system, let‚Äôs start with implementing the Shiny app the driver can interact with:</p>\n<pre>#' app.R\napp_ui &lt;- function() {\n  fluidPage(\n    textInput(\"url\", \"URL\"),\n    textInput(\"title\", \"Title\"),\n    actionButton(\"submit\", \"Submit\")\n  )\n}\n\napp_server &lt;- function(input, output, session) {\n  storage &lt;- getOption(\"storage\", make_storage())\n  observeEvent(input$submit, {\n    data &lt;- make_storage_item(url = input$url, title = input$title)\n    storage$add(data)\n  })\n}\n\nshinyApp(app_ui(), app_server)</pre>\n<p>Note the <code>getOption(\"storage\")</code> pattern - this lets me inject storage during testing while keeping flexibility to use a different storage in production.</p>\n<p>We still don‚Äôt have the storage code, so the specification will still fail. Here I imagine I have an extra <code>make_storage_item()</code> function to create a storage item from form inputs.</p>\n<h2 id=\"5-implementing-storage\">5. Implementing Storage</h2>\n<p>Let‚Äôs start with the simplest storage that works:</p>\n<pre>#' R/storage.R\nStorage &lt;- R6::R6Class(\n  private = list(\n    store = NULL,\n    schema = tibble::tibble(\n      url = character(),\n      title = character()\n    )\n  ),\n  public = list(\n    initialize = function(store = cachem::cache_disk(\"store\")) {\n      private$store &lt;- store\n    },\n    add = function(x) {\n      item &lt;- tibble::tibble(\n        url = x$url,\n        title = x$title\n      )\n      items &lt;- private$store$get(\"items\", private$schema)\n      private$store$set(\"items\", dplyr::bind_rows(items, item))\n      self\n    },\n    size = function() {\n      nrow(private$store$get(\"items\", private$schema))\n    }\n  )\n)\n\nmake_storage_item &lt;- function(url, title) {\n  list(\n    url = url,\n    title = title\n  )\n}\n\nmake_storage &lt;- function() {\n  Storage$new()\n}</pre>\n<p><strong>Now this is enough to make the first specification pass! ‚úÖ</strong></p>\n<h2 id=\"6-second-specification\">6. Second Specification</h2>\n<p>Then I create a specification for filling all fields, not just required ones:</p>\n<pre>it(\"should add entry with all fields\", {\n  given_no_content() |&gt;\n    when_i_submit_entry_with_all_fields() |&gt;\n    then_there_are_entries(n = 1)\n})</pre>\n<p>I reuse existing infrastructure but extend the DSL with <code>when_i_submit_entry_with_all_fields</code>.</p>\n<p>The internals of the function say what fields are available and filled:</p>\n<pre>when_i_submit_entry_with_all_fields &lt;- function(context) {\n  context$driver$fill_all_fields(\n    url = \"https://example.com/\",\n    title = \"Example\",\n    description = \"An example entry\"\n  )\n  context\n}\r\nShinyDriver &lt;- R6::R6Class(\n  inherit = shinytest2::AppDriver,\n  public = list(\n    # fill_required_fields = function(...) { ... },\n    fill_all_fields = function(url = NULL, title = NULL, description = NULL) {\n      self$set_inputs(\n        url = url,\n        title = title,\n        description = description\n      )\n      self$click(input = \"submit\")\n    }\n  )\n)</pre>\n<p>and add the extra field to the app and storage:</p>\n<pre>app_ui &lt;- function() {\n  fluidPage(\n    textInput(\"url\", \"URL\"),\n    textInput(\"title\", \"Title\"),\n    textInput(\"description\", \"Description\"),  # New field\n    actionButton(\"submit\", \"Submit\")\n  )\n}\r\nStorage &lt;- R6::R6Class(\n  private = list(\n    store = NULL,\n    schema = tibble::tibble(\n      url = character(),\n      title = character(),\n      description = character()  # New field\n    )\n  ),\n  public = list(\n    # initialize = function(...) { ... },\n    add = function(x) {\n      item &lt;- tibble::tibble(\n        url = x$url,\n        title = x$title,\n        description = x$description  # New field\n      )\n      items &lt;- private$store$get(\"items\", private$schema)\n      private$store$set(\"items\", dplyr::bind_rows(items, item))\n      self\n    },\n    # size = function(...) { ... }\n  )\n)</pre>\n<p>The specification is green! ‚úÖ</p>\n<hr/>\n<h3 id=\"lets-pause-here-and-reflect-on-what-weve-done\">Let‚Äôs pause here and reflect on what we‚Äôve done.</h3>\n<p>We‚Äôve worked our way outside-in, starting from high-level behaviors and working down to implementation details:</p>\n<ul>\n<li>We started with high-level specifications describing user value without implementation details.</li>\n<li>We designed interfaces (driver, storage) that express behaviors we care about.</li>\n<li>We implemented the simplest possible Shiny app and storage that satisfy these specifications.</li>\n</ul>\n<p>Additionally:</p>\n<ul>\n<li>We‚Äôve written 2 specifications for the most important behaviors. This is easily the minimum viable set of behaviors that deliver value.</li>\n<li>We‚Äôve implemented a testing infrastructure that lets us express these behaviors without caring about implementation details. If our project moves to different implementation, we can just swap the driver and storage implementations without changing the specifications.</li>\n<li>We‚Äôve implemented the simplest possible Shiny app that passes these specifications.</li>\n</ul>\n<p>We have an automated safety net that ensures the app delivers the expected behaviors.</p>\n<p>It‚Äôs a solid foundation to build upon.</p>\n<p>Now, with the interfaces we‚Äôve established, we can add more realistic storage (e.g., database, API) and more complex app features (e.g., validation, feedback) while keeping the core behaviors intact.</p>\n<hr/>\n<h2 id=\"7-storage-evolution\">7. Storage Evolution</h2>\n<p>We have specifications that ensure the app works.</p>\n<p>Now we can move to the lower-level details and use TDD to evolve the storage implementation. We will use the same interface, so the integration with the app remains unchanged.</p>\n<p>In tests we can still use the simple disk cache storage, but in production we can switch to a more robust solution, like a database or an API.</p>\n<p>When working on the storage, we ensure specifications stay green throughout - <strong>that‚Äôs the safety net</strong>.</p>\n<h2 id=\"8-working-on-interface-nuances\">8. Working on Interface Nuances</h2>\n<p>In specifications, we‚Äôve abstracted away from UI details. But as we build the app, we need to consider user experience.</p>\n<p>It‚Äôs easy to imagine that some form validation would be useful. Users should not be able to submit the form with empty required fields.</p>\n<p>Now we have a choice to make:</p>\n<ul>\n<li>Add new specification to cover validation behavior</li>\n<li>Add lower-level tests to cover validation logic</li>\n</ul>\n<p>The choice depends on how we view validation from the user‚Äôs perspective. Is it a core behavior that users care about, or an implementation detail?</p>\n<h3 id=\"if-we-decide-its-core-behavior\">If we decide it‚Äôs core behavior</h3>\n<p>Then we can add it as a new specification:</p>\n<pre>it(\"should require all required fields\", {\n  given_no_content() |&gt;\n    when_i_submit_entry_with_missing_required_fields() |&gt;\n    then_i_am_prompted_to_provide_required_fields()\n})</pre>\n<p>This specification doesn‚Äôt say ‚ÄúI see error messages next to input fields‚Äù. It says ‚ÄúI‚Äôm prompted to provide required fields‚Äù. This leaves room for different implementations.</p>\n<p>It will work for a Shiny app, a command-line interface, or even an API that returns validation errors.</p>\n<p>Remember to not couple specifications to implementation details.</p>\n<p>If we decide to implement this specification, remember to only cover the behavior. Focusing on edge cases, text of error messages, when they appear, etc. are all implementation details. Those cases don‚Äôt belong in specifications.</p>\n<p>Push those tests down to lower levels (e.g. module tests, unit tests).</p>\n<h3 id=\"if-we-decide-its-an-implementation-detail\">If we decide it‚Äôs an implementation detail</h3>\n<p>Then we can add lower-level tests to cover validation logic.</p>\n<p>To do that, we should refactor the form into a Shiny module so that it can be tested in isolation.</p>\n<pre>mod_form_ui &lt;- function(id) {\n  # UI elements here\n}\n\nmod_form_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    # Form logic here\n    # Validation logic here\n    # Return form data\n  })\n}</pre>\n<p>You‚Äôll notice some <strong>problems</strong> with this approach: modularization breaks specifications due to namespacing. We can‚Äôt use IDs directly in the driver of specifications.</p>\n<p>The <strong>solution</strong> is to apply techniques for <a href=\"https://jakubsobolewski.com/blog/robust-shinytest2/\" rel=\"nofollow\" target=\"_blank\">robust shinytest2 testing</a>, making tests resilient to UI changes.</p>\n<p>After refactoring, acceptance tests remained green. <strong>Safe to proceed.</strong></p>\n<p>Then we can cover edge cases in module-level tests:</p>\n<ul>\n<li>Test submitting with missing required fields</li>\n<li>Test submitting with invalid fields</li>\n<li>Tests submitting when storage is not available</li>\n</ul>\n<p><strong>Remember to push as many tests as possible to the lowest level</strong> (e.g. unit test level)</p>\n<p>The goal is to have fast feedback loops. If we rely only on specifications, tests will be slow, brittle and specifications will grow in number and complexity. This is the easiest way to shoot yourself in the foot.</p>\n<p>Always prefer to push a test down the <a href=\"https://martinfowler.com/articles/practical-test-pyramid.html\" rel=\"nofollow\" target=\"_blank\">testing pyramid.</a></p>\n<h2 id=\"the-outside-in-journey\">The Outside-In Journey</h2>\n<p>It was a test-first, outside-in journey:</p>\n<ul>\n<li><strong>Start with high-level goals</strong>: work down to implementation details.</li>\n<li><strong>Start with simplest implementation</strong>: add complexity as needed.</li>\n<li><strong>Refactor continuously</strong>: keep specifications working, feedback loops short.</li>\n</ul>\n<p>Following this approach, we achieved several benefits:</p>\n<ul>\n<li><strong>Tests drive design decisions.</strong> Each failing test forced architectural choices. Storage patterns, module structure, DSL design - all emerged from test needs.</li>\n<li><strong>Business value stays visible.</strong> Any person should be able to read specifications and understand what the app does.</li>\n<li><strong>Implementation details get appropriate testing levels.</strong> Form validation gets fast module tests. Storage gets unit tests. User workflows get specifications.</li>\n<li><strong>Refactoring becomes safe.</strong> Green specifications mean user value stays intact while you improve code.</li>\n</ul>\n<h2 id=\"try-this-yourself\">Try This Yourself</h2>\n<p>You don‚Äôt have excuses anymore. Here‚Äôs your playbook:</p>\n<ol>\n<li>Write one acceptance test describing user value (it must fail)</li>\n<li>Build just enough infrastructure to run it (it must fail)</li>\n<li>Implement the simplest solution that passes (make it pass)</li>\n<li>Refactor when tests provide safety (keep it passing)</li>\n</ol>\n<p><strong>Start today.</strong> Pick a feature. Write the specification first. See how it guides your design.</p>\n<p>Don‚Äôt wait for a new project to start from scratch. You can do it for a module just as well.</p>\n<p>Your users will thank you.</p>\n<p>Your future self will thank you.</p>\n<p>Your test suite will actually mean something.</p>\n<h2 id=\"further-reading\">Further Reading</h2>\n<p>To dive deeper into concepts used here, check out my other articles:</p>\n<ul>\n<li><a href=\"https://jakubsobolewski.com/blog/bdd-cadence/\" rel=\"nofollow\" target=\"_blank\">The cadence of Behavior-Driven Development</a></li>\n<li><a href=\"https://jakubsobolewski.com/blog/robust-shinytest2/\" rel=\"nofollow\" target=\"_blank\">Techniques for resilient UI tests</a></li>\n<li><a href=\"https://jakubsobolewski.com/blog/testable-r6-interfaces/\" rel=\"nofollow\" target=\"_blank\">Designing testable R6 classes</a></li>\n<li><a href=\"https://jakubsobolewski.com/blog/2-aspects-of-software-quality/\" rel=\"nofollow\" target=\"_blank\">Unit testing vs acceptance testing</a></li>\n<li><a href=\"https://jakubsobolewski.com/blog/how-tdd-helps-you-build-the-right-thing/\" rel=\"nofollow\" target=\"_blank\">Focus on behavior with TDD</a></li>\n</ul>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://jakubsobolewski.com/blog/bdd-shiny-feature\"> jakub::sobolewski</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div> </div>\n</article>",
    "word_count": 2679,
    "reading_time_min": 13.4,
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/jakubsobolewski/",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "external_links": [
      {
        "href": "https://jakubsobolewski.com/blog/bdd-shiny-feature",
        "text": "jakub::sobolewski"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://jakubsobolewski.com/get-roadmap/",
        "text": "Level-up your testing game! Grab your copy of the R testing roadmap."
      },
      {
        "href": "https://github.com/jakubsob/cucumber",
        "text": "Cucumber"
      },
      {
        "href": "https://jakubsobolewski.com/blog/robust-shinytest2/",
        "text": "robust shinytest2 testing"
      },
      {
        "href": "https://martinfowler.com/articles/practical-test-pyramid.html",
        "text": "testing pyramid."
      },
      {
        "href": "https://jakubsobolewski.com/blog/bdd-cadence/",
        "text": "The cadence of Behavior-Driven Development"
      },
      {
        "href": "https://jakubsobolewski.com/blog/robust-shinytest2/",
        "text": "Techniques for resilient UI tests"
      },
      {
        "href": "https://jakubsobolewski.com/blog/testable-r6-interfaces/",
        "text": "Designing testable R6 classes"
      },
      {
        "href": "https://jakubsobolewski.com/blog/2-aspects-of-software-quality/",
        "text": "Unit testing vs acceptance testing"
      },
      {
        "href": "https://jakubsobolewski.com/blog/how-tdd-helps-you-build-the-right-thing/",
        "text": "Focus on behavior with TDD"
      },
      {
        "href": "https://jakubsobolewski.com/blog/bdd-shiny-feature",
        "text": "jakub::sobolewski"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "images": [],
    "lang": "en-US",
    "crawled_at_utc": "2026-01-04T05:36:49Z"
  }
}