{
  "id": "6fc68d95fd6a2bc2dfc05402594d9adc9307add8",
  "url": "https://www.r-bloggers.com/2025/10/deterministic-shift-adjustment-in-arbitrage-free-pricing-historical-to-risk-neutral-short-rates/",
  "created_at_utc": "2026-01-04T05:35:43Z",
  "crawled_at_utc": "2026-01-04T05:36:16Z",
  "html_title": "Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates) | R-bloggers",
  "meta_description": "This post demonstrates the implementation of deterministic shift adjustments in an arbitrage-free pricing framework using R and the NMOF package. I generate synthetic yield curve data using Nelson-Siegel and Nelson-Siegel-Svensson models, estimate short rates using three different methods, simulate interest rate paths, compute unadjusted zero-coupon bond prices, apply deterministic shift adjustments, and evaluate the results.",
  "data": {
    "url": "https://www.r-bloggers.com/2025/10/deterministic-shift-adjustment-in-arbitrage-free-pricing-historical-to-risk-neutral-short-rates/",
    "canonical_url": "https://www.r-bloggers.com/2025/10/deterministic-shift-adjustment-in-arbitrage-free-pricing-historical-to-risk-neutral-short-rates/",
    "html_title": "Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates) | R-bloggers",
    "h1_title": "R-bloggers",
    "meta_description": "This post demonstrates the implementation of deterministic shift adjustments in an arbitrage-free pricing framework using R and the NMOF package. I generate synthetic yield curve data using Nelson-Siegel and Nelson-Siegel-Svensson models, estimate short rates using three different methods, simulate interest rate paths, compute unadjusted zero-coupon bond prices, apply deterministic shift adjustments, and evaluate the results.",
    "meta_keywords": null,
    "og_title": "Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates) | R-bloggers",
    "og_description": "This post demonstrates the implementation of deterministic shift adjustments in an arbitrage-free pricing framework using R and the NMOF package. I generate synthetic yield curve data using Nelson-Siegel and Nelson-Siegel-Svensson models, estimate short rates using three different methods, simulate interest rate paths, compute unadjusted zero-coupon bond prices, apply deterministic shift adjustments, and evaluate the results.",
    "og_image": "https://thierrymoudiki.github.io/images/2025-10-28/2025-10-28-deterministic-shift_2_1.png",
    "twitter_title": "Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates) | R-bloggers",
    "twitter_description": "This post demonstrates the implementation of deterministic shift adjustments in an arbitrage-free pricing framework using R and the NMOF package. I generate synthetic yield curve data using Nelson-Siegel and Nelson-Siegel-Svensson models, estimate short rates using three different methods, simulate interest rate paths, compute unadjusted zero-coupon bond prices, apply deterministic shift adjustments, and evaluate the results.",
    "raw_jsonld_article": null,
    "article_headline": null,
    "article_section": null,
    "article_tags": null,
    "article_author": null,
    "article_published": null,
    "article_modified": null,
    "main_text": "Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates)\nPosted on\nOctober 27, 2025\nby\nT. Moudiki\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nT. Moudiki's Webpage - R\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nFollowing\nhttps://thierrymoudiki.github.io/blog/2025/10/27/r/python/deterministic-shift-caps-swaptions\n, I propose three distinct methods for short rate\nconstruction—ranging from parametric (Nelson-Siegel) to fully data-driven approaches—and\nderive a deterministic shift adjustment ensuring consistency with the fundamental theorem of\nasset pricing. The framework naturally integrates with modern statistical learning methods,\nincluding conformal prediction and copula-based forecasting. Numerical experiments demon-\nstrate accurate calibration to market zero-coupon bond prices and reliable pricing of interest\nrate derivatives including caps and swaptions\nI developed in conjunction with these short rates models, a flexible framework for arbitrage-free simulation of short rates that reconciles descriptive yield curve models with no-arbitrage pricing theory. Unlike existing approaches that require strong parametric assumptions, the method accommodates any bounded, continuous,\nand simulable short rate process.\nIn this post, we implement three methods for constructing instantaneous short rates from historical yield curves, as described in the preprint\nhttps://www.researchgate.net/publication/393794192_New_Short_Rate_Models_and_their_Arbitrage-Free_Extension_A_Flexible_Framework_for_Historical_and_Market-Consistent_Simulation\n. We also implement the deterministic shift adjustment to ensure arbitrage-free pricing of caps and swaptions.\ninstall.packages(c('randomForest', 'NMOF'))\n\ninstall.packages('gridExtra')\n\nlibrary(tidyverse)\nlibrary(randomForest)\nlibrary(NMOF)  # For NS() and NSS() functions\n\nset.seed(123)\n\n# ============================================================================\n# 1. Generate Synthetic Yield Curve Data (Vectorized with NMOF)\n# ============================================================================\ngenerate_yield_curve_ns <- function(n_dates = 100,\n                                     maturities = c(0.25, 0.5, 1, 2, 3, 5, 7, 10)) {\n  dates <- 1:n_dates\n\n  # Time-varying Nelson-Siegel factors\n  beta1 <- 0.06 + 0.01 * sin(2 * pi * dates / 50) + rnorm(n_dates, 0, 0.002)\n  beta2 <- -0.02 + cumsum(rnorm(n_dates, 0, 0.005)) / sqrt(dates)\n  beta3 <- 0.01 + rnorm(n_dates, 0, 0.003)\n  lambda <- 0.0609\n\n  # Vectorized NS yield generation using NMOF::NS\n  # NS(param, tm) where param = c(beta1, beta2, beta3, lambda)\n  yields <- matrix(0, n_dates, length(maturities))\n  for (i in 1:n_dates) {\n    yields[i, ] <- NS(param = c(beta1[i], beta2[i], beta3[i], lambda),\n                      tm = maturities)\n  }\n\n  list(yields = yields, maturities = maturities,\n       beta1 = beta1, beta2 = beta2, beta3 = beta3, lambda = lambda,\n       type = \"NS\")\n}\n\ngenerate_yield_curve_nss <- function(n_dates = 100,\n                                      maturities = c(0.25, 0.5, 1, 2, 3, 5, 7, 10)) {\n  dates <- 1:n_dates\n\n  # Time-varying Nelson-Siegel-Svensson factors\n  beta1 <- 0.06 + 0.01 * sin(2 * pi * dates / 50) + rnorm(n_dates, 0, 0.002)\n  beta2 <- -0.02 + cumsum(rnorm(n_dates, 0, 0.005)) / sqrt(dates)\n  beta3 <- 0.01 + rnorm(n_dates, 0, 0.003)\n  beta4 <- 0.005 + rnorm(n_dates, 0, 0.002)  # Additional NSS factor\n  lambda1 <- 0.0609\n  lambda2 <- 0.50    # Second decay parameter for NSS\n\n  # Vectorized NSS yield generation using NMOF::NSS\n  # NSS(param, tm) where param = c(beta1, beta2, beta3, beta4, lambda1, lambda2)\n  yields <- matrix(0, n_dates, length(maturities))\n  for (i in 1:n_dates) {\n    yields[i, ] <- NSS(param = c(beta1[i], beta2[i], beta3[i], beta4[i],\n                                  lambda1, lambda2),\n                       tm = maturities)\n  }\n\n  list(yields = yields, maturities = maturities,\n       beta1 = beta1, beta2 = beta2, beta3 = beta3, beta4 = beta4,\n       lambda1 = lambda1, lambda2 = lambda2,\n       type = \"NSS\")\n}\n\n# ============================================================================\n# 2. Method 1: NS/NSS Extrapolation to Zero Maturity (Analytical Limit)\n# ============================================================================\nmethod1_ns_extrapolation <- function(data) {\n  if (data$type == \"NS\") {\n    # r(t) = lim_{tau->0} NS(tau) = beta1 + beta2\n    # Since lim_{tau->0} (1-exp(-tau/lambda))/(tau/lambda) = 1\n    # and lim_{tau->0} exp(-tau/lambda) = 1\n    short_rates <- data$beta1 + data$beta2\n  } else if (data$type == \"NSS\") {\n    # r(t) = lim_{tau->0} NSS(tau) = beta1 + beta2 + beta4\n    # Both slope terms converge to 1 as tau->0\n    short_rates <- data$beta1 + data$beta2 + data$beta4\n  }\n  short_rates\n}\n\n# ============================================================================\n# 3. Method 2: NS/NSS Features with Random Forest (Using Small Tau)\n# ============================================================================\nmethod2_ns_ml <- function(data) {\n  n_dates <- nrow(data$yields)\n  short_rates <- numeric(n_dates)\n\n  # Use very small tau to approximate zero (e.g., 1 day = 1/252 years)\n  tau_tiny <- 1/252\n\n  if (data$type == \"NS\") {\n    for (i in 1:n_dates) {\n      # Create NS features using NMOF::NSf (factor loadings)\n      # NSf(lambda, tm) returns matrix: rows = maturities, cols = 3 factors\n      loadings_matrix <- NSf(lambda = data$lambda, tm = data$maturities)\n\n      # Convert to data frame\n      features <- as.data.frame(loadings_matrix)\n      colnames(features) <- c(\"L1\", \"L2\", \"L3\")\n      target <- data$yields[i, ]\n\n      # Train RF\n      rf <- randomForest(x = features, y = target, ntree = 50, nodesize = 2)\n\n      # Predict at tau ≈ 0: Use analytical limit values (1, 1, 0)\n      # OR use very small tau\n      # Analytical approach (more accurate):\n      features_zero <- data.frame(L1 = 1, L2 = 1, L3 = 0)\n\n      short_rates[i] <- suppressWarnings(predict(rf, features_zero))\n    }\n  } else if (data$type == \"NSS\") {\n    for (i in 1:n_dates) {\n      # Create NSS features using NMOF::NSSf\n      # NSSf(lambda1, lambda2, tm) returns matrix: rows = maturities, cols = 4 factors\n      loadings_matrix <- NSSf(lambda1 = data$lambda1,\n                              lambda2 = data$lambda2,\n                              tm = data$maturities)\n\n      # Convert to data frame\n      features <- as.data.frame(loadings_matrix)\n      colnames(features) <- c(\"L1\", \"L2\", \"L3\", \"L4\")\n      target <- data$yields[i, ]\n\n      # Train RF\n      rf <- randomForest(x = features, y = target, ntree = 50, nodesize = 2)\n\n      # Predict at tau ≈ 0: Use analytical limit values (1, 1, 0, 0)\n      # Note: L4 = (1-exp(-aux2))/aux2 - exp(-aux2) -> 1 - 1 = 0 as tau->0\n      features_zero <- data.frame(L1 = 1, L2 = 1, L3 = 0, L4 = 0)\n\n      short_rates[i] <- suppressWarnings(predict(rf, features_zero))\n    }\n  }\n\n  short_rates\n}\n\n# ============================================================================\n# 4. Method 3: Direct Linear Regression to Zero Maturity\n# ============================================================================\nmethod3_direct_regression <- function(data) {\n  n_dates <- nrow(data$yields)\n  short_rates <- numeric(n_dates)\n\n  for (i in 1:n_dates) {\n    # Fit linear model: R(tau) = a + b*tau\n    model <- lm(data$yields[i, ] ~ data$maturities)\n    # Extrapolate to tau=0\n    short_rates[i] <- coef(model)[1]\n  }\n\n  short_rates\n}\n\n# ============================================================================\n# 5. Simulate Short Rate Paths\n# ============================================================================\nsimulate_paths <- function(short_rates, n_sims = 100,\n                           horizon = 10, dt = 0.25) {\n  n_steps <- horizon / dt\n  paths <- matrix(0, n_sims, n_steps + 1)\n  # AR(1) model\n  r0 <- tail(short_rates, 1)\n  mu <- mean(short_rates)\n  phi <- 0.95\n  sigma <- sd(diff(short_rates)) * sqrt(dt)\n\n  paths[, 1] <- r0\n\n  for (t in 2:(n_steps + 1)) {\n    paths[, t] <- mu + phi * (paths[, t-1] - mu) + rnorm(n_sims, 0, sigma)\n    paths[, t] <- pmax(paths[, t], 0.001)\n  }\n  paths\n}\n\n# ============================================================================\n# 6. Compute Unadjusted ZCB Prices (Vectorized)\n# ============================================================================\ncompute_unadjusted_zcb <- function(paths, maturities, dt = 0.25) {\n   n_sims <- nrow(paths)\n   zcb_prices <- numeric(length(maturities))\n\n   for (i in 1:length(maturities)) {\n     T_mat <- maturities[i]\n     n_steps <- round(T_mat / dt)\n     # Vectorized integration\n     integrals <- rowSums(paths[, 1:n_steps, drop = FALSE]) * dt\n     zcb_prices[i] <- mean(exp(-integrals))\n   }\n   zcb_prices\n}\n\n# ============================================================================\n# 7. Market ZCB Prices\n# ============================================================================\nget_market_zcb <- function(data, date_idx, target_maturities) {\n  yields <- data$yields[date_idx, ]\n  maturities <- data$maturities\n  # Interpolate yields\n  yields_interp <- approx(maturities, yields, target_maturities)$y\n  return(exp(-yields_interp * target_maturities))\n}\n\n# ============================================================================\n# 8. Deterministic Shift Adjustment (Vectorized)\n# ============================================================================\napply_deterministic_shift <- function(paths, zcb_unadjusted, zcb_market,\n                                       maturities, dt = 0.25) {\n  n_sims <- nrow(paths)\n  # Compute simulated forward rates (vectorized)\n  f_sim <- numeric(length(maturities))\n  for (i in 1:length(maturities)) {\n    T_mat <- maturities[i]\n    n_steps <- round(T_mat / dt)\n    r_T <- paths[, n_steps]\n    integrals <- rowSums(paths[, 1:n_steps, drop = FALSE]) * dt\n    discount <- exp(-integrals)\n    f_sim[i] <- sum(r_T * discount) / sum(discount)\n  }\n  # Market forward rates\n  f_market <- -diff(log(zcb_market)) / diff(maturities)\n  f_market <- c(f_market[1], f_market)\n  # Shift function\n  phi <- f_market - f_sim\n  # Adjusted ZCB prices (vectorized)\n  zcb_adjusted <- numeric(length(maturities))\n  for (i in 1:length(maturities)) {\n    if (i == 1) {\n      int_phi <- phi[1] * maturities[1]\n    } else {\n      int_phi <- sum(phi[1:i] * diff(c(0, maturities[1:i])))\n    }\n    zcb_adjusted[i] <- exp(-int_phi) * zcb_unadjusted[i]\n  }\n  return(list(zcb_adjusted = zcb_adjusted,\n              phi = phi))\n}\n\n# ============================================================================\n# 9. Calibrated Confidence Intervals for Adjusted Prices\n# ============================================================================\ncompute_adjusted_confidence_intervals <- function(paths, zcb_market, maturities,\n                                                   n_boot = 500, dt = 0.25,\n                                                   alpha = 0.01) {\n  n_sims <- nrow(paths)\n  boot_adjusted_prices <- matrix(0, n_boot, length(maturities))\n\n  for (b in 1:n_boot) {\n    idx <- sample(1:n_sims, n_sims, replace = TRUE)\n    boot_paths <- paths[idx, ]\n\n    boot_unadj <- compute_unadjusted_zcb(boot_paths, maturities, dt)\n    boot_adjustment <- apply_deterministic_shift(boot_paths, boot_unadj,\n                                                  zcb_market, maturities, dt)\n    boot_adjusted_prices[b, ] <- boot_adjustment$zcb_adjusted\n  }\n\n  ci_lower <- apply(boot_adjusted_prices, 2, quantile, probs = alpha/2)\n  ci_upper <- apply(boot_adjusted_prices, 2, quantile, probs = 1 - alpha/2)\n  return(list(lower = ci_lower, upper = ci_upper))\n}\n\n# ============================================================================\n# 10. Run Analysis Function\n# ============================================================================\nrun_analysis <- function(data, model_name) {\n  cat(sprintf(\"\\n========== %s ANALYSIS ==========\\n\\n\", model_name))\n\n  test_maturities <- c(1, 3, 5, 7, 10)\n  zcb_market_test <- get_market_zcb(data, nrow(data$yields), test_maturities)\n\n  cat(\"Market ZCB Prices:\\n\")\n  print(data.frame(Maturity = test_maturities, Price = round(zcb_market_test, 6)))\n  cat(\"\\n\")\n\n  results_list <- list()\n\n  # Method 1: NS/NSS Extrapolation\n  cat(\"--- METHOD 1: Short rates \\n with NS/NSS Extrapolation ---\\n\")\n  r1 <- method1_ns_extrapolation(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r1[length(r1)] * 100))\n\n  paths1 <- simulate_paths(r1, n_sims = 100L)\n  zcb_unadj1 <- compute_unadjusted_zcb(paths1, test_maturities)\n  adjustment1 <- apply_deterministic_shift(paths1, zcb_unadj1, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci1 <- compute_adjusted_confidence_intervals(paths1, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results1 <- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj1, 6),\n    Adjusted = round(adjustment1$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment1$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci1$lower, 6),\n    CI_Upper = round(ci1$upper, 6),\n    CI_Width_bps = round((ci1$upper - ci1$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test >= ci1$lower & zcb_market_test <= ci1$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results1)\n  cat(\"\\n\")\n  results_list[[1]] <- results1 %>% mutate(Method = \"Method 1: NS/NSS Extrapolation\")\n\n  # Method 2: NS/NSS + Random Forest\n  cat(\"--- METHOD 2: Short rates \\n with NS/NSS + Random Forest ---\\n\")\n  r2 <- method2_ns_ml(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r2[length(r2)] * 100))\n\n  paths2 <- simulate_paths(r2, n_sims = 100L)\n  zcb_unadj2 <- compute_unadjusted_zcb(paths2, test_maturities)\n  adjustment2 <- apply_deterministic_shift(paths2, zcb_unadj2, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci2 <- compute_adjusted_confidence_intervals(paths2, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results2 <- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj2, 6),\n    Adjusted = round(adjustment2$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment2$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci2$lower, 6),\n    CI_Upper = round(ci2$upper, 6),\n    CI_Width_bps = round((ci2$upper - ci2$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test >= ci2$lower & zcb_market_test <= ci2$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results2)\n  cat(\"\\n\")\n  results_list[[2]] <- results2 %>% mutate(Method = \"Method 2: NS/NSS + RF\")\n\n  # Method 3: Direct Regression\n  cat(\"--- METHOD 3: Short rates \\n with Direct Regression ---\\n\")\n  r3 <- method3_direct_regression(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r3[length(r3)] * 100))\n\n  paths3 <- simulate_paths(r3, n_sims = 100L)\n  zcb_unadj3 <- compute_unadjusted_zcb(paths3, test_maturities)\n  adjustment3 <- apply_deterministic_shift(paths3, zcb_unadj3, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci3 <- compute_adjusted_confidence_intervals(paths3, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results3 <- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj3, 6),\n    Adjusted = round(adjustment3$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment3$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci3$lower, 6),\n    CI_Upper = round(ci3$upper, 6),\n    CI_Width_bps = round((ci3$upper - ci3$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test >= ci3$lower & zcb_market_test <= ci3$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results3)\n  cat(\"\\n\")\n  results_list[[3]] <- results3 %>% mutate(Method = \"Method 3: Direct Regression\")\n\n  # Summary\n  cat(\"=== SUMMARY ===\\n\")\n  cat(sprintf(\"Method 1 - Mean absolute error: %.3f%%\\n\", mean(results1$Error_pct)))\n  cat(sprintf(\"Method 2 - Mean absolute error: %.3f%%\\n\", mean(results2$Error_pct)))\n  cat(sprintf(\"Method 3 - Mean absolute error: %.3f%%\\n\", mean(results3$Error_pct)))\n\n  coverage1 <- mean(results1$Market_In_CI) * 100\n  coverage2 <- mean(results2$Market_In_CI) * 100\n  coverage3 <- mean(results3$Market_In_CI) * 100\n\n  cat(\"\\n=== CI Coverage ===\\n\")\n  cat(sprintf(\"Method 1 - Market in 99%% CI: %.0f%%\\n\", coverage1))\n  cat(sprintf(\"Method 2 - Market in 99%% CI: %.0f%%\\n\", coverage2))\n  cat(sprintf(\"Method 3 - Market in 99%% CI: %.0f%%\\n\", coverage3))\n  cat(sprintf(\"\\nAvg CI Width: %.1f bps (M1), %.1f bps (M2), %.1f bps (M3)\\n\",\n              mean(results1$CI_Width_bps), mean(results2$CI_Width_bps),\n              mean(results3$CI_Width_bps)))\n\n  return(bind_rows(results_list))\n}\n\n# ============================================================================\n# 11. Main Execution\n# ============================================================================\ncat(\"=== Arbitrage-Free Framework: NMOF Implementation ===\\n\")\ncat(\"Using vectorized NS() and NSS() functions\\n\\n\")\n\n# Generate data for both NS and NSS\ncat(\"Generating synthetic yield curves...\\n\")\ndata_ns <- generate_yield_curve_ns(n_dates = 100)\ndata_nss <- generate_yield_curve_nss(n_dates = 100)\n\n# Run analysis for NS\nresults_ns <- run_analysis(data_ns, \"NELSON-SIEGEL (NS)\")\n\n# Run analysis for NSS\nresults_nss <- run_analysis(data_nss, \"NELSON-SIEGEL-SVENSSON (NSS)\")\n\n# ============================================================================\n# 12. Comparative Visualization\n# ============================================================================\ncat(\"\\n=== Generating Comparative Visualization ===\\n\")\n\nlibrary(gridExtra)\n\n# Add model type to results\nresults_ns <- results_ns %>% mutate(Model = \"NS\")\nresults_nss <- results_nss %>% mutate(Model = \"NSS\")\nall_results <- bind_rows(results_ns, results_nss)\n\n# Plot 3: Adjusted vs Market Prices\np3 <- ggplot(all_results, aes(x = Maturity)) +\n  geom_point(aes(y = Market), size = 3, shape = 4, stroke = 2) +\n  geom_point(aes(y = Adjusted, color = Model), size = 2, alpha = 0.7) +\n  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper, color = Model),\n                width = 0.2, alpha = 0.5) +\n  facet_wrap(~Method, ncol = 3) +\n  scale_color_manual(values = c(\"NS\" = \"#E41A1C\", \"NSS\" = \"#377EB8\")) +\n  labs(title = \"Adjusted Prices with Confidence Intervals\",\n       subtitle = \"Market prices (×) vs Adjusted prices (•) with 95% CI\",\n       x = \"Maturity (Years)\", y = \"Zero-Coupon Bond Prices\") +\n  theme_minimal(base_size = 11) +\n  theme(legend.position = \"bottom\", strip.text = element_text(face = \"bold\"))\n\nprint(p3)\n\n=== Arbitrage-Free Framework: NMOF Implementation ===\nUsing vectorized NS() and NSS() functions\n\nGenerating synthetic yield curves...\n\n========== NELSON-SIEGEL (NS) ANALYSIS ==========\n\nMarket ZCB Prices:\n  Maturity    Price\n1        1 0.944368\n2        3 0.841025\n3        5 0.748991\n4        7 0.667029\n5       10 0.560591\n\n--- METHOD 1: Short rates \n with NS/NSS Extrapolation ---\nShort rate (last obs): 3.2570%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.967691 0.943862     0.054 0.943584 0.944152\n2        3 0.841025   0.905163 0.841066     0.005 0.840352 0.841831\n3        5 0.748991   0.846230 0.749097     0.014 0.748257 0.750021\n4        7 0.667029   0.791175 0.667194     0.025 0.666362 0.668134\n5       10 0.560591   0.715174 0.560692     0.018 0.559592 0.561671\n  CI_Width_bps Market_In_CI\n1          5.7        FALSE\n2         14.8         TRUE\n3         17.6         TRUE\n4         17.7         TRUE\n5         20.8         TRUE\n\n--- METHOD 2: Short rates \n with NS/NSS + Random Forest ---\nShort rate (last obs): 5.6769%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.944570 0.943958     0.043 0.943678 0.944300\n2        3 0.841025   0.841244 0.841482     0.054 0.840561 0.842174\n3        5 0.748991   0.748978 0.749251     0.035 0.748509 0.749930\n4        7 0.667029   0.666754 0.667387     0.054 0.666451 0.668276\n5       10 0.560591   0.558617 0.561682     0.195 0.560760 0.562701\n  CI_Width_bps Market_In_CI\n1          6.2        FALSE\n2         16.1         TRUE\n3         14.2         TRUE\n4         18.3         TRUE\n5         19.4        FALSE\n\n--- METHOD 3: Short rates \n with Direct Regression ---\nShort rate (last obs): 5.6515%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.944990 0.943743     0.066 0.943456 0.944000\n2        3 0.841025   0.843021 0.841146     0.014 0.840457 0.841841\n3        5 0.748991   0.751161 0.749289     0.040 0.748411 0.750119\n4        7 0.667029   0.668924 0.667445     0.062 0.666569 0.668325\n5       10 0.560591   0.561686 0.560619     0.005 0.559444 0.561621\n  CI_Width_bps Market_In_CI\n1          5.4        FALSE\n2         13.8         TRUE\n3         17.1         TRUE\n4         17.6         TRUE\n5         21.8         TRUE\n\n=== SUMMARY ===\nMethod 1 - Mean absolute error: 0.023%\nMethod 2 - Mean absolute error: 0.076%\nMethod 3 - Mean absolute error: 0.037%\n\n=== CI Coverage ===\nMethod 1 - Market in 99% CI: 80%\nMethod 2 - Market in 99% CI: 60%\nMethod 3 - Market in 99% CI: 80%\n\nAvg CI Width: 15.3 bps (M1), 14.8 bps (M2), 15.1 bps (M3)\n\n========== NELSON-SIEGEL-SVENSSON (NSS) ANALYSIS ==========\n\nMarket ZCB Prices:\n  Maturity    Price\n1        1 0.941887\n2        3 0.836276\n3        5 0.742752\n4        7 0.659696\n5       10 0.552198\n\n--- METHOD 1: Short rates \n with NS/NSS Extrapolation ---\nShort rate (last obs): 4.6355%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.954688 0.942270     0.041 0.941853 0.942716\n2        3 0.836276   0.871008 0.835715     0.067 0.834544 0.836739\n3        5 0.742752   0.794980 0.741836     0.123 0.740349 0.743138\n4        7 0.659696   0.726242 0.658950     0.113 0.657747 0.660143\n5       10 0.552198   0.633806 0.551628     0.103 0.549925 0.553257\n  CI_Width_bps Market_In_CI\n1          8.6         TRUE\n2         21.9         TRUE\n3         27.9         TRUE\n4         24.0         TRUE\n5         33.3         TRUE\n\n--- METHOD 2: Short rates \n with NS/NSS + Random Forest ---\nShort rate (last obs): 5.9567%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.942313 0.942164     0.029 0.941784 0.942523\n2        3 0.836276   0.836567 0.836628     0.042 0.835661 0.837590\n3        5 0.742752   0.742821 0.743231     0.064 0.741899 0.744219\n4        7 0.659696   0.658894 0.660377     0.103 0.659165 0.661587\n5       10 0.552198   0.549714 0.552640     0.080 0.551440 0.554016\n  CI_Width_bps Market_In_CI\n1          7.4         TRUE\n2         19.3         TRUE\n3         23.2         TRUE\n4         24.2         TRUE\n5         25.8         TRUE\n\n--- METHOD 3: Short rates \n with Direct Regression ---\nShort rate (last obs): 5.9770%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.942102 0.942063     0.019 0.941738 0.942405\n2        3 0.836276   0.836988 0.836231     0.005 0.835452 0.837112\n3        5 0.742752   0.742843 0.743059     0.041 0.742083 0.744069\n4        7 0.659696   0.658711 0.659669     0.004 0.658707 0.660866\n5       10 0.552198   0.550538 0.552046     0.028 0.550710 0.553238\n  CI_Width_bps Market_In_CI\n1          6.7         TRUE\n2         16.6         TRUE\n3         19.9         TRUE\n4         21.6         TRUE\n5         25.3         TRUE\n\n=== SUMMARY ===\nMethod 1 - Mean absolute error: 0.089%\nMethod 2 - Mean absolute error: 0.064%\nMethod 3 - Mean absolute error: 0.019%\n\n=== CI Coverage ===\nMethod 1 - Market in 99% CI: 100%\nMethod 2 - Market in 99% CI: 100%\nMethod 3 - Market in 99% CI: 100%\n\nAvg CI Width: 23.1 bps (M1), 20.0 bps (M2), 18.0 bps (M3)\n\n=== Generating Comparative Visualization ===\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nT. Moudiki's Webpage - R\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "main_html": "<article class=\"post-396834 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Deterministic Shift Adjustment in Arbitrage-Free Pricing (historical to risk-neutral short rates)</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">October 27, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/t-moudiki/\">T. Moudiki</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://thierrymoudiki.github.io//blog/2025/10/28/r/deterministic-shift\"> T. Moudiki's Webpage - R</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>Following <a href=\"https://thierrymoudiki.github.io/blog/2025/10/27/r/python/deterministic-shift-caps-swaptions\" rel=\"nofollow\" target=\"_blank\">https://thierrymoudiki.github.io/blog/2025/10/27/r/python/deterministic-shift-caps-swaptions</a>, I propose three distinct methods for short rate\nconstruction—ranging from parametric (Nelson-Siegel) to fully data-driven approaches—and\nderive a deterministic shift adjustment ensuring consistency with the fundamental theorem of\nasset pricing. The framework naturally integrates with modern statistical learning methods,\nincluding conformal prediction and copula-based forecasting. Numerical experiments demon-\nstrate accurate calibration to market zero-coupon bond prices and reliable pricing of interest\nrate derivatives including caps and swaptions</p>\n<p>I developed in conjunction with these short rates models, a flexible framework for arbitrage-free simulation of short rates that reconciles descriptive yield curve models with no-arbitrage pricing theory. Unlike existing approaches that require strong parametric assumptions, the method accommodates any bounded, continuous,\nand simulable short rate process.</p>\n<p>In this post, we implement three methods for constructing instantaneous short rates from historical yield curves, as described in the preprint <a href=\"https://www.researchgate.net/publication/393794192_New_Short_Rate_Models_and_their_Arbitrage-Free_Extension_A_Flexible_Framework_for_Historical_and_Market-Consistent_Simulation\" rel=\"nofollow\" target=\"_blank\">https://www.researchgate.net/publication/393794192_New_Short_Rate_Models_and_their_Arbitrage-Free_Extension_A_Flexible_Framework_for_Historical_and_Market-Consistent_Simulation</a>. We also implement the deterministic shift adjustment to ensure arbitrage-free pricing of caps and swaptions.</p>\n<pre>install.packages(c('randomForest', 'NMOF'))\n\r\ninstall.packages('gridExtra')\n\r\nlibrary(tidyverse)\nlibrary(randomForest)\nlibrary(NMOF)  # For NS() and NSS() functions\n\nset.seed(123)\n\n# ============================================================================\n# 1. Generate Synthetic Yield Curve Data (Vectorized with NMOF)\n# ============================================================================\ngenerate_yield_curve_ns &lt;- function(n_dates = 100,\n                                     maturities = c(0.25, 0.5, 1, 2, 3, 5, 7, 10)) {\n  dates &lt;- 1:n_dates\n\n  # Time-varying Nelson-Siegel factors\n  beta1 &lt;- 0.06 + 0.01 * sin(2 * pi * dates / 50) + rnorm(n_dates, 0, 0.002)\n  beta2 &lt;- -0.02 + cumsum(rnorm(n_dates, 0, 0.005)) / sqrt(dates)\n  beta3 &lt;- 0.01 + rnorm(n_dates, 0, 0.003)\n  lambda &lt;- 0.0609\n\n  # Vectorized NS yield generation using NMOF::NS\n  # NS(param, tm) where param = c(beta1, beta2, beta3, lambda)\n  yields &lt;- matrix(0, n_dates, length(maturities))\n  for (i in 1:n_dates) {\n    yields[i, ] &lt;- NS(param = c(beta1[i], beta2[i], beta3[i], lambda),\n                      tm = maturities)\n  }\n\n  list(yields = yields, maturities = maturities,\n       beta1 = beta1, beta2 = beta2, beta3 = beta3, lambda = lambda,\n       type = \"NS\")\n}\n\ngenerate_yield_curve_nss &lt;- function(n_dates = 100,\n                                      maturities = c(0.25, 0.5, 1, 2, 3, 5, 7, 10)) {\n  dates &lt;- 1:n_dates\n\n  # Time-varying Nelson-Siegel-Svensson factors\n  beta1 &lt;- 0.06 + 0.01 * sin(2 * pi * dates / 50) + rnorm(n_dates, 0, 0.002)\n  beta2 &lt;- -0.02 + cumsum(rnorm(n_dates, 0, 0.005)) / sqrt(dates)\n  beta3 &lt;- 0.01 + rnorm(n_dates, 0, 0.003)\n  beta4 &lt;- 0.005 + rnorm(n_dates, 0, 0.002)  # Additional NSS factor\n  lambda1 &lt;- 0.0609\n  lambda2 &lt;- 0.50    # Second decay parameter for NSS\n\n  # Vectorized NSS yield generation using NMOF::NSS\n  # NSS(param, tm) where param = c(beta1, beta2, beta3, beta4, lambda1, lambda2)\n  yields &lt;- matrix(0, n_dates, length(maturities))\n  for (i in 1:n_dates) {\n    yields[i, ] &lt;- NSS(param = c(beta1[i], beta2[i], beta3[i], beta4[i],\n                                  lambda1, lambda2),\n                       tm = maturities)\n  }\n\n  list(yields = yields, maturities = maturities,\n       beta1 = beta1, beta2 = beta2, beta3 = beta3, beta4 = beta4,\n       lambda1 = lambda1, lambda2 = lambda2,\n       type = \"NSS\")\n}\n\n# ============================================================================\n# 2. Method 1: NS/NSS Extrapolation to Zero Maturity (Analytical Limit)\n# ============================================================================\nmethod1_ns_extrapolation &lt;- function(data) {\n  if (data$type == \"NS\") {\n    # r(t) = lim_{tau-&gt;0} NS(tau) = beta1 + beta2\n    # Since lim_{tau-&gt;0} (1-exp(-tau/lambda))/(tau/lambda) = 1\n    # and lim_{tau-&gt;0} exp(-tau/lambda) = 1\n    short_rates &lt;- data$beta1 + data$beta2\n  } else if (data$type == \"NSS\") {\n    # r(t) = lim_{tau-&gt;0} NSS(tau) = beta1 + beta2 + beta4\n    # Both slope terms converge to 1 as tau-&gt;0\n    short_rates &lt;- data$beta1 + data$beta2 + data$beta4\n  }\n  short_rates\n}\n\n# ============================================================================\n# 3. Method 2: NS/NSS Features with Random Forest (Using Small Tau)\n# ============================================================================\nmethod2_ns_ml &lt;- function(data) {\n  n_dates &lt;- nrow(data$yields)\n  short_rates &lt;- numeric(n_dates)\n\n  # Use very small tau to approximate zero (e.g., 1 day = 1/252 years)\n  tau_tiny &lt;- 1/252\n\n  if (data$type == \"NS\") {\n    for (i in 1:n_dates) {\n      # Create NS features using NMOF::NSf (factor loadings)\n      # NSf(lambda, tm) returns matrix: rows = maturities, cols = 3 factors\n      loadings_matrix &lt;- NSf(lambda = data$lambda, tm = data$maturities)\n\n      # Convert to data frame\n      features &lt;- as.data.frame(loadings_matrix)\n      colnames(features) &lt;- c(\"L1\", \"L2\", \"L3\")\n      target &lt;- data$yields[i, ]\n\n      # Train RF\n      rf &lt;- randomForest(x = features, y = target, ntree = 50, nodesize = 2)\n\n      # Predict at tau ≈ 0: Use analytical limit values (1, 1, 0)\n      # OR use very small tau\n      # Analytical approach (more accurate):\n      features_zero &lt;- data.frame(L1 = 1, L2 = 1, L3 = 0)\n\n      short_rates[i] &lt;- suppressWarnings(predict(rf, features_zero))\n    }\n  } else if (data$type == \"NSS\") {\n    for (i in 1:n_dates) {\n      # Create NSS features using NMOF::NSSf\n      # NSSf(lambda1, lambda2, tm) returns matrix: rows = maturities, cols = 4 factors\n      loadings_matrix &lt;- NSSf(lambda1 = data$lambda1,\n                              lambda2 = data$lambda2,\n                              tm = data$maturities)\n\n      # Convert to data frame\n      features &lt;- as.data.frame(loadings_matrix)\n      colnames(features) &lt;- c(\"L1\", \"L2\", \"L3\", \"L4\")\n      target &lt;- data$yields[i, ]\n\n      # Train RF\n      rf &lt;- randomForest(x = features, y = target, ntree = 50, nodesize = 2)\n\n      # Predict at tau ≈ 0: Use analytical limit values (1, 1, 0, 0)\n      # Note: L4 = (1-exp(-aux2))/aux2 - exp(-aux2) -&gt; 1 - 1 = 0 as tau-&gt;0\n      features_zero &lt;- data.frame(L1 = 1, L2 = 1, L3 = 0, L4 = 0)\n\n      short_rates[i] &lt;- suppressWarnings(predict(rf, features_zero))\n    }\n  }\n\n  short_rates\n}\n\n# ============================================================================\n# 4. Method 3: Direct Linear Regression to Zero Maturity\n# ============================================================================\nmethod3_direct_regression &lt;- function(data) {\n  n_dates &lt;- nrow(data$yields)\n  short_rates &lt;- numeric(n_dates)\n\n  for (i in 1:n_dates) {\n    # Fit linear model: R(tau) = a + b*tau\n    model &lt;- lm(data$yields[i, ] ~ data$maturities)\n    # Extrapolate to tau=0\n    short_rates[i] &lt;- coef(model)[1]\n  }\n\n  short_rates\n}\n\n# ============================================================================\n# 5. Simulate Short Rate Paths\n# ============================================================================\nsimulate_paths &lt;- function(short_rates, n_sims = 100,\n                           horizon = 10, dt = 0.25) {\n  n_steps &lt;- horizon / dt\n  paths &lt;- matrix(0, n_sims, n_steps + 1)\n  # AR(1) model\n  r0 &lt;- tail(short_rates, 1)\n  mu &lt;- mean(short_rates)\n  phi &lt;- 0.95\n  sigma &lt;- sd(diff(short_rates)) * sqrt(dt)\n\n  paths[, 1] &lt;- r0\n\n  for (t in 2:(n_steps + 1)) {\n    paths[, t] &lt;- mu + phi * (paths[, t-1] - mu) + rnorm(n_sims, 0, sigma)\n    paths[, t] &lt;- pmax(paths[, t], 0.001)\n  }\n  paths\n}\n\n# ============================================================================\n# 6. Compute Unadjusted ZCB Prices (Vectorized)\n# ============================================================================\ncompute_unadjusted_zcb &lt;- function(paths, maturities, dt = 0.25) {\n   n_sims &lt;- nrow(paths)\n   zcb_prices &lt;- numeric(length(maturities))\n\n   for (i in 1:length(maturities)) {\n     T_mat &lt;- maturities[i]\n     n_steps &lt;- round(T_mat / dt)\n     # Vectorized integration\n     integrals &lt;- rowSums(paths[, 1:n_steps, drop = FALSE]) * dt\n     zcb_prices[i] &lt;- mean(exp(-integrals))\n   }\n   zcb_prices\n}\n\n# ============================================================================\n# 7. Market ZCB Prices\n# ============================================================================\nget_market_zcb &lt;- function(data, date_idx, target_maturities) {\n  yields &lt;- data$yields[date_idx, ]\n  maturities &lt;- data$maturities\n  # Interpolate yields\n  yields_interp &lt;- approx(maturities, yields, target_maturities)$y\n  return(exp(-yields_interp * target_maturities))\n}\n\n# ============================================================================\n# 8. Deterministic Shift Adjustment (Vectorized)\n# ============================================================================\napply_deterministic_shift &lt;- function(paths, zcb_unadjusted, zcb_market,\n                                       maturities, dt = 0.25) {\n  n_sims &lt;- nrow(paths)\n  # Compute simulated forward rates (vectorized)\n  f_sim &lt;- numeric(length(maturities))\n  for (i in 1:length(maturities)) {\n    T_mat &lt;- maturities[i]\n    n_steps &lt;- round(T_mat / dt)\n    r_T &lt;- paths[, n_steps]\n    integrals &lt;- rowSums(paths[, 1:n_steps, drop = FALSE]) * dt\n    discount &lt;- exp(-integrals)\n    f_sim[i] &lt;- sum(r_T * discount) / sum(discount)\n  }\n  # Market forward rates\n  f_market &lt;- -diff(log(zcb_market)) / diff(maturities)\n  f_market &lt;- c(f_market[1], f_market)\n  # Shift function\n  phi &lt;- f_market - f_sim\n  # Adjusted ZCB prices (vectorized)\n  zcb_adjusted &lt;- numeric(length(maturities))\n  for (i in 1:length(maturities)) {\n    if (i == 1) {\n      int_phi &lt;- phi[1] * maturities[1]\n    } else {\n      int_phi &lt;- sum(phi[1:i] * diff(c(0, maturities[1:i])))\n    }\n    zcb_adjusted[i] &lt;- exp(-int_phi) * zcb_unadjusted[i]\n  }\n  return(list(zcb_adjusted = zcb_adjusted,\n              phi = phi))\n}\n\n# ============================================================================\n# 9. Calibrated Confidence Intervals for Adjusted Prices\n# ============================================================================\ncompute_adjusted_confidence_intervals &lt;- function(paths, zcb_market, maturities,\n                                                   n_boot = 500, dt = 0.25,\n                                                   alpha = 0.01) {\n  n_sims &lt;- nrow(paths)\n  boot_adjusted_prices &lt;- matrix(0, n_boot, length(maturities))\n\n  for (b in 1:n_boot) {\n    idx &lt;- sample(1:n_sims, n_sims, replace = TRUE)\n    boot_paths &lt;- paths[idx, ]\n\n    boot_unadj &lt;- compute_unadjusted_zcb(boot_paths, maturities, dt)\n    boot_adjustment &lt;- apply_deterministic_shift(boot_paths, boot_unadj,\n                                                  zcb_market, maturities, dt)\n    boot_adjusted_prices[b, ] &lt;- boot_adjustment$zcb_adjusted\n  }\n\n  ci_lower &lt;- apply(boot_adjusted_prices, 2, quantile, probs = alpha/2)\n  ci_upper &lt;- apply(boot_adjusted_prices, 2, quantile, probs = 1 - alpha/2)\n  return(list(lower = ci_lower, upper = ci_upper))\n}\n\n# ============================================================================\n# 10. Run Analysis Function\n# ============================================================================\nrun_analysis &lt;- function(data, model_name) {\n  cat(sprintf(\"\\n========== %s ANALYSIS ==========\\n\\n\", model_name))\n\n  test_maturities &lt;- c(1, 3, 5, 7, 10)\n  zcb_market_test &lt;- get_market_zcb(data, nrow(data$yields), test_maturities)\n\n  cat(\"Market ZCB Prices:\\n\")\n  print(data.frame(Maturity = test_maturities, Price = round(zcb_market_test, 6)))\n  cat(\"\\n\")\n\n  results_list &lt;- list()\n\n  # Method 1: NS/NSS Extrapolation\n  cat(\"--- METHOD 1: Short rates \\n with NS/NSS Extrapolation ---\\n\")\n  r1 &lt;- method1_ns_extrapolation(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r1[length(r1)] * 100))\n\n  paths1 &lt;- simulate_paths(r1, n_sims = 100L)\n  zcb_unadj1 &lt;- compute_unadjusted_zcb(paths1, test_maturities)\n  adjustment1 &lt;- apply_deterministic_shift(paths1, zcb_unadj1, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci1 &lt;- compute_adjusted_confidence_intervals(paths1, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results1 &lt;- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj1, 6),\n    Adjusted = round(adjustment1$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment1$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci1$lower, 6),\n    CI_Upper = round(ci1$upper, 6),\n    CI_Width_bps = round((ci1$upper - ci1$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test &gt;= ci1$lower &amp; zcb_market_test &lt;= ci1$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results1)\n  cat(\"\\n\")\n  results_list[[1]] &lt;- results1 %&gt;% mutate(Method = \"Method 1: NS/NSS Extrapolation\")\n\n  # Method 2: NS/NSS + Random Forest\n  cat(\"--- METHOD 2: Short rates \\n with NS/NSS + Random Forest ---\\n\")\n  r2 &lt;- method2_ns_ml(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r2[length(r2)] * 100))\n\n  paths2 &lt;- simulate_paths(r2, n_sims = 100L)\n  zcb_unadj2 &lt;- compute_unadjusted_zcb(paths2, test_maturities)\n  adjustment2 &lt;- apply_deterministic_shift(paths2, zcb_unadj2, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci2 &lt;- compute_adjusted_confidence_intervals(paths2, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results2 &lt;- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj2, 6),\n    Adjusted = round(adjustment2$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment2$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci2$lower, 6),\n    CI_Upper = round(ci2$upper, 6),\n    CI_Width_bps = round((ci2$upper - ci2$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test &gt;= ci2$lower &amp; zcb_market_test &lt;= ci2$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results2)\n  cat(\"\\n\")\n  results_list[[2]] &lt;- results2 %&gt;% mutate(Method = \"Method 2: NS/NSS + RF\")\n\n  # Method 3: Direct Regression\n  cat(\"--- METHOD 3: Short rates \\n with Direct Regression ---\\n\")\n  r3 &lt;- method3_direct_regression(data)\n  cat(sprintf(\"Short rate (last obs): %.4f%%\\n\", r3[length(r3)] * 100))\n\n  paths3 &lt;- simulate_paths(r3, n_sims = 100L)\n  zcb_unadj3 &lt;- compute_unadjusted_zcb(paths3, test_maturities)\n  adjustment3 &lt;- apply_deterministic_shift(paths3, zcb_unadj3, zcb_market_test,\n                                           test_maturities)\n  cat(\"Computing calibrated confidence intervals...\\n\")\n  ci3 &lt;- compute_adjusted_confidence_intervals(paths3, zcb_market_test,\n                                                test_maturities, n_boot = 500)\n\n  results3 &lt;- data.frame(\n    Maturity = test_maturities,\n    Market = round(zcb_market_test, 6),\n    Unadjusted = round(zcb_unadj3, 6),\n    Adjusted = round(adjustment3$zcb_adjusted, 6),\n    Error_pct = round(abs(adjustment3$zcb_adjusted - zcb_market_test) /\n                        zcb_market_test * 100, 3),\n    CI_Lower = round(ci3$lower, 6),\n    CI_Upper = round(ci3$upper, 6),\n    CI_Width_bps = round((ci3$upper - ci3$lower) * 10000, 1),\n    Market_In_CI = zcb_market_test &gt;= ci3$lower &amp; zcb_market_test &lt;= ci3$upper\n  )\n\n  cat(\"\\nResults:\\n\")\n  print(results3)\n  cat(\"\\n\")\n  results_list[[3]] &lt;- results3 %&gt;% mutate(Method = \"Method 3: Direct Regression\")\n\n  # Summary\n  cat(\"=== SUMMARY ===\\n\")\n  cat(sprintf(\"Method 1 - Mean absolute error: %.3f%%\\n\", mean(results1$Error_pct)))\n  cat(sprintf(\"Method 2 - Mean absolute error: %.3f%%\\n\", mean(results2$Error_pct)))\n  cat(sprintf(\"Method 3 - Mean absolute error: %.3f%%\\n\", mean(results3$Error_pct)))\n\n  coverage1 &lt;- mean(results1$Market_In_CI) * 100\n  coverage2 &lt;- mean(results2$Market_In_CI) * 100\n  coverage3 &lt;- mean(results3$Market_In_CI) * 100\n\n  cat(\"\\n=== CI Coverage ===\\n\")\n  cat(sprintf(\"Method 1 - Market in 99%% CI: %.0f%%\\n\", coverage1))\n  cat(sprintf(\"Method 2 - Market in 99%% CI: %.0f%%\\n\", coverage2))\n  cat(sprintf(\"Method 3 - Market in 99%% CI: %.0f%%\\n\", coverage3))\n  cat(sprintf(\"\\nAvg CI Width: %.1f bps (M1), %.1f bps (M2), %.1f bps (M3)\\n\",\n              mean(results1$CI_Width_bps), mean(results2$CI_Width_bps),\n              mean(results3$CI_Width_bps)))\n\n  return(bind_rows(results_list))\n}\n\n# ============================================================================\n# 11. Main Execution\n# ============================================================================\ncat(\"=== Arbitrage-Free Framework: NMOF Implementation ===\\n\")\ncat(\"Using vectorized NS() and NSS() functions\\n\\n\")\n\n# Generate data for both NS and NSS\ncat(\"Generating synthetic yield curves...\\n\")\ndata_ns &lt;- generate_yield_curve_ns(n_dates = 100)\ndata_nss &lt;- generate_yield_curve_nss(n_dates = 100)\n\n# Run analysis for NS\nresults_ns &lt;- run_analysis(data_ns, \"NELSON-SIEGEL (NS)\")\n\n# Run analysis for NSS\nresults_nss &lt;- run_analysis(data_nss, \"NELSON-SIEGEL-SVENSSON (NSS)\")\n\n# ============================================================================\n# 12. Comparative Visualization\n# ============================================================================\ncat(\"\\n=== Generating Comparative Visualization ===\\n\")\n\nlibrary(gridExtra)\n\n# Add model type to results\nresults_ns &lt;- results_ns %&gt;% mutate(Model = \"NS\")\nresults_nss &lt;- results_nss %&gt;% mutate(Model = \"NSS\")\nall_results &lt;- bind_rows(results_ns, results_nss)\n\n# Plot 3: Adjusted vs Market Prices\np3 &lt;- ggplot(all_results, aes(x = Maturity)) +\n  geom_point(aes(y = Market), size = 3, shape = 4, stroke = 2) +\n  geom_point(aes(y = Adjusted, color = Model), size = 2, alpha = 0.7) +\n  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper, color = Model),\n                width = 0.2, alpha = 0.5) +\n  facet_wrap(~Method, ncol = 3) +\n  scale_color_manual(values = c(\"NS\" = \"#E41A1C\", \"NSS\" = \"#377EB8\")) +\n  labs(title = \"Adjusted Prices with Confidence Intervals\",\n       subtitle = \"Market prices (×) vs Adjusted prices (•) with 95% CI\",\n       x = \"Maturity (Years)\", y = \"Zero-Coupon Bond Prices\") +\n  theme_minimal(base_size = 11) +\n  theme(legend.position = \"bottom\", strip.text = element_text(face = \"bold\"))\n\nprint(p3)\n\n\r\n=== Arbitrage-Free Framework: NMOF Implementation ===\nUsing vectorized NS() and NSS() functions\n\nGenerating synthetic yield curves...\n\n========== NELSON-SIEGEL (NS) ANALYSIS ==========\n\nMarket ZCB Prices:\n  Maturity    Price\n1        1 0.944368\n2        3 0.841025\n3        5 0.748991\n4        7 0.667029\n5       10 0.560591\n\n--- METHOD 1: Short rates \n with NS/NSS Extrapolation ---\nShort rate (last obs): 3.2570%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.967691 0.943862     0.054 0.943584 0.944152\n2        3 0.841025   0.905163 0.841066     0.005 0.840352 0.841831\n3        5 0.748991   0.846230 0.749097     0.014 0.748257 0.750021\n4        7 0.667029   0.791175 0.667194     0.025 0.666362 0.668134\n5       10 0.560591   0.715174 0.560692     0.018 0.559592 0.561671\n  CI_Width_bps Market_In_CI\n1          5.7        FALSE\n2         14.8         TRUE\n3         17.6         TRUE\n4         17.7         TRUE\n5         20.8         TRUE\n\n--- METHOD 2: Short rates \n with NS/NSS + Random Forest ---\nShort rate (last obs): 5.6769%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.944570 0.943958     0.043 0.943678 0.944300\n2        3 0.841025   0.841244 0.841482     0.054 0.840561 0.842174\n3        5 0.748991   0.748978 0.749251     0.035 0.748509 0.749930\n4        7 0.667029   0.666754 0.667387     0.054 0.666451 0.668276\n5       10 0.560591   0.558617 0.561682     0.195 0.560760 0.562701\n  CI_Width_bps Market_In_CI\n1          6.2        FALSE\n2         16.1         TRUE\n3         14.2         TRUE\n4         18.3         TRUE\n5         19.4        FALSE\n\n--- METHOD 3: Short rates \n with Direct Regression ---\nShort rate (last obs): 5.6515%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.944368   0.944990 0.943743     0.066 0.943456 0.944000\n2        3 0.841025   0.843021 0.841146     0.014 0.840457 0.841841\n3        5 0.748991   0.751161 0.749289     0.040 0.748411 0.750119\n4        7 0.667029   0.668924 0.667445     0.062 0.666569 0.668325\n5       10 0.560591   0.561686 0.560619     0.005 0.559444 0.561621\n  CI_Width_bps Market_In_CI\n1          5.4        FALSE\n2         13.8         TRUE\n3         17.1         TRUE\n4         17.6         TRUE\n5         21.8         TRUE\n\n=== SUMMARY ===\nMethod 1 - Mean absolute error: 0.023%\nMethod 2 - Mean absolute error: 0.076%\nMethod 3 - Mean absolute error: 0.037%\n\n=== CI Coverage ===\nMethod 1 - Market in 99% CI: 80%\nMethod 2 - Market in 99% CI: 60%\nMethod 3 - Market in 99% CI: 80%\n\nAvg CI Width: 15.3 bps (M1), 14.8 bps (M2), 15.1 bps (M3)\n\n========== NELSON-SIEGEL-SVENSSON (NSS) ANALYSIS ==========\n\nMarket ZCB Prices:\n  Maturity    Price\n1        1 0.941887\n2        3 0.836276\n3        5 0.742752\n4        7 0.659696\n5       10 0.552198\n\n--- METHOD 1: Short rates \n with NS/NSS Extrapolation ---\nShort rate (last obs): 4.6355%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.954688 0.942270     0.041 0.941853 0.942716\n2        3 0.836276   0.871008 0.835715     0.067 0.834544 0.836739\n3        5 0.742752   0.794980 0.741836     0.123 0.740349 0.743138\n4        7 0.659696   0.726242 0.658950     0.113 0.657747 0.660143\n5       10 0.552198   0.633806 0.551628     0.103 0.549925 0.553257\n  CI_Width_bps Market_In_CI\n1          8.6         TRUE\n2         21.9         TRUE\n3         27.9         TRUE\n4         24.0         TRUE\n5         33.3         TRUE\n\n--- METHOD 2: Short rates \n with NS/NSS + Random Forest ---\nShort rate (last obs): 5.9567%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.942313 0.942164     0.029 0.941784 0.942523\n2        3 0.836276   0.836567 0.836628     0.042 0.835661 0.837590\n3        5 0.742752   0.742821 0.743231     0.064 0.741899 0.744219\n4        7 0.659696   0.658894 0.660377     0.103 0.659165 0.661587\n5       10 0.552198   0.549714 0.552640     0.080 0.551440 0.554016\n  CI_Width_bps Market_In_CI\n1          7.4         TRUE\n2         19.3         TRUE\n3         23.2         TRUE\n4         24.2         TRUE\n5         25.8         TRUE\n\n--- METHOD 3: Short rates \n with Direct Regression ---\nShort rate (last obs): 5.9770%\nComputing calibrated confidence intervals...\n\nResults:\n  Maturity   Market Unadjusted Adjusted Error_pct CI_Lower CI_Upper\n1        1 0.941887   0.942102 0.942063     0.019 0.941738 0.942405\n2        3 0.836276   0.836988 0.836231     0.005 0.835452 0.837112\n3        5 0.742752   0.742843 0.743059     0.041 0.742083 0.744069\n4        7 0.659696   0.658711 0.659669     0.004 0.658707 0.660866\n5       10 0.552198   0.550538 0.552046     0.028 0.550710 0.553238\n  CI_Width_bps Market_In_CI\n1          6.7         TRUE\n2         16.6         TRUE\n3         19.9         TRUE\n4         21.6         TRUE\n5         25.3         TRUE\n\n=== SUMMARY ===\nMethod 1 - Mean absolute error: 0.089%\nMethod 2 - Mean absolute error: 0.064%\nMethod 3 - Mean absolute error: 0.019%\n\n=== CI Coverage ===\nMethod 1 - Market in 99% CI: 100%\nMethod 2 - Market in 99% CI: 100%\nMethod 3 - Market in 99% CI: 100%\n\nAvg CI Width: 23.1 bps (M1), 20.0 bps (M2), 18.0 bps (M3)\n\n=== Generating Comparative Visualization ===\n</pre>\n<p><img alt=\"image-title-here\" class=\"img-responsive\" data-lazy-src=\"https://i0.wp.com/thierrymoudiki.github.io/images/2025-10-28/2025-10-28-deterministic-shift_2_1.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"image-title-here\" class=\"img-responsive\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/thierrymoudiki.github.io/images/2025-10-28/2025-10-28-deterministic-shift_2_1.png?w=578&amp;ssl=1\"/></noscript></p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://thierrymoudiki.github.io//blog/2025/10/28/r/deterministic-shift\"> T. Moudiki's Webpage - R</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div> </div>\n</article>",
    "word_count": 3017,
    "reading_time_min": 15.1,
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/t-moudiki/",
        "text": "T. Moudiki"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "external_links": [
      {
        "href": "https://thierrymoudiki.github.io//blog/2025/10/28/r/deterministic-shift",
        "text": "T. Moudiki's Webpage - R"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://thierrymoudiki.github.io/blog/2025/10/27/r/python/deterministic-shift-caps-swaptions",
        "text": "https://thierrymoudiki.github.io/blog/2025/10/27/r/python/deterministic-shift-caps-swaptions"
      },
      {
        "href": "https://www.researchgate.net/publication/393794192_New_Short_Rate_Models_and_their_Arbitrage-Free_Extension_A_Flexible_Framework_for_Historical_and_Market-Consistent_Simulation",
        "text": "https://www.researchgate.net/publication/393794192_New_Short_Rate_Models_and_their_Arbitrage-Free_Extension_A_Flexible_Framework_for_Historical_and_Market-Consistent_Simulation"
      },
      {
        "href": "https://thierrymoudiki.github.io//blog/2025/10/28/r/deterministic-shift",
        "text": "T. Moudiki's Webpage - R"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "images": [
      {
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif",
        "alt": "image-title-here",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
      },
      {
        "src": "https://i0.wp.com/thierrymoudiki.github.io/images/2025-10-28/2025-10-28-deterministic-shift_2_1.png?w=578&ssl=1",
        "alt": "image-title-here",
        "base64": "data:image/jpeg;base64,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"
      }
    ],
    "lang": "en-US",
    "crawled_at_utc": "2026-01-04T05:36:16Z"
  }
}