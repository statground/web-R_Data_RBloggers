{
  "id": "401ba727cd20acc81735d3da8dec18bbaecf57a8",
  "url": "https://www.r-bloggers.com/2026/01/fight-data-science-in-r-proven-boxing-metrics-models/",
  "created_at_utc": "2026-01-26T01:26:54Z",
  "crawled_at_utc": "2026-01-26T01:26:57Z",
  "html_title": "Fight Data Science in R: Proven Boxing Metrics & Models | R-bloggers",
  "meta_description": "Boxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is data science: repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy. This post shows how to build a professional fight data science workflow in R—from raw data to metrics, modeling, and tactical insights—using code […] The post Fight Data Science in R: Proven Boxing Metrics & Models appeared first on R Programming Books.",
  "data": {
    "url": "https://www.r-bloggers.com/2026/01/fight-data-science-in-r-proven-boxing-metrics-models/",
    "canonical_url": "https://www.r-bloggers.com/2026/01/fight-data-science-in-r-proven-boxing-metrics-models/",
    "html_title": "Fight Data Science in R: Proven Boxing Metrics & Models | R-bloggers",
    "h1_title": "R-bloggers",
    "meta_description": "Boxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is data science: repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy. This post shows how to build a professional fight data science workflow in R—from raw data to metrics, modeling, and tactical insights—using code […] The post Fight Data Science in R: Proven Boxing Metrics & Models appeared first on R Programming Books.",
    "meta_keywords": null,
    "og_title": "Fight Data Science in R: Proven Boxing Metrics & Models | R-bloggers",
    "og_description": "Boxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is data science: repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy. This post shows how to build a professional fight data science workflow in R—from raw data to metrics, modeling, and tactical insights—using code […] The post Fight Data Science in R: Proven Boxing Metrics & Models appeared first on R Programming Books.",
    "og_image": "https://www.r-bloggers.com/wp-content/uploads/2016/04/R_02_2016-05-01.png",
    "twitter_title": "Fight Data Science in R: Proven Boxing Metrics & Models | R-bloggers",
    "twitter_description": "Boxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is data science: repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy. This post shows how to build a professional fight data science workflow in R—from raw data to metrics, modeling, and tactical insights—using code […] The post Fight Data Science in R: Proven Boxing Metrics & Models appeared first on R Programming Books.",
    "raw_jsonld_article": null,
    "article_headline": null,
    "article_section": null,
    "article_tags": null,
    "article_author": null,
    "article_published": null,
    "article_modified": null,
    "main_text": "Fight Data Science in R: Proven Boxing Metrics & Models\nPosted on\nJanuary 25, 2026\nby\nrprogrammingbooks\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nBlog - R Programming Books\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nBoxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is\ndata science\n:\n    repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy.\n    This post shows how to build a professional\nfight data science workflow in R\n—from raw data to metrics,\n    modeling, and tactical insights—using code you can adapt to your own datasets.\nYou’ll get: a production-style project structure, data contracts, validation checks, feature engineering patterns,\n    round-by-round models, fatigue and momentum signals, and high-signal visualizations for coaches and analysts.\n    The goal is to help you move from “interesting charts” to\ndecision-grade\nanalytics.\nTable of Contents\n1) Professional setup and project structure\n2) A fight data contract (schemas that prevent chaos)\n3) Ingestion and standardization\n4) Validation, QA, and anomaly detection\n5) Feature engineering: pace, accuracy, intent, damage proxies\n6) Round-by-round modeling (probability of winning a round)\n7) Fight outcome modeling (interpretable + calibrated)\n8) Fatigue, momentum, and tactical shifts\n9) Visual analytics for strategy\n10) Scalable pipelines: Parquet, DuckDB, reproducibility\n11) Wrap-up and next steps\n1) Professional setup and project structure\nA “pro” analytics workflow starts with discipline: consistent folders, reproducible environments, and clear separation of\n    raw → clean → features → models. Even if you’re solo, this structure makes your work easier to iterate and publish.\n# Core libraries for fight data science\npkgs <- c(\n  \"tidyverse\", \"janitor\", \"lubridate\", \"glue\", \"cli\",\n  \"arrow\", \"here\", \"fs\",\n  \"duckdb\", \"DBI\",\n  \"slider\",\n  \"rsample\", \"recipes\", \"parsnip\", \"workflows\", \"tune\", \"dials\",\n  \"yardstick\", \"broom\",\n  \"ggrepel\", \"patchwork\"\n)\n\nto_install <- pkgs[!pkgs %in% installed.packages()[, \"Package\"]]\nif (length(to_install) > 0) install.packages(to_install, dependencies = TRUE)\ninvisible(lapply(pkgs, library, character.only = TRUE))\n\n# Create a clean project layout (idempotent)\ndirs <- c(\n  \"data/raw\",\n  \"data/clean\",\n  \"data/features\",\n  \"data/models\",\n  \"plots\",\n  \"reports\",\n  \"R\"\n)\n\nwalk(dirs, ~ fs::dir_create(here::here(.x)))\n\nlog_info <- function(...) cli::cli_alert_info(glue::glue(...))\nlog_ok   <- function(...) cli::cli_alert_success(glue::glue(...))\n\nlog_ok(\"Project folders ready at: {here::here()}\")\nTip: store raw files read-only, and always write standardized outputs (e.g., Parquet) to\ndata/clean/\n.\n    You’ll instantly speed up your workflow and reduce “mystery bugs.”\n2) A fight data contract (schemas that prevent chaos)\nThe fastest way to break a fight analytics project is to let columns drift (“fighter” vs “boxer”, mixed date formats,\n    different naming conventions for the same actions). A data contract prevents that.\n    Below are two useful contracts:\nRound totals\n(works with CompuBox-style aggregates)\nEvent-level metadata\n(for joining and reporting)\nround_schema <- tibble::tribble(\n  ~column,              ~type,       ~notes,\n  \"fight_id\",           \"character\",  \"Unique fight identifier\",\n  \"event_id\",           \"character\",  \"Unique event identifier\",\n  \"event_date\",         \"date\",       \"ISO date\",\n  \"weight_class\",       \"character\",  \"e.g., Welterweight\",\n  \"fighter\",            \"character\",  \"This row's fighter\",\n  \"opponent\",           \"character\",  \"Opponent fighter\",\n  \"corner\",             \"character\",  \"Red/Blue or A/B\",\n  \"round\",              \"integer\",    \"Round number\",\n  \"jabs_landed\",        \"integer\",    \"Jabs landed\",\n  \"jabs_attempted\",     \"integer\",    \"Jabs attempted\",\n  \"power_landed\",       \"integer\",    \"Power shots landed\",\n  \"power_attempted\",    \"integer\",    \"Power shots attempted\",\n  \"knockdowns\",         \"integer\",    \"Knockdowns in round\",\n  \"stance\",             \"character\",  \"orthodox/southpaw/other\",\n  \"result_round\",       \"integer\",    \"1 if fighter won the round, 0 if lost (or NA if unknown)\"\n)\n\nevent_schema <- tibble::tribble(\n  ~column,         ~type,       ~notes,\n  \"event_id\",      \"character\", \"Unique event identifier\",\n  \"event_name\",    \"character\", \"Event name\",\n  \"event_date\",    \"date\",      \"ISO date\",\n  \"location\",      \"character\", \"City/Country (optional)\",\n  \"promotion\",     \"character\", \"Promotion/org (optional)\"\n)\n\nround_schema\nIf you don’t have\nresult_round\n, you can still do great analytics: predict round outcomes, infer momentum,\n    and quantify “who was in control” using validated scoring proxies.\n3) Ingestion and standardization\nHere’s a robust ingestion pattern: read raw CSVs, normalize names, enforce types, standardize fighter naming,\n    and write Parquet for speed. Adjust paths to your sources.\nread_round_totals <- function(path) {\n  log_info(\"Reading raw round totals: {path}\")\n  readr::read_csv(path, show_col_types = FALSE) %>%\n    janitor::clean_names()\n}\n\nstandardize_round_totals <- function(df) {\n  df %>%\n    mutate(\n      event_date = as.Date(event_date),\n      round = as.integer(round),\n      across(\n        c(jabs_landed, jabs_attempted, power_landed, power_attempted, knockdowns),\n        ~ as.integer(replace_na(.x, 0))\n      ),\n      across(c(fight_id, event_id, fighter, opponent, weight_class, stance, corner), as.character),\n      stance = tolower(stance),\n      corner = toupper(corner)\n    ) %>%\n    # Basic name normalization\n    mutate(\n      fighter  = str_squish(str_replace_all(fighter, \"\\\\s+\", \" \")),\n      opponent = str_squish(str_replace_all(opponent, \"\\\\s+\", \" \")),\n      weight_class = str_squish(weight_class)\n    )\n}\n\nwrite_clean_parquet <- function(df, out_path) {\n  fs::dir_create(fs::path_dir(out_path))\n  arrow::write_parquet(df, out_path)\n  log_ok(\"Wrote Parquet: {out_path}\")\n}\n\n# Example:\n# raw_path  <- here::here(\"data/raw/round_totals.csv\")\n# clean_out <- here::here(\"data/clean/round_totals.parquet\")\n# rounds_clean <- read_round_totals(raw_path) %>% standardize_round_totals()\n# write_clean_parquet(rounds_clean, clean_out)\nParquet is a game-changer for analytics work: fast I/O, consistent types, and easy integration with DuckDB for SQL-style querying.\n4) Validation, QA, and anomaly detection\nFight data is full of subtle mistakes: attempted shots < landed shots, duplicated rounds, mixed fighter/opponent rows,\n    or “impossible” knockdown counts. Validation should be automatic.\nvalidate_round_totals <- function(df) {\n  # Required columns check\n  required <- round_schema$column\n  missing_cols <- setdiff(required, names(df))\n  if (length(missing_cols) > 0) {\n    stop(glue::glue(\"Missing required columns: {paste(missing_cols, collapse=', ')}\"))\n  }\n\n  # Logical checks\n  bad_landed <- df %>%\n    filter(jabs_landed > jabs_attempted | power_landed > power_attempted)\n\n  if (nrow(bad_landed) > 0) {\n    log_info(\"Found {nrow(bad_landed)} rows where landed > attempted (check source or parsing).\")\n  }\n\n  # Duplicate round rows (same fight_id, fighter, round)\n  dupes <- df %>%\n    count(fight_id, fighter, round) %>%\n    filter(n > 1)\n\n  if (nrow(dupes) > 0) {\n    log_info(\"Found duplicates: {nrow(dupes)} fight/fighter/round combinations.\")\n  }\n\n  # Suspicious extremes (simple heuristic)\n  suspicious <- df %>%\n    mutate(total_attempted = jabs_attempted + power_attempted) %>%\n    filter(total_attempted > 120 | knockdowns > 3)\n\n  if (nrow(suspicious) > 0) {\n    log_info(\"Found {nrow(suspicious)} suspicious rows (very high volume or knockdowns).\")\n  }\n\n  df\n}\n\n# Example:\n# rounds_clean <- rounds_clean %>% validate_round_totals()\nValidation gives you confidence. And confidence is what makes analytics actionable—especially when you’re presenting results\n    to coaches, fighters, or bettors who will challenge your assumptions.\n5) Feature engineering: pace, accuracy, intent, damage proxies\nFight performance is multidimensional. A clean feature set usually includes:\nPace:\nattempts per round, pace change across rounds\nAccuracy:\nlanded / attempted (jabs, power, total)\nIntent / style:\njab share vs power share\nDamage proxies:\npower landed, knockdowns, power accuracy\nRelative dominance:\nfighter metrics minus opponent metrics\nengineer_round_features <- function(df) {\n  df %>%\n    mutate(\n      total_landed    = jabs_landed + power_landed,\n      total_attempted = jabs_attempted + power_attempted,\n      acc_jab   = if_else(jabs_attempted > 0, jabs_landed / jabs_attempted, NA_real_),\n      acc_power = if_else(power_attempted > 0, power_landed / power_attempted, NA_real_),\n      acc_total = if_else(total_attempted > 0, total_landed / total_attempted, NA_real_),\n      jab_share_attempts = if_else(total_attempted > 0, jabs_attempted / total_attempted, NA_real_),\n      power_share_attempts = if_else(total_attempted > 0, power_attempted / total_attempted, NA_real_),\n      # Simple damage proxy: power landed + weighted knockdowns\n      damage_proxy = power_landed + 8 * knockdowns\n    )\n}\n\n# Opponent-relative features (requires pairing fighter vs opponent within the same fight_id and round)\nadd_relative_features <- function(df) {\n  df2 <- df %>%\n    select(fight_id, round, fighter, opponent,\n           total_landed, total_attempted, acc_total,\n           power_landed, power_attempted, acc_power,\n           damage_proxy, knockdowns) %>%\n    rename_with(~ paste0(\"opp_\", .x), -c(fight_id, round, fighter, opponent)) %>%\n    rename(fighter_join = opponent, opponent_join = fighter)\n\n  df %>%\n    left_join(\n      df2,\n      by = c(\"fight_id\" = \"fight_id\", \"round\" = \"round\", \"fighter\" = \"fighter_join\", \"opponent\" = \"opponent_join\")\n    ) %>%\n    mutate(\n      rel_total_landed = total_landed - opp_total_landed,\n      rel_acc_total    = acc_total - opp_acc_total,\n      rel_power_landed = power_landed - opp_power_landed,\n      rel_damage       = damage_proxy - opp_damage_proxy,\n      rel_knockdowns   = knockdowns - opp_knockdowns\n    )\n}\n\n# Example:\n# rounds_feat <- rounds_clean %>% engineer_round_features() %>% add_relative_features()\nRelative features are where fight analytics becomes tactical: a fighter’s pace means little without context.\n    Dominance is “what you did” minus “what you absorbed.”\n6) Round-by-round modeling (probability of winning a round)\nIf you have labeled rounds (\nresult_round\n= 1/0), you can model round outcomes using interpretable classifiers.\n    Even if you don’t, you can label from trusted sources or use proxy labels (with caution).\nBelow is an end-to-end workflow using\ntidymodels\n:\n    split, recipe, logistic regression with regularization, tuning, and calibration-friendly evaluation.\n# Assume you have rounds_feat with result_round (1/0) for some fights\n# rounds_feat <- rounds_feat %>% filter(!is.na(result_round))\n\nset.seed(123)\nspl <- rsample::initial_split(rounds_feat %>% filter(!is.na(result_round)), prop = 0.8, strata = result_round)\ntrain <- rsample::training(spl)\ntest  <- rsample::testing(spl)\n\nrec <- recipes::recipe(result_round ~ rel_total_landed + rel_acc_total + rel_power_landed + rel_damage +\n                        total_attempted + acc_total + jab_share_attempts + damage_proxy +\n                        stance,\n                      data = train) %>%\n  step_impute_median(all_numeric_predictors()) %>%\n  step_impute_mode(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors()) %>%\n  step_normalize(all_numeric_predictors())\n\nmod <- parsnip::logistic_reg(penalty = tune(), mixture = 1) %>%\n  set_engine(\"glmnet\")\n\nwf <- workflows::workflow() %>%\n  add_recipe(rec) %>%\n  add_model(mod)\n\ngrid <- dials::grid_regular(dials::penalty(range = c(-6, 0)), levels = 30)\n\nset.seed(123)\nfolds <- rsample::vfold_cv(train, v = 5, strata = result_round)\n\nmetrics <- yardstick::metric_set(yardstick::roc_auc, yardstick::pr_auc, yardstick::accuracy, yardstick::mn_log_loss)\n\ntuned <- tune::tune_grid(\n  wf,\n  resamples = folds,\n  grid = grid,\n  metrics = metrics\n)\n\nbest <- tune::select_best(tuned, metric = \"mn_log_loss\")\nfinal_wf <- tune::finalize_workflow(wf, best)\n\nfinal_fit <- final_wf %>% fit(train)\n\n# Evaluate on holdout test set\ntest_pred <- predict(final_fit, test, type = \"prob\") %>%\n  bind_cols(test %>% select(result_round))\n\nyardstick::roc_auc(test_pred, truth = result_round, .pred_1)\nyardstick::mn_log_loss(test_pred, truth = result_round, .pred_1)\nWhy log loss? Because in fight analytics,\ncalibrated probabilities\nmatter.\n    A model that says “0.55” should be right ~55% of the time—not just classify correctly.\n7) Fight outcome modeling (interpretable + calibrated)\nFight outcomes can be modeled from aggregated round features:\n    average dominance, variance (consistency), late-round fade, and knockdown impacts.\n    First, summarize per fight and fighter.\nsummarize_fight_features <- function(df) {\n  df %>%\n    group_by(fight_id, event_id, event_date, weight_class, fighter, opponent) %>%\n    summarise(\n      rounds = n(),\n      avg_rel_damage = mean(rel_damage, na.rm = TRUE),\n      avg_rel_power_landed = mean(rel_power_landed, na.rm = TRUE),\n      avg_rel_total_landed = mean(rel_total_landed, na.rm = TRUE),\n      avg_rel_acc_total = mean(rel_acc_total, na.rm = TRUE),\n      # Volatility/consistency\n      sd_rel_damage = sd(rel_damage, na.rm = TRUE),\n      # Pace markers\n      avg_total_attempted = mean(total_attempted, na.rm = TRUE),\n      # Knockdown signal\n      total_knockdowns = sum(knockdowns, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n}\n\nfight_level <- summarize_fight_features(rounds_feat)\n\n# If you have fight outcome label for fighter perspective (win=1/lose=0):\n# fight_level <- fight_level %>% left_join(outcomes, by = c(\"fight_id\",\"fighter\"))\nThen model fight wins with an interpretable learner. Logistic regression is often a strong baseline; boosted trees can\n    add performance if you keep explainability via feature importance and partial dependence (where appropriate).\n# Example: win label in fight_level as win (1/0)\nset.seed(42)\nspl2 <- rsample::initial_split(fight_level %>% filter(!is.na(win)), prop = 0.8, strata = win)\ntr2 <- training(spl2)\nte2 <- testing(spl2)\n\nrec2 <- recipe(win ~ avg_rel_damage + avg_rel_power_landed + avg_rel_total_landed +\n                avg_rel_acc_total + sd_rel_damage + avg_total_attempted + total_knockdowns,\n              data = tr2) %>%\n  step_impute_median(all_numeric_predictors()) %>%\n  step_normalize(all_numeric_predictors())\n\nmod2 <- logistic_reg(penalty = tune(), mixture = 1) %>% set_engine(\"glmnet\")\n\nwf2 <- workflow() %>% add_recipe(rec2) %>% add_model(mod2)\n\ngrid2 <- grid_regular(penalty(range = c(-7, 0)), levels = 40)\n\nset.seed(42)\nfolds2 <- vfold_cv(tr2, v = 5, strata = win)\n\ntuned2 <- tune_grid(wf2, resamples = folds2, grid = grid2, metrics = metrics)\n\nbest2 <- select_best(tuned2, \"mn_log_loss\")\nfinal2 <- finalize_workflow(wf2, best2) %>% fit(tr2)\n\npred2 <- predict(final2, te2, type = \"prob\") %>% bind_cols(te2 %>% select(win))\nroc_auc(pred2, truth = win, .pred_1)\nmn_log_loss(pred2, truth = win, .pred_1)\n\n# Inspect coefficients (interpretability)\nfinal2 %>%\n  extract_fit_parsnip() %>%\n  broom::tidy() %>%\n  arrange(desc(abs(estimate))) %>%\n  head(20)\nA practical coaching readout might be: “Your average relative damage was +4 per round, but volatility was high.\n    You won the peaks and lost the valleys—work on maintaining output in the middle rounds.”\n8) Fatigue, momentum, and tactical shifts\nFatigue often shows up as a drop in attempt rate, a decline in power accuracy, or a shift toward safer output (more jabs, fewer exchanges).\n    Momentum often appears as\nmulti-round streaks\nin relative dominance.\nBelow are two useful constructs:\nFatigue Index:\ncompare late rounds vs early rounds on pace and accuracy\nMomentum Signal:\nrolling mean of relative damage/dominance\nfatigue_index <- function(df) {\n  df %>%\n    group_by(fight_id, fighter) %>%\n    mutate(\n      early = round <= 3,\n      late  = round >= max(round, na.rm = TRUE) - 2\n    ) %>%\n    summarise(\n      early_pace = mean(total_attempted[early], na.rm = TRUE),\n      late_pace  = mean(total_attempted[late], na.rm = TRUE),\n      early_acc  = mean(acc_total[early], na.rm = TRUE),\n      late_acc   = mean(acc_total[late], na.rm = TRUE),\n      fatigue_pace_drop = (late_pace - early_pace) / pmax(early_pace, 1),\n      fatigue_acc_drop  = (late_acc - early_acc) / pmax(early_acc, 1e-6),\n      .groups = \"drop\"\n    ) %>%\n    mutate(\n      fatigue_score = 0.7 * fatigue_pace_drop + 0.3 * fatigue_acc_drop\n    )\n}\n\nmomentum_signal <- function(df, window = 3) {\n  df %>%\n    arrange(fight_id, fighter, round) %>%\n    group_by(fight_id, fighter) %>%\n    mutate(\n      rel_damage_roll = slider::slide_dbl(rel_damage, mean, .before = window - 1, .complete = FALSE, na.rm = TRUE),\n      rel_landed_roll = slider::slide_dbl(rel_total_landed, mean, .before = window - 1, .complete = FALSE, na.rm = TRUE)\n    ) %>%\n    ungroup()\n}\n\nfatigue_tbl <- fatigue_index(rounds_feat)\nrounds_mom <- momentum_signal(rounds_feat, window = 3)\nInterpretation tips:\nFatigue score negative\n→ late output/accuracy declined (common)\nFatigue score near zero\n→ stable performance (valuable at elite levels)\nRolling dominance crossing zero\n→ tactical turning point (corner adjustments matter most here)\n9) Visual analytics for strategy\nThe “best” plots are the ones that change decisions.\n    Two strategy-grade visuals:\nDominance timeline\n(relative damage rolling mean)\nStyle map\n(jab share vs power accuracy)\nplot_dominance_timeline <- function(df, fight_id_pick, fighter_pick) {\n  d <- df %>%\n    filter(fight_id == fight_id_pick, fighter == fighter_pick) %>%\n    arrange(round)\n\n  ggplot(d, aes(x = round, y = rel_damage_roll)) +\n    geom_hline(yintercept = 0, linewidth = 0.6) +\n    geom_line(linewidth = 1) +\n    geom_point(size = 2) +\n    labs(\n      x = \"Round\",\n      y = \"Rolling Relative Damage (windowed mean)\",\n      title = \"Dominance Timeline\",\n      subtitle = glue::glue(\"Fight {fight_id_pick} — {fighter_pick}\")\n    ) +\n    theme_minimal(base_size = 12)\n}\n\nplot_style_map <- function(df, fight_id_pick) {\n  d <- df %>%\n    filter(fight_id == fight_id_pick) %>%\n    group_by(fighter) %>%\n    summarise(\n      jab_share = mean(jab_share_attempts, na.rm = TRUE),\n      power_acc = mean(acc_power, na.rm = TRUE),\n      pace = mean(total_attempted, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n\n  ggplot(d, aes(x = jab_share, y = power_acc, label = fighter, size = pace)) +\n    geom_point(alpha = 0.7) +\n    ggrepel::geom_text_repel(max.overlaps = 50) +\n    labs(\n      x = \"Jab Share (Attempts)\",\n      y = \"Power Accuracy\",\n      title = \"Style Map (per fight)\",\n      subtitle = \"Higher pace = larger point\"\n    ) +\n    theme_minimal(base_size = 12)\n}\n\n# Example:\n# p1 <- plot_dominance_timeline(rounds_mom, fight_id_pick = \"F123\", fighter_pick = \"Fighter A\")\n# p2 <- plot_style_map(rounds_feat, fight_id_pick = \"F123\")\n# p1 + p2\nHow coaches use these:\nIf dominance drops after round 4, check conditioning or defensive adjustments from the opponent.\nIf jab share is high but power accuracy is low, the jab may be “busy” but not creating openings.\nIf pace is high and accuracy stable, that’s often a winning profile—especially across long fights.\n10) Scalable pipelines: Parquet, DuckDB, reproducibility\nOnce your data grows (multiple events, seasons, amateur + pro, different sources),\n    SQL-style analysis becomes extremely useful. DuckDB lets you query Parquet directly with zero database admin.\n# Connect to DuckDB (in-memory or file-backed)\ncon <- DBI::dbConnect(duckdb::duckdb(), dbdir = here::here(\"data/fight_analytics.duckdb\"))\n\n# Point DuckDB at a Parquet file (or a folder of Parquet files)\nparquet_path <- here::here(\"data/clean/round_totals.parquet\")\n\nDBI::dbExecute(con, glue::glue(\"\n  CREATE OR REPLACE VIEW rounds AS\n  SELECT * FROM read_parquet('{parquet_path}')\n\"))\n\n# Example: top rounds by volume (attempted punches)\ntop_volume <- DBI::dbGetQuery(con, \"\n  SELECT fighter, fight_id, round,\n         (jabs_attempted + power_attempted) AS total_attempted\n  FROM rounds\n  ORDER BY total_attempted DESC\n  LIMIT 25\n\")\n\ntop_volume %>% as_tibble()\n\n# Close when done\nDBI::dbDisconnect(con, shutdown = TRUE)\nThis makes it easy to build reliable reporting:\n    “Highest pace fights,” “Largest late-round fades,” “Most consistent dominance,” and “Knockdown-driven wins.”\n11) Wrap-up and next steps\nA fight data science workflow in R becomes powerful when you combine:\nClean contracts\nso your data doesn’t drift\nValidation\nso your results are trustworthy\nRelative features\nso metrics become tactical\nProbability models\nso conclusions are calibrated\nFatigue/momentum\nso strategy reflects real turning points\nIf you want a more structured, end-to-end path with deeper modeling, richer case studies, and a full workflow designed specifically for boxing,\n    you may like this resource:\na complete hands-on book focused on boxing data science and fight performance strategy in R\n.\nThe post\nFight Data Science in R: Proven Boxing Metrics & Models\nappeared first on\nR Programming Books\n.\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nBlog - R Programming Books\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "main_html": "<article class=\"post-398565 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">Fight Data Science in R: Proven Boxing Metrics &amp; Models</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">January 25, 2026</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/rprogrammingbooks/\">rprogrammingbooks</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \n<div style=\"min-height: 30px;\">\n[social4i size=\"small\" align=\"align-left\"]\n</div>\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\n[This article was first published on  <strong><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing\"> Blog - R Programming Books</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div class=\"post-content\">\n<p>\n    Boxing analysis is no longer just about punch totals or “who looked busier.” Modern fight analysis is <strong>data science</strong>:\n    repeatable pipelines, validated data, explainable models, and performance indicators that translate into strategy.\n    This post shows how to build a professional <strong>fight data science workflow in R</strong>—from raw data to metrics,\n    modeling, and tactical insights—using code you can adapt to your own datasets.\n  </p>\n<p>\n    You’ll get: a production-style project structure, data contracts, validation checks, feature engineering patterns,\n    round-by-round models, fatigue and momentum signals, and high-signal visualizations for coaches and analysts.\n    The goal is to help you move from “interesting charts” to <em>decision-grade</em> analytics.\n  </p>\n<hr/>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#setup\" rel=\"nofollow\" target=\"_blank\">1) Professional setup and project structure</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#data-contract\" rel=\"nofollow\" target=\"_blank\">2) A fight data contract (schemas that prevent chaos)</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#ingestion\" rel=\"nofollow\" target=\"_blank\">3) Ingestion and standardization</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#validation\" rel=\"nofollow\" target=\"_blank\">4) Validation, QA, and anomaly detection</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#features\" rel=\"nofollow\" target=\"_blank\">5) Feature engineering: pace, accuracy, intent, damage proxies</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#round-models\" rel=\"nofollow\" target=\"_blank\">6) Round-by-round modeling (probability of winning a round)</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#fight-outcome\" rel=\"nofollow\" target=\"_blank\">7) Fight outcome modeling (interpretable + calibrated)</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#fatigue-momentum\" rel=\"nofollow\" target=\"_blank\">8) Fatigue, momentum, and tactical shifts</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#visuals\" rel=\"nofollow\" target=\"_blank\">9) Visual analytics for strategy</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#pipelines\" rel=\"nofollow\" target=\"_blank\">10) Scalable pipelines: Parquet, DuckDB, reproducibility</a></li>\n<li><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing#wrap-up\" rel=\"nofollow\" target=\"_blank\">11) Wrap-up and next steps</a></li>\n</ul>\n<hr/>\n<h2 id=\"setup\">1) Professional setup and project structure</h2>\n<p>\n    A “pro” analytics workflow starts with discipline: consistent folders, reproducible environments, and clear separation of\n    raw → clean → features → models. Even if you’re solo, this structure makes your work easier to iterate and publish.\n  </p>\n<pre># Core libraries for fight data science\npkgs &lt;- c(\n  \"tidyverse\", \"janitor\", \"lubridate\", \"glue\", \"cli\",\n  \"arrow\", \"here\", \"fs\",\n  \"duckdb\", \"DBI\",\n  \"slider\",\n  \"rsample\", \"recipes\", \"parsnip\", \"workflows\", \"tune\", \"dials\",\n  \"yardstick\", \"broom\",\n  \"ggrepel\", \"patchwork\"\n)\n\nto_install &lt;- pkgs[!pkgs %in% installed.packages()[, \"Package\"]]\nif (length(to_install) &gt; 0) install.packages(to_install, dependencies = TRUE)\ninvisible(lapply(pkgs, library, character.only = TRUE))\n\n# Create a clean project layout (idempotent)\ndirs &lt;- c(\n  \"data/raw\",\n  \"data/clean\",\n  \"data/features\",\n  \"data/models\",\n  \"plots\",\n  \"reports\",\n  \"R\"\n)\n\nwalk(dirs, ~ fs::dir_create(here::here(.x)))\n\nlog_info &lt;- function(...) cli::cli_alert_info(glue::glue(...))\nlog_ok   &lt;- function(...) cli::cli_alert_success(glue::glue(...))\n\nlog_ok(\"Project folders ready at: {here::here()}\")</pre>\n<p>\n    Tip: store raw files read-only, and always write standardized outputs (e.g., Parquet) to <code>data/clean/</code>.\n    You’ll instantly speed up your workflow and reduce “mystery bugs.”\n  </p>\n<hr/>\n<h2 id=\"data-contract\">2) A fight data contract (schemas that prevent chaos)</h2>\n<p>\n    The fastest way to break a fight analytics project is to let columns drift (“fighter” vs “boxer”, mixed date formats,\n    different naming conventions for the same actions). A data contract prevents that.\n    Below are two useful contracts:\n  </p>\n<ul>\n<li><strong>Round totals</strong> (works with CompuBox-style aggregates)</li>\n<li><strong>Event-level metadata</strong> (for joining and reporting)</li>\n</ul>\n<pre>round_schema &lt;- tibble::tribble(\n  ~column,              ~type,       ~notes,\n  \"fight_id\",           \"character\",  \"Unique fight identifier\",\n  \"event_id\",           \"character\",  \"Unique event identifier\",\n  \"event_date\",         \"date\",       \"ISO date\",\n  \"weight_class\",       \"character\",  \"e.g., Welterweight\",\n  \"fighter\",            \"character\",  \"This row's fighter\",\n  \"opponent\",           \"character\",  \"Opponent fighter\",\n  \"corner\",             \"character\",  \"Red/Blue or A/B\",\n  \"round\",              \"integer\",    \"Round number\",\n  \"jabs_landed\",        \"integer\",    \"Jabs landed\",\n  \"jabs_attempted\",     \"integer\",    \"Jabs attempted\",\n  \"power_landed\",       \"integer\",    \"Power shots landed\",\n  \"power_attempted\",    \"integer\",    \"Power shots attempted\",\n  \"knockdowns\",         \"integer\",    \"Knockdowns in round\",\n  \"stance\",             \"character\",  \"orthodox/southpaw/other\",\n  \"result_round\",       \"integer\",    \"1 if fighter won the round, 0 if lost (or NA if unknown)\"\n)\n\nevent_schema &lt;- tibble::tribble(\n  ~column,         ~type,       ~notes,\n  \"event_id\",      \"character\", \"Unique event identifier\",\n  \"event_name\",    \"character\", \"Event name\",\n  \"event_date\",    \"date\",      \"ISO date\",\n  \"location\",      \"character\", \"City/Country (optional)\",\n  \"promotion\",     \"character\", \"Promotion/org (optional)\"\n)\n\nround_schema</pre>\n<p>\n    If you don’t have <code>result_round</code>, you can still do great analytics: predict round outcomes, infer momentum,\n    and quantify “who was in control” using validated scoring proxies.\n  </p>\n<hr/>\n<h2 id=\"ingestion\">3) Ingestion and standardization</h2>\n<p>\n    Here’s a robust ingestion pattern: read raw CSVs, normalize names, enforce types, standardize fighter naming,\n    and write Parquet for speed. Adjust paths to your sources.\n  </p>\n<pre>read_round_totals &lt;- function(path) {\n  log_info(\"Reading raw round totals: {path}\")\n  readr::read_csv(path, show_col_types = FALSE) %&gt;%\n    janitor::clean_names()\n}\n\nstandardize_round_totals &lt;- function(df) {\n  df %&gt;%\n    mutate(\n      event_date = as.Date(event_date),\n      round = as.integer(round),\n      across(\n        c(jabs_landed, jabs_attempted, power_landed, power_attempted, knockdowns),\n        ~ as.integer(replace_na(.x, 0))\n      ),\n      across(c(fight_id, event_id, fighter, opponent, weight_class, stance, corner), as.character),\n      stance = tolower(stance),\n      corner = toupper(corner)\n    ) %&gt;%\n    # Basic name normalization\n    mutate(\n      fighter  = str_squish(str_replace_all(fighter, \"\\\\s+\", \" \")),\n      opponent = str_squish(str_replace_all(opponent, \"\\\\s+\", \" \")),\n      weight_class = str_squish(weight_class)\n    )\n}\n\nwrite_clean_parquet &lt;- function(df, out_path) {\n  fs::dir_create(fs::path_dir(out_path))\n  arrow::write_parquet(df, out_path)\n  log_ok(\"Wrote Parquet: {out_path}\")\n}\n\n# Example:\n# raw_path  &lt;- here::here(\"data/raw/round_totals.csv\")\n# clean_out &lt;- here::here(\"data/clean/round_totals.parquet\")\n# rounds_clean &lt;- read_round_totals(raw_path) %&gt;% standardize_round_totals()\n# write_clean_parquet(rounds_clean, clean_out)</pre>\n<p>\n    Parquet is a game-changer for analytics work: fast I/O, consistent types, and easy integration with DuckDB for SQL-style querying.\n  </p>\n<hr/>\n<h2 id=\"validation\">4) Validation, QA, and anomaly detection</h2>\n<p>\n    Fight data is full of subtle mistakes: attempted shots &lt; landed shots, duplicated rounds, mixed fighter/opponent rows,\n    or “impossible” knockdown counts. Validation should be automatic.\n  </p>\n<pre>validate_round_totals &lt;- function(df) {\n  # Required columns check\n  required &lt;- round_schema$column\n  missing_cols &lt;- setdiff(required, names(df))\n  if (length(missing_cols) &gt; 0) {\n    stop(glue::glue(\"Missing required columns: {paste(missing_cols, collapse=', ')}\"))\n  }\n\n  # Logical checks\n  bad_landed &lt;- df %&gt;%\n    filter(jabs_landed &gt; jabs_attempted | power_landed &gt; power_attempted)\n\n  if (nrow(bad_landed) &gt; 0) {\n    log_info(\"Found {nrow(bad_landed)} rows where landed &gt; attempted (check source or parsing).\")\n  }\n\n  # Duplicate round rows (same fight_id, fighter, round)\n  dupes &lt;- df %&gt;%\n    count(fight_id, fighter, round) %&gt;%\n    filter(n &gt; 1)\n\n  if (nrow(dupes) &gt; 0) {\n    log_info(\"Found duplicates: {nrow(dupes)} fight/fighter/round combinations.\")\n  }\n\n  # Suspicious extremes (simple heuristic)\n  suspicious &lt;- df %&gt;%\n    mutate(total_attempted = jabs_attempted + power_attempted) %&gt;%\n    filter(total_attempted &gt; 120 | knockdowns &gt; 3)\n\n  if (nrow(suspicious) &gt; 0) {\n    log_info(\"Found {nrow(suspicious)} suspicious rows (very high volume or knockdowns).\")\n  }\n\n  df\n}\n\n# Example:\n# rounds_clean &lt;- rounds_clean %&gt;% validate_round_totals()</pre>\n<p>\n    Validation gives you confidence. And confidence is what makes analytics actionable—especially when you’re presenting results\n    to coaches, fighters, or bettors who will challenge your assumptions.\n  </p>\n<hr/>\n<h2 id=\"features\">5) Feature engineering: pace, accuracy, intent, damage proxies</h2>\n<p>\n    Fight performance is multidimensional. A clean feature set usually includes:\n  </p>\n<ul>\n<li><strong>Pace:</strong> attempts per round, pace change across rounds</li>\n<li><strong>Accuracy:</strong> landed / attempted (jabs, power, total)</li>\n<li><strong>Intent / style:</strong> jab share vs power share</li>\n<li><strong>Damage proxies:</strong> power landed, knockdowns, power accuracy</li>\n<li><strong>Relative dominance:</strong> fighter metrics minus opponent metrics</li>\n</ul>\n<pre>engineer_round_features &lt;- function(df) {\n  df %&gt;%\n    mutate(\n      total_landed    = jabs_landed + power_landed,\n      total_attempted = jabs_attempted + power_attempted,\n      acc_jab   = if_else(jabs_attempted &gt; 0, jabs_landed / jabs_attempted, NA_real_),\n      acc_power = if_else(power_attempted &gt; 0, power_landed / power_attempted, NA_real_),\n      acc_total = if_else(total_attempted &gt; 0, total_landed / total_attempted, NA_real_),\n      jab_share_attempts = if_else(total_attempted &gt; 0, jabs_attempted / total_attempted, NA_real_),\n      power_share_attempts = if_else(total_attempted &gt; 0, power_attempted / total_attempted, NA_real_),\n      # Simple damage proxy: power landed + weighted knockdowns\n      damage_proxy = power_landed + 8 * knockdowns\n    )\n}\n\n# Opponent-relative features (requires pairing fighter vs opponent within the same fight_id and round)\nadd_relative_features &lt;- function(df) {\n  df2 &lt;- df %&gt;%\n    select(fight_id, round, fighter, opponent,\n           total_landed, total_attempted, acc_total,\n           power_landed, power_attempted, acc_power,\n           damage_proxy, knockdowns) %&gt;%\n    rename_with(~ paste0(\"opp_\", .x), -c(fight_id, round, fighter, opponent)) %&gt;%\n    rename(fighter_join = opponent, opponent_join = fighter)\n\n  df %&gt;%\n    left_join(\n      df2,\n      by = c(\"fight_id\" = \"fight_id\", \"round\" = \"round\", \"fighter\" = \"fighter_join\", \"opponent\" = \"opponent_join\")\n    ) %&gt;%\n    mutate(\n      rel_total_landed = total_landed - opp_total_landed,\n      rel_acc_total    = acc_total - opp_acc_total,\n      rel_power_landed = power_landed - opp_power_landed,\n      rel_damage       = damage_proxy - opp_damage_proxy,\n      rel_knockdowns   = knockdowns - opp_knockdowns\n    )\n}\n\n# Example:\n# rounds_feat &lt;- rounds_clean %&gt;% engineer_round_features() %&gt;% add_relative_features()</pre>\n<p>\n    Relative features are where fight analytics becomes tactical: a fighter’s pace means little without context.\n    Dominance is “what you did” minus “what you absorbed.”\n  </p>\n<hr/>\n<h2 id=\"round-models\">6) Round-by-round modeling (probability of winning a round)</h2>\n<p>\n    If you have labeled rounds (<code>result_round</code> = 1/0), you can model round outcomes using interpretable classifiers.\n    Even if you don’t, you can label from trusted sources or use proxy labels (with caution).\n  </p>\n<p>\n    Below is an end-to-end workflow using <strong>tidymodels</strong>:\n    split, recipe, logistic regression with regularization, tuning, and calibration-friendly evaluation.\n  </p>\n<pre># Assume you have rounds_feat with result_round (1/0) for some fights\n# rounds_feat &lt;- rounds_feat %&gt;% filter(!is.na(result_round))\n\nset.seed(123)\nspl &lt;- rsample::initial_split(rounds_feat %&gt;% filter(!is.na(result_round)), prop = 0.8, strata = result_round)\ntrain &lt;- rsample::training(spl)\ntest  &lt;- rsample::testing(spl)\n\nrec &lt;- recipes::recipe(result_round ~ rel_total_landed + rel_acc_total + rel_power_landed + rel_damage +\n                        total_attempted + acc_total + jab_share_attempts + damage_proxy +\n                        stance,\n                      data = train) %&gt;%\n  step_impute_median(all_numeric_predictors()) %&gt;%\n  step_impute_mode(all_nominal_predictors()) %&gt;%\n  step_dummy(all_nominal_predictors()) %&gt;%\n  step_zv(all_predictors()) %&gt;%\n  step_normalize(all_numeric_predictors())\n\nmod &lt;- parsnip::logistic_reg(penalty = tune(), mixture = 1) %&gt;%\n  set_engine(\"glmnet\")\n\nwf &lt;- workflows::workflow() %&gt;%\n  add_recipe(rec) %&gt;%\n  add_model(mod)\n\ngrid &lt;- dials::grid_regular(dials::penalty(range = c(-6, 0)), levels = 30)\n\nset.seed(123)\nfolds &lt;- rsample::vfold_cv(train, v = 5, strata = result_round)\n\nmetrics &lt;- yardstick::metric_set(yardstick::roc_auc, yardstick::pr_auc, yardstick::accuracy, yardstick::mn_log_loss)\n\ntuned &lt;- tune::tune_grid(\n  wf,\n  resamples = folds,\n  grid = grid,\n  metrics = metrics\n)\n\nbest &lt;- tune::select_best(tuned, metric = \"mn_log_loss\")\nfinal_wf &lt;- tune::finalize_workflow(wf, best)\n\nfinal_fit &lt;- final_wf %&gt;% fit(train)\n\n# Evaluate on holdout test set\ntest_pred &lt;- predict(final_fit, test, type = \"prob\") %&gt;%\n  bind_cols(test %&gt;% select(result_round))\n\nyardstick::roc_auc(test_pred, truth = result_round, .pred_1)\nyardstick::mn_log_loss(test_pred, truth = result_round, .pred_1)</pre>\n<p>\n    Why log loss? Because in fight analytics, <strong>calibrated probabilities</strong> matter.\n    A model that says “0.55” should be right ~55% of the time—not just classify correctly.\n  </p>\n<hr/>\n<h2 id=\"fight-outcome\">7) Fight outcome modeling (interpretable + calibrated)</h2>\n<p>\n    Fight outcomes can be modeled from aggregated round features:\n    average dominance, variance (consistency), late-round fade, and knockdown impacts.\n    First, summarize per fight and fighter.\n  </p>\n<pre>summarize_fight_features &lt;- function(df) {\n  df %&gt;%\n    group_by(fight_id, event_id, event_date, weight_class, fighter, opponent) %&gt;%\n    summarise(\n      rounds = n(),\n      avg_rel_damage = mean(rel_damage, na.rm = TRUE),\n      avg_rel_power_landed = mean(rel_power_landed, na.rm = TRUE),\n      avg_rel_total_landed = mean(rel_total_landed, na.rm = TRUE),\n      avg_rel_acc_total = mean(rel_acc_total, na.rm = TRUE),\n      # Volatility/consistency\n      sd_rel_damage = sd(rel_damage, na.rm = TRUE),\n      # Pace markers\n      avg_total_attempted = mean(total_attempted, na.rm = TRUE),\n      # Knockdown signal\n      total_knockdowns = sum(knockdowns, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n}\n\nfight_level &lt;- summarize_fight_features(rounds_feat)\n\n# If you have fight outcome label for fighter perspective (win=1/lose=0):\n# fight_level &lt;- fight_level %&gt;% left_join(outcomes, by = c(\"fight_id\",\"fighter\"))</pre>\n<p>\n    Then model fight wins with an interpretable learner. Logistic regression is often a strong baseline; boosted trees can\n    add performance if you keep explainability via feature importance and partial dependence (where appropriate).\n  </p>\n<pre># Example: win label in fight_level as win (1/0)\nset.seed(42)\nspl2 &lt;- rsample::initial_split(fight_level %&gt;% filter(!is.na(win)), prop = 0.8, strata = win)\ntr2 &lt;- training(spl2)\nte2 &lt;- testing(spl2)\n\nrec2 &lt;- recipe(win ~ avg_rel_damage + avg_rel_power_landed + avg_rel_total_landed +\n                avg_rel_acc_total + sd_rel_damage + avg_total_attempted + total_knockdowns,\n              data = tr2) %&gt;%\n  step_impute_median(all_numeric_predictors()) %&gt;%\n  step_normalize(all_numeric_predictors())\n\nmod2 &lt;- logistic_reg(penalty = tune(), mixture = 1) %&gt;% set_engine(\"glmnet\")\n\nwf2 &lt;- workflow() %&gt;% add_recipe(rec2) %&gt;% add_model(mod2)\n\ngrid2 &lt;- grid_regular(penalty(range = c(-7, 0)), levels = 40)\n\nset.seed(42)\nfolds2 &lt;- vfold_cv(tr2, v = 5, strata = win)\n\ntuned2 &lt;- tune_grid(wf2, resamples = folds2, grid = grid2, metrics = metrics)\n\nbest2 &lt;- select_best(tuned2, \"mn_log_loss\")\nfinal2 &lt;- finalize_workflow(wf2, best2) %&gt;% fit(tr2)\n\npred2 &lt;- predict(final2, te2, type = \"prob\") %&gt;% bind_cols(te2 %&gt;% select(win))\nroc_auc(pred2, truth = win, .pred_1)\nmn_log_loss(pred2, truth = win, .pred_1)\n\n# Inspect coefficients (interpretability)\nfinal2 %&gt;%\n  extract_fit_parsnip() %&gt;%\n  broom::tidy() %&gt;%\n  arrange(desc(abs(estimate))) %&gt;%\n  head(20)</pre>\n<p>\n    A practical coaching readout might be: “Your average relative damage was +4 per round, but volatility was high.\n    You won the peaks and lost the valleys—work on maintaining output in the middle rounds.”\n  </p>\n<hr/>\n<h2 id=\"fatigue-momentum\">8) Fatigue, momentum, and tactical shifts</h2>\n<p>\n    Fatigue often shows up as a drop in attempt rate, a decline in power accuracy, or a shift toward safer output (more jabs, fewer exchanges).\n    Momentum often appears as <em>multi-round streaks</em> in relative dominance.\n  </p>\n<p>\n    Below are two useful constructs:\n  </p>\n<ul>\n<li><strong>Fatigue Index:</strong> compare late rounds vs early rounds on pace and accuracy</li>\n<li><strong>Momentum Signal:</strong> rolling mean of relative damage/dominance</li>\n</ul>\n<pre>fatigue_index &lt;- function(df) {\n  df %&gt;%\n    group_by(fight_id, fighter) %&gt;%\n    mutate(\n      early = round &lt;= 3,\n      late  = round &gt;= max(round, na.rm = TRUE) - 2\n    ) %&gt;%\n    summarise(\n      early_pace = mean(total_attempted[early], na.rm = TRUE),\n      late_pace  = mean(total_attempted[late], na.rm = TRUE),\n      early_acc  = mean(acc_total[early], na.rm = TRUE),\n      late_acc   = mean(acc_total[late], na.rm = TRUE),\n      fatigue_pace_drop = (late_pace - early_pace) / pmax(early_pace, 1),\n      fatigue_acc_drop  = (late_acc - early_acc) / pmax(early_acc, 1e-6),\n      .groups = \"drop\"\n    ) %&gt;%\n    mutate(\n      fatigue_score = 0.7 * fatigue_pace_drop + 0.3 * fatigue_acc_drop\n    )\n}\n\nmomentum_signal &lt;- function(df, window = 3) {\n  df %&gt;%\n    arrange(fight_id, fighter, round) %&gt;%\n    group_by(fight_id, fighter) %&gt;%\n    mutate(\n      rel_damage_roll = slider::slide_dbl(rel_damage, mean, .before = window - 1, .complete = FALSE, na.rm = TRUE),\n      rel_landed_roll = slider::slide_dbl(rel_total_landed, mean, .before = window - 1, .complete = FALSE, na.rm = TRUE)\n    ) %&gt;%\n    ungroup()\n}\n\nfatigue_tbl &lt;- fatigue_index(rounds_feat)\nrounds_mom &lt;- momentum_signal(rounds_feat, window = 3)</pre>\n<p>\n    Interpretation tips:\n  </p>\n<ul>\n<li><strong>Fatigue score negative</strong> → late output/accuracy declined (common)</li>\n<li><strong>Fatigue score near zero</strong> → stable performance (valuable at elite levels)</li>\n<li><strong>Rolling dominance crossing zero</strong> → tactical turning point (corner adjustments matter most here)</li>\n</ul>\n<hr/>\n<h2 id=\"visuals\">9) Visual analytics for strategy</h2>\n<p>\n    The “best” plots are the ones that change decisions.\n    Two strategy-grade visuals:\n  </p>\n<ul>\n<li><strong>Dominance timeline</strong> (relative damage rolling mean)</li>\n<li><strong>Style map</strong> (jab share vs power accuracy)</li>\n</ul>\n<pre>plot_dominance_timeline &lt;- function(df, fight_id_pick, fighter_pick) {\n  d &lt;- df %&gt;%\n    filter(fight_id == fight_id_pick, fighter == fighter_pick) %&gt;%\n    arrange(round)\n\n  ggplot(d, aes(x = round, y = rel_damage_roll)) +\n    geom_hline(yintercept = 0, linewidth = 0.6) +\n    geom_line(linewidth = 1) +\n    geom_point(size = 2) +\n    labs(\n      x = \"Round\",\n      y = \"Rolling Relative Damage (windowed mean)\",\n      title = \"Dominance Timeline\",\n      subtitle = glue::glue(\"Fight {fight_id_pick} — {fighter_pick}\")\n    ) +\n    theme_minimal(base_size = 12)\n}\n\nplot_style_map &lt;- function(df, fight_id_pick) {\n  d &lt;- df %&gt;%\n    filter(fight_id == fight_id_pick) %&gt;%\n    group_by(fighter) %&gt;%\n    summarise(\n      jab_share = mean(jab_share_attempts, na.rm = TRUE),\n      power_acc = mean(acc_power, na.rm = TRUE),\n      pace = mean(total_attempted, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n\n  ggplot(d, aes(x = jab_share, y = power_acc, label = fighter, size = pace)) +\n    geom_point(alpha = 0.7) +\n    ggrepel::geom_text_repel(max.overlaps = 50) +\n    labs(\n      x = \"Jab Share (Attempts)\",\n      y = \"Power Accuracy\",\n      title = \"Style Map (per fight)\",\n      subtitle = \"Higher pace = larger point\"\n    ) +\n    theme_minimal(base_size = 12)\n}\n\n# Example:\n# p1 &lt;- plot_dominance_timeline(rounds_mom, fight_id_pick = \"F123\", fighter_pick = \"Fighter A\")\n# p2 &lt;- plot_style_map(rounds_feat, fight_id_pick = \"F123\")\n# p1 + p2</pre>\n<p>\n    How coaches use these:\n  </p>\n<ul>\n<li>If dominance drops after round 4, check conditioning or defensive adjustments from the opponent.</li>\n<li>If jab share is high but power accuracy is low, the jab may be “busy” but not creating openings.</li>\n<li>If pace is high and accuracy stable, that’s often a winning profile—especially across long fights.</li>\n</ul>\n<hr/>\n<h2 id=\"pipelines\">10) Scalable pipelines: Parquet, DuckDB, reproducibility</h2>\n<p>\n    Once your data grows (multiple events, seasons, amateur + pro, different sources),\n    SQL-style analysis becomes extremely useful. DuckDB lets you query Parquet directly with zero database admin.\n  </p>\n<pre># Connect to DuckDB (in-memory or file-backed)\ncon &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = here::here(\"data/fight_analytics.duckdb\"))\n\n# Point DuckDB at a Parquet file (or a folder of Parquet files)\nparquet_path &lt;- here::here(\"data/clean/round_totals.parquet\")\n\nDBI::dbExecute(con, glue::glue(\"\n  CREATE OR REPLACE VIEW rounds AS\n  SELECT * FROM read_parquet('{parquet_path}')\n\"))\n\n# Example: top rounds by volume (attempted punches)\ntop_volume &lt;- DBI::dbGetQuery(con, \"\n  SELECT fighter, fight_id, round,\n         (jabs_attempted + power_attempted) AS total_attempted\n  FROM rounds\n  ORDER BY total_attempted DESC\n  LIMIT 25\n\")\n\ntop_volume %&gt;% as_tibble()\n\n# Close when done\nDBI::dbDisconnect(con, shutdown = TRUE)</pre>\n<p>\n    This makes it easy to build reliable reporting:\n    “Highest pace fights,” “Largest late-round fades,” “Most consistent dominance,” and “Knockdown-driven wins.”\n  </p>\n<hr/>\n<h2 id=\"wrap-up\">11) Wrap-up and next steps</h2>\n<p>\n    A fight data science workflow in R becomes powerful when you combine:\n  </p>\n<ul>\n<li><strong>Clean contracts</strong> so your data doesn’t drift</li>\n<li><strong>Validation</strong> so your results are trustworthy</li>\n<li><strong>Relative features</strong> so metrics become tactical</li>\n<li><strong>Probability models</strong> so conclusions are calibrated</li>\n<li><strong>Fatigue/momentum</strong> so strategy reflects real turning points</li>\n</ul>\n<p>\n    If you want a more structured, end-to-end path with deeper modeling, richer case studies, and a full workflow designed specifically for boxing,\n    you may like this resource:\n    <a href=\"https://rprogrammingbooks.com/product/mastering-boxing-analytics-with-r-data-science-for-fight-performance-and-strategy/\" rel=\"nofollow\" target=\"_blank\">\n      a complete hands-on book focused on boxing data science and fight performance strategy in R\n    </a>.\n  </p>\n</div>\n<p>The post <a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/\" rel=\"nofollow\" target=\"_blank\">Fight Data Science in R: Proven Boxing Metrics &amp; Models</a> appeared first on <a href=\"https://rprogrammingbooks.com/\" rel=\"nofollow\" target=\"_blank\">R Programming Books</a>.</p>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=fight-data-science-in-r-boxing\"> Blog - R Programming Books</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\n\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\n</div> </div>\n</article>",
    "word_count": 2535,
    "reading_time_min": 12.7,
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/rprogrammingbooks/",
        "text": "rprogrammingbooks"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "external_links": [
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing",
        "text": "Blog - R Programming Books"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#setup",
        "text": "1) Professional setup and project structure"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#data-contract",
        "text": "2) A fight data contract (schemas that prevent chaos)"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#ingestion",
        "text": "3) Ingestion and standardization"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#validation",
        "text": "4) Validation, QA, and anomaly detection"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#features",
        "text": "5) Feature engineering: pace, accuracy, intent, damage proxies"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#round-models",
        "text": "6) Round-by-round modeling (probability of winning a round)"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#fight-outcome",
        "text": "7) Fight outcome modeling (interpretable + calibrated)"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#fatigue-momentum",
        "text": "8) Fatigue, momentum, and tactical shifts"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#visuals",
        "text": "9) Visual analytics for strategy"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#pipelines",
        "text": "10) Scalable pipelines: Parquet, DuckDB, reproducibility"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing#wrap-up",
        "text": "11) Wrap-up and next steps"
      },
      {
        "href": "https://rprogrammingbooks.com/product/mastering-boxing-analytics-with-r-data-science-for-fight-performance-and-strategy/",
        "text": "a complete hands-on book focused on boxing data science and fight performance strategy in R"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/",
        "text": "Fight Data Science in R: Proven Boxing Metrics & Models"
      },
      {
        "href": "https://rprogrammingbooks.com/",
        "text": "R Programming Books"
      },
      {
        "href": "https://rprogrammingbooks.com/fight-data-science-in-r-boxing/?utm_source=rss&utm_medium=rss&utm_campaign=fight-data-science-in-r-boxing",
        "text": "Blog - R Programming Books"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "images": [],
    "lang": "en-US",
    "crawled_at_utc": "2026-01-26T01:26:57Z"
  }
}