{
  "id": "c8c285224ca48ba0deb91a20ef978be737c52fbe",
  "url": "https://www.r-bloggers.com/2025/11/readtextgrid-now-uses-c-and-chatgpt-helped/",
  "created_at_utc": "2026-01-04T05:35:43Z",
  "crawled_at_utc": "2026-01-04T05:35:55Z",
  "html_title": "readtextgrid now uses C++ (and ChatGPT helped) | R-bloggers",
  "meta_description": "In this post, I announce the release of version of 0.2.0 of the readtextgrid R package, describe the problem that the package solves, and share some thoughts on LLM-assisted programming. Textgrids are a way to annotate audio data Praat is a program for speech and acoustic analysis that has been around for over 30 years. It includes a scripting language for manipulating and analyzing data and for creating annotation workflows. Users can annotate intervals or points of time in a sound file using a textgrid object. Here is a screenshot of a textgrid in Praat: Screenshot of a Praat editor window. There are three rows in the image, all three of them sharing the same x axis (time). Amplitude waveform, showing intensity over time Spectrogram, showing how the intensity (color) at frequencies (y) changes over time. Red dots mark estimated formants (resonances) in the speech signal. Textgrid of text annotations for the recording A user can edit the textgrid by adding or adjusting boundaries and adding annotations, and Praat will save this data to a .TextGrid file. Other programs can produce .TextGrid files: the textgrid pictured here is the result of forced alignment, specifically by the Montreal Forced Aligner. I told the program I said ‚Äúlibrary tidy verse library b r m s‚Äù, and it looked up the pronunciations of those words and used an acoustic model to estimate the time intervals of each word and each speech sound. The aligner produced a .TextGrid file for this alignment. These textgrids are the bread and butter of some of the research that we do. For example, our article on speaking/articulation rate in children involved over 30,000 single-sentence .wav files and .TextGrid files. We used the alignments to determine the duration of time spent speaking, the number of vowels in each utterance and hence the speaking rate in syllables per second. Reading these .TextGrid files into R was cumbersome, so I wrote and released readtextgrid, an R package built around one simple function: library(tidyverse) library(readtextgrid) path_tg file tier_num tier_name tier_type tier_xmin tier_xmax xmin xmax text #> #> 1 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0 0.08 \"\" #> 2 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.08 0.74 \"lib‚Ä¶ #> 3 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.74 1.12 \"tid‚Ä¶ #> 4 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.12 1.58 \"ver‚Ä¶ #> 5 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.58 1.74 \"\" #> 6 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.74 2.46 \"lib‚Ä¶ #> 7 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.46 2.72 \"b\" #> 8 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.72 2.9 \"r\" #> 9 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.9 3.04 \"m\" #> 10 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 3.04 3.46 \"s\" #> # ‚Ñπ 33 more rows #> # ‚Ñπ 1 more variable: annotation_num The function returns a tidy tibble with one row per annotation. The filename is stored as a column too so that we can lapply() over a directory of files. Annotations are numbered so that we can group_by(text, annotation_num) and have repeated words handled separately. With this textgrid in R, I can measure speaking rate, for example: data_tg |> filter(tier_name == \"phones\", text != \"\") |> summarise( speaking_time = sum(xmax - xmin), # vowels have numbers to indicate degree of stress num_vowels = sum(str_detect(text, \"\\d\")) ) |> mutate( syllables_per_sec = num_vowels / speaking_time ) #> # A tibble: 1 √ó 3 #> speaking_time num_vowels syllables_per_sec #> #> 1 3.22 13 4.04 Or annotate a spectrogram: library(tidyverse) library(ggplot2) path_spectrogram ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Delimiter: \",\" #> dbl (6): y, x, power, time, frequency, db #> #> ‚Ñπ Use `spec()` to retrieve the full column specification for this data. #> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message. data_spectrogram |> mutate( # reserve more of the color variation for intensities above 15 dB db = ifelse(db ggplot() + aes(x = time, y = frequency) + geom_raster(aes(fill = db)) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"words\"), y = 6500, vjust = 0 ) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"phones\"), y = 6100, vjust = 0, size = 2 ) + ylim(c(NA, 6600)) + theme_minimal() + scale_fill_gradient(low = \"white\", high = \"black\") + guides(fill = \"none\") + labs(x = \"time [s]\", y = \"frequency [Hz]\") Spectrogram of me saying 'library tidyverse library brms' I released the first version of the package in 2020. This package, notably for me, contains the first hex badge I ever made. My original .TextGrid parser and its problem Here is what the contents of the .TextGrid file look like. It‚Äôs not the whole file but enough to give a sense of the structure: path_tg |> readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> xmin = 0 #> xmax = 3.596009 #> tiers? #> size = 2 #> item []: #> item [1]: #> class = \"IntervalTier\" #> name = \"words\" #> xmin = 0 #> xmax = 3.596009 #> intervals: size = 11 #> intervals [1]: #> xmin = 0.0 #> xmax = 0.08 #> text = \"\" #> intervals [2]: #> xmin = 0.08 #> xmax = 0.74 #> text = \"library\" #> intervals [3]: #> xmin = 0.74 #> xmax = 1.12 #> text = \"tidy\" #> [... TRUNCATED ... ] The first 7 lines provide some metadata about the time range of the audio and the number of tiers (size = 2). The file then writes out each tier (item [n] lines) by first giving the class, name, time duration and number of marks or intervals. Each mark or interval is enumerated with time values xmin, xmax and text values. Because nearly everything here follows a key = value syntax and because sections are split from each other very neatly with item [n]: or interval [n]: lines, I was able to write a simple parser using regular expressions: Split the file into item [n] sections, split those into interval [n] sections, and extract key-value pairs. This easy approach came with limitations. First, the TextGrid specification was much more flexible. For example, Praat also provides much less verbose ‚Äúshort‚Äù format textgrids which are like a stream of time and text annotations: path_tg_short readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> 0 #> 3.596009 #> #> 2 #> \"IntervalTier\" #> \"words\" #> 0 #> 3.596009 #> 11 #> 0 #> 0.08 #> \"\" #> 0.08 #> 0.74 #> \"library\" #> 0.74 #> 1.12 #> \"tidy\" #> 1.12 #> 1.58 #> \"verse\" #> 1.58 #> 1.74 #> [... TRUNCATED ... ] Everything is in the same order, but the annotations are gone. It turns out that all of the helpful labels from before were actually comments that get ignored. Everything that isn‚Äôt a number or a string in double-quotes (or a ) is a comment. There are also other quirks (\" escapement, ! comments, deviations between the Praat description of the format and the behavior of praat.exe). I have them documented as a kind of unofficial specification in an article on the package website. But my original regular-expression based parser could only handle the verbose long-format textgrids. I knew this. I put this in a GitHub issue in 2020. And this compatibility oversight was never a problem for me until I tried a new phonetics tool that defaulted to saving the textgrids in the short format. Now, readtextgrid could not in fact ‚Äúread textgrid‚Äù. The new R-based tokenizer Josef Fruehwald, a linguist with lots of acoustics/phonetics software, submitted a pull request to implement a proper parser that I eventually rewrote to handle various edge cases and undocumented behavior in the .TextGrid specification. I made an adversarial .TextGrid file üòà that could still be opened by praat.exe but was meant to be difficult to parse. This was a fun development loop: Make the file harder, update the parser to handle the new feature, repeat. Because the essential data in the file are just string tokens and number tokens, I needed to make a tokenizer: a piece of software that reads in characters, groups them into tokens, and figures out what kind of data the token represents. The initial R-based version of the tokenizer did the following: Read the file character by character Gather the characters for the current token and keep them when they form a valid string or number Shift between three states (in_string, in_strong_comment for ! comments, in_escaped_quote) These three states determine how we interpret spaces, newlines, and \" characters. For example, a newline ends a ! comment but a newline can appear in a string so it doesn‚Äôt end a string. Moreover, in a comment, \" is ignored, but in a string, it might be the end of the string or an escaped quote (doubled double-quotes are used for \" characters: the string \"\"\"a\"\"\" has the text \"a\"). But at a high level, the code was simple: for (i in seq_along(all_char)) { # { ... examine current character ... } # { ... handle comment state ... } # { ... collect token if we see whitespace and are not in a string ... } # { ... handle string and escaped quote state ... } } The new character-by-character parser worked üéâ. It had conquered the adversarial example file, but there was still one more problem. It was slower than the original regular-expression parser! tg_lines # A tibble: 2 √ó 6 #> expression min median `itr/sec` mem_alloc `gc/sec` #> #> 1 legacy 75.1ms 76.1ms 13.1 6.81MB 19.7 #> 2 new_r 70.7ms 72.3ms 13.7 590.88KB 10.3 At this point, I asked ChatGPT for tips on speeding up the tokenizer. Some thoughts about LLMs the thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar‚Äî sarah jeong (@sarahjeong.bsky.social) July 6, 2025 at 7:20 PM Now, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I could say about them.1 As a language scientist, I‚Äôll start here: They know syntax. They know which words go together and can generate very plausible sequences of words. They do not know semantics however. They don‚Äôt have any firsthand knowledge or experience about what those sequences express. They can‚Äôt introspect about that knowledge or experience to see whether things ‚Äúmake sense‚Äù.2 They don‚Äôt care about the truth or falsity of statements. They just make plausible sequences of words. Now, it turns out that if you learn how to make sequences of words from an Internet-sized corpus of text, then a lot of the plausible sequences you make will turn out to be true. If you read 10,000 cookbooks, you could probably provide a very classic recipe for scrambled eggs. But because you don‚Äôt know about sarcasm or can‚Äôt draw on your own experience of trying to not ingest non-food chemicals, you might suggest putting glue on a pizza. So, as we use an LLM, we need to ask ourselves how much we care about the truth or care about knowing or understanding things. That may sound like a glib or weird statement: Shouldn‚Äôt we always care about the truth? Well, sometimes we don‚Äôt. We just want some syntax; we want boilerplate or templates to fill out.3 For example, I can ask an LLM to ‚Äúwrite some unit tests for a function round_to(xs, unit) that rounds a vector of values to an arbitrary unit‚Äù and receive: test_that(\"round_to() rounds to nearest multiple of unit\", { expect_equal(round_to(5, 2), 6) expect_equal(round_to(4.9, 2), 4) expect_equal(round_to(5.1, 2), 6) expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4)) }) These tests are not useful until I plug in the correct values for the expected output. In other cases, we don‚Äôt quite care about truth or comprehension because we can get external corroboration.4 When I ask ChatGPT for an obfuscated R script to make Pac-Man in ggplot2, I can run the code to see if it works without trying to decipher its syntax: library(ggplot2) ggplot()+ geom_polygon(aes(x,y), data=within(data.frame(t(sapply(seq(a Error in eval(substitute(expr), e): object '.' not found (Strangely, this is the case where a dot kills Pac-Man.) Vibes are semantic vapor When we abandon caring about truth or understanding things and just rely on external corroboration, we are in the realm of vibe coding. I like this term because of its insouciant honesty: Truth? Comprehension? We‚Äôre just going off the vibes. It would be a great help if we used the word more liberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No thanks.5 If we lean into vibes, we need to get better at external corroboration and know our programming languages even better. R is a flexible programming language and it does some things that ‚Äúhelp‚Äù the user that can lead to silent bugs. Famously, function arguments and $ will match partial names. # Look at the \"Call:\" in the output lm(f = hp ~ cyl, d = mtcars) #> #> Call: #> lm(formula = hp ~ cyl, data = mtcars) #> #> Coefficients: #> (Intercept) cyl #> -51.05 31.96 # There is no `m` column all(mtcars$m == mtcars$mpg) #> [1] TRUE A student I work with was trying to compute sensitivity and specificity on weighted data. The LLM suggested the following: # Make some weighted data using frequencies data count(outcome, age, name = \"weight\") # What the LLM did: pROC::roc(data, \"outcome\", \"age\", weights = data$weight) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", weights = data$weight) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 This code runs without any problems. It‚Äôs wrong, but it runs. The problem is that pROC::roc(...) supports variadic arguments (...): # Note the dots pROC:::roc |> formals() |> str() #> Dotted pair list of 1 #> $ ...: symbol pROC:::roc.data.frame |> formals() |> str() #> Dotted pair list of 5 #> $ data : symbol #> $ response : symbol #> $ predictor: symbol #> $ ret : language c(\"roc\", \"coords\", \"all_coords\") #> $ ... : symbol Those ... are for forwarding arguments to other functions that roc() might call internally. Unfortunately, functions by default don‚Äôt check the contents of the ... to see if they have unsupported arguments. Thus, bad arguments are ignored silently: # method and weights are not real arguments pROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", method = fake, weights = fake) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 The LLM hallucinated a weights argument, which is a plausible argument,6 and the ... syntax behavior swallowed it up like Pac-Man. It always comes back to Pac-Man. I ended up writing a function that could compute sens and spec on weighted data. Unfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire‚Äî Eugene Vinitsky üçí (@eugenevinitsky.bsky.social) November 13, 2025 at 6:21 PM As users, we can guard against the first two silent problems with options(warnPartialMatchArgs, warnPartialMatchDollar), and as developers, we can prevent the second problem with rlang::check_dots_used() and friends. But like I said at the outset, external corroboration requires us to know even more about the language in order to vibe safely. Syntax and semantics, again In this mini-position statement on LLM assistance, the two principles I am trying to develop are: LLMs know text distributions very well. Use them to generate starter syntax. LLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes. If we think of LLMs as syntax generators, we can imagine some pretty good use cases: Write unit tests for a function that does‚Ä¶ Set up Roxygen docs for this function Create a function to simulate data for a model of rt ~ group + (1 | id) Write a Stan program to fit this model. (Mind your priors.) Spoiler alert: Convert this R loop into C++ code Still, we need to be mindful of the semantic limitations and skeptical of the output. We should audit the results and make sure we comprehend them, or admit upfront that this code is running on vibes. In either case, we also need to be vigilant about bugs that could happen silently or bugs that a machine might make but a human wouldn‚Äôt (hallucinations). One thing I worry about with LLM reliance is skill atrophy. If I keep using this bot as a crutch, then some of my skills will get weaker. Sam Mehr has a take I quite like that puts this concern upfront. LLMs are fine for code we don‚Äôt feel bothered to learn: re AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized I'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done & don't care about learning!‚Äî samuel mehr (@mehr.nz) May 13, 2025 at 10:32 PM I quite like programming and want to learn. I like to read the release notes, dig into the documentation and experiment with new modeling features. At the same time, sometimes I just want a bash script to unzip all .zip files in a directory. Time was, we would find something from Stack Overflow to adapt for that problem. Now, we ask ChatGPT for the code, look it over quick, test it and move on. That seems fine. A metacognitive awareness about what is worth learning and what problems are worth solving in a slower methodical way is very useful for an LLM user. Finally, to be clear‚ÄîI can‚Äôt believe I need to make this disclaimer‚Äîwe should always care about truth and accuracy when we write prose and publish it and put our name on it. Vibes are not scientific or scholarly. When I see emails or code documentation with immaculate formatting and perfect language, my bullshit sensor goes off and I worry that I need to read extra carefully because a smooth-talking robot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing except for proofreading or requests for nitpicking. I have an instruction in ChatGPT that says not to revise anything I write unless it sneaks Magic: The Gathering card names into the output. (Alas, it generally ignores that diabolic edict of mine.) AI assistance in readtextgrid Because the old parser was outperforming the newer, more robust parser, I asked ChatGPT for ways to make my textgrid parsing faster. For example, one version of the loop collected characters in a vector and then paste0()-ed them together. ChatGPT suggested that because we are iterating over character indices we instead use substring() to extract tokens from the text. That worked, and it ran faster, until it failed a unit test on a character wearing a diacritic. After a few rounds of trying to improve the loop, I asked quite bluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the viewest [sic] headaches possible‚Äù. And it provided some very legible cpp11 code. I had never used C++ with R before. To get started, I had to call on usethis::use_cpp11() to make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand I had to troubleshoot the first couple versions of the function because of errors. The cpp11 documentation is small in a good way. It has examples of converting R code into C++ equivalents, which is precisely the activity that I was up to. What I liked about the ChatGPT output is how clear the translation was. In the R version, part of the character processing loop is to peek ahead to the next character to see whether \" is an escaped quote \"\" or the end of a string: # ... in the character processing loop # Start or close string mode if we see \" if (c_starts_string) { # Check for \"\" escapes peek_c",
  "data": {
    "url": "https://www.r-bloggers.com/2025/11/readtextgrid-now-uses-c-and-chatgpt-helped/",
    "canonical_url": "https://www.r-bloggers.com/2025/11/readtextgrid-now-uses-c-and-chatgpt-helped/",
    "html_title": "readtextgrid now uses C++ (and ChatGPT helped) | R-bloggers",
    "h1_title": "R-bloggers",
    "meta_description": "In this post, I announce the release of version of 0.2.0 of the readtextgrid R package, describe the problem that the package solves, and share some thoughts on LLM-assisted programming. Textgrids are a way to annotate audio data Praat is a program for speech and acoustic analysis that has been around for over 30 years. It includes a scripting language for manipulating and analyzing data and for creating annotation workflows. Users can annotate intervals or points of time in a sound file using a textgrid object. Here is a screenshot of a textgrid in Praat: Screenshot of a Praat editor window. There are three rows in the image, all three of them sharing the same x axis (time). Amplitude waveform, showing intensity over time Spectrogram, showing how the intensity (color) at frequencies (y) changes over time. Red dots mark estimated formants (resonances) in the speech signal. Textgrid of text annotations for the recording A user can edit the textgrid by adding or adjusting boundaries and adding annotations, and Praat will save this data to a .TextGrid file. Other programs can produce .TextGrid files: the textgrid pictured here is the result of forced alignment, specifically by the Montreal Forced Aligner. I told the program I said ‚Äúlibrary tidy verse library b r m s‚Äù, and it looked up the pronunciations of those words and used an acoustic model to estimate the time intervals of each word and each speech sound. The aligner produced a .TextGrid file for this alignment. These textgrids are the bread and butter of some of the research that we do. For example, our article on speaking/articulation rate in children involved over 30,000 single-sentence .wav files and .TextGrid files. We used the alignments to determine the duration of time spent speaking, the number of vowels in each utterance and hence the speaking rate in syllables per second. Reading these .TextGrid files into R was cumbersome, so I wrote and released readtextgrid, an R package built around one simple function: library(tidyverse) library(readtextgrid) path_tg file tier_num tier_name tier_type tier_xmin tier_xmax xmin xmax text #> #> 1 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0 0.08 \"\" #> 2 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.08 0.74 \"lib‚Ä¶ #> 3 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.74 1.12 \"tid‚Ä¶ #> 4 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.12 1.58 \"ver‚Ä¶ #> 5 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.58 1.74 \"\" #> 6 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.74 2.46 \"lib‚Ä¶ #> 7 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.46 2.72 \"b\" #> 8 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.72 2.9 \"r\" #> 9 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.9 3.04 \"m\" #> 10 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 3.04 3.46 \"s\" #> # ‚Ñπ 33 more rows #> # ‚Ñπ 1 more variable: annotation_num The function returns a tidy tibble with one row per annotation. The filename is stored as a column too so that we can lapply() over a directory of files. Annotations are numbered so that we can group_by(text, annotation_num) and have repeated words handled separately. With this textgrid in R, I can measure speaking rate, for example: data_tg |> filter(tier_name == \"phones\", text != \"\") |> summarise( speaking_time = sum(xmax - xmin), # vowels have numbers to indicate degree of stress num_vowels = sum(str_detect(text, \"\\d\")) ) |> mutate( syllables_per_sec = num_vowels / speaking_time ) #> # A tibble: 1 √ó 3 #> speaking_time num_vowels syllables_per_sec #> #> 1 3.22 13 4.04 Or annotate a spectrogram: library(tidyverse) library(ggplot2) path_spectrogram ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Delimiter: \",\" #> dbl (6): y, x, power, time, frequency, db #> #> ‚Ñπ Use `spec()` to retrieve the full column specification for this data. #> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message. data_spectrogram |> mutate( # reserve more of the color variation for intensities above 15 dB db = ifelse(db ggplot() + aes(x = time, y = frequency) + geom_raster(aes(fill = db)) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"words\"), y = 6500, vjust = 0 ) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"phones\"), y = 6100, vjust = 0, size = 2 ) + ylim(c(NA, 6600)) + theme_minimal() + scale_fill_gradient(low = \"white\", high = \"black\") + guides(fill = \"none\") + labs(x = \"time [s]\", y = \"frequency [Hz]\") Spectrogram of me saying 'library tidyverse library brms' I released the first version of the package in 2020. This package, notably for me, contains the first hex badge I ever made. My original .TextGrid parser and its problem Here is what the contents of the .TextGrid file look like. It‚Äôs not the whole file but enough to give a sense of the structure: path_tg |> readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> xmin = 0 #> xmax = 3.596009 #> tiers? #> size = 2 #> item []: #> item [1]: #> class = \"IntervalTier\" #> name = \"words\" #> xmin = 0 #> xmax = 3.596009 #> intervals: size = 11 #> intervals [1]: #> xmin = 0.0 #> xmax = 0.08 #> text = \"\" #> intervals [2]: #> xmin = 0.08 #> xmax = 0.74 #> text = \"library\" #> intervals [3]: #> xmin = 0.74 #> xmax = 1.12 #> text = \"tidy\" #> [... TRUNCATED ... ] The first 7 lines provide some metadata about the time range of the audio and the number of tiers (size = 2). The file then writes out each tier (item [n] lines) by first giving the class, name, time duration and number of marks or intervals. Each mark or interval is enumerated with time values xmin, xmax and text values. Because nearly everything here follows a key = value syntax and because sections are split from each other very neatly with item [n]: or interval [n]: lines, I was able to write a simple parser using regular expressions: Split the file into item [n] sections, split those into interval [n] sections, and extract key-value pairs. This easy approach came with limitations. First, the TextGrid specification was much more flexible. For example, Praat also provides much less verbose ‚Äúshort‚Äù format textgrids which are like a stream of time and text annotations: path_tg_short readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> 0 #> 3.596009 #> #> 2 #> \"IntervalTier\" #> \"words\" #> 0 #> 3.596009 #> 11 #> 0 #> 0.08 #> \"\" #> 0.08 #> 0.74 #> \"library\" #> 0.74 #> 1.12 #> \"tidy\" #> 1.12 #> 1.58 #> \"verse\" #> 1.58 #> 1.74 #> [... TRUNCATED ... ] Everything is in the same order, but the annotations are gone. It turns out that all of the helpful labels from before were actually comments that get ignored. Everything that isn‚Äôt a number or a string in double-quotes (or a ) is a comment. There are also other quirks (\" escapement, ! comments, deviations between the Praat description of the format and the behavior of praat.exe). I have them documented as a kind of unofficial specification in an article on the package website. But my original regular-expression based parser could only handle the verbose long-format textgrids. I knew this. I put this in a GitHub issue in 2020. And this compatibility oversight was never a problem for me until I tried a new phonetics tool that defaulted to saving the textgrids in the short format. Now, readtextgrid could not in fact ‚Äúread textgrid‚Äù. The new R-based tokenizer Josef Fruehwald, a linguist with lots of acoustics/phonetics software, submitted a pull request to implement a proper parser that I eventually rewrote to handle various edge cases and undocumented behavior in the .TextGrid specification. I made an adversarial .TextGrid file üòà that could still be opened by praat.exe but was meant to be difficult to parse. This was a fun development loop: Make the file harder, update the parser to handle the new feature, repeat. Because the essential data in the file are just string tokens and number tokens, I needed to make a tokenizer: a piece of software that reads in characters, groups them into tokens, and figures out what kind of data the token represents. The initial R-based version of the tokenizer did the following: Read the file character by character Gather the characters for the current token and keep them when they form a valid string or number Shift between three states (in_string, in_strong_comment for ! comments, in_escaped_quote) These three states determine how we interpret spaces, newlines, and \" characters. For example, a newline ends a ! comment but a newline can appear in a string so it doesn‚Äôt end a string. Moreover, in a comment, \" is ignored, but in a string, it might be the end of the string or an escaped quote (doubled double-quotes are used for \" characters: the string \"\"\"a\"\"\" has the text \"a\"). But at a high level, the code was simple: for (i in seq_along(all_char)) { # { ... examine current character ... } # { ... handle comment state ... } # { ... collect token if we see whitespace and are not in a string ... } # { ... handle string and escaped quote state ... } } The new character-by-character parser worked üéâ. It had conquered the adversarial example file, but there was still one more problem. It was slower than the original regular-expression parser! tg_lines # A tibble: 2 √ó 6 #> expression min median `itr/sec` mem_alloc `gc/sec` #> #> 1 legacy 75.1ms 76.1ms 13.1 6.81MB 19.7 #> 2 new_r 70.7ms 72.3ms 13.7 590.88KB 10.3 At this point, I asked ChatGPT for tips on speeding up the tokenizer. Some thoughts about LLMs the thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar‚Äî sarah jeong (@sarahjeong.bsky.social) July 6, 2025 at 7:20 PM Now, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I could say about them.1 As a language scientist, I‚Äôll start here: They know syntax. They know which words go together and can generate very plausible sequences of words. They do not know semantics however. They don‚Äôt have any firsthand knowledge or experience about what those sequences express. They can‚Äôt introspect about that knowledge or experience to see whether things ‚Äúmake sense‚Äù.2 They don‚Äôt care about the truth or falsity of statements. They just make plausible sequences of words. Now, it turns out that if you learn how to make sequences of words from an Internet-sized corpus of text, then a lot of the plausible sequences you make will turn out to be true. If you read 10,000 cookbooks, you could probably provide a very classic recipe for scrambled eggs. But because you don‚Äôt know about sarcasm or can‚Äôt draw on your own experience of trying to not ingest non-food chemicals, you might suggest putting glue on a pizza. So, as we use an LLM, we need to ask ourselves how much we care about the truth or care about knowing or understanding things. That may sound like a glib or weird statement: Shouldn‚Äôt we always care about the truth? Well, sometimes we don‚Äôt. We just want some syntax; we want boilerplate or templates to fill out.3 For example, I can ask an LLM to ‚Äúwrite some unit tests for a function round_to(xs, unit) that rounds a vector of values to an arbitrary unit‚Äù and receive: test_that(\"round_to() rounds to nearest multiple of unit\", { expect_equal(round_to(5, 2), 6) expect_equal(round_to(4.9, 2), 4) expect_equal(round_to(5.1, 2), 6) expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4)) }) These tests are not useful until I plug in the correct values for the expected output. In other cases, we don‚Äôt quite care about truth or comprehension because we can get external corroboration.4 When I ask ChatGPT for an obfuscated R script to make Pac-Man in ggplot2, I can run the code to see if it works without trying to decipher its syntax: library(ggplot2) ggplot()+ geom_polygon(aes(x,y), data=within(data.frame(t(sapply(seq(a Error in eval(substitute(expr), e): object '.' not found (Strangely, this is the case where a dot kills Pac-Man.) Vibes are semantic vapor When we abandon caring about truth or understanding things and just rely on external corroboration, we are in the realm of vibe coding. I like this term because of its insouciant honesty: Truth? Comprehension? We‚Äôre just going off the vibes. It would be a great help if we used the word more liberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No thanks.5 If we lean into vibes, we need to get better at external corroboration and know our programming languages even better. R is a flexible programming language and it does some things that ‚Äúhelp‚Äù the user that can lead to silent bugs. Famously, function arguments and $ will match partial names. # Look at the \"Call:\" in the output lm(f = hp ~ cyl, d = mtcars) #> #> Call: #> lm(formula = hp ~ cyl, data = mtcars) #> #> Coefficients: #> (Intercept) cyl #> -51.05 31.96 # There is no `m` column all(mtcars$m == mtcars$mpg) #> [1] TRUE A student I work with was trying to compute sensitivity and specificity on weighted data. The LLM suggested the following: # Make some weighted data using frequencies data count(outcome, age, name = \"weight\") # What the LLM did: pROC::roc(data, \"outcome\", \"age\", weights = data$weight) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", weights = data$weight) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 This code runs without any problems. It‚Äôs wrong, but it runs. The problem is that pROC::roc(...) supports variadic arguments (...): # Note the dots pROC:::roc |> formals() |> str() #> Dotted pair list of 1 #> $ ...: symbol pROC:::roc.data.frame |> formals() |> str() #> Dotted pair list of 5 #> $ data : symbol #> $ response : symbol #> $ predictor: symbol #> $ ret : language c(\"roc\", \"coords\", \"all_coords\") #> $ ... : symbol Those ... are for forwarding arguments to other functions that roc() might call internally. Unfortunately, functions by default don‚Äôt check the contents of the ... to see if they have unsupported arguments. Thus, bad arguments are ignored silently: # method and weights are not real arguments pROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", method = fake, weights = fake) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 The LLM hallucinated a weights argument, which is a plausible argument,6 and the ... syntax behavior swallowed it up like Pac-Man. It always comes back to Pac-Man. I ended up writing a function that could compute sens and spec on weighted data. Unfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire‚Äî Eugene Vinitsky üçí (@eugenevinitsky.bsky.social) November 13, 2025 at 6:21 PM As users, we can guard against the first two silent problems with options(warnPartialMatchArgs, warnPartialMatchDollar), and as developers, we can prevent the second problem with rlang::check_dots_used() and friends. But like I said at the outset, external corroboration requires us to know even more about the language in order to vibe safely. Syntax and semantics, again In this mini-position statement on LLM assistance, the two principles I am trying to develop are: LLMs know text distributions very well. Use them to generate starter syntax. LLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes. If we think of LLMs as syntax generators, we can imagine some pretty good use cases: Write unit tests for a function that does‚Ä¶ Set up Roxygen docs for this function Create a function to simulate data for a model of rt ~ group + (1 | id) Write a Stan program to fit this model. (Mind your priors.) Spoiler alert: Convert this R loop into C++ code Still, we need to be mindful of the semantic limitations and skeptical of the output. We should audit the results and make sure we comprehend them, or admit upfront that this code is running on vibes. In either case, we also need to be vigilant about bugs that could happen silently or bugs that a machine might make but a human wouldn‚Äôt (hallucinations). One thing I worry about with LLM reliance is skill atrophy. If I keep using this bot as a crutch, then some of my skills will get weaker. Sam Mehr has a take I quite like that puts this concern upfront. LLMs are fine for code we don‚Äôt feel bothered to learn: re AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized I'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done & don't care about learning!‚Äî samuel mehr (@mehr.nz) May 13, 2025 at 10:32 PM I quite like programming and want to learn. I like to read the release notes, dig into the documentation and experiment with new modeling features. At the same time, sometimes I just want a bash script to unzip all .zip files in a directory. Time was, we would find something from Stack Overflow to adapt for that problem. Now, we ask ChatGPT for the code, look it over quick, test it and move on. That seems fine. A metacognitive awareness about what is worth learning and what problems are worth solving in a slower methodical way is very useful for an LLM user. Finally, to be clear‚ÄîI can‚Äôt believe I need to make this disclaimer‚Äîwe should always care about truth and accuracy when we write prose and publish it and put our name on it. Vibes are not scientific or scholarly. When I see emails or code documentation with immaculate formatting and perfect language, my bullshit sensor goes off and I worry that I need to read extra carefully because a smooth-talking robot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing except for proofreading or requests for nitpicking. I have an instruction in ChatGPT that says not to revise anything I write unless it sneaks Magic: The Gathering card names into the output. (Alas, it generally ignores that diabolic edict of mine.) AI assistance in readtextgrid Because the old parser was outperforming the newer, more robust parser, I asked ChatGPT for ways to make my textgrid parsing faster. For example, one version of the loop collected characters in a vector and then paste0()-ed them together. ChatGPT suggested that because we are iterating over character indices we instead use substring() to extract tokens from the text. That worked, and it ran faster, until it failed a unit test on a character wearing a diacritic. After a few rounds of trying to improve the loop, I asked quite bluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the viewest [sic] headaches possible‚Äù. And it provided some very legible cpp11 code. I had never used C++ with R before. To get started, I had to call on usethis::use_cpp11() to make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand I had to troubleshoot the first couple versions of the function because of errors. The cpp11 documentation is small in a good way. It has examples of converting R code into C++ equivalents, which is precisely the activity that I was up to. What I liked about the ChatGPT output is how clear the translation was. In the R version, part of the character processing loop is to peek ahead to the next character to see whether \" is an escaped quote \"\" or the end of a string: # ... in the character processing loop # Start or close string mode if we see \" if (c_starts_string) { # Check for \"\" escapes peek_c",
    "meta_keywords": null,
    "og_title": "readtextgrid now uses C++ (and ChatGPT helped) | R-bloggers",
    "og_description": "In this post, I announce the release of version of 0.2.0 of the readtextgrid R package, describe the problem that the package solves, and share some thoughts on LLM-assisted programming. Textgrids are a way to annotate audio data Praat is a program for speech and acoustic analysis that has been around for over 30 years. It includes a scripting language for manipulating and analyzing data and for creating annotation workflows. Users can annotate intervals or points of time in a sound file using a textgrid object. Here is a screenshot of a textgrid in Praat: Screenshot of a Praat editor window. There are three rows in the image, all three of them sharing the same x axis (time). Amplitude waveform, showing intensity over time Spectrogram, showing how the intensity (color) at frequencies (y) changes over time. Red dots mark estimated formants (resonances) in the speech signal. Textgrid of text annotations for the recording A user can edit the textgrid by adding or adjusting boundaries and adding annotations, and Praat will save this data to a .TextGrid file. Other programs can produce .TextGrid files: the textgrid pictured here is the result of forced alignment, specifically by the Montreal Forced Aligner. I told the program I said ‚Äúlibrary tidy verse library b r m s‚Äù, and it looked up the pronunciations of those words and used an acoustic model to estimate the time intervals of each word and each speech sound. The aligner produced a .TextGrid file for this alignment. These textgrids are the bread and butter of some of the research that we do. For example, our article on speaking/articulation rate in children involved over 30,000 single-sentence .wav files and .TextGrid files. We used the alignments to determine the duration of time spent speaking, the number of vowels in each utterance and hence the speaking rate in syllables per second. Reading these .TextGrid files into R was cumbersome, so I wrote and released readtextgrid, an R package built around one simple function: library(tidyverse) library(readtextgrid) path_tg file tier_num tier_name tier_type tier_xmin tier_xmax xmin xmax text #> #> 1 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0 0.08 \"\" #> 2 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.08 0.74 \"lib‚Ä¶ #> 3 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.74 1.12 \"tid‚Ä¶ #> 4 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.12 1.58 \"ver‚Ä¶ #> 5 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.58 1.74 \"\" #> 6 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.74 2.46 \"lib‚Ä¶ #> 7 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.46 2.72 \"b\" #> 8 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.72 2.9 \"r\" #> 9 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.9 3.04 \"m\" #> 10 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 3.04 3.46 \"s\" #> # ‚Ñπ 33 more rows #> # ‚Ñπ 1 more variable: annotation_num The function returns a tidy tibble with one row per annotation. The filename is stored as a column too so that we can lapply() over a directory of files. Annotations are numbered so that we can group_by(text, annotation_num) and have repeated words handled separately. With this textgrid in R, I can measure speaking rate, for example: data_tg |> filter(tier_name == \"phones\", text != \"\") |> summarise( speaking_time = sum(xmax - xmin), # vowels have numbers to indicate degree of stress num_vowels = sum(str_detect(text, \"\\d\")) ) |> mutate( syllables_per_sec = num_vowels / speaking_time ) #> # A tibble: 1 √ó 3 #> speaking_time num_vowels syllables_per_sec #> #> 1 3.22 13 4.04 Or annotate a spectrogram: library(tidyverse) library(ggplot2) path_spectrogram ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Delimiter: \",\" #> dbl (6): y, x, power, time, frequency, db #> #> ‚Ñπ Use `spec()` to retrieve the full column specification for this data. #> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message. data_spectrogram |> mutate( # reserve more of the color variation for intensities above 15 dB db = ifelse(db ggplot() + aes(x = time, y = frequency) + geom_raster(aes(fill = db)) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"words\"), y = 6500, vjust = 0 ) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"phones\"), y = 6100, vjust = 0, size = 2 ) + ylim(c(NA, 6600)) + theme_minimal() + scale_fill_gradient(low = \"white\", high = \"black\") + guides(fill = \"none\") + labs(x = \"time [s]\", y = \"frequency [Hz]\") Spectrogram of me saying 'library tidyverse library brms' I released the first version of the package in 2020. This package, notably for me, contains the first hex badge I ever made. My original .TextGrid parser and its problem Here is what the contents of the .TextGrid file look like. It‚Äôs not the whole file but enough to give a sense of the structure: path_tg |> readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> xmin = 0 #> xmax = 3.596009 #> tiers? #> size = 2 #> item []: #> item [1]: #> class = \"IntervalTier\" #> name = \"words\" #> xmin = 0 #> xmax = 3.596009 #> intervals: size = 11 #> intervals [1]: #> xmin = 0.0 #> xmax = 0.08 #> text = \"\" #> intervals [2]: #> xmin = 0.08 #> xmax = 0.74 #> text = \"library\" #> intervals [3]: #> xmin = 0.74 #> xmax = 1.12 #> text = \"tidy\" #> [... TRUNCATED ... ] The first 7 lines provide some metadata about the time range of the audio and the number of tiers (size = 2). The file then writes out each tier (item [n] lines) by first giving the class, name, time duration and number of marks or intervals. Each mark or interval is enumerated with time values xmin, xmax and text values. Because nearly everything here follows a key = value syntax and because sections are split from each other very neatly with item [n]: or interval [n]: lines, I was able to write a simple parser using regular expressions: Split the file into item [n] sections, split those into interval [n] sections, and extract key-value pairs. This easy approach came with limitations. First, the TextGrid specification was much more flexible. For example, Praat also provides much less verbose ‚Äúshort‚Äù format textgrids which are like a stream of time and text annotations: path_tg_short readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> 0 #> 3.596009 #> #> 2 #> \"IntervalTier\" #> \"words\" #> 0 #> 3.596009 #> 11 #> 0 #> 0.08 #> \"\" #> 0.08 #> 0.74 #> \"library\" #> 0.74 #> 1.12 #> \"tidy\" #> 1.12 #> 1.58 #> \"verse\" #> 1.58 #> 1.74 #> [... TRUNCATED ... ] Everything is in the same order, but the annotations are gone. It turns out that all of the helpful labels from before were actually comments that get ignored. Everything that isn‚Äôt a number or a string in double-quotes (or a ) is a comment. There are also other quirks (\" escapement, ! comments, deviations between the Praat description of the format and the behavior of praat.exe). I have them documented as a kind of unofficial specification in an article on the package website. But my original regular-expression based parser could only handle the verbose long-format textgrids. I knew this. I put this in a GitHub issue in 2020. And this compatibility oversight was never a problem for me until I tried a new phonetics tool that defaulted to saving the textgrids in the short format. Now, readtextgrid could not in fact ‚Äúread textgrid‚Äù. The new R-based tokenizer Josef Fruehwald, a linguist with lots of acoustics/phonetics software, submitted a pull request to implement a proper parser that I eventually rewrote to handle various edge cases and undocumented behavior in the .TextGrid specification. I made an adversarial .TextGrid file üòà that could still be opened by praat.exe but was meant to be difficult to parse. This was a fun development loop: Make the file harder, update the parser to handle the new feature, repeat. Because the essential data in the file are just string tokens and number tokens, I needed to make a tokenizer: a piece of software that reads in characters, groups them into tokens, and figures out what kind of data the token represents. The initial R-based version of the tokenizer did the following: Read the file character by character Gather the characters for the current token and keep them when they form a valid string or number Shift between three states (in_string, in_strong_comment for ! comments, in_escaped_quote) These three states determine how we interpret spaces, newlines, and \" characters. For example, a newline ends a ! comment but a newline can appear in a string so it doesn‚Äôt end a string. Moreover, in a comment, \" is ignored, but in a string, it might be the end of the string or an escaped quote (doubled double-quotes are used for \" characters: the string \"\"\"a\"\"\" has the text \"a\"). But at a high level, the code was simple: for (i in seq_along(all_char)) { # { ... examine current character ... } # { ... handle comment state ... } # { ... collect token if we see whitespace and are not in a string ... } # { ... handle string and escaped quote state ... } } The new character-by-character parser worked üéâ. It had conquered the adversarial example file, but there was still one more problem. It was slower than the original regular-expression parser! tg_lines # A tibble: 2 √ó 6 #> expression min median `itr/sec` mem_alloc `gc/sec` #> #> 1 legacy 75.1ms 76.1ms 13.1 6.81MB 19.7 #> 2 new_r 70.7ms 72.3ms 13.7 590.88KB 10.3 At this point, I asked ChatGPT for tips on speeding up the tokenizer. Some thoughts about LLMs the thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar‚Äî sarah jeong (@sarahjeong.bsky.social) July 6, 2025 at 7:20 PM Now, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I could say about them.1 As a language scientist, I‚Äôll start here: They know syntax. They know which words go together and can generate very plausible sequences of words. They do not know semantics however. They don‚Äôt have any firsthand knowledge or experience about what those sequences express. They can‚Äôt introspect about that knowledge or experience to see whether things ‚Äúmake sense‚Äù.2 They don‚Äôt care about the truth or falsity of statements. They just make plausible sequences of words. Now, it turns out that if you learn how to make sequences of words from an Internet-sized corpus of text, then a lot of the plausible sequences you make will turn out to be true. If you read 10,000 cookbooks, you could probably provide a very classic recipe for scrambled eggs. But because you don‚Äôt know about sarcasm or can‚Äôt draw on your own experience of trying to not ingest non-food chemicals, you might suggest putting glue on a pizza. So, as we use an LLM, we need to ask ourselves how much we care about the truth or care about knowing or understanding things. That may sound like a glib or weird statement: Shouldn‚Äôt we always care about the truth? Well, sometimes we don‚Äôt. We just want some syntax; we want boilerplate or templates to fill out.3 For example, I can ask an LLM to ‚Äúwrite some unit tests for a function round_to(xs, unit) that rounds a vector of values to an arbitrary unit‚Äù and receive: test_that(\"round_to() rounds to nearest multiple of unit\", { expect_equal(round_to(5, 2), 6) expect_equal(round_to(4.9, 2), 4) expect_equal(round_to(5.1, 2), 6) expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4)) }) These tests are not useful until I plug in the correct values for the expected output. In other cases, we don‚Äôt quite care about truth or comprehension because we can get external corroboration.4 When I ask ChatGPT for an obfuscated R script to make Pac-Man in ggplot2, I can run the code to see if it works without trying to decipher its syntax: library(ggplot2) ggplot()+ geom_polygon(aes(x,y), data=within(data.frame(t(sapply(seq(a Error in eval(substitute(expr), e): object '.' not found (Strangely, this is the case where a dot kills Pac-Man.) Vibes are semantic vapor When we abandon caring about truth or understanding things and just rely on external corroboration, we are in the realm of vibe coding. I like this term because of its insouciant honesty: Truth? Comprehension? We‚Äôre just going off the vibes. It would be a great help if we used the word more liberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No thanks.5 If we lean into vibes, we need to get better at external corroboration and know our programming languages even better. R is a flexible programming language and it does some things that ‚Äúhelp‚Äù the user that can lead to silent bugs. Famously, function arguments and $ will match partial names. # Look at the \"Call:\" in the output lm(f = hp ~ cyl, d = mtcars) #> #> Call: #> lm(formula = hp ~ cyl, data = mtcars) #> #> Coefficients: #> (Intercept) cyl #> -51.05 31.96 # There is no `m` column all(mtcars$m == mtcars$mpg) #> [1] TRUE A student I work with was trying to compute sensitivity and specificity on weighted data. The LLM suggested the following: # Make some weighted data using frequencies data count(outcome, age, name = \"weight\") # What the LLM did: pROC::roc(data, \"outcome\", \"age\", weights = data$weight) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", weights = data$weight) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 This code runs without any problems. It‚Äôs wrong, but it runs. The problem is that pROC::roc(...) supports variadic arguments (...): # Note the dots pROC:::roc |> formals() |> str() #> Dotted pair list of 1 #> $ ...: symbol pROC:::roc.data.frame |> formals() |> str() #> Dotted pair list of 5 #> $ data : symbol #> $ response : symbol #> $ predictor: symbol #> $ ret : language c(\"roc\", \"coords\", \"all_coords\") #> $ ... : symbol Those ... are for forwarding arguments to other functions that roc() might call internally. Unfortunately, functions by default don‚Äôt check the contents of the ... to see if they have unsupported arguments. Thus, bad arguments are ignored silently: # method and weights are not real arguments pROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", method = fake, weights = fake) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 The LLM hallucinated a weights argument, which is a plausible argument,6 and the ... syntax behavior swallowed it up like Pac-Man. It always comes back to Pac-Man. I ended up writing a function that could compute sens and spec on weighted data. Unfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire‚Äî Eugene Vinitsky üçí (@eugenevinitsky.bsky.social) November 13, 2025 at 6:21 PM As users, we can guard against the first two silent problems with options(warnPartialMatchArgs, warnPartialMatchDollar), and as developers, we can prevent the second problem with rlang::check_dots_used() and friends. But like I said at the outset, external corroboration requires us to know even more about the language in order to vibe safely. Syntax and semantics, again In this mini-position statement on LLM assistance, the two principles I am trying to develop are: LLMs know text distributions very well. Use them to generate starter syntax. LLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes. If we think of LLMs as syntax generators, we can imagine some pretty good use cases: Write unit tests for a function that does‚Ä¶ Set up Roxygen docs for this function Create a function to simulate data for a model of rt ~ group + (1 | id) Write a Stan program to fit this model. (Mind your priors.) Spoiler alert: Convert this R loop into C++ code Still, we need to be mindful of the semantic limitations and skeptical of the output. We should audit the results and make sure we comprehend them, or admit upfront that this code is running on vibes. In either case, we also need to be vigilant about bugs that could happen silently or bugs that a machine might make but a human wouldn‚Äôt (hallucinations). One thing I worry about with LLM reliance is skill atrophy. If I keep using this bot as a crutch, then some of my skills will get weaker. Sam Mehr has a take I quite like that puts this concern upfront. LLMs are fine for code we don‚Äôt feel bothered to learn: re AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized I'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done & don't care about learning!‚Äî samuel mehr (@mehr.nz) May 13, 2025 at 10:32 PM I quite like programming and want to learn. I like to read the release notes, dig into the documentation and experiment with new modeling features. At the same time, sometimes I just want a bash script to unzip all .zip files in a directory. Time was, we would find something from Stack Overflow to adapt for that problem. Now, we ask ChatGPT for the code, look it over quick, test it and move on. That seems fine. A metacognitive awareness about what is worth learning and what problems are worth solving in a slower methodical way is very useful for an LLM user. Finally, to be clear‚ÄîI can‚Äôt believe I need to make this disclaimer‚Äîwe should always care about truth and accuracy when we write prose and publish it and put our name on it. Vibes are not scientific or scholarly. When I see emails or code documentation with immaculate formatting and perfect language, my bullshit sensor goes off and I worry that I need to read extra carefully because a smooth-talking robot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing except for proofreading or requests for nitpicking. I have an instruction in ChatGPT that says not to revise anything I write unless it sneaks Magic: The Gathering card names into the output. (Alas, it generally ignores that diabolic edict of mine.) AI assistance in readtextgrid Because the old parser was outperforming the newer, more robust parser, I asked ChatGPT for ways to make my textgrid parsing faster. For example, one version of the loop collected characters in a vector and then paste0()-ed them together. ChatGPT suggested that because we are iterating over character indices we instead use substring() to extract tokens from the text. That worked, and it ran faster, until it failed a unit test on a character wearing a diacritic. After a few rounds of trying to improve the loop, I asked quite bluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the viewest [sic] headaches possible‚Äù. And it provided some very legible cpp11 code. I had never used C++ with R before. To get started, I had to call on usethis::use_cpp11() to make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand I had to troubleshoot the first couple versions of the function because of errors. The cpp11 documentation is small in a good way. It has examples of converting R code into C++ equivalents, which is precisely the activity that I was up to. What I liked about the ChatGPT output is how clear the translation was. In the R version, part of the character processing loop is to peek ahead to the next character to see whether \" is an escaped quote \"\" or the end of a string: # ... in the character processing loop # Start or close string mode if we see \" if (c_starts_string) { # Check for \"\" escapes peek_c",
    "og_image": "https://tjmahr.github.io/assets/images/2025-11-library-tidyverse.png",
    "twitter_title": "readtextgrid now uses C++ (and ChatGPT helped) | R-bloggers",
    "twitter_description": "In this post, I announce the release of version of 0.2.0 of the readtextgrid R package, describe the problem that the package solves, and share some thoughts on LLM-assisted programming. Textgrids are a way to annotate audio data Praat is a program for speech and acoustic analysis that has been around for over 30 years. It includes a scripting language for manipulating and analyzing data and for creating annotation workflows. Users can annotate intervals or points of time in a sound file using a textgrid object. Here is a screenshot of a textgrid in Praat: Screenshot of a Praat editor window. There are three rows in the image, all three of them sharing the same x axis (time). Amplitude waveform, showing intensity over time Spectrogram, showing how the intensity (color) at frequencies (y) changes over time. Red dots mark estimated formants (resonances) in the speech signal. Textgrid of text annotations for the recording A user can edit the textgrid by adding or adjusting boundaries and adding annotations, and Praat will save this data to a .TextGrid file. Other programs can produce .TextGrid files: the textgrid pictured here is the result of forced alignment, specifically by the Montreal Forced Aligner. I told the program I said ‚Äúlibrary tidy verse library b r m s‚Äù, and it looked up the pronunciations of those words and used an acoustic model to estimate the time intervals of each word and each speech sound. The aligner produced a .TextGrid file for this alignment. These textgrids are the bread and butter of some of the research that we do. For example, our article on speaking/articulation rate in children involved over 30,000 single-sentence .wav files and .TextGrid files. We used the alignments to determine the duration of time spent speaking, the number of vowels in each utterance and hence the speaking rate in syllables per second. Reading these .TextGrid files into R was cumbersome, so I wrote and released readtextgrid, an R package built around one simple function: library(tidyverse) library(readtextgrid) path_tg file tier_num tier_name tier_type tier_xmin tier_xmax xmin xmax text #> #> 1 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0 0.08 \"\" #> 2 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.08 0.74 \"lib‚Ä¶ #> 3 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 0.74 1.12 \"tid‚Ä¶ #> 4 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.12 1.58 \"ver‚Ä¶ #> 5 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.58 1.74 \"\" #> 6 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 1.74 2.46 \"lib‚Ä¶ #> 7 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.46 2.72 \"b\" #> 8 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.72 2.9 \"r\" #> 9 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 2.9 3.04 \"m\" #> 10 library-t‚Ä¶ 1 words Interval‚Ä¶ 0 3.60 3.04 3.46 \"s\" #> # ‚Ñπ 33 more rows #> # ‚Ñπ 1 more variable: annotation_num The function returns a tidy tibble with one row per annotation. The filename is stored as a column too so that we can lapply() over a directory of files. Annotations are numbered so that we can group_by(text, annotation_num) and have repeated words handled separately. With this textgrid in R, I can measure speaking rate, for example: data_tg |> filter(tier_name == \"phones\", text != \"\") |> summarise( speaking_time = sum(xmax - xmin), # vowels have numbers to indicate degree of stress num_vowels = sum(str_detect(text, \"\\d\")) ) |> mutate( syllables_per_sec = num_vowels / speaking_time ) #> # A tibble: 1 √ó 3 #> speaking_time num_vowels syllables_per_sec #> #> 1 3.22 13 4.04 Or annotate a spectrogram: library(tidyverse) library(ggplot2) path_spectrogram ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Delimiter: \",\" #> dbl (6): y, x, power, time, frequency, db #> #> ‚Ñπ Use `spec()` to retrieve the full column specification for this data. #> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message. data_spectrogram |> mutate( # reserve more of the color variation for intensities above 15 dB db = ifelse(db ggplot() + aes(x = time, y = frequency) + geom_raster(aes(fill = db)) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"words\"), y = 6500, vjust = 0 ) + geom_text( aes(label = text, x = (xmin + xmax) / 2), data = data_tg |> filter(tier_name == \"phones\"), y = 6100, vjust = 0, size = 2 ) + ylim(c(NA, 6600)) + theme_minimal() + scale_fill_gradient(low = \"white\", high = \"black\") + guides(fill = \"none\") + labs(x = \"time [s]\", y = \"frequency [Hz]\") Spectrogram of me saying 'library tidyverse library brms' I released the first version of the package in 2020. This package, notably for me, contains the first hex badge I ever made. My original .TextGrid parser and its problem Here is what the contents of the .TextGrid file look like. It‚Äôs not the whole file but enough to give a sense of the structure: path_tg |> readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> xmin = 0 #> xmax = 3.596009 #> tiers? #> size = 2 #> item []: #> item [1]: #> class = \"IntervalTier\" #> name = \"words\" #> xmin = 0 #> xmax = 3.596009 #> intervals: size = 11 #> intervals [1]: #> xmin = 0.0 #> xmax = 0.08 #> text = \"\" #> intervals [2]: #> xmin = 0.08 #> xmax = 0.74 #> text = \"library\" #> intervals [3]: #> xmin = 0.74 #> xmax = 1.12 #> text = \"tidy\" #> [... TRUNCATED ... ] The first 7 lines provide some metadata about the time range of the audio and the number of tiers (size = 2). The file then writes out each tier (item [n] lines) by first giving the class, name, time duration and number of marks or intervals. Each mark or interval is enumerated with time values xmin, xmax and text values. Because nearly everything here follows a key = value syntax and because sections are split from each other very neatly with item [n]: or interval [n]: lines, I was able to write a simple parser using regular expressions: Split the file into item [n] sections, split those into interval [n] sections, and extract key-value pairs. This easy approach came with limitations. First, the TextGrid specification was much more flexible. For example, Praat also provides much less verbose ‚Äúshort‚Äù format textgrids which are like a stream of time and text annotations: path_tg_short readLines() |> head(26) |> c(\"[... TRUNCATED ... ]\") |> writeLines() #> File type = \"ooTextFile\" #> Object class = \"TextGrid\" #> #> 0 #> 3.596009 #> #> 2 #> \"IntervalTier\" #> \"words\" #> 0 #> 3.596009 #> 11 #> 0 #> 0.08 #> \"\" #> 0.08 #> 0.74 #> \"library\" #> 0.74 #> 1.12 #> \"tidy\" #> 1.12 #> 1.58 #> \"verse\" #> 1.58 #> 1.74 #> [... TRUNCATED ... ] Everything is in the same order, but the annotations are gone. It turns out that all of the helpful labels from before were actually comments that get ignored. Everything that isn‚Äôt a number or a string in double-quotes (or a ) is a comment. There are also other quirks (\" escapement, ! comments, deviations between the Praat description of the format and the behavior of praat.exe). I have them documented as a kind of unofficial specification in an article on the package website. But my original regular-expression based parser could only handle the verbose long-format textgrids. I knew this. I put this in a GitHub issue in 2020. And this compatibility oversight was never a problem for me until I tried a new phonetics tool that defaulted to saving the textgrids in the short format. Now, readtextgrid could not in fact ‚Äúread textgrid‚Äù. The new R-based tokenizer Josef Fruehwald, a linguist with lots of acoustics/phonetics software, submitted a pull request to implement a proper parser that I eventually rewrote to handle various edge cases and undocumented behavior in the .TextGrid specification. I made an adversarial .TextGrid file üòà that could still be opened by praat.exe but was meant to be difficult to parse. This was a fun development loop: Make the file harder, update the parser to handle the new feature, repeat. Because the essential data in the file are just string tokens and number tokens, I needed to make a tokenizer: a piece of software that reads in characters, groups them into tokens, and figures out what kind of data the token represents. The initial R-based version of the tokenizer did the following: Read the file character by character Gather the characters for the current token and keep them when they form a valid string or number Shift between three states (in_string, in_strong_comment for ! comments, in_escaped_quote) These three states determine how we interpret spaces, newlines, and \" characters. For example, a newline ends a ! comment but a newline can appear in a string so it doesn‚Äôt end a string. Moreover, in a comment, \" is ignored, but in a string, it might be the end of the string or an escaped quote (doubled double-quotes are used for \" characters: the string \"\"\"a\"\"\" has the text \"a\"). But at a high level, the code was simple: for (i in seq_along(all_char)) { # { ... examine current character ... } # { ... handle comment state ... } # { ... collect token if we see whitespace and are not in a string ... } # { ... handle string and escaped quote state ... } } The new character-by-character parser worked üéâ. It had conquered the adversarial example file, but there was still one more problem. It was slower than the original regular-expression parser! tg_lines # A tibble: 2 √ó 6 #> expression min median `itr/sec` mem_alloc `gc/sec` #> #> 1 legacy 75.1ms 76.1ms 13.1 6.81MB 19.7 #> 2 new_r 70.7ms 72.3ms 13.7 590.88KB 10.3 At this point, I asked ChatGPT for tips on speeding up the tokenizer. Some thoughts about LLMs the thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar‚Äî sarah jeong (@sarahjeong.bsky.social) July 6, 2025 at 7:20 PM Now, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I could say about them.1 As a language scientist, I‚Äôll start here: They know syntax. They know which words go together and can generate very plausible sequences of words. They do not know semantics however. They don‚Äôt have any firsthand knowledge or experience about what those sequences express. They can‚Äôt introspect about that knowledge or experience to see whether things ‚Äúmake sense‚Äù.2 They don‚Äôt care about the truth or falsity of statements. They just make plausible sequences of words. Now, it turns out that if you learn how to make sequences of words from an Internet-sized corpus of text, then a lot of the plausible sequences you make will turn out to be true. If you read 10,000 cookbooks, you could probably provide a very classic recipe for scrambled eggs. But because you don‚Äôt know about sarcasm or can‚Äôt draw on your own experience of trying to not ingest non-food chemicals, you might suggest putting glue on a pizza. So, as we use an LLM, we need to ask ourselves how much we care about the truth or care about knowing or understanding things. That may sound like a glib or weird statement: Shouldn‚Äôt we always care about the truth? Well, sometimes we don‚Äôt. We just want some syntax; we want boilerplate or templates to fill out.3 For example, I can ask an LLM to ‚Äúwrite some unit tests for a function round_to(xs, unit) that rounds a vector of values to an arbitrary unit‚Äù and receive: test_that(\"round_to() rounds to nearest multiple of unit\", { expect_equal(round_to(5, 2), 6) expect_equal(round_to(4.9, 2), 4) expect_equal(round_to(5.1, 2), 6) expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4)) }) These tests are not useful until I plug in the correct values for the expected output. In other cases, we don‚Äôt quite care about truth or comprehension because we can get external corroboration.4 When I ask ChatGPT for an obfuscated R script to make Pac-Man in ggplot2, I can run the code to see if it works without trying to decipher its syntax: library(ggplot2) ggplot()+ geom_polygon(aes(x,y), data=within(data.frame(t(sapply(seq(a Error in eval(substitute(expr), e): object '.' not found (Strangely, this is the case where a dot kills Pac-Man.) Vibes are semantic vapor When we abandon caring about truth or understanding things and just rely on external corroboration, we are in the realm of vibe coding. I like this term because of its insouciant honesty: Truth? Comprehension? We‚Äôre just going off the vibes. It would be a great help if we used the word more liberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No thanks.5 If we lean into vibes, we need to get better at external corroboration and know our programming languages even better. R is a flexible programming language and it does some things that ‚Äúhelp‚Äù the user that can lead to silent bugs. Famously, function arguments and $ will match partial names. # Look at the \"Call:\" in the output lm(f = hp ~ cyl, d = mtcars) #> #> Call: #> lm(formula = hp ~ cyl, data = mtcars) #> #> Coefficients: #> (Intercept) cyl #> -51.05 31.96 # There is no `m` column all(mtcars$m == mtcars$mpg) #> [1] TRUE A student I work with was trying to compute sensitivity and specificity on weighted data. The LLM suggested the following: # Make some weighted data using frequencies data count(outcome, age, name = \"weight\") # What the LLM did: pROC::roc(data, \"outcome\", \"age\", weights = data$weight) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", weights = data$weight) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 This code runs without any problems. It‚Äôs wrong, but it runs. The problem is that pROC::roc(...) supports variadic arguments (...): # Note the dots pROC:::roc |> formals() |> str() #> Dotted pair list of 1 #> $ ...: symbol pROC:::roc.data.frame |> formals() |> str() #> Dotted pair list of 5 #> $ data : symbol #> $ response : symbol #> $ predictor: symbol #> $ ret : language c(\"roc\", \"coords\", \"all_coords\") #> $ ... : symbol Those ... are for forwarding arguments to other functions that roc() might call internally. Unfortunately, functions by default don‚Äôt check the contents of the ... to see if they have unsupported arguments. Thus, bad arguments are ignored silently: # method and weights are not real arguments pROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake) #> Setting levels: control = Good, case = Poor #> Setting direction: controls < cases #> #> Call: #> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\", method = fake, weights = fake) #> #> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor). #> Area under the curve: 0.5947 The LLM hallucinated a weights argument, which is a plausible argument,6 and the ... syntax behavior swallowed it up like Pac-Man. It always comes back to Pac-Man. I ended up writing a function that could compute sens and spec on weighted data. Unfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire‚Äî Eugene Vinitsky üçí (@eugenevinitsky.bsky.social) November 13, 2025 at 6:21 PM As users, we can guard against the first two silent problems with options(warnPartialMatchArgs, warnPartialMatchDollar), and as developers, we can prevent the second problem with rlang::check_dots_used() and friends. But like I said at the outset, external corroboration requires us to know even more about the language in order to vibe safely. Syntax and semantics, again In this mini-position statement on LLM assistance, the two principles I am trying to develop are: LLMs know text distributions very well. Use them to generate starter syntax. LLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes. If we think of LLMs as syntax generators, we can imagine some pretty good use cases: Write unit tests for a function that does‚Ä¶ Set up Roxygen docs for this function Create a function to simulate data for a model of rt ~ group + (1 | id) Write a Stan program to fit this model. (Mind your priors.) Spoiler alert: Convert this R loop into C++ code Still, we need to be mindful of the semantic limitations and skeptical of the output. We should audit the results and make sure we comprehend them, or admit upfront that this code is running on vibes. In either case, we also need to be vigilant about bugs that could happen silently or bugs that a machine might make but a human wouldn‚Äôt (hallucinations). One thing I worry about with LLM reliance is skill atrophy. If I keep using this bot as a crutch, then some of my skills will get weaker. Sam Mehr has a take I quite like that puts this concern upfront. LLMs are fine for code we don‚Äôt feel bothered to learn: re AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized I'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done & don't care about learning!‚Äî samuel mehr (@mehr.nz) May 13, 2025 at 10:32 PM I quite like programming and want to learn. I like to read the release notes, dig into the documentation and experiment with new modeling features. At the same time, sometimes I just want a bash script to unzip all .zip files in a directory. Time was, we would find something from Stack Overflow to adapt for that problem. Now, we ask ChatGPT for the code, look it over quick, test it and move on. That seems fine. A metacognitive awareness about what is worth learning and what problems are worth solving in a slower methodical way is very useful for an LLM user. Finally, to be clear‚ÄîI can‚Äôt believe I need to make this disclaimer‚Äîwe should always care about truth and accuracy when we write prose and publish it and put our name on it. Vibes are not scientific or scholarly. When I see emails or code documentation with immaculate formatting and perfect language, my bullshit sensor goes off and I worry that I need to read extra carefully because a smooth-talking robot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing except for proofreading or requests for nitpicking. I have an instruction in ChatGPT that says not to revise anything I write unless it sneaks Magic: The Gathering card names into the output. (Alas, it generally ignores that diabolic edict of mine.) AI assistance in readtextgrid Because the old parser was outperforming the newer, more robust parser, I asked ChatGPT for ways to make my textgrid parsing faster. For example, one version of the loop collected characters in a vector and then paste0()-ed them together. ChatGPT suggested that because we are iterating over character indices we instead use substring() to extract tokens from the text. That worked, and it ran faster, until it failed a unit test on a character wearing a diacritic. After a few rounds of trying to improve the loop, I asked quite bluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the viewest [sic] headaches possible‚Äù. And it provided some very legible cpp11 code. I had never used C++ with R before. To get started, I had to call on usethis::use_cpp11() to make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand I had to troubleshoot the first couple versions of the function because of errors. The cpp11 documentation is small in a good way. It has examples of converting R code into C++ equivalents, which is precisely the activity that I was up to. What I liked about the ChatGPT output is how clear the translation was. In the R version, part of the character processing loop is to peek ahead to the next character to see whether \" is an escaped quote \"\" or the end of a string: # ... in the character processing loop # Start or close string mode if we see \" if (c_starts_string) { # Check for \"\" escapes peek_c",
    "raw_jsonld_article": null,
    "article_headline": null,
    "article_section": null,
    "article_tags": null,
    "article_author": null,
    "article_published": null,
    "article_modified": null,
    "main_text": "readtextgrid now uses C++ (and ChatGPT helped)\nPosted on\nNovember 14, 2025\nby\nHigher Order Functions\nin\nR bloggers\n| 0 Comments\n[This article was first published on\nHigher Order Functions\n, and kindly contributed to\nR-bloggers\n].  (You can report issue about the content on this page\nhere\n)\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.\nIn this post, I announce the release of version of 0.2.0 of the\nreadtextgrid\nR package, describe the problem that\nthe package solves, and share some thoughts on LLM-assisted programming.\nTextgrids are a way to annotate audio data\nPraat\nis a program for speech and \nacoustic analysis that has been around for over 30 years. It includes a \nscripting language for manipulating and analyzing data and for creating\nannotation workflows. Users can annotate intervals or points of time \nin a sound file using a\ntextgrid\nobject. Here is a screenshot of a\ntextgrid in Praat:\nScreenshot of a Praat editor window.\nThere are three rows in the image, all three of them sharing the same\nx\naxis (time).\nAmplitude waveform, showing intensity over time\nSpectrogram, showing how the intensity (\ncolor\n) at frequencies (\ny\n) changes over\ntime. Red dots mark estimated formants (resonances) in the speech signal.\nTextgrid of text annotations for the recording\nA user can edit the textgrid by adding or adjusting boundaries and\nadding annotations, and Praat will save this data to a\n.TextGrid\nfile.\nOther programs can produce\n.TextGrid\nfiles: the textgrid pictured here\nis the result of forced alignment, specifically by the\nMontreal Forced\nAligner\n. I told the program I said ‚Äúlibrary tidy verse library\nb r m s‚Äù, and it looked up the pronunciations of those words and used an\nacoustic model to estimate the time intervals of each word and each\nspeech sound. The aligner produced a\n.TextGrid\nfile for this alignment.\nThese textgrids are the bread and butter of some of the research that we\ndo. For example,\nour article\non speaking/articulation rate in children\ninvolved over 30,000 single-sentence\n.wav\nfiles and\n.TextGrid\nfiles. We\nused the alignments to determine the duration of time spent speaking, the\nnumber of vowels in each utterance and hence the speaking rate in\nsyllables per second.\nReading these\n.TextGrid\nfiles into R was cumbersome, so I wrote and\nreleased\nreadtextgrid\n, an R package built around one \nsimple function:\nlibrary(tidyverse)\nlibrary(readtextgrid)\n\npath_tg <- \"_R/data/mfa-out/library-tidyverse-library-brms.TextGrid\" \ndata_tg <- read_textgrid(path_tg)\n\ndata_tg\n#> # A tibble: 43 √ó 10\n#>    file       tier_num tier_name tier_type tier_xmin tier_xmax  xmin  xmax text \n#>    <chr>         <int> <chr>     <chr>         <dbl>     <dbl> <dbl> <dbl> <chr>\n#>  1 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0     0.08 \"\"   \n#>  2 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0.08  0.74 \"lib‚Ä¶\n#>  3 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0.74  1.12 \"tid‚Ä¶\n#>  4 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.12  1.58 \"ver‚Ä¶\n#>  5 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.58  1.74 \"\"   \n#>  6 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.74  2.46 \"lib‚Ä¶\n#>  7 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.46  2.72 \"b\"  \n#>  8 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.72  2.9  \"r\"  \n#>  9 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.9   3.04 \"m\"  \n#> 10 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  3.04  3.46 \"s\"  \n#> # ‚Ñπ 33 more rows\n#> # ‚Ñπ 1 more variable: annotation_num <int>\nThe function returns a tidy tibble with one row per annotation. The filename is\nstored as a column too so that we can\nlapply()\nover a directory of files.\nAnnotations are numbered so that we can\ngroup_by(text, annotation_num)\nand \nhave repeated words handled separately.\nWith this textgrid in R, I can measure speaking rate, for example:\ndata_tg |> \n  filter(tier_name == \"phones\", text != \"\") |> \n  summarise(\n    speaking_time = sum(xmax - xmin),\n    # vowels have numbers to indicate degree of stress\n    num_vowels = sum(str_detect(text, \"\\\\d\"))\n  ) |> \n  mutate(\n    syllables_per_sec = num_vowels / speaking_time \n  )\n#> # A tibble: 1 √ó 3\n#>   speaking_time num_vowels syllables_per_sec\n#>           <dbl>      <int>             <dbl>\n#> 1          3.22         13              4.04\nOr annotate a spectrogram:\nlibrary(tidyverse)\nlibrary(ggplot2)\npath_spectrogram <- \"_R/data/mfa/library-tidyverse-library-brms.csv\"\ndata_spectrogram <- readr::read_csv(path_spectrogram)\n#> Rows: 249366 Columns: 6\n#> ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#> Delimiter: \",\"\n#> dbl (6): y, x, power, time, frequency, db\n#> \n#> ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#> ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndata_spectrogram |> \n  mutate(\n    # reserve more of the color variation for intensities above 15 dB\n    db = ifelse(db < 15, 15, db)\n  ) |> \n  ggplot() + \n  aes(x = time, y = frequency) +\n  geom_raster(aes(fill = db)) +\n  geom_text(\n    aes(label = text, x = (xmin + xmax) / 2),\n    data = data_tg |> filter(tier_name == \"words\"),\n    y = 6500,\n    vjust = 0\n  )  +\n  geom_text(\n    aes(label = text, x = (xmin + xmax) / 2),\n    data = data_tg |> filter(tier_name == \"phones\"),\n    y = 6100,\n    vjust = 0,\n    size = 2\n  )  +\n  ylim(c(NA, 6600)) +\n  theme_minimal() +\n  scale_fill_gradient(low = \"white\", high = \"black\") +\n  guides(fill = \"none\") +\n  labs(x = \"time [s]\", y = \"frequency [Hz]\")\nSpectrogram of me saying ‚Äòlibrary tidyverse library brms‚Äô\nI released the first version of the package in 2020. This package,\nnotably for me, contains the first hex badge I ever made.\nMy original\n.TextGrid\nparser and its problem\nHere is what the contents of the\n.TextGrid\nfile look like. It‚Äôs not the whole\nfile but enough to give a sense of the structure:\npath_tg |> \n  readLines() |> \n  head(26) |> \n  c(\"[... TRUNCATED ... ]\") |> \n  writeLines()\n#> File type = \"ooTextFile\"\n#> Object class = \"TextGrid\"\n#> \n#> xmin = 0 \n#> xmax = 3.596009 \n#> tiers? <exists> \n#> size = 2 \n#> item []: \n#>     item [1]:\n#>         class = \"IntervalTier\" \n#>         name = \"words\" \n#>         xmin = 0 \n#>         xmax = 3.596009 \n#>         intervals: size = 11 \n#>         intervals [1]:\n#>             xmin = 0.0 \n#>             xmax = 0.08 \n#>             text = \"\" \n#>         intervals [2]:\n#>             xmin = 0.08 \n#>             xmax = 0.74 \n#>             text = \"library\" \n#>         intervals [3]:\n#>             xmin = 0.74 \n#>             xmax = 1.12 \n#>             text = \"tidy\" \n#> [... TRUNCATED ... ]\nThe first 7 lines provide some metadata about the time range of the\naudio and the number of tiers (\nsize = 2\n). The file then writes out each\ntier (\nitem [n]\nlines) by first giving the\nclass\n,\nname\n, time\nduration and number of marks or intervals. Each mark or interval is\nenumerated with time values\nxmin\n,\nxmax\nand\ntext\nvalues.\nBecause nearly everything here follows a\nkey = value\nsyntax and\nbecause sections are split from each other very neatly with\nitem [n]:\nor\ninterval [n]:\nlines, I was able to write\na simple parser using\nregular expressions\n: Split the file into\nitem [n]\nsections, split\nthose into\ninterval [n]\nsections, and extract key-value pairs.\nThis easy approach came with limitations. First, the\nTextGrid\nspecification\nwas much more flexible. For example, Praat\nalso provides much less verbose ‚Äúshort‚Äù format textgrids which are like\na stream of time and text annotations:\npath_tg_short <- \"_R/data/mfa-out/library-tidyverse-library-brms-short.TextGrid\"\npath_tg_short |> \n  readLines() |> \n  head(26) |> \n  c(\"[... TRUNCATED ... ]\") |> \n  writeLines()\n#> File type = \"ooTextFile\"\n#> Object class = \"TextGrid\"\n#> \n#> 0\n#> 3.596009\n#> <exists>\n#> 2\n#> \"IntervalTier\"\n#> \"words\"\n#> 0\n#> 3.596009\n#> 11\n#> 0\n#> 0.08\n#> \"\"\n#> 0.08\n#> 0.74\n#> \"library\"\n#> 0.74\n#> 1.12\n#> \"tidy\"\n#> 1.12\n#> 1.58\n#> \"verse\"\n#> 1.58\n#> 1.74\n#> [... TRUNCATED ... ]\nEverything is in the same order, but the annotations are gone. It turns\nout that all of the helpful labels from before were actually\ncomments\nthat get ignored. Everything that isn‚Äôt a number or a string in\ndouble-quotes (or a\n<flag>\n) is a comment.\nThere are also other quirks (\n\"\nescapement,\n!\ncomments, deviations\nbetween the Praat description of the format and the behavior of\npraat.exe\n). I have them documented as a kind of\nunofficial\nspecification\nin an article on the package website.\nBut my original regular-expression based parser could only handle the\nverbose long-format textgrids. I knew this. I put this in\na GitHub issue\nin 2020\n. And this compatibility oversight was never a\nproblem for me until I tried a new phonetics tool that defaulted to\nsaving the textgrids in the short format. Now, readtextgrid could not\nin fact ‚Äúread textgrid‚Äù.\nThe new R-based tokenizer\nJosef Fruehwald\n, a linguist with\nlots of\nacoustics/phonetics software\n, submitted a pull request to implement a\nproper parser that I eventually rewrote to handle various edge cases and\nundocumented behavior in the\n.TextGrid\nspecification. I made an\nadversarial\n.TextGrid\nfile\nüòà that could still be opened\nby\npraat.exe\nbut was meant to be difficult to parse. This was a fun\ndevelopment loop: Make the file harder, update the parser to handle the\nnew feature, repeat.\nBecause the essential data in the file are just string tokens and\nnumber tokens, I needed to make a\ntokenizer\n: a piece\nof software that reads in characters, groups them into tokens, and\nfigures out what kind of data the token represents. The initial R-based\nversion of the tokenizer did the following:\nRead the file character by character\nGather the characters for the current token and keep them when they\nform a valid string or number\nShift between three states (\nin_string\n,\nin_strong_comment\nfor\n!\ncomments\n,\nin_escaped_quote\n)\nThese three states determine how we interpret spaces, newlines, and\n\"\ncharacters. For example, a newline ends a\n! comment\nbut a newline can\nappear in a string so it doesn‚Äôt end a string. Moreover, in a comment,\n\"\nis ignored, but in a string, it might be the end of the string or an\nescaped quote (doubled double-quotes are used for\n\"\ncharacters: the\nstring\n\"\"\"a\"\"\"\nhas the text\n\"a\"\n).\nBut at a high level, the code was simple:\nfor (i in seq_along(all_char)) {\n\n  # { ... examine current character ... }\n  \n  # { ... handle comment state ... }\n  \n  # { ... collect token if we see whitespace and are not in a string  ... }\n  \n  # { ... handle string and escaped quote state ... }\n\n}\nThe new character-by-character parser worked üéâ. It had conquered\nthe adversarial example file, but there was still one more problem. It was\nslower than the original regular-expression parser!\ntg_lines <- readLines(path_tg)\n\nbench::mark(\n  legacy = readtextgrid:::legacy_read_textgrid_lines(tg_lines),\n  new_r = readtextgrid:::r_read_textgrid_lines(tg_lines)\n)\n#> # A tibble: 2 √ó 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 legacy       75.1ms   76.1ms      13.1    6.81MB     19.7\n#> 2 new_r        70.7ms   72.3ms      13.7  590.88KB     10.3\nAt this point, I asked ChatGPT for tips on speeding up the tokenizer.\nSome thoughts about LLMs\nthe thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar\n‚Äî sarah jeong (\n@sarahjeong.bsky.social\n)\nJuly 6, 2025 at 7:20 PM\nNow, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I\ncould say about them.\n1\nAs a language scientist, I‚Äôll start here: They\nknow\nsyntax\n. They know which words go together and can generate very\nplausible sequences of words. They do not know\nsemantics\nhowever. They\ndon‚Äôt have any firsthand knowledge or experience about what those\nsequences express. They can‚Äôt introspect about that knowledge or\nexperience to see whether things ‚Äúmake sense‚Äù.\n2\nThey\ndon‚Äôt care\nabout the truth or falsity of statements.\nThey just make plausible sequences of words.\nNow, it turns out that if you learn how to make sequences of words from an\nInternet-sized corpus of text, then a lot of the plausible sequences you make\nwill turn out to be true. If you read 10,000 cookbooks, you could probably\nprovide a very classic recipe for scrambled eggs. But because you don‚Äôt know\nabout sarcasm or can‚Äôt draw on your own experience of trying to not ingest\nnon-food chemicals, you might suggest putting\nglue on a pizza\n.\nSo, as we use an LLM, we need to ask ourselves how much we care about\nthe truth or care about knowing or understanding things. That may sound\nlike a glib or weird statement: Shouldn‚Äôt we always care about the\ntruth? Well, sometimes we don‚Äôt. We just want some syntax; we want\nboilerplate or templates\nto fill out.\n3\nFor example, I can ask an LLM to ‚Äúwrite some unit tests for a function\nround_to(xs, unit)\nthat rounds a vector of values to an arbitrary\nunit‚Äù and receive:\ntest_that(\"round_to() rounds to nearest multiple of unit\", {\n  expect_equal(round_to(5, 2), 6)\n  expect_equal(round_to(4.9, 2), 4)\n  expect_equal(round_to(5.1, 2), 6)\n  expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4))\n})\nThese tests are not useful\nuntil\nI plug in the correct values for the expected \noutput.\nIn other cases, we don‚Äôt quite care about truth or comprehension because we can\nget external corroboration.\n4\nWhen I ask ChatGPT for an obfuscated R script to\nmake Pac-Man in ggplot2, I can run the code to see if it works without trying to\ndecipher its syntax:\nlibrary(ggplot2)\nggplot()+\ngeom_polygon(aes(x,y),\ndata=within(data.frame(t(sapply(seq(a<-pi/9,2*pi-a,l<-4e2),\nfunction(t)c(cos(t),sin(t))))),\n{rbind(.,0,0,cos(a),sin(a))->df;x=df[,1];y=df[,2]}),\nfill=\"#FF0\",col=1)+\nannotate(\"point\",x=.35,y=.5,size=3)+\nannotate(\"point\",x=c(1.4,2,2.6),y=0,size=3)+\ncoord_equal(xlim=c(-1.2,3),ylim=c(-1.2,1.2))+\ntheme_void()\n#> Error in eval(substitute(expr), e): object '.' not found\n(Strangely, this is the case where a dot\nkills\nPac-Man.)\nVibes are semantic vapor\nWhen we abandon caring about truth or understanding things and just rely\non external corroboration, we are in the realm of\nvibe\ncoding\n. I like this term\nbecause of its insouciant honesty:\nTruth? Comprehension? We‚Äôre just\ngoing off the vibes.\nIt would be a great help if we used the word more\nliberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No\nthanks.\n5\nIf we lean into vibes, we need to get better at external corroboration\nand know our programming languages even better. R is a flexible\nprogramming language and it does some things that ‚Äúhelp‚Äù the user that\ncan lead to silent bugs. Famously, function arguments and\n$\nwill match\npartial names.\n# Look at the \"Call:\" in the output\nlm(f = hp ~ cyl, d = mtcars)\n#> \n#> Call:\n#> lm(formula = hp ~ cyl, data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)          cyl  \n#>      -51.05        31.96\n\n# There is no `m` column\nall(mtcars$m == mtcars$mpg)\n#> [1] TRUE\nA student I work with was trying to compute sensitivity and specificity on \nweighted data. The LLM suggested the following:\n# Make some weighted data using frequencies\ndata <- pROC::aSAH |> \n  count(outcome, age, name = \"weight\")\n\n# What the LLM did:\npROC::roc(data, \"outcome\", \"age\", weights = data$weight)\n#> Setting levels: control = Good, case = Poor\n#> Setting direction: controls < cases\n#> \n#> Call:\n#> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\",     weights = data$weight)\n#> \n#> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor).\n#> Area under the curve: 0.5947\nThis code runs without any problems. It‚Äôs wrong, but it runs. The problem \nis that\npROC::roc(...)\nsupports variadic arguments (\n...\n):\n# Note the dots\npROC:::roc |> formals() |> str()\n#> Dotted pair list of 1\n#>  $ ...: symbol\npROC:::roc.data.frame |> formals() |> str()\n#> Dotted pair list of 5\n#>  $ data     : symbol \n#>  $ response : symbol \n#>  $ predictor: symbol \n#>  $ ret      : language c(\"roc\", \"coords\", \"all_coords\")\n#>  $ ...      : symbol\nThose\n...\nare for forwarding arguments to other functions that\nroc()\nmight call internally. Unfortunately,\nfunctions by default don‚Äôt check the contents of the\n...\nto see if they\nhave unsupported arguments. Thus, bad arguments are ignored silently:\n# method and weights are not real arguments\npROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake)\n#> Setting levels: control = Good, case = Poor\n#> Setting direction: controls < cases\n#> \n#> Call:\n#> roc.data.frame(data = data, response = \"outcome\", predictor = \"age\",     method = fake, weights = fake)\n#> \n#> Data: age in 44 controls (outcome Good) < 30 cases (outcome Poor).\n#> Area under the curve: 0.5947\nThe LLM hallucinated a\nweights\nargument, which is a plausible\nargument,\n6\nand the\n...\nsyntax behavior swallowed it up like\nPac-Man. It always comes back to Pac-Man. I ended up writing\na\nfunction\nthat could compute sens and spec on weighted data.\nUnfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire\n‚Äî Eugene Vinitsky üçí (\n@eugenevinitsky.bsky.social\n)\nNovember 13, 2025 at 6:21 PM\nAs users, we can guard against the first two silent problems with\noptions(warnPartialMatchArgs, warnPartialMatchDollar)\n, and as\ndevelopers, we can prevent the second problem with\nrlang::check_dots_used()\nand friends. But like I said\nat the outset, external corroboration requires us to know\neven more\nabout the language in order to vibe safely.\nSyntax and semantics, again\nIn this mini-position statement on LLM assistance, the two principles I\nam trying to develop are:\nLLMs know text distributions very well. Use them to generate starter syntax.\nLLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes.\nIf we think of LLMs as syntax generators, we can imagine\nsome pretty good use cases:\nWrite unit tests for a function that does‚Ä¶\nSet up Roxygen docs for this function\nCreate a function to simulate data for a model of\nrt ~ group + (1 | id)\nWrite a Stan program to fit this model. (\nMind your priors.\n)\nSpoiler alert\n: Convert this R loop into C++ code\nStill, we need to be mindful of the semantic limitations and skeptical\nof the output. We should audit the results and make sure we comprehend\nthem, or admit upfront that this code is running on vibes. In either case, \nwe also need to be vigilant about bugs that could happen silently or bugs\nthat a machine might make but a human wouldn‚Äôt (hallucinations).\nOne thing I worry about with LLM reliance is skill atrophy. If I keep\nusing this bot as a crutch, then some of my skills will get weaker. Sam Mehr\nhas a take I quite like that puts this concern upfront. LLMs are\nfine for code we don‚Äôt feel bothered to learn:\nre AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized\nI'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done & don't care about learning!\n‚Äî samuel mehr (\n@mehr.nz\n)\nMay 13, 2025 at 10:32 PM\nI quite like programming and want to learn. I like to read the release\nnotes, dig into the documentation and\nexperiment\nwith new modeling features. At the same time, sometimes I just want a\nbash script to unzip all\n.zip\nfiles in a directory. Time was, we would\nfind something from Stack Overflow to adapt for that problem. Now, we\nask ChatGPT for the code, look it over quick, test it and move on. That\nseems fine. A metacognitive awareness about what is worth \nlearning and what problems are worth solving in a slower methodical way \nis very useful for an LLM user.\nFinally, to be clear‚ÄîI can‚Äôt believe I need to make this\ndisclaimer‚Äîwe should always care about truth and accuracy when we\nwrite prose and publish it and put our name on it. Vibes are not\nscientific or scholarly. When I see emails or code documentation with\nimmaculate formatting and perfect language, my bullshit sensor goes off\nand I worry that I need to read extra carefully because a smooth-talking\nrobot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing\nexcept for proofreading or requests for nitpicking. I have an\ninstruction in ChatGPT that says not to revise anything I write unless\nit sneaks Magic: The Gathering card names into the output. (Alas, it\ngenerally ignores that\ndiabolic edict\nof mine.)\nAI assistance in readtextgrid\nBecause the old parser was outperforming the newer, more robust parser, I\nasked ChatGPT for ways to make my textgrid parsing faster. For example,\none version of the loop collected characters in a vector and then\npaste0()\n-ed them together. ChatGPT suggested that because we are\niterating over character indices we instead use\nsubstring()\nto extract tokens from the text. That worked, and it ran\nfaster, until it failed a unit test on a character wearing a diacritic. \nAfter a few rounds of trying to improve the loop, I asked quite\nbluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the\nviewest [\nsic\n] headaches possible‚Äù.\nAnd it provided some very legible cpp11 code. I had never used C++ with\nR before. To get started, I had to call on\nusethis::use_cpp11()\nto make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand\nI had to troubleshoot the first couple versions of the function because\nof errors. The\ncpp11\ndocumentation\nis small in\na good way. It has examples of converting R code into C++ equivalents,\nwhich is precisely the activity that I was up to.\nWhat I liked about the ChatGPT output is how clear the translation was.\nIn the R version, part of the character processing loop is to peek ahead\nto the next character to see whether\n\"\nis an escaped quote\n\"\"\nor the\nend of a string:\n# ... in the character processing loop\n\n    # Start or close string mode if we see \"\n    if (c_starts_string) {\n      # Check for \"\" escapes\n      peek_c <- all_char[i + 1]\n      if (peek_c == \"\\\"\" & in_string) {\n        in_escaped_quote <- TRUE\n      } else {\n        in_string <- !in_string\n      }\n    }\n\n# ...\nAnd here is the C++ version of the peek ahead code:\n// ... helper functions ...\n\n  // Is this a UTF-8 continuation byte? (10xxxxxx)\n  auto is_cont = [](unsigned char b)->bool {\n    // Are the first two bits 10?\n    return (b & 0xC0) == 0x80;\n  };\n\n// ... in the character processing loop ...\n\n    if (b == 0x22) { // '\"'\n      // peek ahead to see if we have a double \"\" escapement\n      size_t j = i + 1;\n      // We need the next character, not just the next byte, so we skip\n      // continuation characters.\n      while (j < nbytes && is_cont(static_cast<unsigned char>(src[j]))) ++j;\n      // Use `0x00` dummy character if we are at the end of the string\n      unsigned char nextb = (j < nbytes) ? static_cast<unsigned char>(src[j]) : 0x00;\n\n      if (in_string && nextb == 0x22) {\n        esc_next = true;    // consume next '\"' once\n      } else {\n        in_string = !in_string;\n      }\n    }\n\n// ...\nThere is a logical correspondence between the lines that I wrote myself\nin R and the lines that the LLM provided for C++. The C++ version works\nat the level of bytes instead of characters, and that matters:\n\"√©\" |> nchar(type = \"chars\")\n#> [1] 1\n\"√©\" |> nchar(type = \"bytes\")\n#> [1] 2\nBut the C++ code makes sense to me. It looks\nplausible\n, right? Still,\nplausible isn‚Äôt enough. I asked the LLM a lot of follow-up questions:\nwhat does\nauto\ndo, what is\nsize_t\ndoing, and so on. And I annotated\nthe C++ code with comments for my own understanding.\nDuring my auditing, I went down a particular rabbithole to make sure I\nunderstood how Unicode bytes get packed into UTF-8 sequences. I learned\nhow the character\n√©\nfor example has the codepoint (character number)\nU+00E9\nin Unicode, so it falls in the range of codepoints that need to\nbe split into two bytes. The\nscheme for two-byte\nencoding\nis\ncharacter number               ->               character encoding\ncodepoint -> 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx -> UTF-8 bytes\n00E9      -> 00000000 11101001 -> 11000011 10101001 -> c3 a9\nWhich we can check by hand:\nbitchar_to_raw <- function(xs) {\n  xs |> \n    strsplit(\"\") |> \n    lapply(function(x) as.integer(x) |> rev() |> packBits()) |> \n    unlist()\n}\n\nbitchar_to_raw(c(\"11000011\", \"10101001\"))\n#> [1] c3 a9\ncharToRaw(\"√©\")\n#> [1] c3 a9\nIn the UTF-8 scheme, bytes that start with\n10\nare only the second,\nthird and fourth bytes in a character‚Äôs encoding‚Äîthat is, only the\ncontinuation\nbytes. Now, at this point, we can comprehend\nwhy\nthe C++\nis checking for continuation characters and why the check for\ncontinuation characters involves checking the first two bits.\nAnother rabbithole involved how to parse numbers. At first, the LLM\nsuggested I use one of R‚Äôs own C functions to handle it. That idea \nseems really powerful to me‚Äîwait, now I can tap into what R‚Äôs own \nroutines?!‚Äîbut R‚Äôs parser was a bit stricter than what I needed to\nmatch\npraat.exe\n.\nThis new C++ based tokenizer yielded a\nhuge performance gain\n:\nbench::mark(\n  legacy = readtextgrid:::legacy_read_textgrid_lines(tg_lines),\n  new_r = readtextgrid:::r_read_textgrid_lines(tg_lines),\n  new_cpp = readtextgrid::read_textgrid_lines(tg_lines)\n)\n#> # A tibble: 3 √ó 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 legacy      65.22ms  68.77ms      13.8    6.49MB     4.59\n#> 2 new_r       72.67ms   88.5ms      11.5  363.33KB     5.74\n#> 3 new_cpp      3.12ms   3.64ms     272.    96.77KB     4.11\nThat‚Äôs an improvement of 10‚Äì15x! Now, I find myself wondering: What else\ncould use a cpp11 speed boost?\nOne downside of adopting cpp11 is that the package needs to compile\ncode. As a result, I can‚Äôt just tell people to try the developer version\nof the package with\nremotes::install_github()\n.\nCRAN compiles packages so end users don‚Äôt face this issue when\ninstalling the official released version of packages.\nOne workaround I adopted was relying on\nR\nUniverse\nwhich will provide compiled\nversions of packages hosted on GitHub. Then we change the installation\ninstructions to:\ninstall.packages(\n  \"readtextgrid\", \n  repos = c(\"https://tjmahr.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nYou might have seen this pattern elsewhere.\ncmdstanr\nskips CRAN entirely and only\nuses R Universe.\nParting thoughts\nAn LLM helped me translate pokey R code into fast C++ code. The code is\nlive now\non\nCRAN\n, released in readtextgrid 0.2.0. I‚Äôm\nmaybe kind of a C++ developer now? (Nah.)\nThis kind of code translation strikes me as an easy win for R developers: \n‚ÄúI have my version that works right now, but I think it can\ngo faster. Help me convert this to C++.‚Äù I took care to make sure I\nunderstood the output. The syntax came easy, but the semantics\n(comprehension and validation) took more time.\nIf I ask myself,\ncould I have done this translation to C++ without an\nLLM?\nThe answer is no, not in a reasonable timeframe, certainly not as\nfast as the two days it took me in this case. That‚Äôs a pretty undeniable\nboost.\nThings I won‚Äôt talk about: Plagiarism, safety, energy use, hype,\nundercooked AI features making things slower and dumber, stupid people \nemboldened by how trivial AI makes everything seem‚Äî\nwe won‚Äôt need \nprogrammers or doctors or historians or whatever\nis what someone with no\nexpertise in programming, medicine, history, etc. would say‚Äîdumdums \ntearing down\nfences\n,\ncreativity versus productivity\n, aesthetic homogenization or \nhow I keep seeing the same comic style in YouTube thumbnails, nobody asked \nfor slop, oh they did ask for slop, etc.\n‚Ü©\nThere is something introspective about\nreasoning models\nwhich will break a prompt into steps and \nwork through them. But still, I‚Äôm thinking about what the ground truth is in \nthis reasoning. The statistical regularities of word patterns?\n‚Ü©\nI think there is a great ‚Äútradition‚Äù‚Äînot sure of the right \nword here‚Äîin learning programming and other tools where we start from a\nstarter template or maybe small sample project and we experimentally\ntweak the code and iterate until it turns into the thing we want. It‚Äôs\nlike\nscaffolding\nbut at a less metaphorical level: Code that sets a foundation for \nself-directed learning.\n‚Ü©\nI asked ChatGPT for help making a shopping list for a small woodworking\nproject, and it offered a cutting plan for the lumber.\nSure, why not?\nIt\nmessed up the math with a plan that involved cutting off 74 inches of\nwood from a 6-foot piece of lumber. My external corroboration in this case \nwas a scrap of wood.\n‚Ü©\nI am still immensely annoyed about a YouTube video that tried to \ntell me Abadox was a ‚Äúcontroversial‚Äù NES game. Get out of here. Nobody \ntalked about that game. Show me a newspaper clipping or something.\n‚Ü©\nLet‚Äôs count functions with\nweights\narguments in some base R\npackages:\nget_funcs_with_weights <- function(pkg) {\n  ns <- asNamespace(pkg)\n  ls(ns) |> \n    lapply(get, envir = ns) |> \n    setNames(ls(ns)) |> \n    Filter(f = is.function) |> \n    lapply(formals) |> \n    Filter(f = function(x) \"weights\" %in% names(x)) |> \n    names()\n}\n\nget_funcs_with_weights(\"stats\")\n#>  [1] \"density.default\" \"glm\"             \"glm.fit\"         \"lm\"             \n#>  [5] \"loess\"           \"nls\"             \"ppr.default\"     \"ppr.formula\"    \n#>  [9] \"predict.lm\"      \"predLoess\"       \"simpleLoess\"\nget_funcs_with_weights(\"mgcv\")\n#>  [1] \"bam\"             \"bfgs\"            \"deriv.check\"     \"deriv.check5\"   \n#>  [5] \"efsud\"           \"efsudr\"          \"find.null.dev\"   \"gam\"            \n#>  [9] \"gam.fit3\"        \"gam.fit4\"        \"gam.fit5\"        \"gamm\"           \n#> [13] \"gammPQL\"         \"initial.spg\"     \"jagam\"           \"mgcv.find.theta\"\n#> [17] \"mgcv.get.scale\"  \"newton\"          \"scasm\"           \"score.transect\" \n#> [21] \"simplyFit\"\nget_funcs_with_weights(\"MASS\")\n#> [1] \"glm.nb\"      \"glmmPQL\"     \"polr\"        \"rlm.default\" \"rlm.formula\"\n#> [6] \"theta.md\"    \"theta.ml\"    \"theta.mm\"\nget_funcs_with_weights(\"nlme\")\n#>  [1] \"gls\"               \"gnls\"              \"lme\"              \n#>  [4] \"lme.formula\"       \"lme.groupedData\"   \"lme.lmList\"       \n#>  [7] \"nlme\"              \"nlme.formula\"      \"nlme.nlsList\"     \n#> [10] \"plot.simulate.lme\"\n‚Ü©\nRelated\nTo\nleave a comment\nfor the author, please follow the link and comment on their blog:\nHigher Order Functions\n.\nR-bloggers.com\noffers\ndaily e-mail updates\nabout\nR\nnews and tutorials about\nlearning R\nand many other topics.\nClick here if you're looking to post or find an R/data-science job\n.\nWant to share your content on R-bloggers?\nclick here\nif you have a blog, or\nhere\nif you don't.",
    "main_html": "<article class=\"post-396858 post type-post status-publish format-standard hentry category-r-bloggers\">\n<header class=\"post-header\">\n<h1 class=\"entry-title\">readtextgrid now uses C++ (and ChatGPT helped)</h1>\n<p class=\"meta post-meta\">Posted on <span class=\"updated\">November 14, 2025</span>  by <span class=\"vcard author\"><a class=\"fn\" href=\"https://www.r-bloggers.com/author/higher-order-functions/\">Higher Order Functions</a></span>  in <a href=\"https://www.r-bloggers.com/category/r-bloggers/\" rel=\"category tag\">R bloggers</a> | 0 Comments</p>\n</header>\n<div class=\"entry clearfix\">\n<!-- \r\n<div style=\"min-height: 30px;\">\r\n[social4i size=\"small\" align=\"align-left\"]\r\n</div>\r\n-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;\">\r\n[This article was first published on  <strong><a href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/\"> Higher Order Functions</a></strong>, and kindly contributed to <a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers</a>].  (You can report issue about the content on this page <a href=\"https://www.r-bloggers.com/contact-us/\">here</a>)\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div>\n\n<!-- Share buttons by mashshare.net - Version: 4.0.47--><p>In this post, I announce the release of version of 0.2.0 of the\n<a href=\"https://cran.r-project.org/package=readtextgrid\" rel=\"nofollow\" target=\"_blank\" title=\"readtextgrid on CRAN\">readtextgrid</a> R package, describe the problem that\nthe package solves, and share some thoughts on LLM-assisted programming.</p>\n<h2 id=\"textgrids-are-a-way-to-annotate-audio-data\">Textgrids are a way to annotate audio data</h2>\n<p><a href=\"https://www.fon.hum.uva.nl/praat/\" rel=\"nofollow\" target=\"_blank\">Praat</a> is a program for speech and \nacoustic analysis that has been around for over 30 years. It includes a \nscripting language for manipulating and analyzing data and for creating\nannotation workflows. Users can annotate intervals or points of time \nin a sound file using a <strong>textgrid</strong> object. Here is a screenshot of a\ntextgrid in Praat:</p>\n<figure class=\"\" style=\"max-width: 100%; display: block; margin: 2em auto;\"><img alt=\"Screenshot of a Praat editor window showing the amplitude wave form, spectrogram, and textgrid annotations. The audio file is of me saying *library tidyverse library brms*.\" data-lazy-src=\"https://i2.wp.com/tjmahr.github.io/assets/images/2025-11-library-tidyverse.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Screenshot of a Praat editor window showing the amplitude wave form, spectrogram, and textgrid annotations. The audio file is of me saying *library tidyverse library brms*.\" data-recalc-dims=\"1\" src=\"https://i2.wp.com/tjmahr.github.io/assets/images/2025-11-library-tidyverse.png?w=578&amp;ssl=1\"/></noscript><figcaption>\n      Screenshot of a Praat editor window.\n\n    </figcaption></figure>\n<p>There are three rows in the image, all three of them sharing the same\n<em>x</em> axis (time).</p>\n<ol>\n<li>Amplitude waveform, showing intensity over time</li>\n<li>Spectrogram, showing how the intensity (<em>color</em>) at frequencies (<em>y</em>) changes over\ntime. Red dots mark estimated formants (resonances) in the speech signal.</li>\n<li>Textgrid of text annotations for the recording</li>\n</ol>\n<p>A user can edit the textgrid by adding or adjusting boundaries and\nadding annotations, and Praat will save this data to a <code>.TextGrid</code> file.</p>\n<p>Other programs can produce <code>.TextGrid</code> files: the textgrid pictured here\nis the result of forced alignment, specifically by the <a href=\"https://montreal-forced-aligner.readthedocs.io/en/latest/\" rel=\"nofollow\" target=\"_blank\" title=\"Montreal Forced Aligner homepage\">Montreal Forced\nAligner</a>. I told the program I said ‚Äúlibrary tidy verse library\nb r m s‚Äù, and it looked up the pronunciations of those words and used an\nacoustic model to estimate the time intervals of each word and each\nspeech sound. The aligner produced a <code>.TextGrid</code> file for this alignment.</p>\n<p>These textgrids are the bread and butter of some of the research that we\ndo. For example, <a href=\"https://pubs.asha.org/doi/10.1044/2021_JSLHR-21-00206\" rel=\"nofollow\" target=\"_blank\" title=\"Speech Development Between 30 and 119 Months in Typical Children II: Articulation Rate Growth Curves\">our article</a> on speaking/articulation rate in children\ninvolved over 30,000 single-sentence <code>.wav</code> files and <code>.TextGrid</code> files. We\nused the alignments to determine the duration of time spent speaking, the\nnumber of vowels in each utterance and hence the speaking rate in\nsyllables per second.</p>\n<p>Reading these <code>.TextGrid</code> files into R was cumbersome, so I wrote and\nreleased <a href=\"https://cran.r-project.org/package=readtextgrid\" rel=\"nofollow\" target=\"_blank\" title=\"readtextgrid on CRAN\">readtextgrid</a>, an R package built around one \nsimple function:</p>\n<pre>library(tidyverse)\nlibrary(readtextgrid)\n\npath_tg &lt;- \"_R/data/mfa-out/library-tidyverse-library-brms.TextGrid\" \ndata_tg &lt;- read_textgrid(path_tg)\n\ndata_tg\n#&gt; # A tibble: 43 √ó 10\n#&gt;    file       tier_num tier_name tier_type tier_xmin tier_xmax  xmin  xmax text \n#&gt;    &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt;  1 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0     0.08 \"\"   \n#&gt;  2 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0.08  0.74 \"lib‚Ä¶\n#&gt;  3 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  0.74  1.12 \"tid‚Ä¶\n#&gt;  4 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.12  1.58 \"ver‚Ä¶\n#&gt;  5 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.58  1.74 \"\"   \n#&gt;  6 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  1.74  2.46 \"lib‚Ä¶\n#&gt;  7 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.46  2.72 \"b\"  \n#&gt;  8 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.72  2.9  \"r\"  \n#&gt;  9 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  2.9   3.04 \"m\"  \n#&gt; 10 library-t‚Ä¶        1 words     Interval‚Ä¶         0      3.60  3.04  3.46 \"s\"  \n#&gt; # ‚Ñπ 33 more rows\n#&gt; # ‚Ñπ 1 more variable: annotation_num &lt;int&gt;\n</pre>\n<p>The function returns a tidy tibble with one row per annotation. The filename is\nstored as a column too so that we can <code>lapply()</code> over a directory of files.\nAnnotations are numbered so that we can <code>group_by(text, annotation_num)</code> and \nhave repeated words handled separately.</p>\n<p>With this textgrid in R, I can measure speaking rate, for example:</p>\n<pre>data_tg |&gt; \n  filter(tier_name == \"phones\", text != \"\") |&gt; \n  summarise(\n    speaking_time = sum(xmax - xmin),\n    # vowels have numbers to indicate degree of stress\n    num_vowels = sum(str_detect(text, \"\\\\d\"))\n  ) |&gt; \n  mutate(\n    syllables_per_sec = num_vowels / speaking_time \n  )\n#&gt; # A tibble: 1 √ó 3\n#&gt;   speaking_time num_vowels syllables_per_sec\n#&gt;           &lt;dbl&gt;      &lt;int&gt;             &lt;dbl&gt;\n#&gt; 1          3.22         13              4.04\n</pre>\n<p>Or annotate a spectrogram:</p>\n<pre>library(tidyverse)\nlibrary(ggplot2)\npath_spectrogram &lt;- \"_R/data/mfa/library-tidyverse-library-brms.csv\"\ndata_spectrogram &lt;- readr::read_csv(path_spectrogram)\n#&gt; Rows: 249366 Columns: 6\n#&gt; ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#&gt; Delimiter: \",\"\n#&gt; dbl (6): y, x, power, time, frequency, db\n#&gt; \n#&gt; ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndata_spectrogram |&gt; \n  mutate(\n    # reserve more of the color variation for intensities above 15 dB\n    db = ifelse(db &lt; 15, 15, db)\n  ) |&gt; \n  ggplot() + \n  aes(x = time, y = frequency) +\n  geom_raster(aes(fill = db)) +\n  geom_text(\n    aes(label = text, x = (xmin + xmax) / 2),\n    data = data_tg |&gt; filter(tier_name == \"words\"),\n    y = 6500,\n    vjust = 0\n  )  +\n  geom_text(\n    aes(label = text, x = (xmin + xmax) / 2),\n    data = data_tg |&gt; filter(tier_name == \"phones\"),\n    y = 6100,\n    vjust = 0,\n    size = 2\n  )  +\n  ylim(c(NA, 6600)) +\n  theme_minimal() +\n  scale_fill_gradient(low = \"white\", high = \"black\") +\n  guides(fill = \"none\") +\n  labs(x = \"time [s]\", y = \"frequency [Hz]\")\n</pre>\n<div class=\"figure\" style=\"text-align: center\">\n<img alt=\"Spectrogram of me saying 'library tidyverse library brms'\" data-lazy-src=\"https://i1.wp.com/tjmahr.github.io/figs/2025-11-14-readtextgrid-cpp-llms/unnamed-chunk-4-1.png?w=80%25&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\"/><noscript><img alt=\"Spectrogram of me saying 'library tidyverse library brms'\" data-recalc-dims=\"1\" src=\"https://i1.wp.com/tjmahr.github.io/figs/2025-11-14-readtextgrid-cpp-llms/unnamed-chunk-4-1.png?w=80%25&amp;ssl=1\"/></noscript>\n<p class=\"caption\">Spectrogram of me saying ‚Äòlibrary tidyverse library brms‚Äô</p>\n</div>\n<p><img alt=\"Package hex logo\" class=\"align-right\" data-lazy-src=\"https://i0.wp.com/tjmahr.github.io/assets/images/2021-03-read-textgrid-logo.png?w=578&amp;ssl=1\" data-recalc-dims=\"1\" src=\"https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif\" style=\"max-width: 30%;\"/><noscript><img alt=\"Package hex logo\" class=\"align-right\" data-recalc-dims=\"1\" src=\"https://i0.wp.com/tjmahr.github.io/assets/images/2021-03-read-textgrid-logo.png?w=578&amp;ssl=1\" style=\"max-width: 30%;\"/></noscript></p>\n<p>I released the first version of the package in 2020. This package,\nnotably for me, contains the first hex badge I ever made.</p>\n<h2 id=\"my-original-textgrid-parser-and-its-problem\">My original <code>.TextGrid</code> parser and its problem</h2>\n<p>Here is what the contents of the <code>.TextGrid</code> file look like. It‚Äôs not the whole\nfile but enough to give a sense of the structure:</p>\n<pre>path_tg |&gt; \n  readLines() |&gt; \n  head(26) |&gt; \n  c(\"[... TRUNCATED ... ]\") |&gt; \n  writeLines()\n#&gt; File type = \"ooTextFile\"\n#&gt; Object class = \"TextGrid\"\n#&gt; \n#&gt; xmin = 0 \n#&gt; xmax = 3.596009 \n#&gt; tiers? &lt;exists&gt; \n#&gt; size = 2 \n#&gt; item []: \n#&gt;     item [1]:\n#&gt;         class = \"IntervalTier\" \n#&gt;         name = \"words\" \n#&gt;         xmin = 0 \n#&gt;         xmax = 3.596009 \n#&gt;         intervals: size = 11 \n#&gt;         intervals [1]:\n#&gt;             xmin = 0.0 \n#&gt;             xmax = 0.08 \n#&gt;             text = \"\" \n#&gt;         intervals [2]:\n#&gt;             xmin = 0.08 \n#&gt;             xmax = 0.74 \n#&gt;             text = \"library\" \n#&gt;         intervals [3]:\n#&gt;             xmin = 0.74 \n#&gt;             xmax = 1.12 \n#&gt;             text = \"tidy\" \n#&gt; [... TRUNCATED ... ]\n</pre>\n<p>The first 7 lines provide some metadata about the time range of the\naudio and the number of tiers (<code>size = 2</code>). The file then writes out each\ntier (<code>item [n]</code> lines) by first giving the <code>class</code>, <code>name</code>, time\nduration and number of marks or intervals. Each mark or interval is\nenumerated with time values <code>xmin</code>, <code>xmax</code> and <code>text</code> values.</p>\n<p>Because nearly everything here follows a <code>key = value</code> syntax and\nbecause sections are split from each other very neatly with <code>item [n]:</code>\nor <code>interval [n]:</code> lines, I was able to write <strong>a simple parser using\nregular expressions</strong>: Split the file into <code>item [n]</code> sections, split\nthose into <code>interval [n]</code> sections, and extract key-value pairs.</p>\n<p>This easy approach came with limitations. First, the <a href=\"https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html\" rel=\"nofollow\" target=\"_blank\" title=\"TextGrid file formats\">TextGrid\nspecification</a> was much more flexible. For example, Praat\nalso provides much less verbose ‚Äúshort‚Äù format textgrids which are like\na stream of time and text annotations:</p>\n<pre>path_tg_short &lt;- \"_R/data/mfa-out/library-tidyverse-library-brms-short.TextGrid\"\npath_tg_short |&gt; \n  readLines() |&gt; \n  head(26) |&gt; \n  c(\"[... TRUNCATED ... ]\") |&gt; \n  writeLines()\n#&gt; File type = \"ooTextFile\"\n#&gt; Object class = \"TextGrid\"\n#&gt; \n#&gt; 0\n#&gt; 3.596009\n#&gt; &lt;exists&gt;\n#&gt; 2\n#&gt; \"IntervalTier\"\n#&gt; \"words\"\n#&gt; 0\n#&gt; 3.596009\n#&gt; 11\n#&gt; 0\n#&gt; 0.08\n#&gt; \"\"\n#&gt; 0.08\n#&gt; 0.74\n#&gt; \"library\"\n#&gt; 0.74\n#&gt; 1.12\n#&gt; \"tidy\"\n#&gt; 1.12\n#&gt; 1.58\n#&gt; \"verse\"\n#&gt; 1.58\n#&gt; 1.74\n#&gt; [... TRUNCATED ... ]\n</pre>\n<p>Everything is in the same order, but the annotations are gone. It turns\nout that all of the helpful labels from before were actually <em>comments</em>\nthat get ignored. Everything that isn‚Äôt a number or a string in\ndouble-quotes (or a <code>&lt;flag&gt;</code>) is a comment.</p>\n<p>There are also other quirks (<code>\"</code> escapement, <code>!</code> comments, deviations\nbetween the Praat description of the format and the behavior of\n<code>praat.exe</code>). I have them documented as a kind of <a href=\"https://www.tjmahr.com/readtextgrid/articles/textgrid-specification.html\" rel=\"nofollow\" target=\"_blank\" title=\"Textgrid Specification article\">unofficial\nspecification</a> in an article on the package website.</p>\n<p>But my original regular-expression based parser could only handle the\nverbose long-format textgrids. I knew this. I put this in <a href=\"https://github.com/tjmahr/readtextgrid/issues/4\" rel=\"nofollow\" target=\"_blank\" title=\"ugh support textgrid grammar #4\">a GitHub issue\nin 2020</a>. And this compatibility oversight was never a\nproblem for me until I tried a new phonetics tool that defaulted to\nsaving the textgrids in the short format. Now, readtextgrid could not\nin fact ‚Äúread textgrid‚Äù.</p>\n<h2 id=\"the-new-r-based-tokenizer\">The new R-based tokenizer</h2>\n<p><a href=\"https://jofrhwld.github.io/\" rel=\"nofollow\" target=\"_blank\" title=\"Josef Fruehwald's homepage\">Josef Fruehwald</a>, a linguist with <a href=\"https://jofrhwld.github.io/software/\" rel=\"nofollow\" target=\"_blank\" title=\"Josef Fruehwald's software page\">lots of\nacoustics/phonetics software</a>, submitted a pull request to implement a\nproper parser that I eventually rewrote to handle various edge cases and\nundocumented behavior in the <code>.TextGrid</code> specification. I made an\n<a href=\"https://github.com/tjmahr/readtextgrid/blob/ed971e48ab3ea33e3efe0ba59f45ae3e41d07a32/tests/testthat/test-data/hard-to-parse.TextGrid\" rel=\"nofollow\" target=\"_blank\" title=\"hard-to-parse.TextGrid on GitHub\">adversarial <code>.TextGrid</code> file</a> üòà that could still be opened\nby <code>praat.exe</code> but was meant to be difficult to parse. This was a fun\ndevelopment loop: Make the file harder, update the parser to handle the\nnew feature, repeat.</p>\n<p>Because the essential data in the file are just string tokens and\nnumber tokens, I needed to make a <a href=\"https://en.wikipedia.org/wiki/Lexical_analysis\" rel=\"nofollow\" target=\"_blank\" title=\"Wikipedia page on Lexical Analysis\">tokenizer</a>: a piece\nof software that reads in characters, groups them into tokens, and\nfigures out what kind of data the token represents. The initial R-based\nversion of the tokenizer did the following:</p>\n<ul>\n<li>Read the file character by character</li>\n<li>Gather the characters for the current token and keep them when they\nform a valid string or number</li>\n<li>Shift between three states (<code>in_string</code>, <code>in_strong_comment</code> for <code>!\ncomments</code>, <code>in_escaped_quote</code>)</li>\n</ul>\n<p>These three states determine how we interpret spaces, newlines, and <code>\"</code>\ncharacters. For example, a newline ends a <code>! comment</code> but a newline can\nappear in a string so it doesn‚Äôt end a string. Moreover, in a comment,\n<code>\"</code> is ignored, but in a string, it might be the end of the string or an\nescaped quote (doubled double-quotes are used for <code>\"</code> characters: the\nstring <code>\"\"\"a\"\"\"</code> has the text <code>\"a\"</code>).</p>\n<p>But at a high level, the code was simple:</p>\n<pre>for (i in seq_along(all_char)) {\n\n  # { ... examine current character ... }\n  \n  # { ... handle comment state ... }\n  \n  # { ... collect token if we see whitespace and are not in a string  ... }\n  \n  # { ... handle string and escaped quote state ... }\n\n}\n</pre>\n<p>The new character-by-character parser worked üéâ. It had conquered\nthe adversarial example file, but there was still one more problem. It was\nslower than the original regular-expression parser!</p>\n<pre>tg_lines &lt;- readLines(path_tg)\n\nbench::mark(\n  legacy = readtextgrid:::legacy_read_textgrid_lines(tg_lines),\n  new_r = readtextgrid:::r_read_textgrid_lines(tg_lines)\n)\n#&gt; # A tibble: 2 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 legacy       75.1ms   76.1ms      13.1    6.81MB     19.7\n#&gt; 2 new_r        70.7ms   72.3ms      13.7  590.88KB     10.3\n</pre>\n<p>At this point, I asked ChatGPT for tips on speeding up the tokenizer.</p>\n<h2 id=\"some-thoughts-about-llms\">Some thoughts about LLMs</h2>\n<blockquote class=\"bluesky-embed\" data-bluesky-cid=\"bafyreihipumdkez3ifgsyt3eqbgelzuzljvllfwj4lbnfju55vvoxqc5gu\" data-bluesky-embed-color-mode=\"system\" data-bluesky-uri=\"at://did:plc:4t2ziwnnescprzorvmrfduey/app.bsky.feed.post/3ltdjbaktss2s\"><p lang=\"en\">the thing about (the current) chatgpt is that it writes like a fucking idiot with excellent grammar</p>‚Äî sarah jeong (<a href=\"https://bsky.app/profile/did:plc:4t2ziwnnescprzorvmrfduey?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">@sarahjeong.bsky.social</a>) <a href=\"https://bsky.app/profile/did:plc:4t2ziwnnescprzorvmrfduey/post/3ltdjbaktss2s?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">July 6, 2025 at 7:20 PM</a></blockquote>\n<p>Now, let‚Äôs talk about large language models (LLMs). There‚Äôs a lot I\ncould say about them.<sup id=\"fnref:fn-etc\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-etc\" rel=\"nofollow\" target=\"_blank\">1</a></sup> As a language scientist, I‚Äôll start here: They\nknow <em>syntax</em>. They know which words go together and can generate very\nplausible sequences of words. They do not know <em>semantics</em> however. They\ndon‚Äôt have any firsthand knowledge or experience about what those\nsequences express. They can‚Äôt introspect about that knowledge or\nexperience to see whether things ‚Äúmake sense‚Äù.<sup id=\"fnref:fn-reasoning\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-reasoning\" rel=\"nofollow\" target=\"_blank\">2</a></sup> They\n<a href=\"https://www.andrewheiss.com/ai/#text\" rel=\"nofollow\" target=\"_blank\" title=\"Andrew Heiss's AI position statement\">don‚Äôt care</a> about the truth or falsity of statements.\nThey just make plausible sequences of words.</p>\n<p>Now, it turns out that if you learn how to make sequences of words from an\nInternet-sized corpus of text, then a lot of the plausible sequences you make\nwill turn out to be true. If you read 10,000 cookbooks, you could probably\nprovide a very classic recipe for scrambled eggs. But because you don‚Äôt know\nabout sarcasm or can‚Äôt draw on your own experience of trying to not ingest\nnon-food chemicals, you might suggest putting <a href=\"https://www.bbc.com/news/articles/cd11gzejgz4o\" rel=\"nofollow\" target=\"_blank\" title=\"Glue pizza and eat rocks: Google AI search errors go viral\">glue on a pizza</a>.</p>\n<p>So, as we use an LLM, we need to ask ourselves how much we care about\nthe truth or care about knowing or understanding things. That may sound\nlike a glib or weird statement: Shouldn‚Äôt we always care about the\ntruth? Well, sometimes we don‚Äôt. We just want some syntax; we want\n<a href=\"https://usethis.r-lib.org/\" rel=\"nofollow\" target=\"_blank\" title=\"usethis R package\">boilerplate or templates</a> to fill out.<sup id=\"fnref:fn-tradition\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-tradition\" rel=\"nofollow\" target=\"_blank\">3</a></sup>\nFor example, I can ask an LLM to ‚Äúwrite some unit tests for a function\n<code>round_to(xs, unit)</code> that rounds a vector of values to an arbitrary\nunit‚Äù and receive:</p>\n<pre>test_that(\"round_to() rounds to nearest multiple of unit\", {\n  expect_equal(round_to(5, 2), 6)\n  expect_equal(round_to(4.9, 2), 4)\n  expect_equal(round_to(5.1, 2), 6)\n  expect_equal(round_to(c(1, 2, 3, 4), 2), c(2, 2, 4, 4))\n})\n</pre>\n<p>These tests are not useful <em>until</em> I plug in the correct values for the expected \noutput.</p>\n<p>In other cases, we don‚Äôt quite care about truth or comprehension because we can\nget external corroboration.<sup id=\"fnref:fn-wood\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-wood\" rel=\"nofollow\" target=\"_blank\">4</a></sup> When I ask ChatGPT for an obfuscated R script to\nmake Pac-Man in ggplot2, I can run the code to see if it works without trying to\ndecipher its syntax:</p>\n<pre>library(ggplot2)\nggplot()+\ngeom_polygon(aes(x,y),\ndata=within(data.frame(t(sapply(seq(a&lt;-pi/9,2*pi-a,l&lt;-4e2),\nfunction(t)c(cos(t),sin(t))))),\n{rbind(.,0,0,cos(a),sin(a))-&gt;df;x=df[,1];y=df[,2]}),\nfill=\"#FF0\",col=1)+\nannotate(\"point\",x=.35,y=.5,size=3)+\nannotate(\"point\",x=c(1.4,2,2.6),y=0,size=3)+\ncoord_equal(xlim=c(-1.2,3),ylim=c(-1.2,1.2))+\ntheme_void()\n#&gt; Error in eval(substitute(expr), e): object '.' not found\n</pre>\n<p>(Strangely, this is the case where a dot \n<a href=\"https://www.youtube.com/watch?v=NxSj2T2vx7M\" rel=\"nofollow\" target=\"_blank\">kills</a> Pac-Man.)</p>\n<h3 id=\"vibes-are-semantic-vapor\">Vibes are semantic vapor</h3>\n<p>When we abandon caring about truth or understanding things and just rely\non external corroboration, we are in the realm of <a href=\"https://en.wikipedia.org/wiki/Vibe_coding\" rel=\"nofollow\" target=\"_blank\">vibe\ncoding</a>. I like this term\nbecause of its insouciant honesty: <em>Truth? Comprehension? We‚Äôre just\ngoing off the vibes.</em> It would be a great help if we used the word more\nliberally. A YouTube video called ‚ÄúA vibe history of NES videogames‚Äù? No\nthanks.<sup id=\"fnref:fn-abadox\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-abadox\" rel=\"nofollow\" target=\"_blank\">5</a></sup></p>\n<p>If we lean into vibes, we need to get better at external corroboration\nand know our programming languages even better. R is a flexible\nprogramming language and it does some things that ‚Äúhelp‚Äù the user that\ncan lead to silent bugs. Famously, function arguments and <code>$</code> will match\npartial names.</p>\n<pre># Look at the \"Call:\" in the output\nlm(f = hp ~ cyl, d = mtcars)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = hp ~ cyl, data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)          cyl  \n#&gt;      -51.05        31.96\n\n# There is no `m` column\nall(mtcars$m == mtcars$mpg)\n#&gt; [1] TRUE\n</pre>\n<p>A student I work with was trying to compute sensitivity and specificity on \nweighted data. The LLM suggested the following:</p>\n<pre># Make some weighted data using frequencies\ndata &lt;- pROC::aSAH |&gt; \n  count(outcome, age, name = \"weight\")\n\n# What the LLM did:\npROC::roc(data, \"outcome\", \"age\", weights = data$weight)\n#&gt; Setting levels: control = Good, case = Poor\n#&gt; Setting direction: controls &lt; cases\n#&gt; \n#&gt; Call:\n#&gt; roc.data.frame(data = data, response = \"outcome\", predictor = \"age\",     weights = data$weight)\n#&gt; \n#&gt; Data: age in 44 controls (outcome Good) &lt; 30 cases (outcome Poor).\n#&gt; Area under the curve: 0.5947\n</pre>\n<p>This code runs without any problems. It‚Äôs wrong, but it runs. The problem \nis that <a href=\"https://rdrr.io/pkg/pROC/man/roc.html\" rel=\"nofollow\" target=\"_blank\" title=\"Documentation for pROC::roc()\"><code>pROC::roc(...)</code></a> supports variadic arguments (<code>...</code>):</p>\n<pre># Note the dots\npROC:::roc |&gt; formals() |&gt; str()\n#&gt; Dotted pair list of 1\n#&gt;  $ ...: symbol\npROC:::roc.data.frame |&gt; formals() |&gt; str()\n#&gt; Dotted pair list of 5\n#&gt;  $ data     : symbol \n#&gt;  $ response : symbol \n#&gt;  $ predictor: symbol \n#&gt;  $ ret      : language c(\"roc\", \"coords\", \"all_coords\")\n#&gt;  $ ...      : symbol\n</pre>\n<p>Those <code>...</code> are for forwarding arguments to other functions that <code>roc()</code> \nmight call internally. Unfortunately,\nfunctions by default don‚Äôt check the contents of the <code>...</code> to see if they\nhave unsupported arguments. Thus, bad arguments are ignored silently:</p>\n<pre># method and weights are not real arguments\npROC::roc(data, \"outcome\", \"age\", method = fake, weights = fake)\n#&gt; Setting levels: control = Good, case = Poor\n#&gt; Setting direction: controls &lt; cases\n#&gt; \n#&gt; Call:\n#&gt; roc.data.frame(data = data, response = \"outcome\", predictor = \"age\",     method = fake, weights = fake)\n#&gt; \n#&gt; Data: age in 44 controls (outcome Good) &lt; 30 cases (outcome Poor).\n#&gt; Area under the curve: 0.5947\n</pre>\n<p>The LLM hallucinated a <code>weights</code> argument, which is a plausible\nargument,<sup id=\"fnref:fn_weights\" role=\"doc-noteref\"><a class=\"footnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn_weights\" rel=\"nofollow\" target=\"_blank\">6</a></sup> and the <code>...</code> syntax behavior swallowed it up like\nPac-Man. It always comes back to Pac-Man. I ended up writing <a href=\"https://www.tjmahr.com/wisclabmisc/reference/compute_sens_spec_from_ecdf.html\" rel=\"nofollow\" target=\"_blank\">a\nfunction</a>\nthat could compute sens and spec on weighted data.</p>\n<blockquote class=\"bluesky-embed\" data-bluesky-cid=\"bafyreidioowqsfnvvsvesncnb5s6ukkyhxqadinceqnax6ogjt2cj3635i\" data-bluesky-embed-color-mode=\"system\" data-bluesky-uri=\"at://did:plc:5wm25vgenhgut3iqfjf4ozj5/app.bsky.feed.post/3m5kfxmdkx22a\"><p lang=\"en\">Unfortunately the space of LLM code errors and the space of human errors are not the same, making hard-won code review instincts misfire</p>‚Äî Eugene Vinitsky üçí (<a href=\"https://bsky.app/profile/did:plc:5wm25vgenhgut3iqfjf4ozj5?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">@eugenevinitsky.bsky.social</a>) <a href=\"https://bsky.app/profile/did:plc:5wm25vgenhgut3iqfjf4ozj5/post/3m5kfxmdkx22a?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">November 13, 2025 at 6:21 PM</a></blockquote>\n<p>As users, we can guard against the first two silent problems with\n<code>options(warnPartialMatchArgs, warnPartialMatchDollar)</code>, and as\ndevelopers, we can prevent the second problem with\n<a href=\"https://rlang.r-lib.org/reference/check_dots_used.html\" rel=\"nofollow\" target=\"_blank\" title=\"Documentation for check_dots_used()\"><code>rlang::check_dots_used()</code></a> and friends. But like I said\nat the outset, external corroboration requires us to know <em>even more</em>\nabout the language in order to vibe safely.</p>\n<h3 id=\"syntax-and-semantics-again\">Syntax and semantics, again</h3>\n<p>In this mini-position statement on LLM assistance, the two principles I\nam trying to develop are:</p>\n<ul>\n<li>LLMs know text distributions very well. Use them to generate starter syntax.</li>\n<li>LLMs don‚Äôt understand anything. It‚Äôs all bullshit and vibes.</li>\n</ul>\n<p>If we think of LLMs as syntax generators, we can imagine\nsome pretty good use cases:</p>\n<ul>\n<li>Write unit tests for a function that does‚Ä¶</li>\n<li>Set up Roxygen docs for this function</li>\n<li>Create a function to simulate data for a model of <code>rt ~ group + (1 | id)</code></li>\n<li>Write a Stan program to fit this model. (<a href=\"https://chatgpt.com/share/691763d2-87a4-8005-9342-bee0d0222348\" rel=\"nofollow\" target=\"_blank\">Mind your priors.</a>)</li>\n<li><em>Spoiler alert</em>: Convert this R loop into C++ code</li>\n</ul>\n<p>Still, we need to be mindful of the semantic limitations and skeptical\nof the output. We should audit the results and make sure we comprehend\nthem, or admit upfront that this code is running on vibes. In either case, \nwe also need to be vigilant about bugs that could happen silently or bugs\nthat a machine might make but a human wouldn‚Äôt (hallucinations).</p>\n<p>One thing I worry about with LLM reliance is skill atrophy. If I keep\nusing this bot as a crutch, then some of my skills will get weaker. Sam Mehr\nhas a take I quite like that puts this concern upfront. LLMs are\nfine for code we don‚Äôt feel bothered to learn:</p>\n<blockquote class=\"bluesky-embed\" data-bluesky-cid=\"bafyreigsxov4rjblnirmd7samors5k6ygw63lfrenx35g5iwczrs6eawxi\" data-bluesky-embed-color-mode=\"system\" data-bluesky-uri=\"at://did:plc:v6qwaqo24zfrq5fj7ceibxqk/app.bsky.feed.post/3lp42tel3lk2e\"><p lang=\"en\">re AI, a PhD student mentioned sheepishly that they used chatgpt for advice on coding up an unusual element in javascript. Almost apologized\n<br/><br/>\nI'm like no no no you're a psych PhD, not CS, this is exactly what LLMs are for! Doing a so-so job at things you just need done &amp; don't care about learning!</p>‚Äî samuel mehr (<a href=\"https://bsky.app/profile/did:plc:v6qwaqo24zfrq5fj7ceibxqk?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">@mehr.nz</a>) <a href=\"https://bsky.app/profile/did:plc:v6qwaqo24zfrq5fj7ceibxqk/post/3lp42tel3lk2e?ref_src=embed\" rel=\"nofollow\" target=\"_blank\">May 13, 2025 at 10:32 PM</a></blockquote>\n<p>I quite like programming and want to learn. I like to read the release\nnotes, dig into the documentation and\n<a href=\"https://bsky.app/profile/tjmahr.com/post/3m5hjc3ct6s26\" rel=\"nofollow\" target=\"_blank\">experiment</a>\nwith new modeling features. At the same time, sometimes I just want a\nbash script to unzip all <code>.zip</code> files in a directory. Time was, we would\nfind something from Stack Overflow to adapt for that problem. Now, we\nask ChatGPT for the code, look it over quick, test it and move on. That\nseems fine. A metacognitive awareness about what is worth \nlearning and what problems are worth solving in a slower methodical way \nis very useful for an LLM user.</p>\n<p>Finally, to be clear‚ÄîI can‚Äôt believe I need to make this\ndisclaimer‚Äîwe should always care about truth and accuracy when we\nwrite prose and publish it and put our name on it. Vibes are not\nscientific or scholarly. When I see emails or code documentation with\nimmaculate formatting and perfect language, my bullshit sensor goes off\nand I worry that I need to read extra carefully because a smooth-talking\nrobot is trying to pull a fast one on me. I don‚Äôt use LLMs for writing\nexcept for proofreading or requests for nitpicking. I have an\ninstruction in ChatGPT that says not to revise anything I write unless\nit sneaks Magic: The Gathering card names into the output. (Alas, it\ngenerally ignores that <em>diabolic edict</em> of mine.)</p>\n<h2 id=\"ai-assistance-in-readtextgrid\">AI assistance in readtextgrid</h2>\n<p>Because the old parser was outperforming the newer, more robust parser, I\nasked ChatGPT for ways to make my textgrid parsing faster. For example,\none version of the loop collected characters in a vector and then\n<code>paste0()</code>-ed them together. ChatGPT suggested that because we are\niterating over character indices we instead use \n<code>substring()</code> to extract tokens from the text. That worked, and it ran\nfaster, until it failed a unit test on a character wearing a diacritic. \nAfter a few rounds of trying to improve the loop, I asked quite\nbluntly: ‚ÄúHow can we move the tokenize loop into Rcpp or cpp11 with the\nviewest [<em>sic</em>] headaches possible‚Äù.</p>\n<p>And it provided some very legible cpp11 code. I had never used C++ with\nR before. To get started, I had to call on\n<a href=\"https://usethis.r-lib.org/reference/use_cpp11.html\" rel=\"nofollow\" target=\"_blank\"><code>usethis::use_cpp11()</code></a>\nto make the necessary boilerplate‚Äîyou just need syntax sometimes‚Äîand\nI had to troubleshoot the first couple versions of the function because\nof errors. The <a href=\"https://cpp11.r-lib.org/articles/cpp11.html\" rel=\"nofollow\" target=\"_blank\">cpp11\ndocumentation</a> is small in\na good way. It has examples of converting R code into C++ equivalents,\nwhich is precisely the activity that I was up to.</p>\n<p>What I liked about the ChatGPT output is how clear the translation was.\nIn the R version, part of the character processing loop is to peek ahead\nto the next character to see whether <code>\"</code> is an escaped quote <code>\"\"</code> or the\nend of a string:</p>\n<pre># ... in the character processing loop\n\n    # Start or close string mode if we see \"\n    if (c_starts_string) {\n      # Check for \"\" escapes\n      peek_c &lt;- all_char[i + 1]\n      if (peek_c == \"\\\"\" &amp; in_string) {\n        in_escaped_quote &lt;- TRUE\n      } else {\n        in_string &lt;- !in_string\n      }\n    }\n\n# ...\n</pre>\n<p>And here is the C++ version of the peek ahead code:</p>\n<pre>// ... helper functions ...\n\n  // Is this a UTF-8 continuation byte? (10xxxxxx)\n  auto is_cont = [](unsigned char b)-&gt;bool {\n    // Are the first two bits 10?\n    return (b &amp; 0xC0) == 0x80;\n  };\n\n// ... in the character processing loop ...\n\n    if (b == 0x22) { // '\"'\n      // peek ahead to see if we have a double \"\" escapement\n      size_t j = i + 1;\n      // We need the next character, not just the next byte, so we skip\n      // continuation characters.\n      while (j &lt; nbytes &amp;&amp; is_cont(static_cast&lt;unsigned char&gt;(src[j]))) ++j;\n      // Use `0x00` dummy character if we are at the end of the string\n      unsigned char nextb = (j &lt; nbytes) ? static_cast&lt;unsigned char&gt;(src[j]) : 0x00;\n\n      if (in_string &amp;&amp; nextb == 0x22) {\n        esc_next = true;    // consume next '\"' once\n      } else {\n        in_string = !in_string;\n      }\n    }\n\n// ...\n</pre>\n<p>There is a logical correspondence between the lines that I wrote myself\nin R and the lines that the LLM provided for C++. The C++ version works\nat the level of bytes instead of characters, and that matters:</p>\n<pre>\"√©\" |&gt; nchar(type = \"chars\")\n#&gt; [1] 1\n\"√©\" |&gt; nchar(type = \"bytes\")\n#&gt; [1] 2\n</pre>\n<p>But the C++ code makes sense to me. It looks <em>plausible</em>, right? Still,\nplausible isn‚Äôt enough. I asked the LLM a lot of follow-up questions:\nwhat does <code>auto</code> do, what is <code>size_t</code> doing, and so on. And I annotated\nthe C++ code with comments for my own understanding.</p>\n<p>During my auditing, I went down a particular rabbithole to make sure I\nunderstood how Unicode bytes get packed into UTF-8 sequences. I learned\nhow the character <code>√©</code> for example has the codepoint (character number)\n<code>U+00E9</code> in Unicode, so it falls in the range of codepoints that need to\nbe split into two bytes. The <a href=\"https://www.unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G27288\" rel=\"nofollow\" target=\"_blank\" title=\"Table 3-6. UTF-8 Bit Distribution\">scheme for two-byte\nencoding</a> is</p>\n<pre>character number               -&gt;               character encoding\ncodepoint -&gt; 00000yyy yyxxxxxx -&gt; 110yyyyy 10xxxxxx -&gt; UTF-8 bytes\n00E9      -&gt; 00000000 11101001 -&gt; 11000011 10101001 -&gt; c3 a9\n</pre>\n<p>Which we can check by hand:</p>\n<pre>bitchar_to_raw &lt;- function(xs) {\n  xs |&gt; \n    strsplit(\"\") |&gt; \n    lapply(function(x) as.integer(x) |&gt; rev() |&gt; packBits()) |&gt; \n    unlist()\n}\n\nbitchar_to_raw(c(\"11000011\", \"10101001\"))\n#&gt; [1] c3 a9\ncharToRaw(\"√©\")\n#&gt; [1] c3 a9\n</pre>\n<p>In the UTF-8 scheme, bytes that start with <code>10</code> are only the second,\nthird and fourth bytes in a character‚Äôs encoding‚Äîthat is, only the\n<em>continuation</em> bytes. Now, at this point, we can comprehend <em>why</em> the C++\nis checking for continuation characters and why the check for\ncontinuation characters involves checking the first two bits.</p>\n<p>Another rabbithole involved how to parse numbers. At first, the LLM\nsuggested I use one of R‚Äôs own C functions to handle it. That idea \nseems really powerful to me‚Äîwait, now I can tap into what R‚Äôs own \nroutines?!‚Äîbut R‚Äôs parser was a bit stricter than what I needed to\nmatch <code>praat.exe</code>.</p>\n<p>This new C++ based tokenizer yielded a <strong>huge performance gain</strong>:</p>\n<pre>bench::mark(\n  legacy = readtextgrid:::legacy_read_textgrid_lines(tg_lines),\n  new_r = readtextgrid:::r_read_textgrid_lines(tg_lines),\n  new_cpp = readtextgrid::read_textgrid_lines(tg_lines)\n)\n#&gt; # A tibble: 3 √ó 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 legacy      65.22ms  68.77ms      13.8    6.49MB     4.59\n#&gt; 2 new_r       72.67ms   88.5ms      11.5  363.33KB     5.74\n#&gt; 3 new_cpp      3.12ms   3.64ms     272.    96.77KB     4.11\n</pre>\n<p>That‚Äôs an improvement of 10‚Äì15x! Now, I find myself wondering: What else\ncould use a cpp11 speed boost?</p>\n<p>One downside of adopting cpp11 is that the package needs to compile\ncode. As a result, I can‚Äôt just tell people to try the developer version\nof the package with\n<a href=\"https://remotes.r-lib.org/reference/install_github.html\" rel=\"nofollow\" target=\"_blank\"><code>remotes::install_github()</code></a>.\nCRAN compiles packages so end users don‚Äôt face this issue when\ninstalling the official released version of packages.</p>\n<p>One workaround I adopted was relying on <a href=\"https://ropensci.org/r-universe/\" rel=\"nofollow\" target=\"_blank\">R\nUniverse</a> which will provide compiled\nversions of packages hosted on GitHub. Then we change the installation\ninstructions to:</p>\n<pre>install.packages(\n  \"readtextgrid\", \n  repos = c(\"https://tjmahr.r-universe.dev\", \"https://cloud.r-project.org\")\n)\n</pre>\n<p>You might have seen this pattern elsewhere.\n<a href=\"https://mc-stan.org/cmdstanr/\" rel=\"nofollow\" target=\"_blank\">cmdstanr</a> skips CRAN entirely and only\nuses R Universe.</p>\n<h2 id=\"parting-thoughts\">Parting thoughts</h2>\n<p>An LLM helped me translate pokey R code into fast C++ code. The code is\n<em>live now</em> on <a href=\"https://cran.r-project.org/package=readtextgrid\" rel=\"nofollow\" target=\"_blank\" title=\"readtextgrid on CRAN\">CRAN</a>, released in readtextgrid 0.2.0. I‚Äôm\nmaybe kind of a C++ developer now? (Nah.)</p>\n<p>This kind of code translation strikes me as an easy win for R developers: \n‚ÄúI have my version that works right now, but I think it can\ngo faster. Help me convert this to C++.‚Äù I took care to make sure I\nunderstood the output. The syntax came easy, but the semantics\n(comprehension and validation) took more time.</p>\n<p>If I ask myself, <em>could I have done this translation to C++ without an\nLLM?</em> The answer is no, not in a reasonable timeframe, certainly not as\nfast as the two days it took me in this case. That‚Äôs a pretty undeniable\nboost.</p>\n<div class=\"footnotes\" role=\"doc-endnotes\">\n<ol>\n<li id=\"fn:fn-etc\" role=\"doc-endnote\">\n<p>Things I won‚Äôt talk about: Plagiarism, safety, energy use, hype,\nundercooked AI features making things slower and dumber, stupid people \nemboldened by how trivial AI makes everything seem‚Äî<em>we won‚Äôt need \nprogrammers or doctors or historians or whatever</em> is what someone with no\nexpertise in programming, medicine, history, etc. would say‚Äîdumdums \ntearing down <a href=\"https://theknowledge.io/chestertons-fence-explained/\" rel=\"nofollow\" target=\"_blank\">fences</a>,\n<a href=\"https://www.notebookcheck.net/Hideo-Kojima-says-AI-is-a-friend-not-a-threat-to-creativity-in-game-development.1141848.0.html\" rel=\"nofollow\" target=\"_blank\">creativity versus productivity</a>, aesthetic homogenization or \nhow I keep seeing the same comic style in YouTube thumbnails, nobody asked \nfor slop, oh they did ask for slop, etc.¬†<a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-etc\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</li>\n<li id=\"fn:fn-reasoning\" role=\"doc-endnote\">\n<p>There is something introspective about \n<a href=\"https://magazine.sebastianraschka.com/p/understanding-reasoning-llms\" rel=\"nofollow\" target=\"_blank\" title=\"Understanding Reasoning LLMs\">reasoning models</a> which will break a prompt into steps and \nwork through them. But still, I‚Äôm thinking about what the ground truth is in \nthis reasoning. The statistical regularities of word patterns?¬†<a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-reasoning\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</li>\n<li id=\"fn:fn-tradition\" role=\"doc-endnote\">\n<p>I think there is a great ‚Äútradition‚Äù‚Äînot sure of the right \nword here‚Äîin learning programming and other tools where we start from a\nstarter template or maybe small sample project and we experimentally\ntweak the code and iterate until it turns into the thing we want. It‚Äôs\nlike <a href=\"https://en.wikipedia.org/wiki/Lev_Vygotsky#Scaffolding\" rel=\"nofollow\" target=\"_blank\">scaffolding</a>\nbut at a less metaphorical level: Code that sets a foundation for \nself-directed learning.¬†<a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-tradition\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</li>\n<li id=\"fn:fn-wood\" role=\"doc-endnote\">\n<p>I asked ChatGPT for help making a shopping list for a small woodworking\nproject, and it offered a cutting plan for the lumber. <em>Sure, why not?</em> It\nmessed up the math with a plan that involved cutting off 74 inches of\nwood from a 6-foot piece of lumber. My external corroboration in this case \nwas a scrap of wood.¬†<a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-wood\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</li>\n<li id=\"fn:fn-abadox\" role=\"doc-endnote\">\n<p>I am still immensely annoyed about a YouTube video that tried to \ntell me Abadox was a ‚Äúcontroversial‚Äù NES game. Get out of here. Nobody \ntalked about that game. Show me a newspaper clipping or something.¬†<a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-abadox\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</li>\n<li id=\"fn:fn_weights\" role=\"doc-endnote\">\n<p>Let‚Äôs count functions with <code>weights</code> arguments in some base R\npackages:</p>\n<pre>get_funcs_with_weights &lt;- function(pkg) {\n  ns &lt;- asNamespace(pkg)\n  ls(ns) |&gt; \n    lapply(get, envir = ns) |&gt; \n    setNames(ls(ns)) |&gt; \n    Filter(f = is.function) |&gt; \n    lapply(formals) |&gt; \n    Filter(f = function(x) \"weights\" %in% names(x)) |&gt; \n    names()\n}\n\nget_funcs_with_weights(\"stats\")\n#&gt;  [1] \"density.default\" \"glm\"             \"glm.fit\"         \"lm\"             \n#&gt;  [5] \"loess\"           \"nls\"             \"ppr.default\"     \"ppr.formula\"    \n#&gt;  [9] \"predict.lm\"      \"predLoess\"       \"simpleLoess\"\nget_funcs_with_weights(\"mgcv\")\n#&gt;  [1] \"bam\"             \"bfgs\"            \"deriv.check\"     \"deriv.check5\"   \n#&gt;  [5] \"efsud\"           \"efsudr\"          \"find.null.dev\"   \"gam\"            \n#&gt;  [9] \"gam.fit3\"        \"gam.fit4\"        \"gam.fit5\"        \"gamm\"           \n#&gt; [13] \"gammPQL\"         \"initial.spg\"     \"jagam\"           \"mgcv.find.theta\"\n#&gt; [17] \"mgcv.get.scale\"  \"newton\"          \"scasm\"           \"score.transect\" \n#&gt; [21] \"simplyFit\"\nget_funcs_with_weights(\"MASS\")\n#&gt; [1] \"glm.nb\"      \"glmmPQL\"     \"polr\"        \"rlm.default\" \"rlm.formula\"\n#&gt; [6] \"theta.md\"    \"theta.ml\"    \"theta.mm\"\nget_funcs_with_weights(\"nlme\")\n#&gt;  [1] \"gls\"               \"gnls\"              \"lme\"              \n#&gt;  [4] \"lme.formula\"       \"lme.groupedData\"   \"lme.lmList\"       \n#&gt;  [7] \"nlme\"              \"nlme.formula\"      \"nlme.nlsList\"     \n#&gt; [10] \"plot.simulate.lme\"\n</pre> </li></ol></div>\n<p><a class=\"reversefootnote\" href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn_weights\" rel=\"nofollow\" role=\"doc-backlink\" target=\"_blank\">‚Ü©</a></p>\n</div>\n<div class=\"jp-relatedposts\" id=\"jp-relatedposts\">\n<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div>\n<!-- Share buttons by mashshare.net - Version: 4.0.47-->\n<div style=\"border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;\">\n<div style=\"text-align: center;\">To <strong>leave a comment</strong> for the author, please follow the link and comment on their blog: <strong><a href=\"https://tjmahr.github.io/readtextgrid-cpp-llms/\"> Higher Order Functions</a></strong>.</div>\n<hr/>\n<a href=\"https://www.r-bloggers.com/\" rel=\"nofollow\">R-bloggers.com</a> offers <strong><a href=\"https://feedburner.google.com/fb/a/mailverify?uri=RBloggers\" rel=\"nofollow\">daily e-mail updates</a></strong> about <a href=\"https://www.r-project.org/\" rel=\"nofollow\" title=\"The R Project for Statistical Computing\">R</a> news and tutorials about <a href=\"https://www.r-bloggers.com/how-to-learn-r-2/\" rel=\"nofollow\" title=\"R tutorials\">learning R</a> and many other topics. <a href=\"https://www.r-users.com/\" rel=\"nofollow\" title=\"Data science jobs\">Click here if you're looking to post or find an R/data-science job</a>.\r\n\r\n<hr/>Want to share your content on R-bloggers?<a href=\"https://www.r-bloggers.com/add-your-blog/\" rel=\"nofollow\"> click here</a> if you have a blog, or <a href=\"http://r-posts.com/\" rel=\"nofollow\"> here</a> if you don't.\r\n</div> </article>",
    "word_count": 4842,
    "reading_time_min": 24.2,
    "internal_links": [
      {
        "href": "https://www.r-bloggers.com/author/higher-order-functions/",
        "text": "Higher Order Functions"
      },
      {
        "href": "https://www.r-bloggers.com/category/r-bloggers/",
        "text": "R bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers"
      },
      {
        "href": "https://www.r-bloggers.com/contact-us/",
        "text": "here"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      },
      {
        "href": "https://www.r-bloggers.com/",
        "text": "R-bloggers.com"
      },
      {
        "href": "https://www.r-bloggers.com/how-to-learn-r-2/",
        "text": "learning R"
      },
      {
        "href": "https://www.r-bloggers.com/add-your-blog/",
        "text": "click here"
      }
    ],
    "external_links": [
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/",
        "text": "Higher Order Functions"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      },
      {
        "href": "https://cran.r-project.org/package=readtextgrid",
        "text": "readtextgrid"
      },
      {
        "href": "https://www.fon.hum.uva.nl/praat/",
        "text": "Praat"
      },
      {
        "href": "https://montreal-forced-aligner.readthedocs.io/en/latest/",
        "text": "Montreal Forced\nAligner"
      },
      {
        "href": "https://pubs.asha.org/doi/10.1044/2021_JSLHR-21-00206",
        "text": "our article"
      },
      {
        "href": "https://cran.r-project.org/package=readtextgrid",
        "text": "readtextgrid"
      },
      {
        "href": "https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html",
        "text": "TextGrid\nspecification"
      },
      {
        "href": "https://www.tjmahr.com/readtextgrid/articles/textgrid-specification.html",
        "text": "unofficial\nspecification"
      },
      {
        "href": "https://github.com/tjmahr/readtextgrid/issues/4",
        "text": "a GitHub issue\nin 2020"
      },
      {
        "href": "https://jofrhwld.github.io/",
        "text": "Josef Fruehwald"
      },
      {
        "href": "https://jofrhwld.github.io/software/",
        "text": "lots of\nacoustics/phonetics software"
      },
      {
        "href": "https://github.com/tjmahr/readtextgrid/blob/ed971e48ab3ea33e3efe0ba59f45ae3e41d07a32/tests/testthat/test-data/hard-to-parse.TextGrid",
        "text": "adversarial.TextGridfile"
      },
      {
        "href": "https://en.wikipedia.org/wiki/Lexical_analysis",
        "text": "tokenizer"
      },
      {
        "href": "https://bsky.app/profile/did:plc:4t2ziwnnescprzorvmrfduey?ref_src=embed",
        "text": "@sarahjeong.bsky.social"
      },
      {
        "href": "https://bsky.app/profile/did:plc:4t2ziwnnescprzorvmrfduey/post/3ltdjbaktss2s?ref_src=embed",
        "text": "July 6, 2025 at 7:20 PM"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-etc",
        "text": "1"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-reasoning",
        "text": "2"
      },
      {
        "href": "https://www.andrewheiss.com/ai/#text",
        "text": "don‚Äôt care"
      },
      {
        "href": "https://www.bbc.com/news/articles/cd11gzejgz4o",
        "text": "glue on a pizza"
      },
      {
        "href": "https://usethis.r-lib.org/",
        "text": "boilerplate or templates"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-tradition",
        "text": "3"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-wood",
        "text": "4"
      },
      {
        "href": "https://www.youtube.com/watch?v=NxSj2T2vx7M",
        "text": "kills"
      },
      {
        "href": "https://en.wikipedia.org/wiki/Vibe_coding",
        "text": "vibe\ncoding"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn-abadox",
        "text": "5"
      },
      {
        "href": "https://rdrr.io/pkg/pROC/man/roc.html",
        "text": "pROC::roc(...)"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fn:fn_weights",
        "text": "6"
      },
      {
        "href": "https://www.tjmahr.com/wisclabmisc/reference/compute_sens_spec_from_ecdf.html",
        "text": "a\nfunction"
      },
      {
        "href": "https://bsky.app/profile/did:plc:5wm25vgenhgut3iqfjf4ozj5?ref_src=embed",
        "text": "@eugenevinitsky.bsky.social"
      },
      {
        "href": "https://bsky.app/profile/did:plc:5wm25vgenhgut3iqfjf4ozj5/post/3m5kfxmdkx22a?ref_src=embed",
        "text": "November 13, 2025 at 6:21 PM"
      },
      {
        "href": "https://rlang.r-lib.org/reference/check_dots_used.html",
        "text": "rlang::check_dots_used()"
      },
      {
        "href": "https://chatgpt.com/share/691763d2-87a4-8005-9342-bee0d0222348",
        "text": "Mind your priors."
      },
      {
        "href": "https://bsky.app/profile/did:plc:v6qwaqo24zfrq5fj7ceibxqk?ref_src=embed",
        "text": "@mehr.nz"
      },
      {
        "href": "https://bsky.app/profile/did:plc:v6qwaqo24zfrq5fj7ceibxqk/post/3lp42tel3lk2e?ref_src=embed",
        "text": "May 13, 2025 at 10:32 PM"
      },
      {
        "href": "https://bsky.app/profile/tjmahr.com/post/3m5hjc3ct6s26",
        "text": "experiment"
      },
      {
        "href": "https://usethis.r-lib.org/reference/use_cpp11.html",
        "text": "usethis::use_cpp11()"
      },
      {
        "href": "https://cpp11.r-lib.org/articles/cpp11.html",
        "text": "cpp11\ndocumentation"
      },
      {
        "href": "https://www.unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G27288",
        "text": "scheme for two-byte\nencoding"
      },
      {
        "href": "https://remotes.r-lib.org/reference/install_github.html",
        "text": "remotes::install_github()"
      },
      {
        "href": "https://ropensci.org/r-universe/",
        "text": "R\nUniverse"
      },
      {
        "href": "https://mc-stan.org/cmdstanr/",
        "text": "cmdstanr"
      },
      {
        "href": "https://cran.r-project.org/package=readtextgrid",
        "text": "CRAN"
      },
      {
        "href": "https://theknowledge.io/chestertons-fence-explained/",
        "text": "fences"
      },
      {
        "href": "https://www.notebookcheck.net/Hideo-Kojima-says-AI-is-a-friend-not-a-threat-to-creativity-in-game-development.1141848.0.html",
        "text": "creativity versus productivity"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-etc",
        "text": "‚Ü©"
      },
      {
        "href": "https://magazine.sebastianraschka.com/p/understanding-reasoning-llms",
        "text": "reasoning models"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-reasoning",
        "text": "‚Ü©"
      },
      {
        "href": "https://en.wikipedia.org/wiki/Lev_Vygotsky#Scaffolding",
        "text": "scaffolding"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-tradition",
        "text": "‚Ü©"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-wood",
        "text": "‚Ü©"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn-abadox",
        "text": "‚Ü©"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/#fnref:fn_weights",
        "text": "‚Ü©"
      },
      {
        "href": "https://tjmahr.github.io/readtextgrid-cpp-llms/",
        "text": "Higher Order Functions"
      },
      {
        "href": "https://feedburner.google.com/fb/a/mailverify?uri=RBloggers",
        "text": "daily e-mail updates"
      },
      {
        "href": "https://www.r-project.org/",
        "text": "R"
      },
      {
        "href": "https://www.r-users.com/",
        "text": "Click here if you're looking to post or find an R/data-science job"
      },
      {
        "href": "http://r-posts.com/",
        "text": "here"
      }
    ],
    "images": [
      {
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif",
        "alt": "Screenshot of a Praat editor window showing the amplitude wave form, spectrogram, and textgrid annotations. The audio file is of me saying *library tidyverse library brms*.",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
      },
      {
        "src": "https://i2.wp.com/tjmahr.github.io/assets/images/2025-11-library-tidyverse.png?w=578&ssl=1",
        "alt": "Screenshot of a Praat editor window showing the amplitude wave form, spectrogram, and textgrid annotations. The audio file is of me saying *library tidyverse library brms*.",
        "base64": "data:image/jpeg;base64,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"
      },
      {
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif",
        "alt": "Spectrogram of me saying 'library tidyverse library brms'",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
      },
      {
        "src": "https://i1.wp.com/tjmahr.github.io/figs/2025-11-14-readtextgrid-cpp-llms/unnamed-chunk-4-1.png?w=80%25&ssl=1",
        "alt": "Spectrogram of me saying 'library tidyverse library brms'",
        "base64": "data:image/jpeg;base64,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"
      },
      {
        "src": "https://www.r-bloggers.com/wp-content/plugins/jetpack/modules/lazy-images/images/1x1.trans.gif",
        "alt": "Package hex logo",
        "base64": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
      },
      {
        "src": "https://i0.wp.com/tjmahr.github.io/assets/images/2021-03-read-textgrid-logo.png?w=578&ssl=1",
        "alt": "Package hex logo",
        "base64": "data:image/jpeg;base64,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EAABBIwvf2IE6ysgIZAKgAACIICAEoGigIRAKgACCIAAAkoEigISAqkACCAAAggoESgKSAikAiCAAAggwAFFARBIBUAAARBAgAMUAAEEQADBxzoAQtAQkBBQAAQQAAEElAgBHDkmIZAKgAACIICAEoGigIRAKgACCIAAAkoEigISAqkACCAAAggoESgKSAikAiCAAAggwAEKgAACIIAACCDAAQqAAAIggIDxZUaOSQikAiCAAAggoESgKCAhkAqAAAIggIASgaKAhEAqAAIIgAACSgSKAhICqQAIIAACCHCAAiCAAAggAAIIcIACIOgLAQRAAAHjy4wckxBIBUAAARBAQIlAUUBCIBUAAQRAAAElAkUBCYFUAAQQAAEElAgUBSQEUgEQQAAEEOCAogAIpAIggAAIIMABCoAAAiCAgPFlEJAQUAAEEAABBJQIjByTEEgFQAABEEBAiUBRQEIgFQABBEAAASUCRQEJgVQAhLUhgAAIIKBEoCggIZAKgAACIIAABygAAgiAAAIggAAHKACCCgEEQAABDsKMHAPBPdhNQAABEECAAxQAAQRAAAEQQIADFBBfQEDMILAbCIIgRPwf2tw+bTKvbUcAAAAASUVORK5CYII="
      }
    ],
    "lang": "en-US",
    "crawled_at_utc": "2026-01-04T05:35:55Z"
  }
}